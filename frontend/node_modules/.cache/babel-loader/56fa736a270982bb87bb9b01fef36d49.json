{"ast":null,"code":"import { Material } from './Material.js';\nimport { cloneUniforms } from '../renderers/shaders/UniformsUtils.js';\nimport default_vertex from '../renderers/shaders/ShaderChunk/default_vertex.glsl.js';\nimport default_fragment from '../renderers/shaders/ShaderChunk/default_fragment.glsl.js';\n/**\r\n * parameters = {\r\n *  defines: { \"label\" : \"value\" },\r\n *  uniforms: { \"parameter1\": { value: 1.0 }, \"parameter2\": { value2: 2 } },\r\n *\r\n *  fragmentShader: <string>,\r\n *  vertexShader: <string>,\r\n *\r\n *  wireframe: <boolean>,\r\n *  wireframeLinewidth: <float>,\r\n *\r\n *  lights: <bool>\r\n * }\r\n */\n\nclass ShaderMaterial extends Material {\n  constructor(parameters) {\n    super();\n    this.type = 'ShaderMaterial';\n    this.defines = {};\n    this.uniforms = {};\n    this.vertexShader = default_vertex;\n    this.fragmentShader = default_fragment;\n    this.linewidth = 1;\n    this.wireframe = false;\n    this.wireframeLinewidth = 1;\n    this.fog = false; // set to use scene fog\n\n    this.lights = false; // set to use scene lights\n\n    this.clipping = false; // set to use user-defined clipping planes\n\n    this.extensions = {\n      derivatives: false,\n      // set to use derivatives\n      fragDepth: false,\n      // set to use fragment depth values\n      drawBuffers: false,\n      // set to use draw buffers\n      shaderTextureLOD: false // set to use shader texture LOD\n\n    }; // When rendered geometry doesn't include these attributes but the material does,\n    // use these default values in WebGL. This avoids errors when buffer data is missing.\n\n    this.defaultAttributeValues = {\n      'color': [1, 1, 1],\n      'uv': [0, 0],\n      'uv2': [0, 0]\n    };\n    this.index0AttributeName = undefined;\n    this.uniformsNeedUpdate = false;\n    this.glslVersion = null;\n\n    if (parameters !== undefined) {\n      if (parameters.attributes !== undefined) {\n        console.error('THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.');\n      }\n\n      this.setValues(parameters);\n    }\n  }\n\n  copy(source) {\n    super.copy(source);\n    this.fragmentShader = source.fragmentShader;\n    this.vertexShader = source.vertexShader;\n    this.uniforms = cloneUniforms(source.uniforms);\n    this.defines = Object.assign({}, source.defines);\n    this.wireframe = source.wireframe;\n    this.wireframeLinewidth = source.wireframeLinewidth;\n    this.lights = source.lights;\n    this.clipping = source.clipping;\n    this.extensions = Object.assign({}, source.extensions);\n    this.glslVersion = source.glslVersion;\n    return this;\n  }\n\n  toJSON(meta) {\n    const data = super.toJSON(meta);\n    data.glslVersion = this.glslVersion;\n    data.uniforms = {};\n\n    for (const name in this.uniforms) {\n      const uniform = this.uniforms[name];\n      const value = uniform.value;\n\n      if (value && value.isTexture) {\n        data.uniforms[name] = {\n          type: 't',\n          value: value.toJSON(meta).uuid\n        };\n      } else if (value && value.isColor) {\n        data.uniforms[name] = {\n          type: 'c',\n          value: value.getHex()\n        };\n      } else if (value && value.isVector2) {\n        data.uniforms[name] = {\n          type: 'v2',\n          value: value.toArray()\n        };\n      } else if (value && value.isVector3) {\n        data.uniforms[name] = {\n          type: 'v3',\n          value: value.toArray()\n        };\n      } else if (value && value.isVector4) {\n        data.uniforms[name] = {\n          type: 'v4',\n          value: value.toArray()\n        };\n      } else if (value && value.isMatrix3) {\n        data.uniforms[name] = {\n          type: 'm3',\n          value: value.toArray()\n        };\n      } else if (value && value.isMatrix4) {\n        data.uniforms[name] = {\n          type: 'm4',\n          value: value.toArray()\n        };\n      } else {\n        data.uniforms[name] = {\n          value: value\n        }; // note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far\n      }\n    }\n\n    if (Object.keys(this.defines).length > 0) data.defines = this.defines;\n    data.vertexShader = this.vertexShader;\n    data.fragmentShader = this.fragmentShader;\n    const extensions = {};\n\n    for (const key in this.extensions) {\n      if (this.extensions[key] === true) extensions[key] = true;\n    }\n\n    if (Object.keys(extensions).length > 0) data.extensions = extensions;\n    return data;\n  }\n\n}\n\nShaderMaterial.prototype.isShaderMaterial = true;\nexport { ShaderMaterial };","map":{"version":3,"sources":["C:/Users/dell/Desktop/projektlogin/vue-3-authentication-jwt/src/games/three/src/materials/ShaderMaterial.js"],"names":["Material","cloneUniforms","default_vertex","default_fragment","ShaderMaterial","constructor","parameters","type","defines","uniforms","vertexShader","fragmentShader","linewidth","wireframe","wireframeLinewidth","fog","lights","clipping","extensions","derivatives","fragDepth","drawBuffers","shaderTextureLOD","defaultAttributeValues","index0AttributeName","undefined","uniformsNeedUpdate","glslVersion","attributes","console","error","setValues","copy","source","Object","assign","toJSON","meta","data","name","uniform","value","isTexture","uuid","isColor","getHex","isVector2","toArray","isVector3","isVector4","isMatrix3","isMatrix4","keys","length","key","prototype","isShaderMaterial"],"mappings":"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","sourcesContent":["import { Material } from './Material.js';\r\nimport { cloneUniforms } from '../renderers/shaders/UniformsUtils.js';\r\n\r\nimport default_vertex from '../renderers/shaders/ShaderChunk/default_vertex.glsl.js';\r\nimport default_fragment from '../renderers/shaders/ShaderChunk/default_fragment.glsl.js';\r\n\r\n/**\r\n * parameters = {\r\n *  defines: { \"label\" : \"value\" },\r\n *  uniforms: { \"parameter1\": { value: 1.0 }, \"parameter2\": { value2: 2 } },\r\n *\r\n *  fragmentShader: <string>,\r\n *  vertexShader: <string>,\r\n *\r\n *  wireframe: <boolean>,\r\n *  wireframeLinewidth: <float>,\r\n *\r\n *  lights: <bool>\r\n * }\r\n */\r\n\r\nclass ShaderMaterial extends Material {\r\n\r\n\tconstructor( parameters ) {\r\n\r\n\t\tsuper();\r\n\r\n\t\tthis.type = 'ShaderMaterial';\r\n\r\n\t\tthis.defines = {};\r\n\t\tthis.uniforms = {};\r\n\r\n\t\tthis.vertexShader = default_vertex;\r\n\t\tthis.fragmentShader = default_fragment;\r\n\r\n\t\tthis.linewidth = 1;\r\n\r\n\t\tthis.wireframe = false;\r\n\t\tthis.wireframeLinewidth = 1;\r\n\r\n\t\tthis.fog = false; // set to use scene fog\r\n\t\tthis.lights = false; // set to use scene lights\r\n\t\tthis.clipping = false; // set to use user-defined clipping planes\r\n\r\n\t\tthis.extensions = {\r\n\t\t\tderivatives: false, // set to use derivatives\r\n\t\t\tfragDepth: false, // set to use fragment depth values\r\n\t\t\tdrawBuffers: false, // set to use draw buffers\r\n\t\t\tshaderTextureLOD: false // set to use shader texture LOD\r\n\t\t};\r\n\r\n\t\t// When rendered geometry doesn't include these attributes but the material does,\r\n\t\t// use these default values in WebGL. This avoids errors when buffer data is missing.\r\n\t\tthis.defaultAttributeValues = {\r\n\t\t\t'color': [ 1, 1, 1 ],\r\n\t\t\t'uv': [ 0, 0 ],\r\n\t\t\t'uv2': [ 0, 0 ]\r\n\t\t};\r\n\r\n\t\tthis.index0AttributeName = undefined;\r\n\t\tthis.uniformsNeedUpdate = false;\r\n\r\n\t\tthis.glslVersion = null;\r\n\r\n\t\tif ( parameters !== undefined ) {\r\n\r\n\t\t\tif ( parameters.attributes !== undefined ) {\r\n\r\n\t\t\t\tconsole.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.setValues( parameters );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tcopy( source ) {\r\n\r\n\t\tsuper.copy( source );\r\n\r\n\t\tthis.fragmentShader = source.fragmentShader;\r\n\t\tthis.vertexShader = source.vertexShader;\r\n\r\n\t\tthis.uniforms = cloneUniforms( source.uniforms );\r\n\r\n\t\tthis.defines = Object.assign( {}, source.defines );\r\n\r\n\t\tthis.wireframe = source.wireframe;\r\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\r\n\r\n\t\tthis.lights = source.lights;\r\n\t\tthis.clipping = source.clipping;\r\n\r\n\t\tthis.extensions = Object.assign( {}, source.extensions );\r\n\r\n\t\tthis.glslVersion = source.glslVersion;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\ttoJSON( meta ) {\r\n\r\n\t\tconst data = super.toJSON( meta );\r\n\r\n\t\tdata.glslVersion = this.glslVersion;\r\n\t\tdata.uniforms = {};\r\n\r\n\t\tfor ( const name in this.uniforms ) {\r\n\r\n\t\t\tconst uniform = this.uniforms[ name ];\r\n\t\t\tconst value = uniform.value;\r\n\r\n\t\t\tif ( value && value.isTexture ) {\r\n\r\n\t\t\t\tdata.uniforms[ name ] = {\r\n\t\t\t\t\ttype: 't',\r\n\t\t\t\t\tvalue: value.toJSON( meta ).uuid\r\n\t\t\t\t};\r\n\r\n\t\t\t} else if ( value && value.isColor ) {\r\n\r\n\t\t\t\tdata.uniforms[ name ] = {\r\n\t\t\t\t\ttype: 'c',\r\n\t\t\t\t\tvalue: value.getHex()\r\n\t\t\t\t};\r\n\r\n\t\t\t} else if ( value && value.isVector2 ) {\r\n\r\n\t\t\t\tdata.uniforms[ name ] = {\r\n\t\t\t\t\ttype: 'v2',\r\n\t\t\t\t\tvalue: value.toArray()\r\n\t\t\t\t};\r\n\r\n\t\t\t} else if ( value && value.isVector3 ) {\r\n\r\n\t\t\t\tdata.uniforms[ name ] = {\r\n\t\t\t\t\ttype: 'v3',\r\n\t\t\t\t\tvalue: value.toArray()\r\n\t\t\t\t};\r\n\r\n\t\t\t} else if ( value && value.isVector4 ) {\r\n\r\n\t\t\t\tdata.uniforms[ name ] = {\r\n\t\t\t\t\ttype: 'v4',\r\n\t\t\t\t\tvalue: value.toArray()\r\n\t\t\t\t};\r\n\r\n\t\t\t} else if ( value && value.isMatrix3 ) {\r\n\r\n\t\t\t\tdata.uniforms[ name ] = {\r\n\t\t\t\t\ttype: 'm3',\r\n\t\t\t\t\tvalue: value.toArray()\r\n\t\t\t\t};\r\n\r\n\t\t\t} else if ( value && value.isMatrix4 ) {\r\n\r\n\t\t\t\tdata.uniforms[ name ] = {\r\n\t\t\t\t\ttype: 'm4',\r\n\t\t\t\t\tvalue: value.toArray()\r\n\t\t\t\t};\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tdata.uniforms[ name ] = {\r\n\t\t\t\t\tvalue: value\r\n\t\t\t\t};\r\n\r\n\t\t\t\t// note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( Object.keys( this.defines ).length > 0 ) data.defines = this.defines;\r\n\r\n\t\tdata.vertexShader = this.vertexShader;\r\n\t\tdata.fragmentShader = this.fragmentShader;\r\n\r\n\t\tconst extensions = {};\r\n\r\n\t\tfor ( const key in this.extensions ) {\r\n\r\n\t\t\tif ( this.extensions[ key ] === true ) extensions[ key ] = true;\r\n\r\n\t\t}\r\n\r\n\t\tif ( Object.keys( extensions ).length > 0 ) data.extensions = extensions;\r\n\r\n\t\treturn data;\r\n\r\n\t}\r\n\r\n}\r\n\r\nShaderMaterial.prototype.isShaderMaterial = true;\r\n\r\nexport { ShaderMaterial };\r\n"]},"metadata":{},"sourceType":"module"}