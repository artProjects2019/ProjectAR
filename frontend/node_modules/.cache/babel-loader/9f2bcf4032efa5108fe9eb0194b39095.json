{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nimport { REVISION, BackSide, DoubleSide, FrontSide, RGBAFormat, HalfFloatType, FloatType, UnsignedByteType, LinearEncoding, NoToneMapping, LinearMipmapLinearFilter } from '../constants.js';\nimport { floorPowerOfTwo } from '../math/MathUtils.js';\nimport { Frustum } from '../math/Frustum.js';\nimport { Matrix4 } from '../math/Matrix4.js';\nimport { Vector2 } from '../math/Vector2.js';\nimport { Vector3 } from '../math/Vector3.js';\nimport { Vector4 } from '../math/Vector4.js';\nimport { WebGLAnimation } from './webgl/WebGLAnimation.js';\nimport { WebGLAttributes } from './webgl/WebGLAttributes.js';\nimport { WebGLBackground } from './webgl/WebGLBackground.js';\nimport { WebGLBindingStates } from './webgl/WebGLBindingStates.js';\nimport { WebGLBufferRenderer } from './webgl/WebGLBufferRenderer.js';\nimport { WebGLCapabilities } from './webgl/WebGLCapabilities.js';\nimport { WebGLClipping } from './webgl/WebGLClipping.js';\nimport { WebGLCubeMaps } from './webgl/WebGLCubeMaps.js';\nimport { WebGLCubeUVMaps } from './webgl/WebGLCubeUVMaps.js';\nimport { WebGLExtensions } from './webgl/WebGLExtensions.js';\nimport { WebGLGeometries } from './webgl/WebGLGeometries.js';\nimport { WebGLIndexedBufferRenderer } from './webgl/WebGLIndexedBufferRenderer.js';\nimport { WebGLInfo } from './webgl/WebGLInfo.js';\nimport { WebGLMorphtargets } from './webgl/WebGLMorphtargets.js';\nimport { WebGLObjects } from './webgl/WebGLObjects.js';\nimport { WebGLPrograms } from './webgl/WebGLPrograms.js';\nimport { WebGLProperties } from './webgl/WebGLProperties.js';\nimport { WebGLRenderLists } from './webgl/WebGLRenderLists.js';\nimport { WebGLRenderStates } from './webgl/WebGLRenderStates.js';\nimport { WebGLRenderTarget } from './WebGLRenderTarget.js';\nimport { WebGLShadowMap } from './webgl/WebGLShadowMap.js';\nimport { WebGLState } from './webgl/WebGLState.js';\nimport { WebGLTextures } from './webgl/WebGLTextures.js';\nimport { WebGLUniforms } from './webgl/WebGLUniforms.js';\nimport { WebGLUtils } from './webgl/WebGLUtils.js';\nimport { WebXRManager } from './webxr/WebXRManager.js';\nimport { WebGLMaterials } from './webgl/WebGLMaterials.js';\nimport { createElementNS } from '../utils.js';\n\nfunction createCanvasElement() {\n  const canvas = createElementNS('canvas');\n  canvas.style.display = 'block';\n  return canvas;\n}\n\nfunction WebGLRenderer(parameters = {}) {\n  const _canvas = parameters.canvas !== undefined ? parameters.canvas : createCanvasElement(),\n        _context = parameters.context !== undefined ? parameters.context : null,\n        _depth = parameters.depth !== undefined ? parameters.depth : true,\n        _stencil = parameters.stencil !== undefined ? parameters.stencil : true,\n        _antialias = parameters.antialias !== undefined ? parameters.antialias : false,\n        _premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,\n        _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,\n        _powerPreference = parameters.powerPreference !== undefined ? parameters.powerPreference : 'default',\n        _failIfMajorPerformanceCaveat = parameters.failIfMajorPerformanceCaveat !== undefined ? parameters.failIfMajorPerformanceCaveat : false;\n\n  let _alpha;\n\n  if (parameters.context !== undefined) {\n    _alpha = _context.getContextAttributes().alpha;\n  } else {\n    _alpha = parameters.alpha !== undefined ? parameters.alpha : false;\n  }\n\n  let currentRenderList = null;\n  let currentRenderState = null; // render() can be called from within a callback triggered by another render.\n  // We track this so that the nested render call gets its list and state isolated from the parent render call.\n\n  const renderListStack = [];\n  const renderStateStack = []; // public properties\n\n  this.domElement = _canvas; // Debug configuration container\n\n  this.debug = {\n    /**\r\n     * Enables error checking and reporting when shader programs are being compiled\r\n     * @type {boolean}\r\n     */\n    checkShaderErrors: true\n  }; // clearing\n\n  this.autoClear = true;\n  this.autoClearColor = true;\n  this.autoClearDepth = true;\n  this.autoClearStencil = true; // scene graph\n\n  this.sortObjects = true; // user-defined clipping\n\n  this.clippingPlanes = [];\n  this.localClippingEnabled = false; // physically based shading\n\n  this.outputEncoding = LinearEncoding; // physical lights\n\n  this.physicallyCorrectLights = false; // tone mapping\n\n  this.toneMapping = NoToneMapping;\n  this.toneMappingExposure = 1.0; // internal properties\n\n  const _this = this;\n\n  let _isContextLost = false; // internal state cache\n\n  let _currentActiveCubeFace = 0;\n  let _currentActiveMipmapLevel = 0;\n  let _currentRenderTarget = null;\n\n  let _currentMaterialId = -1;\n\n  let _currentCamera = null;\n\n  const _currentViewport = new Vector4();\n\n  const _currentScissor = new Vector4();\n\n  let _currentScissorTest = null; //\n\n  let _width = _canvas.width;\n  let _height = _canvas.height;\n  let _pixelRatio = 1;\n  let _opaqueSort = null;\n  let _transparentSort = null;\n\n  const _viewport = new Vector4(0, 0, _width, _height);\n\n  const _scissor = new Vector4(0, 0, _width, _height);\n\n  let _scissorTest = false; // frustum\n\n  const _frustum = new Frustum(); // clipping\n\n\n  let _clippingEnabled = false;\n  let _localClippingEnabled = false; // transmission\n\n  let _transmissionRenderTarget = null; // camera matrices cache\n\n  const _projScreenMatrix = new Matrix4();\n\n  const _vector2 = new Vector2();\n\n  const _vector3 = new Vector3();\n\n  const _emptyScene = {\n    background: null,\n    fog: null,\n    environment: null,\n    overrideMaterial: null,\n    isScene: true\n  };\n\n  function getTargetPixelRatio() {\n    return _currentRenderTarget === null ? _pixelRatio : 1;\n  } // initialize\n\n\n  let _gl = _context;\n\n  function getContext(contextNames, contextAttributes) {\n    for (let i = 0; i < contextNames.length; i++) {\n      const contextName = contextNames[i];\n\n      const context = _canvas.getContext(contextName, contextAttributes);\n\n      if (context !== null) return context;\n    }\n\n    return null;\n  }\n\n  try {\n    const contextAttributes = {\n      alpha: true,\n      depth: _depth,\n      stencil: _stencil,\n      antialias: _antialias,\n      premultipliedAlpha: _premultipliedAlpha,\n      preserveDrawingBuffer: _preserveDrawingBuffer,\n      powerPreference: _powerPreference,\n      failIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat\n    }; // OffscreenCanvas does not have setAttribute, see #22811\n\n    if ('setAttribute' in _canvas) _canvas.setAttribute('data-engine', `three.js r${REVISION}`); // event listeners must be registered before WebGL context is created, see #12753\n\n    _canvas.addEventListener('webglcontextlost', onContextLost, false);\n\n    _canvas.addEventListener('webglcontextrestored', onContextRestore, false);\n\n    if (_gl === null) {\n      const contextNames = ['webgl2', 'webgl', 'experimental-webgl'];\n\n      if (_this.isWebGL1Renderer === true) {\n        contextNames.shift();\n      }\n\n      _gl = getContext(contextNames, contextAttributes);\n\n      if (_gl === null) {\n        if (getContext(contextNames)) {\n          throw new Error('Error creating WebGL context with your selected attributes.');\n        } else {\n          throw new Error('Error creating WebGL context.');\n        }\n      }\n    } // Some experimental-webgl implementations do not have getShaderPrecisionFormat\n\n\n    if (_gl.getShaderPrecisionFormat === undefined) {\n      _gl.getShaderPrecisionFormat = function () {\n        return {\n          'rangeMin': 1,\n          'rangeMax': 1,\n          'precision': 1\n        };\n      };\n    }\n  } catch (error) {\n    console.error('THREE.WebGLRenderer: ' + error.message);\n    throw error;\n  }\n\n  let extensions, capabilities, state, info;\n  let properties, textures, cubemaps, cubeuvmaps, attributes, geometries, objects;\n  let programCache, materials, renderLists, renderStates, clipping, shadowMap;\n  let background, morphtargets, bufferRenderer, indexedBufferRenderer;\n  let utils, bindingStates;\n\n  function initGLContext() {\n    extensions = new WebGLExtensions(_gl);\n    capabilities = new WebGLCapabilities(_gl, extensions, parameters);\n    extensions.init(capabilities);\n    utils = new WebGLUtils(_gl, extensions, capabilities);\n    state = new WebGLState(_gl, extensions, capabilities);\n    info = new WebGLInfo(_gl);\n    properties = new WebGLProperties();\n    textures = new WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info);\n    cubemaps = new WebGLCubeMaps(_this);\n    cubeuvmaps = new WebGLCubeUVMaps(_this);\n    attributes = new WebGLAttributes(_gl, capabilities);\n    bindingStates = new WebGLBindingStates(_gl, extensions, attributes, capabilities);\n    geometries = new WebGLGeometries(_gl, attributes, info, bindingStates);\n    objects = new WebGLObjects(_gl, geometries, attributes, info);\n    morphtargets = new WebGLMorphtargets(_gl, capabilities, textures);\n    clipping = new WebGLClipping(properties);\n    programCache = new WebGLPrograms(_this, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping);\n    materials = new WebGLMaterials(properties);\n    renderLists = new WebGLRenderLists();\n    renderStates = new WebGLRenderStates(extensions, capabilities);\n    background = new WebGLBackground(_this, cubemaps, state, objects, _alpha, _premultipliedAlpha);\n    shadowMap = new WebGLShadowMap(_this, objects, capabilities);\n    bufferRenderer = new WebGLBufferRenderer(_gl, extensions, info, capabilities);\n    indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, info, capabilities);\n    info.programs = programCache.programs;\n    _this.capabilities = capabilities;\n    _this.extensions = extensions;\n    _this.properties = properties;\n    _this.renderLists = renderLists;\n    _this.shadowMap = shadowMap;\n    _this.state = state;\n    _this.info = info;\n  }\n\n  initGLContext(); // xr\n\n  const xr = new WebXRManager(_this, _gl);\n  this.xr = xr; // API\n\n  this.getContext = function () {\n    return _gl;\n  };\n\n  this.getContextAttributes = function () {\n    return _gl.getContextAttributes();\n  };\n\n  this.forceContextLoss = function () {\n    const extension = extensions.get('WEBGL_lose_context');\n    if (extension) extension.loseContext();\n  };\n\n  this.forceContextRestore = function () {\n    const extension = extensions.get('WEBGL_lose_context');\n    if (extension) extension.restoreContext();\n  };\n\n  this.getPixelRatio = function () {\n    return _pixelRatio;\n  };\n\n  this.setPixelRatio = function (value) {\n    if (value === undefined) return;\n    _pixelRatio = value;\n    this.setSize(_width, _height, false);\n  };\n\n  this.getSize = function (target) {\n    return target.set(_width, _height);\n  };\n\n  this.setSize = function (width, height, updateStyle) {\n    if (xr.isPresenting) {\n      console.warn('THREE.WebGLRenderer: Can\\'t change size while VR device is presenting.');\n      return;\n    }\n\n    _width = width;\n    _height = height;\n    _canvas.width = Math.floor(width * _pixelRatio);\n    _canvas.height = Math.floor(height * _pixelRatio);\n\n    if (updateStyle !== false) {\n      _canvas.style.width = width + 'px';\n      _canvas.style.height = height + 'px';\n    }\n\n    this.setViewport(0, 0, width, height);\n  };\n\n  this.getDrawingBufferSize = function (target) {\n    return target.set(_width * _pixelRatio, _height * _pixelRatio).floor();\n  };\n\n  this.setDrawingBufferSize = function (width, height, pixelRatio) {\n    _width = width;\n    _height = height;\n    _pixelRatio = pixelRatio;\n    _canvas.width = Math.floor(width * pixelRatio);\n    _canvas.height = Math.floor(height * pixelRatio);\n    this.setViewport(0, 0, width, height);\n  };\n\n  this.getCurrentViewport = function (target) {\n    return target.copy(_currentViewport);\n  };\n\n  this.getViewport = function (target) {\n    return target.copy(_viewport);\n  };\n\n  this.setViewport = function (x, y, width, height) {\n    if (x.isVector4) {\n      _viewport.set(x.x, x.y, x.z, x.w);\n    } else {\n      _viewport.set(x, y, width, height);\n    }\n\n    state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());\n  };\n\n  this.getScissor = function (target) {\n    return target.copy(_scissor);\n  };\n\n  this.setScissor = function (x, y, width, height) {\n    if (x.isVector4) {\n      _scissor.set(x.x, x.y, x.z, x.w);\n    } else {\n      _scissor.set(x, y, width, height);\n    }\n\n    state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());\n  };\n\n  this.getScissorTest = function () {\n    return _scissorTest;\n  };\n\n  this.setScissorTest = function (boolean) {\n    state.setScissorTest(_scissorTest = boolean);\n  };\n\n  this.setOpaqueSort = function (method) {\n    _opaqueSort = method;\n  };\n\n  this.setTransparentSort = function (method) {\n    _transparentSort = method;\n  }; // Clearing\n\n\n  this.getClearColor = function (target) {\n    return target.copy(background.getClearColor());\n  };\n\n  this.setClearColor = function () {\n    background.setClearColor.apply(background, arguments);\n  };\n\n  this.getClearAlpha = function () {\n    return background.getClearAlpha();\n  };\n\n  this.setClearAlpha = function () {\n    background.setClearAlpha.apply(background, arguments);\n  };\n\n  this.clear = function (color = true, depth = true, stencil = true) {\n    let bits = 0;\n    if (color) bits |= _gl.COLOR_BUFFER_BIT;\n    if (depth) bits |= _gl.DEPTH_BUFFER_BIT;\n    if (stencil) bits |= _gl.STENCIL_BUFFER_BIT;\n\n    _gl.clear(bits);\n  };\n\n  this.clearColor = function () {\n    this.clear(true, false, false);\n  };\n\n  this.clearDepth = function () {\n    this.clear(false, true, false);\n  };\n\n  this.clearStencil = function () {\n    this.clear(false, false, true);\n  }; //\n\n\n  this.dispose = function () {\n    _canvas.removeEventListener('webglcontextlost', onContextLost, false);\n\n    _canvas.removeEventListener('webglcontextrestored', onContextRestore, false);\n\n    renderLists.dispose();\n    renderStates.dispose();\n    properties.dispose();\n    cubemaps.dispose();\n    cubeuvmaps.dispose();\n    objects.dispose();\n    bindingStates.dispose();\n    programCache.dispose();\n    xr.dispose();\n    xr.removeEventListener('sessionstart', onXRSessionStart);\n    xr.removeEventListener('sessionend', onXRSessionEnd);\n\n    if (_transmissionRenderTarget) {\n      _transmissionRenderTarget.dispose();\n\n      _transmissionRenderTarget = null;\n    }\n\n    animation.stop();\n  }; // Events\n\n\n  function onContextLost(event) {\n    event.preventDefault();\n    console.log('THREE.WebGLRenderer: Context Lost.');\n    _isContextLost = true;\n  }\n\n  function\n    /* event */\n  onContextRestore() {\n    console.log('THREE.WebGLRenderer: Context Restored.');\n    _isContextLost = false;\n    const infoAutoReset = info.autoReset;\n    const shadowMapEnabled = shadowMap.enabled;\n    const shadowMapAutoUpdate = shadowMap.autoUpdate;\n    const shadowMapNeedsUpdate = shadowMap.needsUpdate;\n    const shadowMapType = shadowMap.type;\n    initGLContext();\n    info.autoReset = infoAutoReset;\n    shadowMap.enabled = shadowMapEnabled;\n    shadowMap.autoUpdate = shadowMapAutoUpdate;\n    shadowMap.needsUpdate = shadowMapNeedsUpdate;\n    shadowMap.type = shadowMapType;\n  }\n\n  function onMaterialDispose(event) {\n    const material = event.target;\n    material.removeEventListener('dispose', onMaterialDispose);\n    deallocateMaterial(material);\n  } // Buffer deallocation\n\n\n  function deallocateMaterial(material) {\n    releaseMaterialProgramReferences(material);\n    properties.remove(material);\n  }\n\n  function releaseMaterialProgramReferences(material) {\n    const programs = properties.get(material).programs;\n\n    if (programs !== undefined) {\n      programs.forEach(function (program) {\n        programCache.releaseProgram(program);\n      });\n\n      if (material.isShaderMaterial) {\n        programCache.releaseShaderCache(material);\n      }\n    }\n  } // Buffer rendering\n\n\n  this.renderBufferDirect = function (camera, scene, geometry, material, object, group) {\n    if (scene === null) scene = _emptyScene; // renderBufferDirect second parameter used to be fog (could be null)\n\n    const frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0;\n    const program = setProgram(camera, scene, geometry, material, object);\n    state.setMaterial(material, frontFaceCW); //\n\n    let index = geometry.index;\n    const position = geometry.attributes.position; //\n\n    if (index === null) {\n      if (position === undefined || position.count === 0) return;\n    } else if (index.count === 0) {\n      return;\n    } //\n\n\n    let rangeFactor = 1;\n\n    if (material.wireframe === true) {\n      index = geometries.getWireframeAttribute(geometry);\n      rangeFactor = 2;\n    }\n\n    bindingStates.setup(object, material, program, geometry, index);\n    let attribute;\n    let renderer = bufferRenderer;\n\n    if (index !== null) {\n      attribute = attributes.get(index);\n      renderer = indexedBufferRenderer;\n      renderer.setIndex(attribute);\n    } //\n\n\n    const dataCount = index !== null ? index.count : position.count;\n    const rangeStart = geometry.drawRange.start * rangeFactor;\n    const rangeCount = geometry.drawRange.count * rangeFactor;\n    const groupStart = group !== null ? group.start * rangeFactor : 0;\n    const groupCount = group !== null ? group.count * rangeFactor : Infinity;\n    const drawStart = Math.max(rangeStart, groupStart);\n    const drawEnd = Math.min(dataCount, rangeStart + rangeCount, groupStart + groupCount) - 1;\n    const drawCount = Math.max(0, drawEnd - drawStart + 1);\n    if (drawCount === 0) return; //\n\n    if (object.isMesh) {\n      if (material.wireframe === true) {\n        state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());\n        renderer.setMode(_gl.LINES);\n      } else {\n        renderer.setMode(_gl.TRIANGLES);\n      }\n    } else if (object.isLine) {\n      let lineWidth = material.linewidth;\n      if (lineWidth === undefined) lineWidth = 1; // Not using Line*Material\n\n      state.setLineWidth(lineWidth * getTargetPixelRatio());\n\n      if (object.isLineSegments) {\n        renderer.setMode(_gl.LINES);\n      } else if (object.isLineLoop) {\n        renderer.setMode(_gl.LINE_LOOP);\n      } else {\n        renderer.setMode(_gl.LINE_STRIP);\n      }\n    } else if (object.isPoints) {\n      renderer.setMode(_gl.POINTS);\n    } else if (object.isSprite) {\n      renderer.setMode(_gl.TRIANGLES);\n    }\n\n    if (object.isInstancedMesh) {\n      renderer.renderInstances(drawStart, drawCount, object.count);\n    } else if (geometry.isInstancedBufferGeometry) {\n      const instanceCount = Math.min(geometry.instanceCount, geometry._maxInstanceCount);\n      renderer.renderInstances(drawStart, drawCount, instanceCount);\n    } else {\n      renderer.render(drawStart, drawCount);\n    }\n  }; // Compile\n\n\n  this.compile = function (scene, camera) {\n    currentRenderState = renderStates.get(scene);\n    currentRenderState.init();\n    renderStateStack.push(currentRenderState);\n    scene.traverseVisible(function (object) {\n      if (object.isLight && object.layers.test(camera.layers)) {\n        currentRenderState.pushLight(object);\n\n        if (object.castShadow) {\n          currentRenderState.pushShadow(object);\n        }\n      }\n    });\n    currentRenderState.setupLights(_this.physicallyCorrectLights);\n    scene.traverse(function (object) {\n      const material = object.material;\n\n      if (material) {\n        if (Array.isArray(material)) {\n          for (let i = 0; i < material.length; i++) {\n            const material2 = material[i];\n            getProgram(material2, scene, object);\n          }\n        } else {\n          getProgram(material, scene, object);\n        }\n      }\n    });\n    renderStateStack.pop();\n    currentRenderState = null;\n  }; // Animation Loop\n\n\n  let onAnimationFrameCallback = null;\n\n  function onAnimationFrame(time) {\n    if (onAnimationFrameCallback) onAnimationFrameCallback(time);\n  }\n\n  function onXRSessionStart() {\n    animation.stop();\n  }\n\n  function onXRSessionEnd() {\n    animation.start();\n  }\n\n  const animation = new WebGLAnimation();\n  animation.setAnimationLoop(onAnimationFrame);\n  if (typeof window !== 'undefined') animation.setContext(window);\n\n  this.setAnimationLoop = function (callback) {\n    onAnimationFrameCallback = callback;\n    xr.setAnimationLoop(callback);\n    callback === null ? animation.stop() : animation.start();\n  };\n\n  xr.addEventListener('sessionstart', onXRSessionStart);\n  xr.addEventListener('sessionend', onXRSessionEnd); // Rendering\n\n  this.render = function (scene, camera) {\n    if (camera !== undefined && camera.isCamera !== true) {\n      console.error('THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.');\n      return;\n    }\n\n    if (_isContextLost === true) return; // update scene graph\n\n    if (scene.autoUpdate === true) scene.updateMatrixWorld(); // update camera matrices and frustum\n\n    if (camera.parent === null) camera.updateMatrixWorld();\n\n    if (xr.enabled === true && xr.isPresenting === true) {\n      if (xr.cameraAutoUpdate === true) xr.updateCamera(camera);\n      camera = xr.getCamera(); // use XR camera for rendering\n    } //\n\n\n    if (scene.isScene === true) scene.onBeforeRender(_this, scene, camera, _currentRenderTarget);\n    currentRenderState = renderStates.get(scene, renderStateStack.length);\n    currentRenderState.init();\n    renderStateStack.push(currentRenderState);\n\n    _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);\n\n    _frustum.setFromProjectionMatrix(_projScreenMatrix);\n\n    _localClippingEnabled = this.localClippingEnabled;\n    _clippingEnabled = clipping.init(this.clippingPlanes, _localClippingEnabled, camera);\n    currentRenderList = renderLists.get(scene, renderListStack.length);\n    currentRenderList.init();\n    renderListStack.push(currentRenderList);\n    projectObject(scene, camera, 0, _this.sortObjects);\n    currentRenderList.finish();\n\n    if (_this.sortObjects === true) {\n      currentRenderList.sort(_opaqueSort, _transparentSort);\n    } //\n\n\n    if (_clippingEnabled === true) clipping.beginShadows();\n    const shadowsArray = currentRenderState.state.shadowsArray;\n    shadowMap.render(shadowsArray, scene, camera);\n    if (_clippingEnabled === true) clipping.endShadows(); //\n\n    if (this.info.autoReset === true) this.info.reset(); //\n\n    background.render(currentRenderList, scene); // render scene\n\n    currentRenderState.setupLights(_this.physicallyCorrectLights);\n\n    if (camera.isArrayCamera) {\n      const cameras = camera.cameras;\n\n      for (let i = 0, l = cameras.length; i < l; i++) {\n        const camera2 = cameras[i];\n        renderScene(currentRenderList, scene, camera2, camera2.viewport);\n      }\n    } else {\n      renderScene(currentRenderList, scene, camera);\n    } //\n\n\n    if (_currentRenderTarget !== null) {\n      // resolve multisample renderbuffers to a single-sample texture if necessary\n      textures.updateMultisampleRenderTarget(_currentRenderTarget); // Generate mipmap if we're using any kind of mipmap filtering\n\n      textures.updateRenderTargetMipmap(_currentRenderTarget);\n    } //\n\n\n    if (scene.isScene === true) scene.onAfterRender(_this, scene, camera); // _gl.finish();\n\n    bindingStates.resetDefaultState();\n    _currentMaterialId = -1;\n    _currentCamera = null;\n    renderStateStack.pop();\n\n    if (renderStateStack.length > 0) {\n      currentRenderState = renderStateStack[renderStateStack.length - 1];\n    } else {\n      currentRenderState = null;\n    }\n\n    renderListStack.pop();\n\n    if (renderListStack.length > 0) {\n      currentRenderList = renderListStack[renderListStack.length - 1];\n    } else {\n      currentRenderList = null;\n    }\n  };\n\n  function projectObject(object, camera, groupOrder, sortObjects) {\n    if (object.visible === false) return;\n    const visible = object.layers.test(camera.layers);\n\n    if (visible) {\n      if (object.isGroup) {\n        groupOrder = object.renderOrder;\n      } else if (object.isLOD) {\n        if (object.autoUpdate === true) object.update(camera);\n      } else if (object.isLight) {\n        currentRenderState.pushLight(object);\n\n        if (object.castShadow) {\n          currentRenderState.pushShadow(object);\n        }\n      } else if (object.isSprite) {\n        if (!object.frustumCulled || _frustum.intersectsSprite(object)) {\n          if (sortObjects) {\n            _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);\n          }\n\n          const geometry = objects.update(object);\n          const material = object.material;\n\n          if (material.visible) {\n            currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);\n          }\n        }\n      } else if (object.isMesh || object.isLine || object.isPoints) {\n        if (object.isSkinnedMesh) {\n          // update skeleton only once in a frame\n          if (object.skeleton.frame !== info.render.frame) {\n            object.skeleton.update();\n            object.skeleton.frame = info.render.frame;\n          }\n        }\n\n        if (!object.frustumCulled || _frustum.intersectsObject(object)) {\n          if (sortObjects) {\n            _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);\n          }\n\n          const geometry = objects.update(object);\n          const material = object.material;\n\n          if (Array.isArray(material)) {\n            const groups = geometry.groups;\n\n            for (let i = 0, l = groups.length; i < l; i++) {\n              const group = groups[i];\n              const groupMaterial = material[group.materialIndex];\n\n              if (groupMaterial && groupMaterial.visible) {\n                currentRenderList.push(object, geometry, groupMaterial, groupOrder, _vector3.z, group);\n              }\n            }\n          } else if (material.visible) {\n            currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);\n          }\n        }\n      }\n    }\n\n    const children = object.children;\n\n    for (let i = 0, l = children.length; i < l; i++) {\n      projectObject(children[i], camera, groupOrder, sortObjects);\n    }\n  }\n\n  function renderScene(currentRenderList, scene, camera, viewport) {\n    const opaqueObjects = currentRenderList.opaque;\n    const transmissiveObjects = currentRenderList.transmissive;\n    const transparentObjects = currentRenderList.transparent;\n    currentRenderState.setupLightsView(camera);\n    if (transmissiveObjects.length > 0) renderTransmissionPass(opaqueObjects, scene, camera);\n    if (viewport) state.viewport(_currentViewport.copy(viewport));\n    if (opaqueObjects.length > 0) renderObjects(opaqueObjects, scene, camera);\n    if (transmissiveObjects.length > 0) renderObjects(transmissiveObjects, scene, camera);\n    if (transparentObjects.length > 0) renderObjects(transparentObjects, scene, camera); // Ensure depth buffer writing is enabled so it can be cleared on next render\n\n    state.buffers.depth.setTest(true);\n    state.buffers.depth.setMask(true);\n    state.buffers.color.setMask(true);\n    state.setPolygonOffset(false);\n  }\n\n  function renderTransmissionPass(opaqueObjects, scene, camera) {\n    const isWebGL2 = capabilities.isWebGL2;\n\n    if (_transmissionRenderTarget === null) {\n      _transmissionRenderTarget = new WebGLRenderTarget(1, 1, {\n        generateMipmaps: true,\n        type: utils.convert(HalfFloatType) !== null ? HalfFloatType : UnsignedByteType,\n        minFilter: LinearMipmapLinearFilter,\n        samples: isWebGL2 && _antialias === true ? 4 : 0\n      });\n    }\n\n    _this.getDrawingBufferSize(_vector2);\n\n    if (isWebGL2) {\n      _transmissionRenderTarget.setSize(_vector2.x, _vector2.y);\n    } else {\n      _transmissionRenderTarget.setSize(floorPowerOfTwo(_vector2.x), floorPowerOfTwo(_vector2.y));\n    } //\n\n\n    const currentRenderTarget = _this.getRenderTarget();\n\n    _this.setRenderTarget(_transmissionRenderTarget);\n\n    _this.clear(); // Turn off the features which can affect the frag color for opaque objects pass.\n    // Otherwise they are applied twice in opaque objects pass and transmission objects pass.\n\n\n    const currentToneMapping = _this.toneMapping;\n    _this.toneMapping = NoToneMapping;\n    renderObjects(opaqueObjects, scene, camera);\n    _this.toneMapping = currentToneMapping;\n    textures.updateMultisampleRenderTarget(_transmissionRenderTarget);\n    textures.updateRenderTargetMipmap(_transmissionRenderTarget);\n\n    _this.setRenderTarget(currentRenderTarget);\n  }\n\n  function renderObjects(renderList, scene, camera) {\n    const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;\n\n    for (let i = 0, l = renderList.length; i < l; i++) {\n      const renderItem = renderList[i];\n      const object = renderItem.object;\n      const geometry = renderItem.geometry;\n      const material = overrideMaterial === null ? renderItem.material : overrideMaterial;\n      const group = renderItem.group;\n\n      if (object.layers.test(camera.layers)) {\n        renderObject(object, scene, camera, geometry, material, group);\n      }\n    }\n  }\n\n  function renderObject(object, scene, camera, geometry, material, group) {\n    object.onBeforeRender(_this, scene, camera, geometry, material, group);\n    object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);\n    object.normalMatrix.getNormalMatrix(object.modelViewMatrix);\n    material.onBeforeRender(_this, scene, camera, geometry, object, group);\n\n    if (material.transparent === true && material.side === DoubleSide) {\n      material.side = BackSide;\n      material.needsUpdate = true;\n\n      _this.renderBufferDirect(camera, scene, geometry, material, object, group);\n\n      material.side = FrontSide;\n      material.needsUpdate = true;\n\n      _this.renderBufferDirect(camera, scene, geometry, material, object, group);\n\n      material.side = DoubleSide;\n    } else {\n      _this.renderBufferDirect(camera, scene, geometry, material, object, group);\n    }\n\n    object.onAfterRender(_this, scene, camera, geometry, material, group);\n  }\n\n  function getProgram(material, scene, object) {\n    if (scene.isScene !== true) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...\n\n    const materialProperties = properties.get(material);\n    const lights = currentRenderState.state.lights;\n    const shadowsArray = currentRenderState.state.shadowsArray;\n    const lightsStateVersion = lights.state.version;\n    const parameters = programCache.getParameters(material, lights.state, shadowsArray, scene, object);\n    const programCacheKey = programCache.getProgramCacheKey(parameters);\n    let programs = materialProperties.programs; // always update environment and fog - changing these trigger an getProgram call, but it's possible that the program doesn't change\n\n    materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;\n    materialProperties.fog = scene.fog;\n    materialProperties.envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || materialProperties.environment);\n\n    if (programs === undefined) {\n      // new material\n      material.addEventListener('dispose', onMaterialDispose);\n      programs = new Map();\n      materialProperties.programs = programs;\n    }\n\n    let program = programs.get(programCacheKey);\n\n    if (program !== undefined) {\n      // early out if program and light state is identical\n      if (materialProperties.currentProgram === program && materialProperties.lightsStateVersion === lightsStateVersion) {\n        updateCommonMaterialProperties(material, parameters);\n        return program;\n      }\n    } else {\n      parameters.uniforms = programCache.getUniforms(material);\n      material.onBuild(object, parameters, _this);\n      material.onBeforeCompile(parameters, _this);\n      program = programCache.acquireProgram(parameters, programCacheKey);\n      programs.set(programCacheKey, program);\n      materialProperties.uniforms = parameters.uniforms;\n    }\n\n    const uniforms = materialProperties.uniforms;\n\n    if (!material.isShaderMaterial && !material.isRawShaderMaterial || material.clipping === true) {\n      uniforms.clippingPlanes = clipping.uniform;\n    }\n\n    updateCommonMaterialProperties(material, parameters); // store the light setup it was created for\n\n    materialProperties.needsLights = materialNeedsLights(material);\n    materialProperties.lightsStateVersion = lightsStateVersion;\n\n    if (materialProperties.needsLights) {\n      // wire up the material to this renderer's lighting state\n      uniforms.ambientLightColor.value = lights.state.ambient;\n      uniforms.lightProbe.value = lights.state.probe;\n      uniforms.directionalLights.value = lights.state.directional;\n      uniforms.directionalLightShadows.value = lights.state.directionalShadow;\n      uniforms.spotLights.value = lights.state.spot;\n      uniforms.spotLightShadows.value = lights.state.spotShadow;\n      uniforms.rectAreaLights.value = lights.state.rectArea;\n      uniforms.ltc_1.value = lights.state.rectAreaLTC1;\n      uniforms.ltc_2.value = lights.state.rectAreaLTC2;\n      uniforms.pointLights.value = lights.state.point;\n      uniforms.pointLightShadows.value = lights.state.pointShadow;\n      uniforms.hemisphereLights.value = lights.state.hemi;\n      uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;\n      uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;\n      uniforms.spotShadowMap.value = lights.state.spotShadowMap;\n      uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;\n      uniforms.pointShadowMap.value = lights.state.pointShadowMap;\n      uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix; // TODO (abelnation): add area lights shadow info to uniforms\n    }\n\n    const progUniforms = program.getUniforms();\n    const uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, uniforms);\n    materialProperties.currentProgram = program;\n    materialProperties.uniformsList = uniformsList;\n    return program;\n  }\n\n  function updateCommonMaterialProperties(material, parameters) {\n    const materialProperties = properties.get(material);\n    materialProperties.outputEncoding = parameters.outputEncoding;\n    materialProperties.instancing = parameters.instancing;\n    materialProperties.skinning = parameters.skinning;\n    materialProperties.morphTargets = parameters.morphTargets;\n    materialProperties.morphNormals = parameters.morphNormals;\n    materialProperties.morphColors = parameters.morphColors;\n    materialProperties.morphTargetsCount = parameters.morphTargetsCount;\n    materialProperties.numClippingPlanes = parameters.numClippingPlanes;\n    materialProperties.numIntersection = parameters.numClipIntersection;\n    materialProperties.vertexAlphas = parameters.vertexAlphas;\n    materialProperties.vertexTangents = parameters.vertexTangents;\n    materialProperties.toneMapping = parameters.toneMapping;\n  }\n\n  function setProgram(camera, scene, geometry, material, object) {\n    if (scene.isScene !== true) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...\n\n    textures.resetTextureUnits();\n    const fog = scene.fog;\n    const environment = material.isMeshStandardMaterial ? scene.environment : null;\n    const encoding = _currentRenderTarget === null ? _this.outputEncoding : _currentRenderTarget.isXRRenderTarget === true ? _currentRenderTarget.texture.encoding : LinearEncoding;\n    const envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment);\n    const vertexAlphas = material.vertexColors === true && !!geometry.attributes.color && geometry.attributes.color.itemSize === 4;\n    const vertexTangents = !!material.normalMap && !!geometry.attributes.tangent;\n    const morphTargets = !!geometry.morphAttributes.position;\n    const morphNormals = !!geometry.morphAttributes.normal;\n    const morphColors = !!geometry.morphAttributes.color;\n    const toneMapping = material.toneMapped ? _this.toneMapping : NoToneMapping;\n    const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;\n    const morphTargetsCount = morphAttribute !== undefined ? morphAttribute.length : 0;\n    const materialProperties = properties.get(material);\n    const lights = currentRenderState.state.lights;\n\n    if (_clippingEnabled === true) {\n      if (_localClippingEnabled === true || camera !== _currentCamera) {\n        const useCache = camera === _currentCamera && material.id === _currentMaterialId; // we might want to call this function with some ClippingGroup\n        // object instead of the material, once it becomes feasible\n        // (#8465, #8379)\n\n        clipping.setState(material, camera, useCache);\n      }\n    } //\n\n\n    let needsProgramChange = false;\n\n    if (material.version === materialProperties.__version) {\n      if (materialProperties.needsLights && materialProperties.lightsStateVersion !== lights.state.version) {\n        needsProgramChange = true;\n      } else if (materialProperties.outputEncoding !== encoding) {\n        needsProgramChange = true;\n      } else if (object.isInstancedMesh && materialProperties.instancing === false) {\n        needsProgramChange = true;\n      } else if (!object.isInstancedMesh && materialProperties.instancing === true) {\n        needsProgramChange = true;\n      } else if (object.isSkinnedMesh && materialProperties.skinning === false) {\n        needsProgramChange = true;\n      } else if (!object.isSkinnedMesh && materialProperties.skinning === true) {\n        needsProgramChange = true;\n      } else if (materialProperties.envMap !== envMap) {\n        needsProgramChange = true;\n      } else if (material.fog && materialProperties.fog !== fog) {\n        needsProgramChange = true;\n      } else if (materialProperties.numClippingPlanes !== undefined && (materialProperties.numClippingPlanes !== clipping.numPlanes || materialProperties.numIntersection !== clipping.numIntersection)) {\n        needsProgramChange = true;\n      } else if (materialProperties.vertexAlphas !== vertexAlphas) {\n        needsProgramChange = true;\n      } else if (materialProperties.vertexTangents !== vertexTangents) {\n        needsProgramChange = true;\n      } else if (materialProperties.morphTargets !== morphTargets) {\n        needsProgramChange = true;\n      } else if (materialProperties.morphNormals !== morphNormals) {\n        needsProgramChange = true;\n      } else if (materialProperties.morphColors !== morphColors) {\n        needsProgramChange = true;\n      } else if (materialProperties.toneMapping !== toneMapping) {\n        needsProgramChange = true;\n      } else if (capabilities.isWebGL2 === true && materialProperties.morphTargetsCount !== morphTargetsCount) {\n        needsProgramChange = true;\n      }\n    } else {\n      needsProgramChange = true;\n      materialProperties.__version = material.version;\n    } //\n\n\n    let program = materialProperties.currentProgram;\n\n    if (needsProgramChange === true) {\n      program = getProgram(material, scene, object);\n    }\n\n    let refreshProgram = false;\n    let refreshMaterial = false;\n    let refreshLights = false;\n    const p_uniforms = program.getUniforms(),\n          m_uniforms = materialProperties.uniforms;\n\n    if (state.useProgram(program.program)) {\n      refreshProgram = true;\n      refreshMaterial = true;\n      refreshLights = true;\n    }\n\n    if (material.id !== _currentMaterialId) {\n      _currentMaterialId = material.id;\n      refreshMaterial = true;\n    }\n\n    if (refreshProgram || _currentCamera !== camera) {\n      p_uniforms.setValue(_gl, 'projectionMatrix', camera.projectionMatrix);\n\n      if (capabilities.logarithmicDepthBuffer) {\n        p_uniforms.setValue(_gl, 'logDepthBufFC', 2.0 / (Math.log(camera.far + 1.0) / Math.LN2));\n      }\n\n      if (_currentCamera !== camera) {\n        _currentCamera = camera; // lighting uniforms depend on the camera so enforce an update\n        // now, in case this material supports lights - or later, when\n        // the next material that does gets activated:\n\n        refreshMaterial = true; // set to true on material change\n\n        refreshLights = true; // remains set until update done\n      } // load material specific uniforms\n      // (shader material also gets them for the sake of genericity)\n\n\n      if (material.isShaderMaterial || material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshStandardMaterial || material.envMap) {\n        const uCamPos = p_uniforms.map.cameraPosition;\n\n        if (uCamPos !== undefined) {\n          uCamPos.setValue(_gl, _vector3.setFromMatrixPosition(camera.matrixWorld));\n        }\n      }\n\n      if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial) {\n        p_uniforms.setValue(_gl, 'isOrthographic', camera.isOrthographicCamera === true);\n      }\n\n      if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial || material.isShadowMaterial || object.isSkinnedMesh) {\n        p_uniforms.setValue(_gl, 'viewMatrix', camera.matrixWorldInverse);\n      }\n    } // skinning and morph target uniforms must be set even if material didn't change\n    // auto-setting of texture unit for bone and morph texture must go before other textures\n    // otherwise textures used for skinning and morphing can take over texture units reserved for other material textures\n\n\n    if (object.isSkinnedMesh) {\n      p_uniforms.setOptional(_gl, object, 'bindMatrix');\n      p_uniforms.setOptional(_gl, object, 'bindMatrixInverse');\n      const skeleton = object.skeleton;\n\n      if (skeleton) {\n        if (capabilities.floatVertexTextures) {\n          if (skeleton.boneTexture === null) skeleton.computeBoneTexture();\n          p_uniforms.setValue(_gl, 'boneTexture', skeleton.boneTexture, textures);\n          p_uniforms.setValue(_gl, 'boneTextureSize', skeleton.boneTextureSize);\n        } else {\n          p_uniforms.setOptional(_gl, skeleton, 'boneMatrices');\n        }\n      }\n    }\n\n    const morphAttributes = geometry.morphAttributes;\n\n    if (morphAttributes.position !== undefined || morphAttributes.normal !== undefined || morphAttributes.color !== undefined && capabilities.isWebGL2 === true) {\n      morphtargets.update(object, geometry, material, program);\n    }\n\n    if (refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow) {\n      materialProperties.receiveShadow = object.receiveShadow;\n      p_uniforms.setValue(_gl, 'receiveShadow', object.receiveShadow);\n    }\n\n    if (refreshMaterial) {\n      p_uniforms.setValue(_gl, 'toneMappingExposure', _this.toneMappingExposure);\n\n      if (materialProperties.needsLights) {\n        // the current material requires lighting info\n        // note: all lighting uniforms are always set correctly\n        // they simply reference the renderer's state for their\n        // values\n        //\n        // use the current material's .needsUpdate flags to set\n        // the GL state when required\n        markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);\n      } // refresh uniforms common to several materials\n\n\n      if (fog && material.fog) {\n        materials.refreshFogUniforms(m_uniforms, fog);\n      }\n\n      materials.refreshMaterialUniforms(m_uniforms, material, _pixelRatio, _height, _transmissionRenderTarget);\n      WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);\n    }\n\n    if (material.isShaderMaterial && material.uniformsNeedUpdate === true) {\n      WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);\n      material.uniformsNeedUpdate = false;\n    }\n\n    if (material.isSpriteMaterial) {\n      p_uniforms.setValue(_gl, 'center', object.center);\n    } // common matrices\n\n\n    p_uniforms.setValue(_gl, 'modelViewMatrix', object.modelViewMatrix);\n    p_uniforms.setValue(_gl, 'normalMatrix', object.normalMatrix);\n    p_uniforms.setValue(_gl, 'modelMatrix', object.matrixWorld);\n    return program;\n  } // If uniforms are marked as clean, they don't need to be loaded to the GPU.\n\n\n  function markUniformsLightsNeedsUpdate(uniforms, value) {\n    uniforms.ambientLightColor.needsUpdate = value;\n    uniforms.lightProbe.needsUpdate = value;\n    uniforms.directionalLights.needsUpdate = value;\n    uniforms.directionalLightShadows.needsUpdate = value;\n    uniforms.pointLights.needsUpdate = value;\n    uniforms.pointLightShadows.needsUpdate = value;\n    uniforms.spotLights.needsUpdate = value;\n    uniforms.spotLightShadows.needsUpdate = value;\n    uniforms.rectAreaLights.needsUpdate = value;\n    uniforms.hemisphereLights.needsUpdate = value;\n  }\n\n  function materialNeedsLights(material) {\n    return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.isShadowMaterial || material.isShaderMaterial && material.lights === true;\n  }\n\n  this.getActiveCubeFace = function () {\n    return _currentActiveCubeFace;\n  };\n\n  this.getActiveMipmapLevel = function () {\n    return _currentActiveMipmapLevel;\n  };\n\n  this.getRenderTarget = function () {\n    return _currentRenderTarget;\n  };\n\n  this.setRenderTargetTextures = function (renderTarget, colorTexture, depthTexture) {\n    properties.get(renderTarget.texture).__webglTexture = colorTexture;\n    properties.get(renderTarget.depthTexture).__webglTexture = depthTexture;\n    const renderTargetProperties = properties.get(renderTarget);\n    renderTargetProperties.__hasExternalTextures = true;\n\n    if (renderTargetProperties.__hasExternalTextures) {\n      renderTargetProperties.__autoAllocateDepthBuffer = depthTexture === undefined;\n\n      if (!renderTargetProperties.__autoAllocateDepthBuffer) {\n        // The multisample_render_to_texture extension doesn't work properly if there\n        // are midframe flushes and an external depth buffer. Disable use of the extension.\n        if (extensions.has('WEBGL_multisampled_render_to_texture') === true) {\n          console.warn('THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided');\n          renderTargetProperties.__useRenderToTexture = false;\n        }\n      }\n    }\n  };\n\n  this.setRenderTargetFramebuffer = function (renderTarget, defaultFramebuffer) {\n    const renderTargetProperties = properties.get(renderTarget);\n    renderTargetProperties.__webglFramebuffer = defaultFramebuffer;\n    renderTargetProperties.__useDefaultFramebuffer = defaultFramebuffer === undefined;\n  };\n\n  this.setRenderTarget = function (renderTarget, activeCubeFace = 0, activeMipmapLevel = 0) {\n    _currentRenderTarget = renderTarget;\n    _currentActiveCubeFace = activeCubeFace;\n    _currentActiveMipmapLevel = activeMipmapLevel;\n    let useDefaultFramebuffer = true;\n\n    if (renderTarget) {\n      const renderTargetProperties = properties.get(renderTarget);\n\n      if (renderTargetProperties.__useDefaultFramebuffer !== undefined) {\n        // We need to make sure to rebind the framebuffer.\n        state.bindFramebuffer(_gl.FRAMEBUFFER, null);\n        useDefaultFramebuffer = false;\n      } else if (renderTargetProperties.__webglFramebuffer === undefined) {\n        textures.setupRenderTarget(renderTarget);\n      } else if (renderTargetProperties.__hasExternalTextures) {\n        // Color and depth texture must be rebound in order for the swapchain to update.\n        textures.rebindTextures(renderTarget, properties.get(renderTarget.texture).__webglTexture, properties.get(renderTarget.depthTexture).__webglTexture);\n      }\n    }\n\n    let framebuffer = null;\n    let isCube = false;\n    let isRenderTarget3D = false;\n\n    if (renderTarget) {\n      const texture = renderTarget.texture;\n\n      if (texture.isData3DTexture || texture.isDataArrayTexture) {\n        isRenderTarget3D = true;\n      }\n\n      const __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;\n\n      if (renderTarget.isWebGLCubeRenderTarget) {\n        framebuffer = __webglFramebuffer[activeCubeFace];\n        isCube = true;\n      } else if (capabilities.isWebGL2 && renderTarget.samples > 0 && textures.useMultisampledRTT(renderTarget) === false) {\n        framebuffer = properties.get(renderTarget).__webglMultisampledFramebuffer;\n      } else {\n        framebuffer = __webglFramebuffer;\n      }\n\n      _currentViewport.copy(renderTarget.viewport);\n\n      _currentScissor.copy(renderTarget.scissor);\n\n      _currentScissorTest = renderTarget.scissorTest;\n    } else {\n      _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor();\n\n      _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor();\n\n      _currentScissorTest = _scissorTest;\n    }\n\n    const framebufferBound = state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);\n\n    if (framebufferBound && capabilities.drawBuffers && useDefaultFramebuffer) {\n      state.drawBuffers(renderTarget, framebuffer);\n    }\n\n    state.viewport(_currentViewport);\n    state.scissor(_currentScissor);\n    state.setScissorTest(_currentScissorTest);\n\n    if (isCube) {\n      const textureProperties = properties.get(renderTarget.texture);\n\n      _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel);\n    } else if (isRenderTarget3D) {\n      const textureProperties = properties.get(renderTarget.texture);\n      const layer = activeCubeFace || 0;\n\n      _gl.framebufferTextureLayer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureProperties.__webglTexture, activeMipmapLevel || 0, layer);\n    }\n\n    _currentMaterialId = -1; // reset current material to ensure correct uniform bindings\n  };\n\n  this.readRenderTargetPixels = function (renderTarget, x, y, width, height, buffer, activeCubeFaceIndex) {\n    if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {\n      console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.');\n      return;\n    }\n\n    let framebuffer = properties.get(renderTarget).__webglFramebuffer;\n\n    if (renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== undefined) {\n      framebuffer = framebuffer[activeCubeFaceIndex];\n    }\n\n    if (framebuffer) {\n      state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);\n\n      try {\n        const texture = renderTarget.texture;\n        const textureFormat = texture.format;\n        const textureType = texture.type;\n\n        if (textureFormat !== RGBAFormat && utils.convert(textureFormat) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_FORMAT)) {\n          console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.');\n          return;\n        }\n\n        const halfFloatSupportedByExt = textureType === HalfFloatType && (extensions.has('EXT_color_buffer_half_float') || capabilities.isWebGL2 && extensions.has('EXT_color_buffer_float'));\n\n        if (textureType !== UnsignedByteType && utils.convert(textureType) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_TYPE) && // Edge and Chrome Mac < 52 (#9513)\n        !(textureType === FloatType && (capabilities.isWebGL2 || extensions.has('OES_texture_float') || extensions.has('WEBGL_color_buffer_float'))) && // Chrome Mac >= 52 and Firefox\n        !halfFloatSupportedByExt) {\n          console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.');\n          return;\n        }\n\n        if (_gl.checkFramebufferStatus(_gl.FRAMEBUFFER) === _gl.FRAMEBUFFER_COMPLETE) {\n          // the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)\n          if (x >= 0 && x <= renderTarget.width - width && y >= 0 && y <= renderTarget.height - height) {\n            _gl.readPixels(x, y, width, height, utils.convert(textureFormat), utils.convert(textureType), buffer);\n          }\n        } else {\n          console.error('THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.');\n        }\n      } finally {\n        // restore framebuffer of current render target if necessary\n        const framebuffer = _currentRenderTarget !== null ? properties.get(_currentRenderTarget).__webglFramebuffer : null;\n        state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);\n      }\n    }\n  };\n\n  this.copyFramebufferToTexture = function (position, texture, level = 0) {\n    if (texture.isFramebufferTexture !== true) {\n      console.error('THREE.WebGLRenderer: copyFramebufferToTexture() can only be used with FramebufferTexture.');\n      return;\n    }\n\n    const levelScale = Math.pow(2, -level);\n    const width = Math.floor(texture.image.width * levelScale);\n    const height = Math.floor(texture.image.height * levelScale);\n    textures.setTexture2D(texture, 0);\n\n    _gl.copyTexSubImage2D(_gl.TEXTURE_2D, level, 0, 0, position.x, position.y, width, height);\n\n    state.unbindTexture();\n  };\n\n  this.copyTextureToTexture = function (position, srcTexture, dstTexture, level = 0) {\n    const width = srcTexture.image.width;\n    const height = srcTexture.image.height;\n    const glFormat = utils.convert(dstTexture.format);\n    const glType = utils.convert(dstTexture.type);\n    textures.setTexture2D(dstTexture, 0); // As another texture upload may have changed pixelStorei\n    // parameters, make sure they are correct for the dstTexture\n\n    _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY);\n\n    _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha);\n\n    _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment);\n\n    if (srcTexture.isDataTexture) {\n      _gl.texSubImage2D(_gl.TEXTURE_2D, level, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data);\n    } else {\n      if (srcTexture.isCompressedTexture) {\n        _gl.compressedTexSubImage2D(_gl.TEXTURE_2D, level, position.x, position.y, srcTexture.mipmaps[0].width, srcTexture.mipmaps[0].height, glFormat, srcTexture.mipmaps[0].data);\n      } else {\n        _gl.texSubImage2D(_gl.TEXTURE_2D, level, position.x, position.y, glFormat, glType, srcTexture.image);\n      }\n    } // Generate mipmaps only when copying level 0\n\n\n    if (level === 0 && dstTexture.generateMipmaps) _gl.generateMipmap(_gl.TEXTURE_2D);\n    state.unbindTexture();\n  };\n\n  this.copyTextureToTexture3D = function (sourceBox, position, srcTexture, dstTexture, level = 0) {\n    if (_this.isWebGL1Renderer) {\n      console.warn('THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.');\n      return;\n    }\n\n    const width = sourceBox.max.x - sourceBox.min.x + 1;\n    const height = sourceBox.max.y - sourceBox.min.y + 1;\n    const depth = sourceBox.max.z - sourceBox.min.z + 1;\n    const glFormat = utils.convert(dstTexture.format);\n    const glType = utils.convert(dstTexture.type);\n    let glTarget;\n\n    if (dstTexture.isData3DTexture) {\n      textures.setTexture3D(dstTexture, 0);\n      glTarget = _gl.TEXTURE_3D;\n    } else if (dstTexture.isDataArrayTexture) {\n      textures.setTexture2DArray(dstTexture, 0);\n      glTarget = _gl.TEXTURE_2D_ARRAY;\n    } else {\n      console.warn('THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.');\n      return;\n    }\n\n    _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY);\n\n    _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha);\n\n    _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment);\n\n    const unpackRowLen = _gl.getParameter(_gl.UNPACK_ROW_LENGTH);\n\n    const unpackImageHeight = _gl.getParameter(_gl.UNPACK_IMAGE_HEIGHT);\n\n    const unpackSkipPixels = _gl.getParameter(_gl.UNPACK_SKIP_PIXELS);\n\n    const unpackSkipRows = _gl.getParameter(_gl.UNPACK_SKIP_ROWS);\n\n    const unpackSkipImages = _gl.getParameter(_gl.UNPACK_SKIP_IMAGES);\n\n    const image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[0] : srcTexture.image;\n\n    _gl.pixelStorei(_gl.UNPACK_ROW_LENGTH, image.width);\n\n    _gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT, image.height);\n\n    _gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS, sourceBox.min.x);\n\n    _gl.pixelStorei(_gl.UNPACK_SKIP_ROWS, sourceBox.min.y);\n\n    _gl.pixelStorei(_gl.UNPACK_SKIP_IMAGES, sourceBox.min.z);\n\n    if (srcTexture.isDataTexture || srcTexture.isData3DTexture) {\n      _gl.texSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image.data);\n    } else {\n      if (srcTexture.isCompressedTexture) {\n        console.warn('THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture.');\n\n        _gl.compressedTexSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, image.data);\n      } else {\n        _gl.texSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image);\n      }\n    }\n\n    _gl.pixelStorei(_gl.UNPACK_ROW_LENGTH, unpackRowLen);\n\n    _gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT, unpackImageHeight);\n\n    _gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS, unpackSkipPixels);\n\n    _gl.pixelStorei(_gl.UNPACK_SKIP_ROWS, unpackSkipRows);\n\n    _gl.pixelStorei(_gl.UNPACK_SKIP_IMAGES, unpackSkipImages); // Generate mipmaps only when copying level 0\n\n\n    if (level === 0 && dstTexture.generateMipmaps) _gl.generateMipmap(glTarget);\n    state.unbindTexture();\n  };\n\n  this.initTexture = function (texture) {\n    textures.setTexture2D(texture, 0);\n    state.unbindTexture();\n  };\n\n  this.resetState = function () {\n    _currentActiveCubeFace = 0;\n    _currentActiveMipmapLevel = 0;\n    _currentRenderTarget = null;\n    state.reset();\n    bindingStates.reset();\n  };\n\n  if (typeof __THREE_DEVTOOLS__ !== 'undefined') {\n    __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', {\n      detail: this\n    }));\n  }\n}\n\nWebGLRenderer.prototype.isWebGLRenderer = true;\nexport { WebGLRenderer };","map":{"version":3,"sources":["C:/Users/dell/Desktop/projektlogin/vue-3-authentication-jwt/src/games/three/src/renderers/WebGLRenderer.js"],"names":["REVISION","BackSide","DoubleSide","FrontSide","RGBAFormat","HalfFloatType","FloatType","UnsignedByteType","LinearEncoding","NoToneMapping","LinearMipmapLinearFilter","floorPowerOfTwo","Frustum","Matrix4","Vector2","Vector3","Vector4","WebGLAnimation","WebGLAttributes","WebGLBackground","WebGLBindingStates","WebGLBufferRenderer","WebGLCapabilities","WebGLClipping","WebGLCubeMaps","WebGLCubeUVMaps","WebGLExtensions","WebGLGeometries","WebGLIndexedBufferRenderer","WebGLInfo","WebGLMorphtargets","WebGLObjects","WebGLPrograms","WebGLProperties","WebGLRenderLists","WebGLRenderStates","WebGLRenderTarget","WebGLShadowMap","WebGLState","WebGLTextures","WebGLUniforms","WebGLUtils","WebXRManager","WebGLMaterials","createElementNS","createCanvasElement","canvas","style","display","WebGLRenderer","parameters","_canvas","undefined","_context","context","_depth","depth","_stencil","stencil","_antialias","antialias","_premultipliedAlpha","premultipliedAlpha","_preserveDrawingBuffer","preserveDrawingBuffer","_powerPreference","powerPreference","_failIfMajorPerformanceCaveat","failIfMajorPerformanceCaveat","_alpha","getContextAttributes","alpha","currentRenderList","currentRenderState","renderListStack","renderStateStack","domElement","debug","checkShaderErrors","autoClear","autoClearColor","autoClearDepth","autoClearStencil","sortObjects","clippingPlanes","localClippingEnabled","outputEncoding","physicallyCorrectLights","toneMapping","toneMappingExposure","_this","_isContextLost","_currentActiveCubeFace","_currentActiveMipmapLevel","_currentRenderTarget","_currentMaterialId","_currentCamera","_currentViewport","_currentScissor","_currentScissorTest","_width","width","_height","height","_pixelRatio","_opaqueSort","_transparentSort","_viewport","_scissor","_scissorTest","_frustum","_clippingEnabled","_localClippingEnabled","_transmissionRenderTarget","_projScreenMatrix","_vector2","_vector3","_emptyScene","background","fog","environment","overrideMaterial","isScene","getTargetPixelRatio","_gl","getContext","contextNames","contextAttributes","i","length","contextName","setAttribute","addEventListener","onContextLost","onContextRestore","isWebGL1Renderer","shift","Error","getShaderPrecisionFormat","error","console","message","extensions","capabilities","state","info","properties","textures","cubemaps","cubeuvmaps","attributes","geometries","objects","programCache","materials","renderLists","renderStates","clipping","shadowMap","morphtargets","bufferRenderer","indexedBufferRenderer","utils","bindingStates","initGLContext","init","programs","xr","forceContextLoss","extension","get","loseContext","forceContextRestore","restoreContext","getPixelRatio","setPixelRatio","value","setSize","getSize","target","set","updateStyle","isPresenting","warn","Math","floor","setViewport","getDrawingBufferSize","setDrawingBufferSize","pixelRatio","getCurrentViewport","copy","getViewport","x","y","isVector4","z","w","viewport","multiplyScalar","getScissor","setScissor","scissor","getScissorTest","setScissorTest","boolean","setOpaqueSort","method","setTransparentSort","getClearColor","setClearColor","apply","arguments","getClearAlpha","setClearAlpha","clear","color","bits","COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","STENCIL_BUFFER_BIT","clearColor","clearDepth","clearStencil","dispose","removeEventListener","onXRSessionStart","onXRSessionEnd","animation","stop","event","preventDefault","log","infoAutoReset","autoReset","shadowMapEnabled","enabled","shadowMapAutoUpdate","autoUpdate","shadowMapNeedsUpdate","needsUpdate","shadowMapType","type","onMaterialDispose","material","deallocateMaterial","releaseMaterialProgramReferences","remove","forEach","program","releaseProgram","isShaderMaterial","releaseShaderCache","renderBufferDirect","camera","scene","geometry","object","group","frontFaceCW","isMesh","matrixWorld","determinant","setProgram","setMaterial","index","position","count","rangeFactor","wireframe","getWireframeAttribute","setup","attribute","renderer","setIndex","dataCount","rangeStart","drawRange","start","rangeCount","groupStart","groupCount","Infinity","drawStart","max","drawEnd","min","drawCount","setLineWidth","wireframeLinewidth","setMode","LINES","TRIANGLES","isLine","lineWidth","linewidth","isLineSegments","isLineLoop","LINE_LOOP","LINE_STRIP","isPoints","POINTS","isSprite","isInstancedMesh","renderInstances","isInstancedBufferGeometry","instanceCount","_maxInstanceCount","render","compile","push","traverseVisible","isLight","layers","test","pushLight","castShadow","pushShadow","setupLights","traverse","Array","isArray","material2","getProgram","pop","onAnimationFrameCallback","onAnimationFrame","time","setAnimationLoop","window","setContext","callback","isCamera","updateMatrixWorld","parent","cameraAutoUpdate","updateCamera","getCamera","onBeforeRender","multiplyMatrices","projectionMatrix","matrixWorldInverse","setFromProjectionMatrix","projectObject","finish","sort","beginShadows","shadowsArray","endShadows","reset","isArrayCamera","cameras","l","camera2","renderScene","updateMultisampleRenderTarget","updateRenderTargetMipmap","onAfterRender","resetDefaultState","groupOrder","visible","isGroup","renderOrder","isLOD","update","frustumCulled","intersectsSprite","setFromMatrixPosition","applyMatrix4","isSkinnedMesh","skeleton","frame","intersectsObject","groups","groupMaterial","materialIndex","children","opaqueObjects","opaque","transmissiveObjects","transmissive","transparentObjects","transparent","setupLightsView","renderTransmissionPass","renderObjects","buffers","setTest","setMask","setPolygonOffset","isWebGL2","generateMipmaps","convert","minFilter","samples","currentRenderTarget","getRenderTarget","setRenderTarget","currentToneMapping","renderList","renderItem","renderObject","modelViewMatrix","normalMatrix","getNormalMatrix","side","materialProperties","lights","lightsStateVersion","version","getParameters","programCacheKey","getProgramCacheKey","isMeshStandardMaterial","envMap","Map","currentProgram","updateCommonMaterialProperties","uniforms","getUniforms","onBuild","onBeforeCompile","acquireProgram","isRawShaderMaterial","uniform","needsLights","materialNeedsLights","ambientLightColor","ambient","lightProbe","probe","directionalLights","directional","directionalLightShadows","directionalShadow","spotLights","spot","spotLightShadows","spotShadow","rectAreaLights","rectArea","ltc_1","rectAreaLTC1","ltc_2","rectAreaLTC2","pointLights","point","pointLightShadows","pointShadow","hemisphereLights","hemi","directionalShadowMap","directionalShadowMatrix","spotShadowMap","spotShadowMatrix","pointShadowMap","pointShadowMatrix","progUniforms","uniformsList","seqWithValue","seq","instancing","skinning","morphTargets","morphNormals","morphColors","morphTargetsCount","numClippingPlanes","numIntersection","numClipIntersection","vertexAlphas","vertexTangents","resetTextureUnits","encoding","isXRRenderTarget","texture","vertexColors","itemSize","normalMap","tangent","morphAttributes","normal","toneMapped","morphAttribute","useCache","id","setState","needsProgramChange","__version","numPlanes","refreshProgram","refreshMaterial","refreshLights","p_uniforms","m_uniforms","useProgram","setValue","logarithmicDepthBuffer","far","LN2","isMeshPhongMaterial","isMeshToonMaterial","uCamPos","map","cameraPosition","isMeshLambertMaterial","isMeshBasicMaterial","isOrthographicCamera","isShadowMaterial","setOptional","floatVertexTextures","boneTexture","computeBoneTexture","boneTextureSize","receiveShadow","markUniformsLightsNeedsUpdate","refreshFogUniforms","refreshMaterialUniforms","upload","uniformsNeedUpdate","isSpriteMaterial","center","getActiveCubeFace","getActiveMipmapLevel","setRenderTargetTextures","renderTarget","colorTexture","depthTexture","__webglTexture","renderTargetProperties","__hasExternalTextures","__autoAllocateDepthBuffer","has","__useRenderToTexture","setRenderTargetFramebuffer","defaultFramebuffer","__webglFramebuffer","__useDefaultFramebuffer","activeCubeFace","activeMipmapLevel","useDefaultFramebuffer","bindFramebuffer","FRAMEBUFFER","setupRenderTarget","rebindTextures","framebuffer","isCube","isRenderTarget3D","isData3DTexture","isDataArrayTexture","isWebGLCubeRenderTarget","useMultisampledRTT","__webglMultisampledFramebuffer","scissorTest","framebufferBound","drawBuffers","textureProperties","framebufferTexture2D","COLOR_ATTACHMENT0","TEXTURE_CUBE_MAP_POSITIVE_X","layer","framebufferTextureLayer","readRenderTargetPixels","buffer","activeCubeFaceIndex","isWebGLRenderTarget","textureFormat","format","textureType","getParameter","IMPLEMENTATION_COLOR_READ_FORMAT","halfFloatSupportedByExt","IMPLEMENTATION_COLOR_READ_TYPE","checkFramebufferStatus","FRAMEBUFFER_COMPLETE","readPixels","copyFramebufferToTexture","level","isFramebufferTexture","levelScale","pow","image","setTexture2D","copyTexSubImage2D","TEXTURE_2D","unbindTexture","copyTextureToTexture","srcTexture","dstTexture","glFormat","glType","pixelStorei","UNPACK_FLIP_Y_WEBGL","flipY","UNPACK_PREMULTIPLY_ALPHA_WEBGL","premultiplyAlpha","UNPACK_ALIGNMENT","unpackAlignment","isDataTexture","texSubImage2D","data","isCompressedTexture","compressedTexSubImage2D","mipmaps","generateMipmap","copyTextureToTexture3D","sourceBox","glTarget","setTexture3D","TEXTURE_3D","setTexture2DArray","TEXTURE_2D_ARRAY","unpackRowLen","UNPACK_ROW_LENGTH","unpackImageHeight","UNPACK_IMAGE_HEIGHT","unpackSkipPixels","UNPACK_SKIP_PIXELS","unpackSkipRows","UNPACK_SKIP_ROWS","unpackSkipImages","UNPACK_SKIP_IMAGES","texSubImage3D","compressedTexSubImage3D","initTexture","resetState","__THREE_DEVTOOLS__","dispatchEvent","CustomEvent","detail","prototype","isWebGLRenderer"],"mappings":"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","sourcesContent":["import {\r\n\tREVISION,\r\n\tBackSide,\r\n\tDoubleSide,\r\n\tFrontSide,\r\n\tRGBAFormat,\r\n\tHalfFloatType,\r\n\tFloatType,\r\n\tUnsignedByteType,\r\n\tLinearEncoding,\r\n\tNoToneMapping,\r\n\tLinearMipmapLinearFilter\r\n} from '../constants.js';\r\nimport { floorPowerOfTwo } from '../math/MathUtils.js';\r\nimport { Frustum } from '../math/Frustum.js';\r\nimport { Matrix4 } from '../math/Matrix4.js';\r\nimport { Vector2 } from '../math/Vector2.js';\r\nimport { Vector3 } from '../math/Vector3.js';\r\nimport { Vector4 } from '../math/Vector4.js';\r\nimport { WebGLAnimation } from './webgl/WebGLAnimation.js';\r\nimport { WebGLAttributes } from './webgl/WebGLAttributes.js';\r\nimport { WebGLBackground } from './webgl/WebGLBackground.js';\r\nimport { WebGLBindingStates } from './webgl/WebGLBindingStates.js';\r\nimport { WebGLBufferRenderer } from './webgl/WebGLBufferRenderer.js';\r\nimport { WebGLCapabilities } from './webgl/WebGLCapabilities.js';\r\nimport { WebGLClipping } from './webgl/WebGLClipping.js';\r\nimport { WebGLCubeMaps } from './webgl/WebGLCubeMaps.js';\r\nimport { WebGLCubeUVMaps } from './webgl/WebGLCubeUVMaps.js';\r\nimport { WebGLExtensions } from './webgl/WebGLExtensions.js';\r\nimport { WebGLGeometries } from './webgl/WebGLGeometries.js';\r\nimport { WebGLIndexedBufferRenderer } from './webgl/WebGLIndexedBufferRenderer.js';\r\nimport { WebGLInfo } from './webgl/WebGLInfo.js';\r\nimport { WebGLMorphtargets } from './webgl/WebGLMorphtargets.js';\r\nimport { WebGLObjects } from './webgl/WebGLObjects.js';\r\nimport { WebGLPrograms } from './webgl/WebGLPrograms.js';\r\nimport { WebGLProperties } from './webgl/WebGLProperties.js';\r\nimport { WebGLRenderLists } from './webgl/WebGLRenderLists.js';\r\nimport { WebGLRenderStates } from './webgl/WebGLRenderStates.js';\r\nimport { WebGLRenderTarget } from './WebGLRenderTarget.js';\r\nimport { WebGLShadowMap } from './webgl/WebGLShadowMap.js';\r\nimport { WebGLState } from './webgl/WebGLState.js';\r\nimport { WebGLTextures } from './webgl/WebGLTextures.js';\r\nimport { WebGLUniforms } from './webgl/WebGLUniforms.js';\r\nimport { WebGLUtils } from './webgl/WebGLUtils.js';\r\nimport { WebXRManager } from './webxr/WebXRManager.js';\r\nimport { WebGLMaterials } from './webgl/WebGLMaterials.js';\r\nimport { createElementNS } from '../utils.js';\r\n\r\nfunction createCanvasElement() {\r\n\r\n\tconst canvas = createElementNS( 'canvas' );\r\n\tcanvas.style.display = 'block';\r\n\treturn canvas;\r\n\r\n}\r\n\r\nfunction WebGLRenderer( parameters = {} ) {\r\n\r\n\tconst _canvas = parameters.canvas !== undefined ? parameters.canvas : createCanvasElement(),\r\n\t\t_context = parameters.context !== undefined ? parameters.context : null,\r\n\r\n\t\t_depth = parameters.depth !== undefined ? parameters.depth : true,\r\n\t\t_stencil = parameters.stencil !== undefined ? parameters.stencil : true,\r\n\t\t_antialias = parameters.antialias !== undefined ? parameters.antialias : false,\r\n\t\t_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,\r\n\t\t_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,\r\n\t\t_powerPreference = parameters.powerPreference !== undefined ? parameters.powerPreference : 'default',\r\n\t\t_failIfMajorPerformanceCaveat = parameters.failIfMajorPerformanceCaveat !== undefined ? parameters.failIfMajorPerformanceCaveat : false;\r\n\r\n\tlet _alpha;\r\n\r\n\tif ( parameters.context !== undefined ) {\r\n\r\n\t\t_alpha = _context.getContextAttributes().alpha;\r\n\r\n\t} else {\r\n\r\n\t\t_alpha = parameters.alpha !== undefined ? parameters.alpha : false;\r\n\r\n\t}\r\n\r\n\tlet currentRenderList = null;\r\n\tlet currentRenderState = null;\r\n\r\n\t// render() can be called from within a callback triggered by another render.\r\n\t// We track this so that the nested render call gets its list and state isolated from the parent render call.\r\n\r\n\tconst renderListStack = [];\r\n\tconst renderStateStack = [];\r\n\r\n\t// public properties\r\n\r\n\tthis.domElement = _canvas;\r\n\r\n\t// Debug configuration container\r\n\tthis.debug = {\r\n\r\n\t\t/**\r\n\t\t * Enables error checking and reporting when shader programs are being compiled\r\n\t\t * @type {boolean}\r\n\t\t */\r\n\t\tcheckShaderErrors: true\r\n\t};\r\n\r\n\t// clearing\r\n\r\n\tthis.autoClear = true;\r\n\tthis.autoClearColor = true;\r\n\tthis.autoClearDepth = true;\r\n\tthis.autoClearStencil = true;\r\n\r\n\t// scene graph\r\n\r\n\tthis.sortObjects = true;\r\n\r\n\t// user-defined clipping\r\n\r\n\tthis.clippingPlanes = [];\r\n\tthis.localClippingEnabled = false;\r\n\r\n\t// physically based shading\r\n\r\n\tthis.outputEncoding = LinearEncoding;\r\n\r\n\t// physical lights\r\n\r\n\tthis.physicallyCorrectLights = false;\r\n\r\n\t// tone mapping\r\n\r\n\tthis.toneMapping = NoToneMapping;\r\n\tthis.toneMappingExposure = 1.0;\r\n\r\n\t// internal properties\r\n\r\n\tconst _this = this;\r\n\r\n\tlet _isContextLost = false;\r\n\r\n\t// internal state cache\r\n\r\n\tlet _currentActiveCubeFace = 0;\r\n\tlet _currentActiveMipmapLevel = 0;\r\n\tlet _currentRenderTarget = null;\r\n\tlet _currentMaterialId = - 1;\r\n\r\n\tlet _currentCamera = null;\r\n\r\n\tconst _currentViewport = new Vector4();\r\n\tconst _currentScissor = new Vector4();\r\n\tlet _currentScissorTest = null;\r\n\r\n\t//\r\n\r\n\tlet _width = _canvas.width;\r\n\tlet _height = _canvas.height;\r\n\r\n\tlet _pixelRatio = 1;\r\n\tlet _opaqueSort = null;\r\n\tlet _transparentSort = null;\r\n\r\n\tconst _viewport = new Vector4( 0, 0, _width, _height );\r\n\tconst _scissor = new Vector4( 0, 0, _width, _height );\r\n\tlet _scissorTest = false;\r\n\r\n\t// frustum\r\n\r\n\tconst _frustum = new Frustum();\r\n\r\n\t// clipping\r\n\r\n\tlet _clippingEnabled = false;\r\n\tlet _localClippingEnabled = false;\r\n\r\n\t// transmission\r\n\r\n\tlet _transmissionRenderTarget = null;\r\n\r\n\t// camera matrices cache\r\n\r\n\tconst _projScreenMatrix = new Matrix4();\r\n\r\n\tconst _vector2 = new Vector2();\r\n\tconst _vector3 = new Vector3();\r\n\r\n\tconst _emptyScene = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: true };\r\n\r\n\tfunction getTargetPixelRatio() {\r\n\r\n\t\treturn _currentRenderTarget === null ? _pixelRatio : 1;\r\n\r\n\t}\r\n\r\n\t// initialize\r\n\r\n\tlet _gl = _context;\r\n\r\n\tfunction getContext( contextNames, contextAttributes ) {\r\n\r\n\t\tfor ( let i = 0; i < contextNames.length; i ++ ) {\r\n\r\n\t\t\tconst contextName = contextNames[ i ];\r\n\t\t\tconst context = _canvas.getContext( contextName, contextAttributes );\r\n\t\t\tif ( context !== null ) return context;\r\n\r\n\t\t}\r\n\r\n\t\treturn null;\r\n\r\n\t}\r\n\r\n\ttry {\r\n\r\n\t\tconst contextAttributes = {\r\n\t\t\talpha: true,\r\n\t\t\tdepth: _depth,\r\n\t\t\tstencil: _stencil,\r\n\t\t\tantialias: _antialias,\r\n\t\t\tpremultipliedAlpha: _premultipliedAlpha,\r\n\t\t\tpreserveDrawingBuffer: _preserveDrawingBuffer,\r\n\t\t\tpowerPreference: _powerPreference,\r\n\t\t\tfailIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat\r\n\t\t};\r\n\r\n\t\t// OffscreenCanvas does not have setAttribute, see #22811\r\n\t\tif ( 'setAttribute' in _canvas ) _canvas.setAttribute( 'data-engine', `three.js r${REVISION}` );\r\n\r\n\t\t// event listeners must be registered before WebGL context is created, see #12753\r\n\t\t_canvas.addEventListener( 'webglcontextlost', onContextLost, false );\r\n\t\t_canvas.addEventListener( 'webglcontextrestored', onContextRestore, false );\r\n\r\n\t\tif ( _gl === null ) {\r\n\r\n\t\t\tconst contextNames = [ 'webgl2', 'webgl', 'experimental-webgl' ];\r\n\r\n\t\t\tif ( _this.isWebGL1Renderer === true ) {\r\n\r\n\t\t\t\tcontextNames.shift();\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_gl = getContext( contextNames, contextAttributes );\r\n\r\n\t\t\tif ( _gl === null ) {\r\n\r\n\t\t\t\tif ( getContext( contextNames ) ) {\r\n\r\n\t\t\t\t\tthrow new Error( 'Error creating WebGL context with your selected attributes.' );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tthrow new Error( 'Error creating WebGL context.' );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// Some experimental-webgl implementations do not have getShaderPrecisionFormat\r\n\r\n\t\tif ( _gl.getShaderPrecisionFormat === undefined ) {\r\n\r\n\t\t\t_gl.getShaderPrecisionFormat = function () {\r\n\r\n\t\t\t\treturn { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };\r\n\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t} catch ( error ) {\r\n\r\n\t\tconsole.error( 'THREE.WebGLRenderer: ' + error.message );\r\n\t\tthrow error;\r\n\r\n\t}\r\n\r\n\tlet extensions, capabilities, state, info;\r\n\tlet properties, textures, cubemaps, cubeuvmaps, attributes, geometries, objects;\r\n\tlet programCache, materials, renderLists, renderStates, clipping, shadowMap;\r\n\r\n\tlet background, morphtargets, bufferRenderer, indexedBufferRenderer;\r\n\r\n\tlet utils, bindingStates;\r\n\r\n\tfunction initGLContext() {\r\n\r\n\t\textensions = new WebGLExtensions( _gl );\r\n\r\n\t\tcapabilities = new WebGLCapabilities( _gl, extensions, parameters );\r\n\r\n\t\textensions.init( capabilities );\r\n\r\n\t\tutils = new WebGLUtils( _gl, extensions, capabilities );\r\n\r\n\t\tstate = new WebGLState( _gl, extensions, capabilities );\r\n\r\n\t\tinfo = new WebGLInfo( _gl );\r\n\t\tproperties = new WebGLProperties();\r\n\t\ttextures = new WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info );\r\n\t\tcubemaps = new WebGLCubeMaps( _this );\r\n\t\tcubeuvmaps = new WebGLCubeUVMaps( _this );\r\n\t\tattributes = new WebGLAttributes( _gl, capabilities );\r\n\t\tbindingStates = new WebGLBindingStates( _gl, extensions, attributes, capabilities );\r\n\t\tgeometries = new WebGLGeometries( _gl, attributes, info, bindingStates );\r\n\t\tobjects = new WebGLObjects( _gl, geometries, attributes, info );\r\n\t\tmorphtargets = new WebGLMorphtargets( _gl, capabilities, textures );\r\n\t\tclipping = new WebGLClipping( properties );\r\n\t\tprogramCache = new WebGLPrograms( _this, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping );\r\n\t\tmaterials = new WebGLMaterials( properties );\r\n\t\trenderLists = new WebGLRenderLists();\r\n\t\trenderStates = new WebGLRenderStates( extensions, capabilities );\r\n\t\tbackground = new WebGLBackground( _this, cubemaps, state, objects, _alpha, _premultipliedAlpha );\r\n\t\tshadowMap = new WebGLShadowMap( _this, objects, capabilities );\r\n\r\n\t\tbufferRenderer = new WebGLBufferRenderer( _gl, extensions, info, capabilities );\r\n\t\tindexedBufferRenderer = new WebGLIndexedBufferRenderer( _gl, extensions, info, capabilities );\r\n\r\n\t\tinfo.programs = programCache.programs;\r\n\r\n\t\t_this.capabilities = capabilities;\r\n\t\t_this.extensions = extensions;\r\n\t\t_this.properties = properties;\r\n\t\t_this.renderLists = renderLists;\r\n\t\t_this.shadowMap = shadowMap;\r\n\t\t_this.state = state;\r\n\t\t_this.info = info;\r\n\r\n\t}\r\n\r\n\tinitGLContext();\r\n\r\n\t// xr\r\n\r\n\tconst xr = new WebXRManager( _this, _gl );\r\n\r\n\tthis.xr = xr;\r\n\r\n\t// API\r\n\r\n\tthis.getContext = function () {\r\n\r\n\t\treturn _gl;\r\n\r\n\t};\r\n\r\n\tthis.getContextAttributes = function () {\r\n\r\n\t\treturn _gl.getContextAttributes();\r\n\r\n\t};\r\n\r\n\tthis.forceContextLoss = function () {\r\n\r\n\t\tconst extension = extensions.get( 'WEBGL_lose_context' );\r\n\t\tif ( extension ) extension.loseContext();\r\n\r\n\t};\r\n\r\n\tthis.forceContextRestore = function () {\r\n\r\n\t\tconst extension = extensions.get( 'WEBGL_lose_context' );\r\n\t\tif ( extension ) extension.restoreContext();\r\n\r\n\t};\r\n\r\n\tthis.getPixelRatio = function () {\r\n\r\n\t\treturn _pixelRatio;\r\n\r\n\t};\r\n\r\n\tthis.setPixelRatio = function ( value ) {\r\n\r\n\t\tif ( value === undefined ) return;\r\n\r\n\t\t_pixelRatio = value;\r\n\r\n\t\tthis.setSize( _width, _height, false );\r\n\r\n\t};\r\n\r\n\tthis.getSize = function ( target ) {\r\n\r\n\t\treturn target.set( _width, _height );\r\n\r\n\t};\r\n\r\n\tthis.setSize = function ( width, height, updateStyle ) {\r\n\r\n\t\tif ( xr.isPresenting ) {\r\n\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: Can\\'t change size while VR device is presenting.' );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\t_width = width;\r\n\t\t_height = height;\r\n\r\n\t\t_canvas.width = Math.floor( width * _pixelRatio );\r\n\t\t_canvas.height = Math.floor( height * _pixelRatio );\r\n\r\n\t\tif ( updateStyle !== false ) {\r\n\r\n\t\t\t_canvas.style.width = width + 'px';\r\n\t\t\t_canvas.style.height = height + 'px';\r\n\r\n\t\t}\r\n\r\n\t\tthis.setViewport( 0, 0, width, height );\r\n\r\n\t};\r\n\r\n\tthis.getDrawingBufferSize = function ( target ) {\r\n\r\n\t\treturn target.set( _width * _pixelRatio, _height * _pixelRatio ).floor();\r\n\r\n\t};\r\n\r\n\tthis.setDrawingBufferSize = function ( width, height, pixelRatio ) {\r\n\r\n\t\t_width = width;\r\n\t\t_height = height;\r\n\r\n\t\t_pixelRatio = pixelRatio;\r\n\r\n\t\t_canvas.width = Math.floor( width * pixelRatio );\r\n\t\t_canvas.height = Math.floor( height * pixelRatio );\r\n\r\n\t\tthis.setViewport( 0, 0, width, height );\r\n\r\n\t};\r\n\r\n\tthis.getCurrentViewport = function ( target ) {\r\n\r\n\t\treturn target.copy( _currentViewport );\r\n\r\n\t};\r\n\r\n\tthis.getViewport = function ( target ) {\r\n\r\n\t\treturn target.copy( _viewport );\r\n\r\n\t};\r\n\r\n\tthis.setViewport = function ( x, y, width, height ) {\r\n\r\n\t\tif ( x.isVector4 ) {\r\n\r\n\t\t\t_viewport.set( x.x, x.y, x.z, x.w );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t_viewport.set( x, y, width, height );\r\n\r\n\t\t}\r\n\r\n\t\tstate.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ).floor() );\r\n\r\n\t};\r\n\r\n\tthis.getScissor = function ( target ) {\r\n\r\n\t\treturn target.copy( _scissor );\r\n\r\n\t};\r\n\r\n\tthis.setScissor = function ( x, y, width, height ) {\r\n\r\n\t\tif ( x.isVector4 ) {\r\n\r\n\t\t\t_scissor.set( x.x, x.y, x.z, x.w );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t_scissor.set( x, y, width, height );\r\n\r\n\t\t}\r\n\r\n\t\tstate.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ).floor() );\r\n\r\n\t};\r\n\r\n\tthis.getScissorTest = function () {\r\n\r\n\t\treturn _scissorTest;\r\n\r\n\t};\r\n\r\n\tthis.setScissorTest = function ( boolean ) {\r\n\r\n\t\tstate.setScissorTest( _scissorTest = boolean );\r\n\r\n\t};\r\n\r\n\tthis.setOpaqueSort = function ( method ) {\r\n\r\n\t\t_opaqueSort = method;\r\n\r\n\t};\r\n\r\n\tthis.setTransparentSort = function ( method ) {\r\n\r\n\t\t_transparentSort = method;\r\n\r\n\t};\r\n\r\n\t// Clearing\r\n\r\n\tthis.getClearColor = function ( target ) {\r\n\r\n\t\treturn target.copy( background.getClearColor() );\r\n\r\n\t};\r\n\r\n\tthis.setClearColor = function () {\r\n\r\n\t\tbackground.setClearColor.apply( background, arguments );\r\n\r\n\t};\r\n\r\n\tthis.getClearAlpha = function () {\r\n\r\n\t\treturn background.getClearAlpha();\r\n\r\n\t};\r\n\r\n\tthis.setClearAlpha = function () {\r\n\r\n\t\tbackground.setClearAlpha.apply( background, arguments );\r\n\r\n\t};\r\n\r\n\tthis.clear = function ( color = true, depth = true, stencil = true ) {\r\n\r\n\t\tlet bits = 0;\r\n\r\n\t\tif ( color ) bits |= _gl.COLOR_BUFFER_BIT;\r\n\t\tif ( depth ) bits |= _gl.DEPTH_BUFFER_BIT;\r\n\t\tif ( stencil ) bits |= _gl.STENCIL_BUFFER_BIT;\r\n\r\n\t\t_gl.clear( bits );\r\n\r\n\t};\r\n\r\n\tthis.clearColor = function () {\r\n\r\n\t\tthis.clear( true, false, false );\r\n\r\n\t};\r\n\r\n\tthis.clearDepth = function () {\r\n\r\n\t\tthis.clear( false, true, false );\r\n\r\n\t};\r\n\r\n\tthis.clearStencil = function () {\r\n\r\n\t\tthis.clear( false, false, true );\r\n\r\n\t};\r\n\r\n\t//\r\n\r\n\tthis.dispose = function () {\r\n\r\n\t\t_canvas.removeEventListener( 'webglcontextlost', onContextLost, false );\r\n\t\t_canvas.removeEventListener( 'webglcontextrestored', onContextRestore, false );\r\n\r\n\t\trenderLists.dispose();\r\n\t\trenderStates.dispose();\r\n\t\tproperties.dispose();\r\n\t\tcubemaps.dispose();\r\n\t\tcubeuvmaps.dispose();\r\n\t\tobjects.dispose();\r\n\t\tbindingStates.dispose();\r\n\t\tprogramCache.dispose();\r\n\r\n\t\txr.dispose();\r\n\r\n\t\txr.removeEventListener( 'sessionstart', onXRSessionStart );\r\n\t\txr.removeEventListener( 'sessionend', onXRSessionEnd );\r\n\r\n\t\tif ( _transmissionRenderTarget ) {\r\n\r\n\t\t\t_transmissionRenderTarget.dispose();\r\n\t\t\t_transmissionRenderTarget = null;\r\n\r\n\t\t}\r\n\r\n\t\tanimation.stop();\r\n\r\n\t};\r\n\r\n\t// Events\r\n\r\n\tfunction onContextLost( event ) {\r\n\r\n\t\tevent.preventDefault();\r\n\r\n\t\tconsole.log( 'THREE.WebGLRenderer: Context Lost.' );\r\n\r\n\t\t_isContextLost = true;\r\n\r\n\t}\r\n\r\n\tfunction onContextRestore( /* event */ ) {\r\n\r\n\t\tconsole.log( 'THREE.WebGLRenderer: Context Restored.' );\r\n\r\n\t\t_isContextLost = false;\r\n\r\n\t\tconst infoAutoReset = info.autoReset;\r\n\t\tconst shadowMapEnabled = shadowMap.enabled;\r\n\t\tconst shadowMapAutoUpdate = shadowMap.autoUpdate;\r\n\t\tconst shadowMapNeedsUpdate = shadowMap.needsUpdate;\r\n\t\tconst shadowMapType = shadowMap.type;\r\n\r\n\t\tinitGLContext();\r\n\r\n\t\tinfo.autoReset = infoAutoReset;\r\n\t\tshadowMap.enabled = shadowMapEnabled;\r\n\t\tshadowMap.autoUpdate = shadowMapAutoUpdate;\r\n\t\tshadowMap.needsUpdate = shadowMapNeedsUpdate;\r\n\t\tshadowMap.type = shadowMapType;\r\n\r\n\t}\r\n\r\n\tfunction onMaterialDispose( event ) {\r\n\r\n\t\tconst material = event.target;\r\n\r\n\t\tmaterial.removeEventListener( 'dispose', onMaterialDispose );\r\n\r\n\t\tdeallocateMaterial( material );\r\n\r\n\t}\r\n\r\n\t// Buffer deallocation\r\n\r\n\tfunction deallocateMaterial( material ) {\r\n\r\n\t\treleaseMaterialProgramReferences( material );\r\n\r\n\t\tproperties.remove( material );\r\n\r\n\t}\r\n\r\n\r\n\tfunction releaseMaterialProgramReferences( material ) {\r\n\r\n\t\tconst programs = properties.get( material ).programs;\r\n\r\n\t\tif ( programs !== undefined ) {\r\n\r\n\t\t\tprograms.forEach( function ( program ) {\r\n\r\n\t\t\t\tprogramCache.releaseProgram( program );\r\n\r\n\t\t\t} );\r\n\r\n\t\t\tif ( material.isShaderMaterial ) {\r\n\r\n\t\t\t\tprogramCache.releaseShaderCache( material );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// Buffer rendering\r\n\r\n\tthis.renderBufferDirect = function ( camera, scene, geometry, material, object, group ) {\r\n\r\n\t\tif ( scene === null ) scene = _emptyScene; // renderBufferDirect second parameter used to be fog (could be null)\r\n\r\n\t\tconst frontFaceCW = ( object.isMesh && object.matrixWorld.determinant() < 0 );\r\n\r\n\t\tconst program = setProgram( camera, scene, geometry, material, object );\r\n\r\n\t\tstate.setMaterial( material, frontFaceCW );\r\n\r\n\t\t//\r\n\r\n\t\tlet index = geometry.index;\r\n\t\tconst position = geometry.attributes.position;\r\n\r\n\t\t//\r\n\r\n\t\tif ( index === null ) {\r\n\r\n\t\t\tif ( position === undefined || position.count === 0 ) return;\r\n\r\n\t\t} else if ( index.count === 0 ) {\r\n\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\r\n\t\tlet rangeFactor = 1;\r\n\r\n\t\tif ( material.wireframe === true ) {\r\n\r\n\t\t\tindex = geometries.getWireframeAttribute( geometry );\r\n\t\t\trangeFactor = 2;\r\n\r\n\t\t}\r\n\r\n\t\tbindingStates.setup( object, material, program, geometry, index );\r\n\r\n\t\tlet attribute;\r\n\t\tlet renderer = bufferRenderer;\r\n\r\n\t\tif ( index !== null ) {\r\n\r\n\t\t\tattribute = attributes.get( index );\r\n\r\n\t\t\trenderer = indexedBufferRenderer;\r\n\t\t\trenderer.setIndex( attribute );\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\r\n\t\tconst dataCount = ( index !== null ) ? index.count : position.count;\r\n\r\n\t\tconst rangeStart = geometry.drawRange.start * rangeFactor;\r\n\t\tconst rangeCount = geometry.drawRange.count * rangeFactor;\r\n\r\n\t\tconst groupStart = group !== null ? group.start * rangeFactor : 0;\r\n\t\tconst groupCount = group !== null ? group.count * rangeFactor : Infinity;\r\n\r\n\t\tconst drawStart = Math.max( rangeStart, groupStart );\r\n\t\tconst drawEnd = Math.min( dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1;\r\n\r\n\t\tconst drawCount = Math.max( 0, drawEnd - drawStart + 1 );\r\n\r\n\t\tif ( drawCount === 0 ) return;\r\n\r\n\t\t//\r\n\r\n\t\tif ( object.isMesh ) {\r\n\r\n\t\t\tif ( material.wireframe === true ) {\r\n\r\n\t\t\t\tstate.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );\r\n\t\t\t\trenderer.setMode( _gl.LINES );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\trenderer.setMode( _gl.TRIANGLES );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( object.isLine ) {\r\n\r\n\t\t\tlet lineWidth = material.linewidth;\r\n\r\n\t\t\tif ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material\r\n\r\n\t\t\tstate.setLineWidth( lineWidth * getTargetPixelRatio() );\r\n\r\n\t\t\tif ( object.isLineSegments ) {\r\n\r\n\t\t\t\trenderer.setMode( _gl.LINES );\r\n\r\n\t\t\t} else if ( object.isLineLoop ) {\r\n\r\n\t\t\t\trenderer.setMode( _gl.LINE_LOOP );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\trenderer.setMode( _gl.LINE_STRIP );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( object.isPoints ) {\r\n\r\n\t\t\trenderer.setMode( _gl.POINTS );\r\n\r\n\t\t} else if ( object.isSprite ) {\r\n\r\n\t\t\trenderer.setMode( _gl.TRIANGLES );\r\n\r\n\t\t}\r\n\r\n\t\tif ( object.isInstancedMesh ) {\r\n\r\n\t\t\trenderer.renderInstances( drawStart, drawCount, object.count );\r\n\r\n\t\t} else if ( geometry.isInstancedBufferGeometry ) {\r\n\r\n\t\t\tconst instanceCount = Math.min( geometry.instanceCount, geometry._maxInstanceCount );\r\n\r\n\t\t\trenderer.renderInstances( drawStart, drawCount, instanceCount );\r\n\r\n\t\t} else {\r\n\r\n\t\t\trenderer.render( drawStart, drawCount );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\t// Compile\r\n\r\n\tthis.compile = function ( scene, camera ) {\r\n\r\n\t\tcurrentRenderState = renderStates.get( scene );\r\n\t\tcurrentRenderState.init();\r\n\r\n\t\trenderStateStack.push( currentRenderState );\r\n\r\n\t\tscene.traverseVisible( function ( object ) {\r\n\r\n\t\t\tif ( object.isLight && object.layers.test( camera.layers ) ) {\r\n\r\n\t\t\t\tcurrentRenderState.pushLight( object );\r\n\r\n\t\t\t\tif ( object.castShadow ) {\r\n\r\n\t\t\t\t\tcurrentRenderState.pushShadow( object );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} );\r\n\r\n\t\tcurrentRenderState.setupLights( _this.physicallyCorrectLights );\r\n\r\n\t\tscene.traverse( function ( object ) {\r\n\r\n\t\t\tconst material = object.material;\r\n\r\n\t\t\tif ( material ) {\r\n\r\n\t\t\t\tif ( Array.isArray( material ) ) {\r\n\r\n\t\t\t\t\tfor ( let i = 0; i < material.length; i ++ ) {\r\n\r\n\t\t\t\t\t\tconst material2 = material[ i ];\r\n\r\n\t\t\t\t\t\tgetProgram( material2, scene, object );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tgetProgram( material, scene, object );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} );\r\n\r\n\t\trenderStateStack.pop();\r\n\t\tcurrentRenderState = null;\r\n\r\n\t};\r\n\r\n\t// Animation Loop\r\n\r\n\tlet onAnimationFrameCallback = null;\r\n\r\n\tfunction onAnimationFrame( time ) {\r\n\r\n\t\tif ( onAnimationFrameCallback ) onAnimationFrameCallback( time );\r\n\r\n\t}\r\n\r\n\tfunction onXRSessionStart() {\r\n\r\n\t\tanimation.stop();\r\n\r\n\t}\r\n\r\n\tfunction onXRSessionEnd() {\r\n\r\n\t\tanimation.start();\r\n\r\n\t}\r\n\r\n\tconst animation = new WebGLAnimation();\r\n\tanimation.setAnimationLoop( onAnimationFrame );\r\n\r\n\tif ( typeof window !== 'undefined' ) animation.setContext( window );\r\n\r\n\tthis.setAnimationLoop = function ( callback ) {\r\n\r\n\t\tonAnimationFrameCallback = callback;\r\n\t\txr.setAnimationLoop( callback );\r\n\r\n\t\t( callback === null ) ? animation.stop() : animation.start();\r\n\r\n\t};\r\n\r\n\txr.addEventListener( 'sessionstart', onXRSessionStart );\r\n\txr.addEventListener( 'sessionend', onXRSessionEnd );\r\n\r\n\t// Rendering\r\n\r\n\tthis.render = function ( scene, camera ) {\r\n\r\n\t\tif ( camera !== undefined && camera.isCamera !== true ) {\r\n\r\n\t\t\tconsole.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tif ( _isContextLost === true ) return;\r\n\r\n\t\t// update scene graph\r\n\r\n\t\tif ( scene.autoUpdate === true ) scene.updateMatrixWorld();\r\n\r\n\t\t// update camera matrices and frustum\r\n\r\n\t\tif ( camera.parent === null ) camera.updateMatrixWorld();\r\n\r\n\t\tif ( xr.enabled === true && xr.isPresenting === true ) {\r\n\r\n\t\t\tif ( xr.cameraAutoUpdate === true ) xr.updateCamera( camera );\r\n\r\n\t\t\tcamera = xr.getCamera(); // use XR camera for rendering\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\t\tif ( scene.isScene === true ) scene.onBeforeRender( _this, scene, camera, _currentRenderTarget );\r\n\r\n\t\tcurrentRenderState = renderStates.get( scene, renderStateStack.length );\r\n\t\tcurrentRenderState.init();\r\n\r\n\t\trenderStateStack.push( currentRenderState );\r\n\r\n\t\t_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );\r\n\t\t_frustum.setFromProjectionMatrix( _projScreenMatrix );\r\n\r\n\t\t_localClippingEnabled = this.localClippingEnabled;\r\n\t\t_clippingEnabled = clipping.init( this.clippingPlanes, _localClippingEnabled, camera );\r\n\r\n\t\tcurrentRenderList = renderLists.get( scene, renderListStack.length );\r\n\t\tcurrentRenderList.init();\r\n\r\n\t\trenderListStack.push( currentRenderList );\r\n\r\n\t\tprojectObject( scene, camera, 0, _this.sortObjects );\r\n\r\n\t\tcurrentRenderList.finish();\r\n\r\n\t\tif ( _this.sortObjects === true ) {\r\n\r\n\t\t\tcurrentRenderList.sort( _opaqueSort, _transparentSort );\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\r\n\t\tif ( _clippingEnabled === true ) clipping.beginShadows();\r\n\r\n\t\tconst shadowsArray = currentRenderState.state.shadowsArray;\r\n\r\n\t\tshadowMap.render( shadowsArray, scene, camera );\r\n\r\n\t\tif ( _clippingEnabled === true ) clipping.endShadows();\r\n\r\n\t\t//\r\n\r\n\t\tif ( this.info.autoReset === true ) this.info.reset();\r\n\r\n\t\t//\r\n\r\n\t\tbackground.render( currentRenderList, scene );\r\n\r\n\t\t// render scene\r\n\r\n\t\tcurrentRenderState.setupLights( _this.physicallyCorrectLights );\r\n\r\n\t\tif ( camera.isArrayCamera ) {\r\n\r\n\t\t\tconst cameras = camera.cameras;\r\n\r\n\t\t\tfor ( let i = 0, l = cameras.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tconst camera2 = cameras[ i ];\r\n\r\n\t\t\t\trenderScene( currentRenderList, scene, camera2, camera2.viewport );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\trenderScene( currentRenderList, scene, camera );\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\r\n\t\tif ( _currentRenderTarget !== null ) {\r\n\r\n\t\t\t// resolve multisample renderbuffers to a single-sample texture if necessary\r\n\r\n\t\t\ttextures.updateMultisampleRenderTarget( _currentRenderTarget );\r\n\r\n\t\t\t// Generate mipmap if we're using any kind of mipmap filtering\r\n\r\n\t\t\ttextures.updateRenderTargetMipmap( _currentRenderTarget );\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\r\n\t\tif ( scene.isScene === true ) scene.onAfterRender( _this, scene, camera );\r\n\r\n\t\t// _gl.finish();\r\n\r\n\t\tbindingStates.resetDefaultState();\r\n\t\t_currentMaterialId = - 1;\r\n\t\t_currentCamera = null;\r\n\r\n\t\trenderStateStack.pop();\r\n\r\n\t\tif ( renderStateStack.length > 0 ) {\r\n\r\n\t\t\tcurrentRenderState = renderStateStack[ renderStateStack.length - 1 ];\r\n\r\n\t\t} else {\r\n\r\n\t\t\tcurrentRenderState = null;\r\n\r\n\t\t}\r\n\r\n\t\trenderListStack.pop();\r\n\r\n\t\tif ( renderListStack.length > 0 ) {\r\n\r\n\t\t\tcurrentRenderList = renderListStack[ renderListStack.length - 1 ];\r\n\r\n\t\t} else {\r\n\r\n\t\t\tcurrentRenderList = null;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction projectObject( object, camera, groupOrder, sortObjects ) {\r\n\r\n\t\tif ( object.visible === false ) return;\r\n\r\n\t\tconst visible = object.layers.test( camera.layers );\r\n\r\n\t\tif ( visible ) {\r\n\r\n\t\t\tif ( object.isGroup ) {\r\n\r\n\t\t\t\tgroupOrder = object.renderOrder;\r\n\r\n\t\t\t} else if ( object.isLOD ) {\r\n\r\n\t\t\t\tif ( object.autoUpdate === true ) object.update( camera );\r\n\r\n\t\t\t} else if ( object.isLight ) {\r\n\r\n\t\t\t\tcurrentRenderState.pushLight( object );\r\n\r\n\t\t\t\tif ( object.castShadow ) {\r\n\r\n\t\t\t\t\tcurrentRenderState.pushShadow( object );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( object.isSprite ) {\r\n\r\n\t\t\t\tif ( ! object.frustumCulled || _frustum.intersectsSprite( object ) ) {\r\n\r\n\t\t\t\t\tif ( sortObjects ) {\r\n\r\n\t\t\t\t\t\t_vector3.setFromMatrixPosition( object.matrixWorld )\r\n\t\t\t\t\t\t\t.applyMatrix4( _projScreenMatrix );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tconst geometry = objects.update( object );\r\n\t\t\t\t\tconst material = object.material;\r\n\r\n\t\t\t\t\tif ( material.visible ) {\r\n\r\n\t\t\t\t\t\tcurrentRenderList.push( object, geometry, material, groupOrder, _vector3.z, null );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( object.isMesh || object.isLine || object.isPoints ) {\r\n\r\n\t\t\t\tif ( object.isSkinnedMesh ) {\r\n\r\n\t\t\t\t\t// update skeleton only once in a frame\r\n\r\n\t\t\t\t\tif ( object.skeleton.frame !== info.render.frame ) {\r\n\r\n\t\t\t\t\t\tobject.skeleton.update();\r\n\t\t\t\t\t\tobject.skeleton.frame = info.render.frame;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) {\r\n\r\n\t\t\t\t\tif ( sortObjects ) {\r\n\r\n\t\t\t\t\t\t_vector3.setFromMatrixPosition( object.matrixWorld )\r\n\t\t\t\t\t\t\t.applyMatrix4( _projScreenMatrix );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tconst geometry = objects.update( object );\r\n\t\t\t\t\tconst material = object.material;\r\n\r\n\t\t\t\t\tif ( Array.isArray( material ) ) {\r\n\r\n\t\t\t\t\t\tconst groups = geometry.groups;\r\n\r\n\t\t\t\t\t\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\r\n\r\n\t\t\t\t\t\t\tconst group = groups[ i ];\r\n\t\t\t\t\t\t\tconst groupMaterial = material[ group.materialIndex ];\r\n\r\n\t\t\t\t\t\t\tif ( groupMaterial && groupMaterial.visible ) {\r\n\r\n\t\t\t\t\t\t\t\tcurrentRenderList.push( object, geometry, groupMaterial, groupOrder, _vector3.z, group );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if ( material.visible ) {\r\n\r\n\t\t\t\t\t\tcurrentRenderList.push( object, geometry, material, groupOrder, _vector3.z, null );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tconst children = object.children;\r\n\r\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\r\n\r\n\t\t\tprojectObject( children[ i ], camera, groupOrder, sortObjects );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction renderScene( currentRenderList, scene, camera, viewport ) {\r\n\r\n\t\tconst opaqueObjects = currentRenderList.opaque;\r\n\t\tconst transmissiveObjects = currentRenderList.transmissive;\r\n\t\tconst transparentObjects = currentRenderList.transparent;\r\n\r\n\t\tcurrentRenderState.setupLightsView( camera );\r\n\r\n\t\tif ( transmissiveObjects.length > 0 ) renderTransmissionPass( opaqueObjects, scene, camera );\r\n\r\n\t\tif ( viewport ) state.viewport( _currentViewport.copy( viewport ) );\r\n\r\n\t\tif ( opaqueObjects.length > 0 ) renderObjects( opaqueObjects, scene, camera );\r\n\t\tif ( transmissiveObjects.length > 0 ) renderObjects( transmissiveObjects, scene, camera );\r\n\t\tif ( transparentObjects.length > 0 ) renderObjects( transparentObjects, scene, camera );\r\n\r\n\t\t// Ensure depth buffer writing is enabled so it can be cleared on next render\r\n\r\n\t\tstate.buffers.depth.setTest( true );\r\n\t\tstate.buffers.depth.setMask( true );\r\n\t\tstate.buffers.color.setMask( true );\r\n\r\n\t\tstate.setPolygonOffset( false );\r\n\r\n\t}\r\n\r\n\tfunction renderTransmissionPass( opaqueObjects, scene, camera ) {\r\n\r\n\t\tconst isWebGL2 = capabilities.isWebGL2;\r\n\r\n\t\tif ( _transmissionRenderTarget === null ) {\r\n\r\n\t\t\t_transmissionRenderTarget = new WebGLRenderTarget( 1, 1, {\r\n\t\t\t\tgenerateMipmaps: true,\r\n\t\t\t\ttype: utils.convert( HalfFloatType ) !== null ? HalfFloatType : UnsignedByteType,\r\n\t\t\t\tminFilter: LinearMipmapLinearFilter,\r\n\t\t\t\tsamples: ( isWebGL2 && _antialias === true ) ? 4 : 0\r\n\t\t\t} );\r\n\r\n\t\t}\r\n\r\n\t\t_this.getDrawingBufferSize( _vector2 );\r\n\r\n\t\tif ( isWebGL2 ) {\r\n\r\n\t\t\t_transmissionRenderTarget.setSize( _vector2.x, _vector2.y );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t_transmissionRenderTarget.setSize( floorPowerOfTwo( _vector2.x ), floorPowerOfTwo( _vector2.y ) );\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\r\n\t\tconst currentRenderTarget = _this.getRenderTarget();\r\n\t\t_this.setRenderTarget( _transmissionRenderTarget );\r\n\t\t_this.clear();\r\n\r\n\t\t// Turn off the features which can affect the frag color for opaque objects pass.\r\n\t\t// Otherwise they are applied twice in opaque objects pass and transmission objects pass.\r\n\t\tconst currentToneMapping = _this.toneMapping;\r\n\t\t_this.toneMapping = NoToneMapping;\r\n\r\n\t\trenderObjects( opaqueObjects, scene, camera );\r\n\r\n\t\t_this.toneMapping = currentToneMapping;\r\n\r\n\t\ttextures.updateMultisampleRenderTarget( _transmissionRenderTarget );\r\n\t\ttextures.updateRenderTargetMipmap( _transmissionRenderTarget );\r\n\r\n\t\t_this.setRenderTarget( currentRenderTarget );\r\n\r\n\t}\r\n\r\n\tfunction renderObjects( renderList, scene, camera ) {\r\n\r\n\t\tconst overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;\r\n\r\n\t\tfor ( let i = 0, l = renderList.length; i < l; i ++ ) {\r\n\r\n\t\t\tconst renderItem = renderList[ i ];\r\n\r\n\t\t\tconst object = renderItem.object;\r\n\t\t\tconst geometry = renderItem.geometry;\r\n\t\t\tconst material = overrideMaterial === null ? renderItem.material : overrideMaterial;\r\n\t\t\tconst group = renderItem.group;\r\n\r\n\t\t\tif ( object.layers.test( camera.layers ) ) {\r\n\r\n\t\t\t\trenderObject( object, scene, camera, geometry, material, group );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction renderObject( object, scene, camera, geometry, material, group ) {\r\n\r\n\t\tobject.onBeforeRender( _this, scene, camera, geometry, material, group );\r\n\r\n\t\tobject.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );\r\n\t\tobject.normalMatrix.getNormalMatrix( object.modelViewMatrix );\r\n\r\n\t\tmaterial.onBeforeRender( _this, scene, camera, geometry, object, group );\r\n\r\n\t\tif ( material.transparent === true && material.side === DoubleSide ) {\r\n\r\n\t\t\tmaterial.side = BackSide;\r\n\t\t\tmaterial.needsUpdate = true;\r\n\t\t\t_this.renderBufferDirect( camera, scene, geometry, material, object, group );\r\n\r\n\t\t\tmaterial.side = FrontSide;\r\n\t\t\tmaterial.needsUpdate = true;\r\n\t\t\t_this.renderBufferDirect( camera, scene, geometry, material, object, group );\r\n\r\n\t\t\tmaterial.side = DoubleSide;\r\n\r\n\t\t} else {\r\n\r\n\t\t\t_this.renderBufferDirect( camera, scene, geometry, material, object, group );\r\n\r\n\t\t}\r\n\r\n\t\tobject.onAfterRender( _this, scene, camera, geometry, material, group );\r\n\r\n\t}\r\n\r\n\tfunction getProgram( material, scene, object ) {\r\n\r\n\t\tif ( scene.isScene !== true ) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...\r\n\r\n\t\tconst materialProperties = properties.get( material );\r\n\r\n\t\tconst lights = currentRenderState.state.lights;\r\n\t\tconst shadowsArray = currentRenderState.state.shadowsArray;\r\n\r\n\t\tconst lightsStateVersion = lights.state.version;\r\n\r\n\t\tconst parameters = programCache.getParameters( material, lights.state, shadowsArray, scene, object );\r\n\t\tconst programCacheKey = programCache.getProgramCacheKey( parameters );\r\n\r\n\t\tlet programs = materialProperties.programs;\r\n\r\n\t\t// always update environment and fog - changing these trigger an getProgram call, but it's possible that the program doesn't change\r\n\r\n\t\tmaterialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;\r\n\t\tmaterialProperties.fog = scene.fog;\r\n\t\tmaterialProperties.envMap = ( material.isMeshStandardMaterial ? cubeuvmaps : cubemaps ).get( material.envMap || materialProperties.environment );\r\n\r\n\t\tif ( programs === undefined ) {\r\n\r\n\t\t\t// new material\r\n\r\n\t\t\tmaterial.addEventListener( 'dispose', onMaterialDispose );\r\n\r\n\t\t\tprograms = new Map();\r\n\t\t\tmaterialProperties.programs = programs;\r\n\r\n\t\t}\r\n\r\n\t\tlet program = programs.get( programCacheKey );\r\n\r\n\t\tif ( program !== undefined ) {\r\n\r\n\t\t\t// early out if program and light state is identical\r\n\r\n\t\t\tif ( materialProperties.currentProgram === program && materialProperties.lightsStateVersion === lightsStateVersion ) {\r\n\r\n\t\t\t\tupdateCommonMaterialProperties( material, parameters );\r\n\r\n\t\t\t\treturn program;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tparameters.uniforms = programCache.getUniforms( material );\r\n\r\n\t\t\tmaterial.onBuild( object, parameters, _this );\r\n\r\n\t\t\tmaterial.onBeforeCompile( parameters, _this );\r\n\r\n\t\t\tprogram = programCache.acquireProgram( parameters, programCacheKey );\r\n\t\t\tprograms.set( programCacheKey, program );\r\n\r\n\t\t\tmaterialProperties.uniforms = parameters.uniforms;\r\n\r\n\t\t}\r\n\r\n\t\tconst uniforms = materialProperties.uniforms;\r\n\r\n\t\tif ( ( ! material.isShaderMaterial && ! material.isRawShaderMaterial ) || material.clipping === true ) {\r\n\r\n\t\t\tuniforms.clippingPlanes = clipping.uniform;\r\n\r\n\t\t}\r\n\r\n\t\tupdateCommonMaterialProperties( material, parameters );\r\n\r\n\t\t// store the light setup it was created for\r\n\r\n\t\tmaterialProperties.needsLights = materialNeedsLights( material );\r\n\t\tmaterialProperties.lightsStateVersion = lightsStateVersion;\r\n\r\n\t\tif ( materialProperties.needsLights ) {\r\n\r\n\t\t\t// wire up the material to this renderer's lighting state\r\n\r\n\t\t\tuniforms.ambientLightColor.value = lights.state.ambient;\r\n\t\t\tuniforms.lightProbe.value = lights.state.probe;\r\n\t\t\tuniforms.directionalLights.value = lights.state.directional;\r\n\t\t\tuniforms.directionalLightShadows.value = lights.state.directionalShadow;\r\n\t\t\tuniforms.spotLights.value = lights.state.spot;\r\n\t\t\tuniforms.spotLightShadows.value = lights.state.spotShadow;\r\n\t\t\tuniforms.rectAreaLights.value = lights.state.rectArea;\r\n\t\t\tuniforms.ltc_1.value = lights.state.rectAreaLTC1;\r\n\t\t\tuniforms.ltc_2.value = lights.state.rectAreaLTC2;\r\n\t\t\tuniforms.pointLights.value = lights.state.point;\r\n\t\t\tuniforms.pointLightShadows.value = lights.state.pointShadow;\r\n\t\t\tuniforms.hemisphereLights.value = lights.state.hemi;\r\n\r\n\t\t\tuniforms.directionalShadowMap.value = lights.state.directionalShadowMap;\r\n\t\t\tuniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;\r\n\t\t\tuniforms.spotShadowMap.value = lights.state.spotShadowMap;\r\n\t\t\tuniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;\r\n\t\t\tuniforms.pointShadowMap.value = lights.state.pointShadowMap;\r\n\t\t\tuniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;\r\n\t\t\t// TODO (abelnation): add area lights shadow info to uniforms\r\n\r\n\t\t}\r\n\r\n\t\tconst progUniforms = program.getUniforms();\r\n\t\tconst uniformsList = WebGLUniforms.seqWithValue( progUniforms.seq, uniforms );\r\n\r\n\t\tmaterialProperties.currentProgram = program;\r\n\t\tmaterialProperties.uniformsList = uniformsList;\r\n\r\n\t\treturn program;\r\n\r\n\t}\r\n\r\n\tfunction updateCommonMaterialProperties( material, parameters ) {\r\n\r\n\t\tconst materialProperties = properties.get( material );\r\n\r\n\t\tmaterialProperties.outputEncoding = parameters.outputEncoding;\r\n\t\tmaterialProperties.instancing = parameters.instancing;\r\n\t\tmaterialProperties.skinning = parameters.skinning;\r\n\t\tmaterialProperties.morphTargets = parameters.morphTargets;\r\n\t\tmaterialProperties.morphNormals = parameters.morphNormals;\r\n\t\tmaterialProperties.morphColors = parameters.morphColors;\r\n\t\tmaterialProperties.morphTargetsCount = parameters.morphTargetsCount;\r\n\t\tmaterialProperties.numClippingPlanes = parameters.numClippingPlanes;\r\n\t\tmaterialProperties.numIntersection = parameters.numClipIntersection;\r\n\t\tmaterialProperties.vertexAlphas = parameters.vertexAlphas;\r\n\t\tmaterialProperties.vertexTangents = parameters.vertexTangents;\r\n\t\tmaterialProperties.toneMapping = parameters.toneMapping;\r\n\r\n\t}\r\n\r\n\tfunction setProgram( camera, scene, geometry, material, object ) {\r\n\r\n\t\tif ( scene.isScene !== true ) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...\r\n\r\n\t\ttextures.resetTextureUnits();\r\n\r\n\t\tconst fog = scene.fog;\r\n\t\tconst environment = material.isMeshStandardMaterial ? scene.environment : null;\r\n\t\tconst encoding = ( _currentRenderTarget === null ) ? _this.outputEncoding : ( _currentRenderTarget.isXRRenderTarget === true ? _currentRenderTarget.texture.encoding : LinearEncoding );\r\n\t\tconst envMap = ( material.isMeshStandardMaterial ? cubeuvmaps : cubemaps ).get( material.envMap || environment );\r\n\t\tconst vertexAlphas = material.vertexColors === true && !! geometry.attributes.color && geometry.attributes.color.itemSize === 4;\r\n\t\tconst vertexTangents = !! material.normalMap && !! geometry.attributes.tangent;\r\n\t\tconst morphTargets = !! geometry.morphAttributes.position;\r\n\t\tconst morphNormals = !! geometry.morphAttributes.normal;\r\n\t\tconst morphColors = !! geometry.morphAttributes.color;\r\n\t\tconst toneMapping = material.toneMapped ? _this.toneMapping : NoToneMapping;\r\n\r\n\t\tconst morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;\r\n\t\tconst morphTargetsCount = ( morphAttribute !== undefined ) ? morphAttribute.length : 0;\r\n\r\n\t\tconst materialProperties = properties.get( material );\r\n\t\tconst lights = currentRenderState.state.lights;\r\n\r\n\t\tif ( _clippingEnabled === true ) {\r\n\r\n\t\t\tif ( _localClippingEnabled === true || camera !== _currentCamera ) {\r\n\r\n\t\t\t\tconst useCache =\r\n\t\t\t\t\tcamera === _currentCamera &&\r\n\t\t\t\t\tmaterial.id === _currentMaterialId;\r\n\r\n\t\t\t\t// we might want to call this function with some ClippingGroup\r\n\t\t\t\t// object instead of the material, once it becomes feasible\r\n\t\t\t\t// (#8465, #8379)\r\n\t\t\t\tclipping.setState( material, camera, useCache );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\r\n\t\tlet needsProgramChange = false;\r\n\r\n\t\tif ( material.version === materialProperties.__version ) {\r\n\r\n\t\t\tif ( materialProperties.needsLights && ( materialProperties.lightsStateVersion !== lights.state.version ) ) {\r\n\r\n\t\t\t\tneedsProgramChange = true;\r\n\r\n\t\t\t} else if ( materialProperties.outputEncoding !== encoding ) {\r\n\r\n\t\t\t\tneedsProgramChange = true;\r\n\r\n\t\t\t} else if ( object.isInstancedMesh && materialProperties.instancing === false ) {\r\n\r\n\t\t\t\tneedsProgramChange = true;\r\n\r\n\t\t\t} else if ( ! object.isInstancedMesh && materialProperties.instancing === true ) {\r\n\r\n\t\t\t\tneedsProgramChange = true;\r\n\r\n\t\t\t} else if ( object.isSkinnedMesh && materialProperties.skinning === false ) {\r\n\r\n\t\t\t\tneedsProgramChange = true;\r\n\r\n\t\t\t} else if ( ! object.isSkinnedMesh && materialProperties.skinning === true ) {\r\n\r\n\t\t\t\tneedsProgramChange = true;\r\n\r\n\t\t\t} else if ( materialProperties.envMap !== envMap ) {\r\n\r\n\t\t\t\tneedsProgramChange = true;\r\n\r\n\t\t\t} else if ( material.fog && materialProperties.fog !== fog ) {\r\n\r\n\t\t\t\tneedsProgramChange = true;\r\n\r\n\t\t\t} else if ( materialProperties.numClippingPlanes !== undefined &&\r\n\t\t\t\t( materialProperties.numClippingPlanes !== clipping.numPlanes ||\r\n\t\t\t\tmaterialProperties.numIntersection !== clipping.numIntersection ) ) {\r\n\r\n\t\t\t\tneedsProgramChange = true;\r\n\r\n\t\t\t} else if ( materialProperties.vertexAlphas !== vertexAlphas ) {\r\n\r\n\t\t\t\tneedsProgramChange = true;\r\n\r\n\t\t\t} else if ( materialProperties.vertexTangents !== vertexTangents ) {\r\n\r\n\t\t\t\tneedsProgramChange = true;\r\n\r\n\t\t\t} else if ( materialProperties.morphTargets !== morphTargets ) {\r\n\r\n\t\t\t\tneedsProgramChange = true;\r\n\r\n\t\t\t} else if ( materialProperties.morphNormals !== morphNormals ) {\r\n\r\n\t\t\t\tneedsProgramChange = true;\r\n\r\n\t\t\t} else if ( materialProperties.morphColors !== morphColors ) {\r\n\r\n\t\t\t\tneedsProgramChange = true;\r\n\r\n\t\t\t} else if ( materialProperties.toneMapping !== toneMapping ) {\r\n\r\n\t\t\t\tneedsProgramChange = true;\r\n\r\n\t\t\t} else if ( capabilities.isWebGL2 === true && materialProperties.morphTargetsCount !== morphTargetsCount ) {\r\n\r\n\t\t\t\tneedsProgramChange = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tneedsProgramChange = true;\r\n\t\t\tmaterialProperties.__version = material.version;\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\r\n\t\tlet program = materialProperties.currentProgram;\r\n\r\n\t\tif ( needsProgramChange === true ) {\r\n\r\n\t\t\tprogram = getProgram( material, scene, object );\r\n\r\n\t\t}\r\n\r\n\t\tlet refreshProgram = false;\r\n\t\tlet refreshMaterial = false;\r\n\t\tlet refreshLights = false;\r\n\r\n\t\tconst p_uniforms = program.getUniforms(),\r\n\t\t\tm_uniforms = materialProperties.uniforms;\r\n\r\n\t\tif ( state.useProgram( program.program ) ) {\r\n\r\n\t\t\trefreshProgram = true;\r\n\t\t\trefreshMaterial = true;\r\n\t\t\trefreshLights = true;\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.id !== _currentMaterialId ) {\r\n\r\n\t\t\t_currentMaterialId = material.id;\r\n\r\n\t\t\trefreshMaterial = true;\r\n\r\n\t\t}\r\n\r\n\t\tif ( refreshProgram || _currentCamera !== camera ) {\r\n\r\n\t\t\tp_uniforms.setValue( _gl, 'projectionMatrix', camera.projectionMatrix );\r\n\r\n\t\t\tif ( capabilities.logarithmicDepthBuffer ) {\r\n\r\n\t\t\t\tp_uniforms.setValue( _gl, 'logDepthBufFC',\r\n\t\t\t\t\t2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( _currentCamera !== camera ) {\r\n\r\n\t\t\t\t_currentCamera = camera;\r\n\r\n\t\t\t\t// lighting uniforms depend on the camera so enforce an update\r\n\t\t\t\t// now, in case this material supports lights - or later, when\r\n\t\t\t\t// the next material that does gets activated:\r\n\r\n\t\t\t\trefreshMaterial = true;\t\t// set to true on material change\r\n\t\t\t\trefreshLights = true;\t\t// remains set until update done\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// load material specific uniforms\r\n\t\t\t// (shader material also gets them for the sake of genericity)\r\n\r\n\t\t\tif ( material.isShaderMaterial ||\r\n\t\t\t\tmaterial.isMeshPhongMaterial ||\r\n\t\t\t\tmaterial.isMeshToonMaterial ||\r\n\t\t\t\tmaterial.isMeshStandardMaterial ||\r\n\t\t\t\tmaterial.envMap ) {\r\n\r\n\t\t\t\tconst uCamPos = p_uniforms.map.cameraPosition;\r\n\r\n\t\t\t\tif ( uCamPos !== undefined ) {\r\n\r\n\t\t\t\t\tuCamPos.setValue( _gl,\r\n\t\t\t\t\t\t_vector3.setFromMatrixPosition( camera.matrixWorld ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( material.isMeshPhongMaterial ||\r\n\t\t\t\tmaterial.isMeshToonMaterial ||\r\n\t\t\t\tmaterial.isMeshLambertMaterial ||\r\n\t\t\t\tmaterial.isMeshBasicMaterial ||\r\n\t\t\t\tmaterial.isMeshStandardMaterial ||\r\n\t\t\t\tmaterial.isShaderMaterial ) {\r\n\r\n\t\t\t\tp_uniforms.setValue( _gl, 'isOrthographic', camera.isOrthographicCamera === true );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( material.isMeshPhongMaterial ||\r\n\t\t\t\tmaterial.isMeshToonMaterial ||\r\n\t\t\t\tmaterial.isMeshLambertMaterial ||\r\n\t\t\t\tmaterial.isMeshBasicMaterial ||\r\n\t\t\t\tmaterial.isMeshStandardMaterial ||\r\n\t\t\t\tmaterial.isShaderMaterial ||\r\n\t\t\t\tmaterial.isShadowMaterial ||\r\n\t\t\t\tobject.isSkinnedMesh ) {\r\n\r\n\t\t\t\tp_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// skinning and morph target uniforms must be set even if material didn't change\r\n\t\t// auto-setting of texture unit for bone and morph texture must go before other textures\r\n\t\t// otherwise textures used for skinning and morphing can take over texture units reserved for other material textures\r\n\r\n\t\tif ( object.isSkinnedMesh ) {\r\n\r\n\t\t\tp_uniforms.setOptional( _gl, object, 'bindMatrix' );\r\n\t\t\tp_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );\r\n\r\n\t\t\tconst skeleton = object.skeleton;\r\n\r\n\t\t\tif ( skeleton ) {\r\n\r\n\t\t\t\tif ( capabilities.floatVertexTextures ) {\r\n\r\n\t\t\t\t\tif ( skeleton.boneTexture === null ) skeleton.computeBoneTexture();\r\n\r\n\t\t\t\t\tp_uniforms.setValue( _gl, 'boneTexture', skeleton.boneTexture, textures );\r\n\t\t\t\t\tp_uniforms.setValue( _gl, 'boneTextureSize', skeleton.boneTextureSize );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tp_uniforms.setOptional( _gl, skeleton, 'boneMatrices' );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tconst morphAttributes = geometry.morphAttributes;\r\n\r\n\t\tif ( morphAttributes.position !== undefined || morphAttributes.normal !== undefined || ( morphAttributes.color !== undefined && capabilities.isWebGL2 === true ) ) {\r\n\r\n\t\t\tmorphtargets.update( object, geometry, material, program );\r\n\r\n\t\t}\r\n\r\n\r\n\t\tif ( refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow ) {\r\n\r\n\t\t\tmaterialProperties.receiveShadow = object.receiveShadow;\r\n\t\t\tp_uniforms.setValue( _gl, 'receiveShadow', object.receiveShadow );\r\n\r\n\t\t}\r\n\r\n\t\tif ( refreshMaterial ) {\r\n\r\n\t\t\tp_uniforms.setValue( _gl, 'toneMappingExposure', _this.toneMappingExposure );\r\n\r\n\t\t\tif ( materialProperties.needsLights ) {\r\n\r\n\t\t\t\t// the current material requires lighting info\r\n\r\n\t\t\t\t// note: all lighting uniforms are always set correctly\r\n\t\t\t\t// they simply reference the renderer's state for their\r\n\t\t\t\t// values\r\n\t\t\t\t//\r\n\t\t\t\t// use the current material's .needsUpdate flags to set\r\n\t\t\t\t// the GL state when required\r\n\r\n\t\t\t\tmarkUniformsLightsNeedsUpdate( m_uniforms, refreshLights );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// refresh uniforms common to several materials\r\n\r\n\t\t\tif ( fog && material.fog ) {\r\n\r\n\t\t\t\tmaterials.refreshFogUniforms( m_uniforms, fog );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tmaterials.refreshMaterialUniforms( m_uniforms, material, _pixelRatio, _height, _transmissionRenderTarget );\r\n\r\n\t\t\tWebGLUniforms.upload( _gl, materialProperties.uniformsList, m_uniforms, textures );\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.isShaderMaterial && material.uniformsNeedUpdate === true ) {\r\n\r\n\t\t\tWebGLUniforms.upload( _gl, materialProperties.uniformsList, m_uniforms, textures );\r\n\t\t\tmaterial.uniformsNeedUpdate = false;\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.isSpriteMaterial ) {\r\n\r\n\t\t\tp_uniforms.setValue( _gl, 'center', object.center );\r\n\r\n\t\t}\r\n\r\n\t\t// common matrices\r\n\r\n\t\tp_uniforms.setValue( _gl, 'modelViewMatrix', object.modelViewMatrix );\r\n\t\tp_uniforms.setValue( _gl, 'normalMatrix', object.normalMatrix );\r\n\t\tp_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );\r\n\r\n\t\treturn program;\r\n\r\n\t}\r\n\r\n\t// If uniforms are marked as clean, they don't need to be loaded to the GPU.\r\n\r\n\tfunction markUniformsLightsNeedsUpdate( uniforms, value ) {\r\n\r\n\t\tuniforms.ambientLightColor.needsUpdate = value;\r\n\t\tuniforms.lightProbe.needsUpdate = value;\r\n\r\n\t\tuniforms.directionalLights.needsUpdate = value;\r\n\t\tuniforms.directionalLightShadows.needsUpdate = value;\r\n\t\tuniforms.pointLights.needsUpdate = value;\r\n\t\tuniforms.pointLightShadows.needsUpdate = value;\r\n\t\tuniforms.spotLights.needsUpdate = value;\r\n\t\tuniforms.spotLightShadows.needsUpdate = value;\r\n\t\tuniforms.rectAreaLights.needsUpdate = value;\r\n\t\tuniforms.hemisphereLights.needsUpdate = value;\r\n\r\n\t}\r\n\r\n\tfunction materialNeedsLights( material ) {\r\n\r\n\t\treturn material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial ||\r\n\t\t\tmaterial.isMeshStandardMaterial || material.isShadowMaterial ||\r\n\t\t\t( material.isShaderMaterial && material.lights === true );\r\n\r\n\t}\r\n\r\n\tthis.getActiveCubeFace = function () {\r\n\r\n\t\treturn _currentActiveCubeFace;\r\n\r\n\t};\r\n\r\n\tthis.getActiveMipmapLevel = function () {\r\n\r\n\t\treturn _currentActiveMipmapLevel;\r\n\r\n\t};\r\n\r\n\tthis.getRenderTarget = function () {\r\n\r\n\t\treturn _currentRenderTarget;\r\n\r\n\t};\r\n\r\n\tthis.setRenderTargetTextures = function ( renderTarget, colorTexture, depthTexture ) {\r\n\r\n\t\tproperties.get( renderTarget.texture ).__webglTexture = colorTexture;\r\n\t\tproperties.get( renderTarget.depthTexture ).__webglTexture = depthTexture;\r\n\r\n\t\tconst renderTargetProperties = properties.get( renderTarget );\r\n\t\trenderTargetProperties.__hasExternalTextures = true;\r\n\r\n\t\tif ( renderTargetProperties.__hasExternalTextures ) {\r\n\r\n\t\t\trenderTargetProperties.__autoAllocateDepthBuffer = depthTexture === undefined;\r\n\r\n\t\t\tif ( ! renderTargetProperties.__autoAllocateDepthBuffer ) {\r\n\r\n\t\t\t\t// The multisample_render_to_texture extension doesn't work properly if there\r\n\t\t\t\t// are midframe flushes and an external depth buffer. Disable use of the extension.\r\n\t\t\t\tif ( extensions.has( 'WEBGL_multisampled_render_to_texture' ) === true ) {\r\n\r\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided' );\r\n\t\t\t\t\trenderTargetProperties.__useRenderToTexture = false;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.setRenderTargetFramebuffer = function ( renderTarget, defaultFramebuffer ) {\r\n\r\n\t\tconst renderTargetProperties = properties.get( renderTarget );\r\n\t\trenderTargetProperties.__webglFramebuffer = defaultFramebuffer;\r\n\t\trenderTargetProperties.__useDefaultFramebuffer = defaultFramebuffer === undefined;\r\n\r\n\t};\r\n\r\n\tthis.setRenderTarget = function ( renderTarget, activeCubeFace = 0, activeMipmapLevel = 0 ) {\r\n\r\n\t\t_currentRenderTarget = renderTarget;\r\n\t\t_currentActiveCubeFace = activeCubeFace;\r\n\t\t_currentActiveMipmapLevel = activeMipmapLevel;\r\n\r\n\t\tlet useDefaultFramebuffer = true;\r\n\r\n\t\tif ( renderTarget ) {\r\n\r\n\t\t\tconst renderTargetProperties = properties.get( renderTarget );\r\n\r\n\t\t\tif ( renderTargetProperties.__useDefaultFramebuffer !== undefined ) {\r\n\r\n\t\t\t\t// We need to make sure to rebind the framebuffer.\r\n\t\t\t\tstate.bindFramebuffer( _gl.FRAMEBUFFER, null );\r\n\t\t\t\tuseDefaultFramebuffer = false;\r\n\r\n\t\t\t} else if ( renderTargetProperties.__webglFramebuffer === undefined ) {\r\n\r\n\t\t\t\ttextures.setupRenderTarget( renderTarget );\r\n\r\n\t\t\t} else if ( renderTargetProperties.__hasExternalTextures ) {\r\n\r\n\t\t\t\t// Color and depth texture must be rebound in order for the swapchain to update.\r\n\t\t\t\ttextures.rebindTextures( renderTarget, properties.get( renderTarget.texture ).__webglTexture, properties.get( renderTarget.depthTexture ).__webglTexture );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tlet framebuffer = null;\r\n\t\tlet isCube = false;\r\n\t\tlet isRenderTarget3D = false;\r\n\r\n\t\tif ( renderTarget ) {\r\n\r\n\t\t\tconst texture = renderTarget.texture;\r\n\r\n\t\t\tif ( texture.isData3DTexture || texture.isDataArrayTexture ) {\r\n\r\n\t\t\t\tisRenderTarget3D = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst __webglFramebuffer = properties.get( renderTarget ).__webglFramebuffer;\r\n\r\n\t\t\tif ( renderTarget.isWebGLCubeRenderTarget ) {\r\n\r\n\t\t\t\tframebuffer = __webglFramebuffer[ activeCubeFace ];\r\n\t\t\t\tisCube = true;\r\n\r\n\t\t\t} else if ( ( capabilities.isWebGL2 && renderTarget.samples > 0 ) && textures.useMultisampledRTT( renderTarget ) === false ) {\r\n\r\n\t\t\t\tframebuffer = properties.get( renderTarget ).__webglMultisampledFramebuffer;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tframebuffer = __webglFramebuffer;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_currentViewport.copy( renderTarget.viewport );\r\n\t\t\t_currentScissor.copy( renderTarget.scissor );\r\n\t\t\t_currentScissorTest = renderTarget.scissorTest;\r\n\r\n\t\t} else {\r\n\r\n\t\t\t_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ).floor();\r\n\t\t\t_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ).floor();\r\n\t\t\t_currentScissorTest = _scissorTest;\r\n\r\n\t\t}\r\n\r\n\t\tconst framebufferBound = state.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\r\n\r\n\t\tif ( framebufferBound && capabilities.drawBuffers && useDefaultFramebuffer ) {\r\n\r\n\t\t\tstate.drawBuffers( renderTarget, framebuffer );\r\n\r\n\t\t}\r\n\r\n\t\tstate.viewport( _currentViewport );\r\n\t\tstate.scissor( _currentScissor );\r\n\t\tstate.setScissorTest( _currentScissorTest );\r\n\r\n\t\tif ( isCube ) {\r\n\r\n\t\t\tconst textureProperties = properties.get( renderTarget.texture );\r\n\t\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel );\r\n\r\n\t\t} else if ( isRenderTarget3D ) {\r\n\r\n\t\t\tconst textureProperties = properties.get( renderTarget.texture );\r\n\t\t\tconst layer = activeCubeFace || 0;\r\n\t\t\t_gl.framebufferTextureLayer( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureProperties.__webglTexture, activeMipmapLevel || 0, layer );\r\n\r\n\t\t}\r\n\r\n\t\t_currentMaterialId = - 1; // reset current material to ensure correct uniform bindings\r\n\r\n\t};\r\n\r\n\tthis.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer, activeCubeFaceIndex ) {\r\n\r\n\t\tif ( ! ( renderTarget && renderTarget.isWebGLRenderTarget ) ) {\r\n\r\n\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tlet framebuffer = properties.get( renderTarget ).__webglFramebuffer;\r\n\r\n\t\tif ( renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== undefined ) {\r\n\r\n\t\t\tframebuffer = framebuffer[ activeCubeFaceIndex ];\r\n\r\n\t\t}\r\n\r\n\t\tif ( framebuffer ) {\r\n\r\n\t\t\tstate.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\r\n\r\n\t\t\ttry {\r\n\r\n\t\t\t\tconst texture = renderTarget.texture;\r\n\t\t\t\tconst textureFormat = texture.format;\r\n\t\t\t\tconst textureType = texture.type;\r\n\r\n\t\t\t\tif ( textureFormat !== RGBAFormat && utils.convert( textureFormat ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_FORMAT ) ) {\r\n\r\n\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );\r\n\t\t\t\t\treturn;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconst halfFloatSupportedByExt = ( textureType === HalfFloatType ) && ( extensions.has( 'EXT_color_buffer_half_float' ) || ( capabilities.isWebGL2 && extensions.has( 'EXT_color_buffer_float' ) ) );\r\n\r\n\t\t\t\tif ( textureType !== UnsignedByteType && utils.convert( textureType ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_TYPE ) && // Edge and Chrome Mac < 52 (#9513)\r\n\t\t\t\t\t! ( textureType === FloatType && ( capabilities.isWebGL2 || extensions.has( 'OES_texture_float' ) || extensions.has( 'WEBGL_color_buffer_float' ) ) ) && // Chrome Mac >= 52 and Firefox\r\n\t\t\t\t\t! halfFloatSupportedByExt ) {\r\n\r\n\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );\r\n\t\t\t\t\treturn;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( _gl.checkFramebufferStatus( _gl.FRAMEBUFFER ) === _gl.FRAMEBUFFER_COMPLETE ) {\r\n\r\n\t\t\t\t\t// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)\r\n\r\n\t\t\t\t\tif ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {\r\n\r\n\t\t\t\t\t\t_gl.readPixels( x, y, width, height, utils.convert( textureFormat ), utils.convert( textureType ), buffer );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} finally {\r\n\r\n\t\t\t\t// restore framebuffer of current render target if necessary\r\n\r\n\t\t\t\tconst framebuffer = ( _currentRenderTarget !== null ) ? properties.get( _currentRenderTarget ).__webglFramebuffer : null;\r\n\t\t\t\tstate.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.copyFramebufferToTexture = function ( position, texture, level = 0 ) {\r\n\r\n\t\tif ( texture.isFramebufferTexture !== true ) {\r\n\r\n\t\t\tconsole.error( 'THREE.WebGLRenderer: copyFramebufferToTexture() can only be used with FramebufferTexture.' );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tconst levelScale = Math.pow( 2, - level );\r\n\t\tconst width = Math.floor( texture.image.width * levelScale );\r\n\t\tconst height = Math.floor( texture.image.height * levelScale );\r\n\r\n\t\ttextures.setTexture2D( texture, 0 );\r\n\r\n\t\t_gl.copyTexSubImage2D( _gl.TEXTURE_2D, level, 0, 0, position.x, position.y, width, height );\r\n\r\n\t\tstate.unbindTexture();\r\n\r\n\t};\r\n\r\n\tthis.copyTextureToTexture = function ( position, srcTexture, dstTexture, level = 0 ) {\r\n\r\n\t\tconst width = srcTexture.image.width;\r\n\t\tconst height = srcTexture.image.height;\r\n\t\tconst glFormat = utils.convert( dstTexture.format );\r\n\t\tconst glType = utils.convert( dstTexture.type );\r\n\r\n\t\ttextures.setTexture2D( dstTexture, 0 );\r\n\r\n\t\t// As another texture upload may have changed pixelStorei\r\n\t\t// parameters, make sure they are correct for the dstTexture\r\n\t\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY );\r\n\t\t_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha );\r\n\t\t_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment );\r\n\r\n\t\tif ( srcTexture.isDataTexture ) {\r\n\r\n\t\t\t_gl.texSubImage2D( _gl.TEXTURE_2D, level, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tif ( srcTexture.isCompressedTexture ) {\r\n\r\n\t\t\t\t_gl.compressedTexSubImage2D( _gl.TEXTURE_2D, level, position.x, position.y, srcTexture.mipmaps[ 0 ].width, srcTexture.mipmaps[ 0 ].height, glFormat, srcTexture.mipmaps[ 0 ].data );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t_gl.texSubImage2D( _gl.TEXTURE_2D, level, position.x, position.y, glFormat, glType, srcTexture.image );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// Generate mipmaps only when copying level 0\r\n\t\tif ( level === 0 && dstTexture.generateMipmaps ) _gl.generateMipmap( _gl.TEXTURE_2D );\r\n\r\n\t\tstate.unbindTexture();\r\n\r\n\t};\r\n\r\n\tthis.copyTextureToTexture3D = function ( sourceBox, position, srcTexture, dstTexture, level = 0 ) {\r\n\r\n\t\tif ( _this.isWebGL1Renderer ) {\r\n\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.' );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tconst width = sourceBox.max.x - sourceBox.min.x + 1;\r\n\t\tconst height = sourceBox.max.y - sourceBox.min.y + 1;\r\n\t\tconst depth = sourceBox.max.z - sourceBox.min.z + 1;\r\n\t\tconst glFormat = utils.convert( dstTexture.format );\r\n\t\tconst glType = utils.convert( dstTexture.type );\r\n\t\tlet glTarget;\r\n\r\n\t\tif ( dstTexture.isData3DTexture ) {\r\n\r\n\t\t\ttextures.setTexture3D( dstTexture, 0 );\r\n\t\t\tglTarget = _gl.TEXTURE_3D;\r\n\r\n\t\t} else if ( dstTexture.isDataArrayTexture ) {\r\n\r\n\t\t\ttextures.setTexture2DArray( dstTexture, 0 );\r\n\t\t\tglTarget = _gl.TEXTURE_2D_ARRAY;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.' );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY );\r\n\t\t_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha );\r\n\t\t_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment );\r\n\r\n\t\tconst unpackRowLen = _gl.getParameter( _gl.UNPACK_ROW_LENGTH );\r\n\t\tconst unpackImageHeight = _gl.getParameter( _gl.UNPACK_IMAGE_HEIGHT );\r\n\t\tconst unpackSkipPixels = _gl.getParameter( _gl.UNPACK_SKIP_PIXELS );\r\n\t\tconst unpackSkipRows = _gl.getParameter( _gl.UNPACK_SKIP_ROWS );\r\n\t\tconst unpackSkipImages = _gl.getParameter( _gl.UNPACK_SKIP_IMAGES );\r\n\r\n\t\tconst image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[ 0 ] : srcTexture.image;\r\n\r\n\t\t_gl.pixelStorei( _gl.UNPACK_ROW_LENGTH, image.width );\r\n\t\t_gl.pixelStorei( _gl.UNPACK_IMAGE_HEIGHT, image.height );\r\n\t\t_gl.pixelStorei( _gl.UNPACK_SKIP_PIXELS, sourceBox.min.x );\r\n\t\t_gl.pixelStorei( _gl.UNPACK_SKIP_ROWS, sourceBox.min.y );\r\n\t\t_gl.pixelStorei( _gl.UNPACK_SKIP_IMAGES, sourceBox.min.z );\r\n\r\n\t\tif ( srcTexture.isDataTexture || srcTexture.isData3DTexture ) {\r\n\r\n\t\t\t_gl.texSubImage3D( glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image.data );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tif ( srcTexture.isCompressedTexture ) {\r\n\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture.' );\r\n\t\t\t\t_gl.compressedTexSubImage3D( glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, image.data );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t_gl.texSubImage3D( glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t_gl.pixelStorei( _gl.UNPACK_ROW_LENGTH, unpackRowLen );\r\n\t\t_gl.pixelStorei( _gl.UNPACK_IMAGE_HEIGHT, unpackImageHeight );\r\n\t\t_gl.pixelStorei( _gl.UNPACK_SKIP_PIXELS, unpackSkipPixels );\r\n\t\t_gl.pixelStorei( _gl.UNPACK_SKIP_ROWS, unpackSkipRows );\r\n\t\t_gl.pixelStorei( _gl.UNPACK_SKIP_IMAGES, unpackSkipImages );\r\n\r\n\t\t// Generate mipmaps only when copying level 0\r\n\t\tif ( level === 0 && dstTexture.generateMipmaps ) _gl.generateMipmap( glTarget );\r\n\r\n\t\tstate.unbindTexture();\r\n\r\n\t};\r\n\r\n\tthis.initTexture = function ( texture ) {\r\n\r\n\t\ttextures.setTexture2D( texture, 0 );\r\n\r\n\t\tstate.unbindTexture();\r\n\r\n\t};\r\n\r\n\tthis.resetState = function () {\r\n\r\n\t\t_currentActiveCubeFace = 0;\r\n\t\t_currentActiveMipmapLevel = 0;\r\n\t\t_currentRenderTarget = null;\r\n\r\n\t\tstate.reset();\r\n\t\tbindingStates.reset();\r\n\r\n\t};\r\n\r\n\tif ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {\r\n\r\n\t\t__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'observe', { detail: this } ) );\r\n\r\n\t}\r\n\r\n}\r\n\r\nWebGLRenderer.prototype.isWebGLRenderer = true;\r\n\r\nexport { WebGLRenderer };\r\n"]},"metadata":{},"sourceType":"module"}