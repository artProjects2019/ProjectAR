{"ast":null,"code":"import \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport { InstancedBufferAttribute } from '../core/InstancedBufferAttribute.js';\nimport { Mesh } from './Mesh.js';\nimport { Matrix4 } from '../math/Matrix4.js';\n\nconst _instanceLocalMatrix = /*@__PURE__*/new Matrix4();\n\nconst _instanceWorldMatrix = /*@__PURE__*/new Matrix4();\n\nconst _instanceIntersects = [];\n\nconst _mesh = /*@__PURE__*/new Mesh();\n\nclass InstancedMesh extends Mesh {\n  constructor(geometry, material, count) {\n    super(geometry, material);\n    this.instanceMatrix = new InstancedBufferAttribute(new Float32Array(count * 16), 16);\n    this.instanceColor = null;\n    this.count = count;\n    this.frustumCulled = false;\n  }\n\n  copy(source) {\n    super.copy(source);\n    this.instanceMatrix.copy(source.instanceMatrix);\n    if (source.instanceColor !== null) this.instanceColor = source.instanceColor.clone();\n    this.count = source.count;\n    return this;\n  }\n\n  getColorAt(index, color) {\n    color.fromArray(this.instanceColor.array, index * 3);\n  }\n\n  getMatrixAt(index, matrix) {\n    matrix.fromArray(this.instanceMatrix.array, index * 16);\n  }\n\n  raycast(raycaster, intersects) {\n    const matrixWorld = this.matrixWorld;\n    const raycastTimes = this.count;\n    _mesh.geometry = this.geometry;\n    _mesh.material = this.material;\n    if (_mesh.material === undefined) return;\n\n    for (let instanceId = 0; instanceId < raycastTimes; instanceId++) {\n      // calculate the world matrix for each instance\n      this.getMatrixAt(instanceId, _instanceLocalMatrix);\n\n      _instanceWorldMatrix.multiplyMatrices(matrixWorld, _instanceLocalMatrix); // the mesh represents this single instance\n\n\n      _mesh.matrixWorld = _instanceWorldMatrix;\n\n      _mesh.raycast(raycaster, _instanceIntersects); // process the result of raycast\n\n\n      for (let i = 0, l = _instanceIntersects.length; i < l; i++) {\n        const intersect = _instanceIntersects[i];\n        intersect.instanceId = instanceId;\n        intersect.object = this;\n        intersects.push(intersect);\n      }\n\n      _instanceIntersects.length = 0;\n    }\n  }\n\n  setColorAt(index, color) {\n    if (this.instanceColor === null) {\n      this.instanceColor = new InstancedBufferAttribute(new Float32Array(this.instanceMatrix.count * 3), 3);\n    }\n\n    color.toArray(this.instanceColor.array, index * 3);\n  }\n\n  setMatrixAt(index, matrix) {\n    matrix.toArray(this.instanceMatrix.array, index * 16);\n  }\n\n  updateMorphTargets() {}\n\n  dispose() {\n    this.dispatchEvent({\n      type: 'dispose'\n    });\n  }\n\n}\n\nInstancedMesh.prototype.isInstancedMesh = true;\nexport { InstancedMesh };","map":{"version":3,"sources":["C:/Users/dell/Desktop/projektlogin/vue-3-authentication-jwt/src/games/three/src/objects/InstancedMesh.js"],"names":["InstancedBufferAttribute","Mesh","Matrix4","_instanceLocalMatrix","_instanceWorldMatrix","_instanceIntersects","_mesh","InstancedMesh","constructor","geometry","material","count","instanceMatrix","Float32Array","instanceColor","frustumCulled","copy","source","clone","getColorAt","index","color","fromArray","array","getMatrixAt","matrix","raycast","raycaster","intersects","matrixWorld","raycastTimes","undefined","instanceId","multiplyMatrices","i","l","length","intersect","object","push","setColorAt","toArray","setMatrixAt","updateMorphTargets","dispose","dispatchEvent","type","prototype","isInstancedMesh"],"mappings":"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","sourcesContent":["import { InstancedBufferAttribute } from '../core/InstancedBufferAttribute.js';\r\nimport { Mesh } from './Mesh.js';\r\nimport { Matrix4 } from '../math/Matrix4.js';\r\n\r\nconst _instanceLocalMatrix = /*@__PURE__*/ new Matrix4();\r\nconst _instanceWorldMatrix = /*@__PURE__*/ new Matrix4();\r\n\r\nconst _instanceIntersects = [];\r\n\r\nconst _mesh = /*@__PURE__*/ new Mesh();\r\n\r\nclass InstancedMesh extends Mesh {\r\n\r\n\tconstructor( geometry, material, count ) {\r\n\r\n\t\tsuper( geometry, material );\r\n\r\n\t\tthis.instanceMatrix = new InstancedBufferAttribute( new Float32Array( count * 16 ), 16 );\r\n\t\tthis.instanceColor = null;\r\n\r\n\t\tthis.count = count;\r\n\r\n\t\tthis.frustumCulled = false;\r\n\r\n\t}\r\n\r\n\tcopy( source ) {\r\n\r\n\t\tsuper.copy( source );\r\n\r\n\t\tthis.instanceMatrix.copy( source.instanceMatrix );\r\n\r\n\t\tif ( source.instanceColor !== null ) this.instanceColor = source.instanceColor.clone();\r\n\r\n\t\tthis.count = source.count;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tgetColorAt( index, color ) {\r\n\r\n\t\tcolor.fromArray( this.instanceColor.array, index * 3 );\r\n\r\n\t}\r\n\r\n\tgetMatrixAt( index, matrix ) {\r\n\r\n\t\tmatrix.fromArray( this.instanceMatrix.array, index * 16 );\r\n\r\n\t}\r\n\r\n\traycast( raycaster, intersects ) {\r\n\r\n\t\tconst matrixWorld = this.matrixWorld;\r\n\t\tconst raycastTimes = this.count;\r\n\r\n\t\t_mesh.geometry = this.geometry;\r\n\t\t_mesh.material = this.material;\r\n\r\n\t\tif ( _mesh.material === undefined ) return;\r\n\r\n\t\tfor ( let instanceId = 0; instanceId < raycastTimes; instanceId ++ ) {\r\n\r\n\t\t\t// calculate the world matrix for each instance\r\n\r\n\t\t\tthis.getMatrixAt( instanceId, _instanceLocalMatrix );\r\n\r\n\t\t\t_instanceWorldMatrix.multiplyMatrices( matrixWorld, _instanceLocalMatrix );\r\n\r\n\t\t\t// the mesh represents this single instance\r\n\r\n\t\t\t_mesh.matrixWorld = _instanceWorldMatrix;\r\n\r\n\t\t\t_mesh.raycast( raycaster, _instanceIntersects );\r\n\r\n\t\t\t// process the result of raycast\r\n\r\n\t\t\tfor ( let i = 0, l = _instanceIntersects.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tconst intersect = _instanceIntersects[ i ];\r\n\t\t\t\tintersect.instanceId = instanceId;\r\n\t\t\t\tintersect.object = this;\r\n\t\t\t\tintersects.push( intersect );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_instanceIntersects.length = 0;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tsetColorAt( index, color ) {\r\n\r\n\t\tif ( this.instanceColor === null ) {\r\n\r\n\t\t\tthis.instanceColor = new InstancedBufferAttribute( new Float32Array( this.instanceMatrix.count * 3 ), 3 );\r\n\r\n\t\t}\r\n\r\n\t\tcolor.toArray( this.instanceColor.array, index * 3 );\r\n\r\n\t}\r\n\r\n\tsetMatrixAt( index, matrix ) {\r\n\r\n\t\tmatrix.toArray( this.instanceMatrix.array, index * 16 );\r\n\r\n\t}\r\n\r\n\tupdateMorphTargets() {\r\n\r\n\t}\r\n\r\n\tdispose() {\r\n\r\n\t\tthis.dispatchEvent( { type: 'dispose' } );\r\n\r\n\t}\r\n\r\n}\r\n\r\nInstancedMesh.prototype.isInstancedMesh = true;\r\n\r\nexport { InstancedMesh };\r\n"]},"metadata":{},"sourceType":"module"}