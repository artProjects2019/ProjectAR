{"ast":null,"code":"import { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport { Vector3 } from '../math/Vector3.js';\n\nclass BoxGeometry extends BufferGeometry {\n  constructor(width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1) {\n    super();\n    this.type = 'BoxGeometry';\n    this.parameters = {\n      width: width,\n      height: height,\n      depth: depth,\n      widthSegments: widthSegments,\n      heightSegments: heightSegments,\n      depthSegments: depthSegments\n    };\n    const scope = this; // segments\n\n    widthSegments = Math.floor(widthSegments);\n    heightSegments = Math.floor(heightSegments);\n    depthSegments = Math.floor(depthSegments); // buffers\n\n    const indices = [];\n    const vertices = [];\n    const normals = [];\n    const uvs = []; // helper variables\n\n    let numberOfVertices = 0;\n    let groupStart = 0; // build each side of the box geometry\n\n    buildPlane('z', 'y', 'x', -1, -1, depth, height, width, depthSegments, heightSegments, 0); // px\n\n    buildPlane('z', 'y', 'x', 1, -1, depth, height, -width, depthSegments, heightSegments, 1); // nx\n\n    buildPlane('x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2); // py\n\n    buildPlane('x', 'z', 'y', 1, -1, width, depth, -height, widthSegments, depthSegments, 3); // ny\n\n    buildPlane('x', 'y', 'z', 1, -1, width, height, depth, widthSegments, heightSegments, 4); // pz\n\n    buildPlane('x', 'y', 'z', -1, -1, width, height, -depth, widthSegments, heightSegments, 5); // nz\n    // build geometry\n\n    this.setIndex(indices);\n    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\n\n    function buildPlane(u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex) {\n      const segmentWidth = width / gridX;\n      const segmentHeight = height / gridY;\n      const widthHalf = width / 2;\n      const heightHalf = height / 2;\n      const depthHalf = depth / 2;\n      const gridX1 = gridX + 1;\n      const gridY1 = gridY + 1;\n      let vertexCounter = 0;\n      let groupCount = 0;\n      const vector = new Vector3(); // generate vertices, normals and uvs\n\n      for (let iy = 0; iy < gridY1; iy++) {\n        const y = iy * segmentHeight - heightHalf;\n\n        for (let ix = 0; ix < gridX1; ix++) {\n          const x = ix * segmentWidth - widthHalf; // set values to correct vector component\n\n          vector[u] = x * udir;\n          vector[v] = y * vdir;\n          vector[w] = depthHalf; // now apply vector to vertex buffer\n\n          vertices.push(vector.x, vector.y, vector.z); // set values to correct vector component\n\n          vector[u] = 0;\n          vector[v] = 0;\n          vector[w] = depth > 0 ? 1 : -1; // now apply vector to normal buffer\n\n          normals.push(vector.x, vector.y, vector.z); // uvs\n\n          uvs.push(ix / gridX);\n          uvs.push(1 - iy / gridY); // counters\n\n          vertexCounter += 1;\n        }\n      } // indices\n      // 1. you need three indices to draw a single face\n      // 2. a single segment consists of two faces\n      // 3. so we need to generate six (2*3) indices per segment\n\n\n      for (let iy = 0; iy < gridY; iy++) {\n        for (let ix = 0; ix < gridX; ix++) {\n          const a = numberOfVertices + ix + gridX1 * iy;\n          const b = numberOfVertices + ix + gridX1 * (iy + 1);\n          const c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);\n          const d = numberOfVertices + (ix + 1) + gridX1 * iy; // faces\n\n          indices.push(a, b, d);\n          indices.push(b, c, d); // increase counter\n\n          groupCount += 6;\n        }\n      } // add a group to the geometry. this will ensure multi material support\n\n\n      scope.addGroup(groupStart, groupCount, materialIndex); // calculate new start value for groups\n\n      groupStart += groupCount; // update total number of vertices\n\n      numberOfVertices += vertexCounter;\n    }\n  }\n\n  static fromJSON(data) {\n    return new BoxGeometry(data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);\n  }\n\n}\n\nexport { BoxGeometry, BoxGeometry as BoxBufferGeometry };","map":{"version":3,"sources":["C:/Users/dell/Desktop/projektlogin/vue-3-authentication-jwt/src/games/three/src/geometries/BoxGeometry.js"],"names":["BufferGeometry","Float32BufferAttribute","Vector3","BoxGeometry","constructor","width","height","depth","widthSegments","heightSegments","depthSegments","type","parameters","scope","Math","floor","indices","vertices","normals","uvs","numberOfVertices","groupStart","buildPlane","setIndex","setAttribute","u","v","w","udir","vdir","gridX","gridY","materialIndex","segmentWidth","segmentHeight","widthHalf","heightHalf","depthHalf","gridX1","gridY1","vertexCounter","groupCount","vector","iy","y","ix","x","push","z","a","b","c","d","addGroup","fromJSON","data","BoxBufferGeometry"],"mappings":"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","sourcesContent":["import { BufferGeometry } from '../core/BufferGeometry.js';\r\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\r\nimport { Vector3 } from '../math/Vector3.js';\r\n\r\nclass BoxGeometry extends BufferGeometry {\r\n\r\n\tconstructor( width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1 ) {\r\n\r\n\t\tsuper();\r\n\r\n\t\tthis.type = 'BoxGeometry';\r\n\r\n\t\tthis.parameters = {\r\n\t\t\twidth: width,\r\n\t\t\theight: height,\r\n\t\t\tdepth: depth,\r\n\t\t\twidthSegments: widthSegments,\r\n\t\t\theightSegments: heightSegments,\r\n\t\t\tdepthSegments: depthSegments\r\n\t\t};\r\n\r\n\t\tconst scope = this;\r\n\r\n\t\t// segments\r\n\r\n\t\twidthSegments = Math.floor( widthSegments );\r\n\t\theightSegments = Math.floor( heightSegments );\r\n\t\tdepthSegments = Math.floor( depthSegments );\r\n\r\n\t\t// buffers\r\n\r\n\t\tconst indices = [];\r\n\t\tconst vertices = [];\r\n\t\tconst normals = [];\r\n\t\tconst uvs = [];\r\n\r\n\t\t// helper variables\r\n\r\n\t\tlet numberOfVertices = 0;\r\n\t\tlet groupStart = 0;\r\n\r\n\t\t// build each side of the box geometry\r\n\r\n\t\tbuildPlane( 'z', 'y', 'x', - 1, - 1, depth, height, width, depthSegments, heightSegments, 0 ); // px\r\n\t\tbuildPlane( 'z', 'y', 'x', 1, - 1, depth, height, - width, depthSegments, heightSegments, 1 ); // nx\r\n\t\tbuildPlane( 'x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2 ); // py\r\n\t\tbuildPlane( 'x', 'z', 'y', 1, - 1, width, depth, - height, widthSegments, depthSegments, 3 ); // ny\r\n\t\tbuildPlane( 'x', 'y', 'z', 1, - 1, width, height, depth, widthSegments, heightSegments, 4 ); // pz\r\n\t\tbuildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth, widthSegments, heightSegments, 5 ); // nz\r\n\r\n\t\t// build geometry\r\n\r\n\t\tthis.setIndex( indices );\r\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\r\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\r\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\r\n\r\n\t\tfunction buildPlane( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {\r\n\r\n\t\t\tconst segmentWidth = width / gridX;\r\n\t\t\tconst segmentHeight = height / gridY;\r\n\r\n\t\t\tconst widthHalf = width / 2;\r\n\t\t\tconst heightHalf = height / 2;\r\n\t\t\tconst depthHalf = depth / 2;\r\n\r\n\t\t\tconst gridX1 = gridX + 1;\r\n\t\t\tconst gridY1 = gridY + 1;\r\n\r\n\t\t\tlet vertexCounter = 0;\r\n\t\t\tlet groupCount = 0;\r\n\r\n\t\t\tconst vector = new Vector3();\r\n\r\n\t\t\t// generate vertices, normals and uvs\r\n\r\n\t\t\tfor ( let iy = 0; iy < gridY1; iy ++ ) {\r\n\r\n\t\t\t\tconst y = iy * segmentHeight - heightHalf;\r\n\r\n\t\t\t\tfor ( let ix = 0; ix < gridX1; ix ++ ) {\r\n\r\n\t\t\t\t\tconst x = ix * segmentWidth - widthHalf;\r\n\r\n\t\t\t\t\t// set values to correct vector component\r\n\r\n\t\t\t\t\tvector[ u ] = x * udir;\r\n\t\t\t\t\tvector[ v ] = y * vdir;\r\n\t\t\t\t\tvector[ w ] = depthHalf;\r\n\r\n\t\t\t\t\t// now apply vector to vertex buffer\r\n\r\n\t\t\t\t\tvertices.push( vector.x, vector.y, vector.z );\r\n\r\n\t\t\t\t\t// set values to correct vector component\r\n\r\n\t\t\t\t\tvector[ u ] = 0;\r\n\t\t\t\t\tvector[ v ] = 0;\r\n\t\t\t\t\tvector[ w ] = depth > 0 ? 1 : - 1;\r\n\r\n\t\t\t\t\t// now apply vector to normal buffer\r\n\r\n\t\t\t\t\tnormals.push( vector.x, vector.y, vector.z );\r\n\r\n\t\t\t\t\t// uvs\r\n\r\n\t\t\t\t\tuvs.push( ix / gridX );\r\n\t\t\t\t\tuvs.push( 1 - ( iy / gridY ) );\r\n\r\n\t\t\t\t\t// counters\r\n\r\n\t\t\t\t\tvertexCounter += 1;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// indices\r\n\r\n\t\t\t// 1. you need three indices to draw a single face\r\n\t\t\t// 2. a single segment consists of two faces\r\n\t\t\t// 3. so we need to generate six (2*3) indices per segment\r\n\r\n\t\t\tfor ( let iy = 0; iy < gridY; iy ++ ) {\r\n\r\n\t\t\t\tfor ( let ix = 0; ix < gridX; ix ++ ) {\r\n\r\n\t\t\t\t\tconst a = numberOfVertices + ix + gridX1 * iy;\r\n\t\t\t\t\tconst b = numberOfVertices + ix + gridX1 * ( iy + 1 );\r\n\t\t\t\t\tconst c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );\r\n\t\t\t\t\tconst d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;\r\n\r\n\t\t\t\t\t// faces\r\n\r\n\t\t\t\t\tindices.push( a, b, d );\r\n\t\t\t\t\tindices.push( b, c, d );\r\n\r\n\t\t\t\t\t// increase counter\r\n\r\n\t\t\t\t\tgroupCount += 6;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// add a group to the geometry. this will ensure multi material support\r\n\r\n\t\t\tscope.addGroup( groupStart, groupCount, materialIndex );\r\n\r\n\t\t\t// calculate new start value for groups\r\n\r\n\t\t\tgroupStart += groupCount;\r\n\r\n\t\t\t// update total number of vertices\r\n\r\n\t\t\tnumberOfVertices += vertexCounter;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tstatic fromJSON( data ) {\r\n\r\n\t\treturn new BoxGeometry( data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments );\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport { BoxGeometry, BoxGeometry as BoxBufferGeometry };\r\n"]},"metadata":{},"sourceType":"module"}