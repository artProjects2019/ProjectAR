{"ast":null,"code":"import { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport { Vector2 } from '../math/Vector2.js';\nimport { Vector3 } from '../math/Vector3.js';\n\nclass RingGeometry extends BufferGeometry {\n  constructor(innerRadius = 0.5, outerRadius = 1, thetaSegments = 8, phiSegments = 1, thetaStart = 0, thetaLength = Math.PI * 2) {\n    super();\n    this.type = 'RingGeometry';\n    this.parameters = {\n      innerRadius: innerRadius,\n      outerRadius: outerRadius,\n      thetaSegments: thetaSegments,\n      phiSegments: phiSegments,\n      thetaStart: thetaStart,\n      thetaLength: thetaLength\n    };\n    thetaSegments = Math.max(3, thetaSegments);\n    phiSegments = Math.max(1, phiSegments); // buffers\n\n    const indices = [];\n    const vertices = [];\n    const normals = [];\n    const uvs = []; // some helper variables\n\n    let radius = innerRadius;\n    const radiusStep = (outerRadius - innerRadius) / phiSegments;\n    const vertex = new Vector3();\n    const uv = new Vector2(); // generate vertices, normals and uvs\n\n    for (let j = 0; j <= phiSegments; j++) {\n      for (let i = 0; i <= thetaSegments; i++) {\n        // values are generate from the inside of the ring to the outside\n        const segment = thetaStart + i / thetaSegments * thetaLength; // vertex\n\n        vertex.x = radius * Math.cos(segment);\n        vertex.y = radius * Math.sin(segment);\n        vertices.push(vertex.x, vertex.y, vertex.z); // normal\n\n        normals.push(0, 0, 1); // uv\n\n        uv.x = (vertex.x / outerRadius + 1) / 2;\n        uv.y = (vertex.y / outerRadius + 1) / 2;\n        uvs.push(uv.x, uv.y);\n      } // increase the radius for next row of vertices\n\n\n      radius += radiusStep;\n    } // indices\n\n\n    for (let j = 0; j < phiSegments; j++) {\n      const thetaSegmentLevel = j * (thetaSegments + 1);\n\n      for (let i = 0; i < thetaSegments; i++) {\n        const segment = i + thetaSegmentLevel;\n        const a = segment;\n        const b = segment + thetaSegments + 1;\n        const c = segment + thetaSegments + 2;\n        const d = segment + 1; // faces\n\n        indices.push(a, b, d);\n        indices.push(b, c, d);\n      }\n    } // build geometry\n\n\n    this.setIndex(indices);\n    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\n  }\n\n  static fromJSON(data) {\n    return new RingGeometry(data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength);\n  }\n\n}\n\nexport { RingGeometry, RingGeometry as RingBufferGeometry };","map":{"version":3,"sources":["C:/Users/dell/Desktop/projektlogin/vue-3-authentication-jwt/src/games/three/src/geometries/RingGeometry.js"],"names":["BufferGeometry","Float32BufferAttribute","Vector2","Vector3","RingGeometry","constructor","innerRadius","outerRadius","thetaSegments","phiSegments","thetaStart","thetaLength","Math","PI","type","parameters","max","indices","vertices","normals","uvs","radius","radiusStep","vertex","uv","j","i","segment","x","cos","y","sin","push","z","thetaSegmentLevel","a","b","c","d","setIndex","setAttribute","fromJSON","data","RingBufferGeometry"],"mappings":"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","sourcesContent":["import { BufferGeometry } from '../core/BufferGeometry.js';\r\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\r\nimport { Vector2 } from '../math/Vector2.js';\r\nimport { Vector3 } from '../math/Vector3.js';\r\n\r\nclass RingGeometry extends BufferGeometry {\r\n\r\n\tconstructor( innerRadius = 0.5, outerRadius = 1, thetaSegments = 8, phiSegments = 1, thetaStart = 0, thetaLength = Math.PI * 2 ) {\r\n\r\n\t\tsuper();\r\n\r\n\t\tthis.type = 'RingGeometry';\r\n\r\n\t\tthis.parameters = {\r\n\t\t\tinnerRadius: innerRadius,\r\n\t\t\touterRadius: outerRadius,\r\n\t\t\tthetaSegments: thetaSegments,\r\n\t\t\tphiSegments: phiSegments,\r\n\t\t\tthetaStart: thetaStart,\r\n\t\t\tthetaLength: thetaLength\r\n\t\t};\r\n\r\n\t\tthetaSegments = Math.max( 3, thetaSegments );\r\n\t\tphiSegments = Math.max( 1, phiSegments );\r\n\r\n\t\t// buffers\r\n\r\n\t\tconst indices = [];\r\n\t\tconst vertices = [];\r\n\t\tconst normals = [];\r\n\t\tconst uvs = [];\r\n\r\n\t\t// some helper variables\r\n\r\n\t\tlet radius = innerRadius;\r\n\t\tconst radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );\r\n\t\tconst vertex = new Vector3();\r\n\t\tconst uv = new Vector2();\r\n\r\n\t\t// generate vertices, normals and uvs\r\n\r\n\t\tfor ( let j = 0; j <= phiSegments; j ++ ) {\r\n\r\n\t\t\tfor ( let i = 0; i <= thetaSegments; i ++ ) {\r\n\r\n\t\t\t\t// values are generate from the inside of the ring to the outside\r\n\r\n\t\t\t\tconst segment = thetaStart + i / thetaSegments * thetaLength;\r\n\r\n\t\t\t\t// vertex\r\n\r\n\t\t\t\tvertex.x = radius * Math.cos( segment );\r\n\t\t\t\tvertex.y = radius * Math.sin( segment );\r\n\r\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\r\n\r\n\t\t\t\t// normal\r\n\r\n\t\t\t\tnormals.push( 0, 0, 1 );\r\n\r\n\t\t\t\t// uv\r\n\r\n\t\t\t\tuv.x = ( vertex.x / outerRadius + 1 ) / 2;\r\n\t\t\t\tuv.y = ( vertex.y / outerRadius + 1 ) / 2;\r\n\r\n\t\t\t\tuvs.push( uv.x, uv.y );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// increase the radius for next row of vertices\r\n\r\n\t\t\tradius += radiusStep;\r\n\r\n\t\t}\r\n\r\n\t\t// indices\r\n\r\n\t\tfor ( let j = 0; j < phiSegments; j ++ ) {\r\n\r\n\t\t\tconst thetaSegmentLevel = j * ( thetaSegments + 1 );\r\n\r\n\t\t\tfor ( let i = 0; i < thetaSegments; i ++ ) {\r\n\r\n\t\t\t\tconst segment = i + thetaSegmentLevel;\r\n\r\n\t\t\t\tconst a = segment;\r\n\t\t\t\tconst b = segment + thetaSegments + 1;\r\n\t\t\t\tconst c = segment + thetaSegments + 2;\r\n\t\t\t\tconst d = segment + 1;\r\n\r\n\t\t\t\t// faces\r\n\r\n\t\t\t\tindices.push( a, b, d );\r\n\t\t\t\tindices.push( b, c, d );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// build geometry\r\n\r\n\t\tthis.setIndex( indices );\r\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\r\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\r\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\r\n\r\n\t}\r\n\r\n\tstatic fromJSON( data ) {\r\n\r\n\t\treturn new RingGeometry( data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength );\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\nexport { RingGeometry, RingGeometry as RingBufferGeometry };\r\n"]},"metadata":{},"sourceType":"module"}