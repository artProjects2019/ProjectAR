{"ast":null,"code":"import { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport { Vector3 } from '../math/Vector3.js';\nimport { Vector2 } from '../math/Vector2.js';\n\nclass PolyhedronGeometry extends BufferGeometry {\n  constructor(vertices = [], indices = [], radius = 1, detail = 0) {\n    super();\n    this.type = 'PolyhedronGeometry';\n    this.parameters = {\n      vertices: vertices,\n      indices: indices,\n      radius: radius,\n      detail: detail\n    }; // default buffer data\n\n    const vertexBuffer = [];\n    const uvBuffer = []; // the subdivision creates the vertex buffer data\n\n    subdivide(detail); // all vertices should lie on a conceptual sphere with a given radius\n\n    applyRadius(radius); // finally, create the uv data\n\n    generateUVs(); // build non-indexed geometry\n\n    this.setAttribute('position', new Float32BufferAttribute(vertexBuffer, 3));\n    this.setAttribute('normal', new Float32BufferAttribute(vertexBuffer.slice(), 3));\n    this.setAttribute('uv', new Float32BufferAttribute(uvBuffer, 2));\n\n    if (detail === 0) {\n      this.computeVertexNormals(); // flat normals\n    } else {\n      this.normalizeNormals(); // smooth normals\n    } // helper functions\n\n\n    function subdivide(detail) {\n      const a = new Vector3();\n      const b = new Vector3();\n      const c = new Vector3(); // iterate over all faces and apply a subdivison with the given detail value\n\n      for (let i = 0; i < indices.length; i += 3) {\n        // get the vertices of the face\n        getVertexByIndex(indices[i + 0], a);\n        getVertexByIndex(indices[i + 1], b);\n        getVertexByIndex(indices[i + 2], c); // perform subdivision\n\n        subdivideFace(a, b, c, detail);\n      }\n    }\n\n    function subdivideFace(a, b, c, detail) {\n      const cols = detail + 1; // we use this multidimensional array as a data structure for creating the subdivision\n\n      const v = []; // construct all of the vertices for this subdivision\n\n      for (let i = 0; i <= cols; i++) {\n        v[i] = [];\n        const aj = a.clone().lerp(c, i / cols);\n        const bj = b.clone().lerp(c, i / cols);\n        const rows = cols - i;\n\n        for (let j = 0; j <= rows; j++) {\n          if (j === 0 && i === cols) {\n            v[i][j] = aj;\n          } else {\n            v[i][j] = aj.clone().lerp(bj, j / rows);\n          }\n        }\n      } // construct all of the faces\n\n\n      for (let i = 0; i < cols; i++) {\n        for (let j = 0; j < 2 * (cols - i) - 1; j++) {\n          const k = Math.floor(j / 2);\n\n          if (j % 2 === 0) {\n            pushVertex(v[i][k + 1]);\n            pushVertex(v[i + 1][k]);\n            pushVertex(v[i][k]);\n          } else {\n            pushVertex(v[i][k + 1]);\n            pushVertex(v[i + 1][k + 1]);\n            pushVertex(v[i + 1][k]);\n          }\n        }\n      }\n    }\n\n    function applyRadius(radius) {\n      const vertex = new Vector3(); // iterate over the entire buffer and apply the radius to each vertex\n\n      for (let i = 0; i < vertexBuffer.length; i += 3) {\n        vertex.x = vertexBuffer[i + 0];\n        vertex.y = vertexBuffer[i + 1];\n        vertex.z = vertexBuffer[i + 2];\n        vertex.normalize().multiplyScalar(radius);\n        vertexBuffer[i + 0] = vertex.x;\n        vertexBuffer[i + 1] = vertex.y;\n        vertexBuffer[i + 2] = vertex.z;\n      }\n    }\n\n    function generateUVs() {\n      const vertex = new Vector3();\n\n      for (let i = 0; i < vertexBuffer.length; i += 3) {\n        vertex.x = vertexBuffer[i + 0];\n        vertex.y = vertexBuffer[i + 1];\n        vertex.z = vertexBuffer[i + 2];\n        const u = azimuth(vertex) / 2 / Math.PI + 0.5;\n        const v = inclination(vertex) / Math.PI + 0.5;\n        uvBuffer.push(u, 1 - v);\n      }\n\n      correctUVs();\n      correctSeam();\n    }\n\n    function correctSeam() {\n      // handle case when face straddles the seam, see #3269\n      for (let i = 0; i < uvBuffer.length; i += 6) {\n        // uv data of a single face\n        const x0 = uvBuffer[i + 0];\n        const x1 = uvBuffer[i + 2];\n        const x2 = uvBuffer[i + 4];\n        const max = Math.max(x0, x1, x2);\n        const min = Math.min(x0, x1, x2); // 0.9 is somewhat arbitrary\n\n        if (max > 0.9 && min < 0.1) {\n          if (x0 < 0.2) uvBuffer[i + 0] += 1;\n          if (x1 < 0.2) uvBuffer[i + 2] += 1;\n          if (x2 < 0.2) uvBuffer[i + 4] += 1;\n        }\n      }\n    }\n\n    function pushVertex(vertex) {\n      vertexBuffer.push(vertex.x, vertex.y, vertex.z);\n    }\n\n    function getVertexByIndex(index, vertex) {\n      const stride = index * 3;\n      vertex.x = vertices[stride + 0];\n      vertex.y = vertices[stride + 1];\n      vertex.z = vertices[stride + 2];\n    }\n\n    function correctUVs() {\n      const a = new Vector3();\n      const b = new Vector3();\n      const c = new Vector3();\n      const centroid = new Vector3();\n      const uvA = new Vector2();\n      const uvB = new Vector2();\n      const uvC = new Vector2();\n\n      for (let i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6) {\n        a.set(vertexBuffer[i + 0], vertexBuffer[i + 1], vertexBuffer[i + 2]);\n        b.set(vertexBuffer[i + 3], vertexBuffer[i + 4], vertexBuffer[i + 5]);\n        c.set(vertexBuffer[i + 6], vertexBuffer[i + 7], vertexBuffer[i + 8]);\n        uvA.set(uvBuffer[j + 0], uvBuffer[j + 1]);\n        uvB.set(uvBuffer[j + 2], uvBuffer[j + 3]);\n        uvC.set(uvBuffer[j + 4], uvBuffer[j + 5]);\n        centroid.copy(a).add(b).add(c).divideScalar(3);\n        const azi = azimuth(centroid);\n        correctUV(uvA, j + 0, a, azi);\n        correctUV(uvB, j + 2, b, azi);\n        correctUV(uvC, j + 4, c, azi);\n      }\n    }\n\n    function correctUV(uv, stride, vector, azimuth) {\n      if (azimuth < 0 && uv.x === 1) {\n        uvBuffer[stride] = uv.x - 1;\n      }\n\n      if (vector.x === 0 && vector.z === 0) {\n        uvBuffer[stride] = azimuth / 2 / Math.PI + 0.5;\n      }\n    } // Angle around the Y axis, counter-clockwise when looking from above.\n\n\n    function azimuth(vector) {\n      return Math.atan2(vector.z, -vector.x);\n    } // Angle above the XZ plane.\n\n\n    function inclination(vector) {\n      return Math.atan2(-vector.y, Math.sqrt(vector.x * vector.x + vector.z * vector.z));\n    }\n  }\n\n  static fromJSON(data) {\n    return new PolyhedronGeometry(data.vertices, data.indices, data.radius, data.details);\n  }\n\n}\n\nexport { PolyhedronGeometry, PolyhedronGeometry as PolyhedronBufferGeometry };","map":{"version":3,"sources":["C:/Users/dell/Desktop/projektlogin/vue-3-authentication-jwt/src/games/three/src/geometries/PolyhedronGeometry.js"],"names":["BufferGeometry","Float32BufferAttribute","Vector3","Vector2","PolyhedronGeometry","constructor","vertices","indices","radius","detail","type","parameters","vertexBuffer","uvBuffer","subdivide","applyRadius","generateUVs","setAttribute","slice","computeVertexNormals","normalizeNormals","a","b","c","i","length","getVertexByIndex","subdivideFace","cols","v","aj","clone","lerp","bj","rows","j","k","Math","floor","pushVertex","vertex","x","y","z","normalize","multiplyScalar","u","azimuth","PI","inclination","push","correctUVs","correctSeam","x0","x1","x2","max","min","index","stride","centroid","uvA","uvB","uvC","set","copy","add","divideScalar","azi","correctUV","uv","vector","atan2","sqrt","fromJSON","data","details","PolyhedronBufferGeometry"],"mappings":"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","sourcesContent":["import { BufferGeometry } from '../core/BufferGeometry.js';\r\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\r\nimport { Vector3 } from '../math/Vector3.js';\r\nimport { Vector2 } from '../math/Vector2.js';\r\n\r\nclass PolyhedronGeometry extends BufferGeometry {\r\n\r\n\tconstructor( vertices = [], indices = [], radius = 1, detail = 0 ) {\r\n\r\n\t\tsuper();\r\n\r\n\t\tthis.type = 'PolyhedronGeometry';\r\n\r\n\t\tthis.parameters = {\r\n\t\t\tvertices: vertices,\r\n\t\t\tindices: indices,\r\n\t\t\tradius: radius,\r\n\t\t\tdetail: detail\r\n\t\t};\r\n\r\n\t\t// default buffer data\r\n\r\n\t\tconst vertexBuffer = [];\r\n\t\tconst uvBuffer = [];\r\n\r\n\t\t// the subdivision creates the vertex buffer data\r\n\r\n\t\tsubdivide( detail );\r\n\r\n\t\t// all vertices should lie on a conceptual sphere with a given radius\r\n\r\n\t\tapplyRadius( radius );\r\n\r\n\t\t// finally, create the uv data\r\n\r\n\t\tgenerateUVs();\r\n\r\n\t\t// build non-indexed geometry\r\n\r\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertexBuffer, 3 ) );\r\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( vertexBuffer.slice(), 3 ) );\r\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvBuffer, 2 ) );\r\n\r\n\t\tif ( detail === 0 ) {\r\n\r\n\t\t\tthis.computeVertexNormals(); // flat normals\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.normalizeNormals(); // smooth normals\r\n\r\n\t\t}\r\n\r\n\t\t// helper functions\r\n\r\n\t\tfunction subdivide( detail ) {\r\n\r\n\t\t\tconst a = new Vector3();\r\n\t\t\tconst b = new Vector3();\r\n\t\t\tconst c = new Vector3();\r\n\r\n\t\t\t// iterate over all faces and apply a subdivison with the given detail value\r\n\r\n\t\t\tfor ( let i = 0; i < indices.length; i += 3 ) {\r\n\r\n\t\t\t\t// get the vertices of the face\r\n\r\n\t\t\t\tgetVertexByIndex( indices[ i + 0 ], a );\r\n\t\t\t\tgetVertexByIndex( indices[ i + 1 ], b );\r\n\t\t\t\tgetVertexByIndex( indices[ i + 2 ], c );\r\n\r\n\t\t\t\t// perform subdivision\r\n\r\n\t\t\t\tsubdivideFace( a, b, c, detail );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction subdivideFace( a, b, c, detail ) {\r\n\r\n\t\t\tconst cols = detail + 1;\r\n\r\n\t\t\t// we use this multidimensional array as a data structure for creating the subdivision\r\n\r\n\t\t\tconst v = [];\r\n\r\n\t\t\t// construct all of the vertices for this subdivision\r\n\r\n\t\t\tfor ( let i = 0; i <= cols; i ++ ) {\r\n\r\n\t\t\t\tv[ i ] = [];\r\n\r\n\t\t\t\tconst aj = a.clone().lerp( c, i / cols );\r\n\t\t\t\tconst bj = b.clone().lerp( c, i / cols );\r\n\r\n\t\t\t\tconst rows = cols - i;\r\n\r\n\t\t\t\tfor ( let j = 0; j <= rows; j ++ ) {\r\n\r\n\t\t\t\t\tif ( j === 0 && i === cols ) {\r\n\r\n\t\t\t\t\t\tv[ i ][ j ] = aj;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tv[ i ][ j ] = aj.clone().lerp( bj, j / rows );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// construct all of the faces\r\n\r\n\t\t\tfor ( let i = 0; i < cols; i ++ ) {\r\n\r\n\t\t\t\tfor ( let j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {\r\n\r\n\t\t\t\t\tconst k = Math.floor( j / 2 );\r\n\r\n\t\t\t\t\tif ( j % 2 === 0 ) {\r\n\r\n\t\t\t\t\t\tpushVertex( v[ i ][ k + 1 ] );\r\n\t\t\t\t\t\tpushVertex( v[ i + 1 ][ k ] );\r\n\t\t\t\t\t\tpushVertex( v[ i ][ k ] );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tpushVertex( v[ i ][ k + 1 ] );\r\n\t\t\t\t\t\tpushVertex( v[ i + 1 ][ k + 1 ] );\r\n\t\t\t\t\t\tpushVertex( v[ i + 1 ][ k ] );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction applyRadius( radius ) {\r\n\r\n\t\t\tconst vertex = new Vector3();\r\n\r\n\t\t\t// iterate over the entire buffer and apply the radius to each vertex\r\n\r\n\t\t\tfor ( let i = 0; i < vertexBuffer.length; i += 3 ) {\r\n\r\n\t\t\t\tvertex.x = vertexBuffer[ i + 0 ];\r\n\t\t\t\tvertex.y = vertexBuffer[ i + 1 ];\r\n\t\t\t\tvertex.z = vertexBuffer[ i + 2 ];\r\n\r\n\t\t\t\tvertex.normalize().multiplyScalar( radius );\r\n\r\n\t\t\t\tvertexBuffer[ i + 0 ] = vertex.x;\r\n\t\t\t\tvertexBuffer[ i + 1 ] = vertex.y;\r\n\t\t\t\tvertexBuffer[ i + 2 ] = vertex.z;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction generateUVs() {\r\n\r\n\t\t\tconst vertex = new Vector3();\r\n\r\n\t\t\tfor ( let i = 0; i < vertexBuffer.length; i += 3 ) {\r\n\r\n\t\t\t\tvertex.x = vertexBuffer[ i + 0 ];\r\n\t\t\t\tvertex.y = vertexBuffer[ i + 1 ];\r\n\t\t\t\tvertex.z = vertexBuffer[ i + 2 ];\r\n\r\n\t\t\t\tconst u = azimuth( vertex ) / 2 / Math.PI + 0.5;\r\n\t\t\t\tconst v = inclination( vertex ) / Math.PI + 0.5;\r\n\t\t\t\tuvBuffer.push( u, 1 - v );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tcorrectUVs();\r\n\r\n\t\t\tcorrectSeam();\r\n\r\n\t\t}\r\n\r\n\t\tfunction correctSeam() {\r\n\r\n\t\t\t// handle case when face straddles the seam, see #3269\r\n\r\n\t\t\tfor ( let i = 0; i < uvBuffer.length; i += 6 ) {\r\n\r\n\t\t\t\t// uv data of a single face\r\n\r\n\t\t\t\tconst x0 = uvBuffer[ i + 0 ];\r\n\t\t\t\tconst x1 = uvBuffer[ i + 2 ];\r\n\t\t\t\tconst x2 = uvBuffer[ i + 4 ];\r\n\r\n\t\t\t\tconst max = Math.max( x0, x1, x2 );\r\n\t\t\t\tconst min = Math.min( x0, x1, x2 );\r\n\r\n\t\t\t\t// 0.9 is somewhat arbitrary\r\n\r\n\t\t\t\tif ( max > 0.9 && min < 0.1 ) {\r\n\r\n\t\t\t\t\tif ( x0 < 0.2 ) uvBuffer[ i + 0 ] += 1;\r\n\t\t\t\t\tif ( x1 < 0.2 ) uvBuffer[ i + 2 ] += 1;\r\n\t\t\t\t\tif ( x2 < 0.2 ) uvBuffer[ i + 4 ] += 1;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction pushVertex( vertex ) {\r\n\r\n\t\t\tvertexBuffer.push( vertex.x, vertex.y, vertex.z );\r\n\r\n\t\t}\r\n\r\n\t\tfunction getVertexByIndex( index, vertex ) {\r\n\r\n\t\t\tconst stride = index * 3;\r\n\r\n\t\t\tvertex.x = vertices[ stride + 0 ];\r\n\t\t\tvertex.y = vertices[ stride + 1 ];\r\n\t\t\tvertex.z = vertices[ stride + 2 ];\r\n\r\n\t\t}\r\n\r\n\t\tfunction correctUVs() {\r\n\r\n\t\t\tconst a = new Vector3();\r\n\t\t\tconst b = new Vector3();\r\n\t\t\tconst c = new Vector3();\r\n\r\n\t\t\tconst centroid = new Vector3();\r\n\r\n\t\t\tconst uvA = new Vector2();\r\n\t\t\tconst uvB = new Vector2();\r\n\t\t\tconst uvC = new Vector2();\r\n\r\n\t\t\tfor ( let i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6 ) {\r\n\r\n\t\t\t\ta.set( vertexBuffer[ i + 0 ], vertexBuffer[ i + 1 ], vertexBuffer[ i + 2 ] );\r\n\t\t\t\tb.set( vertexBuffer[ i + 3 ], vertexBuffer[ i + 4 ], vertexBuffer[ i + 5 ] );\r\n\t\t\t\tc.set( vertexBuffer[ i + 6 ], vertexBuffer[ i + 7 ], vertexBuffer[ i + 8 ] );\r\n\r\n\t\t\t\tuvA.set( uvBuffer[ j + 0 ], uvBuffer[ j + 1 ] );\r\n\t\t\t\tuvB.set( uvBuffer[ j + 2 ], uvBuffer[ j + 3 ] );\r\n\t\t\t\tuvC.set( uvBuffer[ j + 4 ], uvBuffer[ j + 5 ] );\r\n\r\n\t\t\t\tcentroid.copy( a ).add( b ).add( c ).divideScalar( 3 );\r\n\r\n\t\t\t\tconst azi = azimuth( centroid );\r\n\r\n\t\t\t\tcorrectUV( uvA, j + 0, a, azi );\r\n\t\t\t\tcorrectUV( uvB, j + 2, b, azi );\r\n\t\t\t\tcorrectUV( uvC, j + 4, c, azi );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction correctUV( uv, stride, vector, azimuth ) {\r\n\r\n\t\t\tif ( ( azimuth < 0 ) && ( uv.x === 1 ) ) {\r\n\r\n\t\t\t\tuvBuffer[ stride ] = uv.x - 1;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( ( vector.x === 0 ) && ( vector.z === 0 ) ) {\r\n\r\n\t\t\t\tuvBuffer[ stride ] = azimuth / 2 / Math.PI + 0.5;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// Angle around the Y axis, counter-clockwise when looking from above.\r\n\r\n\t\tfunction azimuth( vector ) {\r\n\r\n\t\t\treturn Math.atan2( vector.z, - vector.x );\r\n\r\n\t\t}\r\n\r\n\r\n\t\t// Angle above the XZ plane.\r\n\r\n\t\tfunction inclination( vector ) {\r\n\r\n\t\t\treturn Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tstatic fromJSON( data ) {\r\n\r\n\t\treturn new PolyhedronGeometry( data.vertices, data.indices, data.radius, data.details );\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport { PolyhedronGeometry, PolyhedronGeometry as PolyhedronBufferGeometry };\r\n"]},"metadata":{},"sourceType":"module"}