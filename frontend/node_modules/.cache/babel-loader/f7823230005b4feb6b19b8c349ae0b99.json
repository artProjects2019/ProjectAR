{"ast":null,"code":"import { Vector3 } from '../math/Vector3.js';\nimport { Vector2 } from '../math/Vector2.js';\nimport { Sphere } from '../math/Sphere.js';\nimport { Ray } from '../math/Ray.js';\nimport { Matrix4 } from '../math/Matrix4.js';\nimport { Object3D } from '../core/Object3D.js';\nimport { Triangle } from '../math/Triangle.js';\nimport { DoubleSide, BackSide } from '../constants.js';\nimport { MeshBasicMaterial } from '../materials/MeshBasicMaterial.js';\nimport { BufferGeometry } from '../core/BufferGeometry.js';\n\nconst _inverseMatrix = /*@__PURE__*/new Matrix4();\n\nconst _ray = /*@__PURE__*/new Ray();\n\nconst _sphere = /*@__PURE__*/new Sphere();\n\nconst _vA = /*@__PURE__*/new Vector3();\n\nconst _vB = /*@__PURE__*/new Vector3();\n\nconst _vC = /*@__PURE__*/new Vector3();\n\nconst _tempA = /*@__PURE__*/new Vector3();\n\nconst _tempB = /*@__PURE__*/new Vector3();\n\nconst _tempC = /*@__PURE__*/new Vector3();\n\nconst _morphA = /*@__PURE__*/new Vector3();\n\nconst _morphB = /*@__PURE__*/new Vector3();\n\nconst _morphC = /*@__PURE__*/new Vector3();\n\nconst _uvA = /*@__PURE__*/new Vector2();\n\nconst _uvB = /*@__PURE__*/new Vector2();\n\nconst _uvC = /*@__PURE__*/new Vector2();\n\nconst _intersectionPoint = /*@__PURE__*/new Vector3();\n\nconst _intersectionPointWorld = /*@__PURE__*/new Vector3();\n\nclass Mesh extends Object3D {\n  constructor(geometry = new BufferGeometry(), material = new MeshBasicMaterial()) {\n    super();\n    this.type = 'Mesh';\n    this.geometry = geometry;\n    this.material = material;\n    this.updateMorphTargets();\n  }\n\n  copy(source) {\n    super.copy(source);\n\n    if (source.morphTargetInfluences !== undefined) {\n      this.morphTargetInfluences = source.morphTargetInfluences.slice();\n    }\n\n    if (source.morphTargetDictionary !== undefined) {\n      this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);\n    }\n\n    this.material = source.material;\n    this.geometry = source.geometry;\n    return this;\n  }\n\n  updateMorphTargets() {\n    const geometry = this.geometry;\n\n    if (geometry.isBufferGeometry) {\n      const morphAttributes = geometry.morphAttributes;\n      const keys = Object.keys(morphAttributes);\n\n      if (keys.length > 0) {\n        const morphAttribute = morphAttributes[keys[0]];\n\n        if (morphAttribute !== undefined) {\n          this.morphTargetInfluences = [];\n          this.morphTargetDictionary = {};\n\n          for (let m = 0, ml = morphAttribute.length; m < ml; m++) {\n            const name = morphAttribute[m].name || String(m);\n            this.morphTargetInfluences.push(0);\n            this.morphTargetDictionary[name] = m;\n          }\n        }\n      }\n    } else {\n      const morphTargets = geometry.morphTargets;\n\n      if (morphTargets !== undefined && morphTargets.length > 0) {\n        console.error('THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');\n      }\n    }\n  }\n\n  raycast(raycaster, intersects) {\n    const geometry = this.geometry;\n    const material = this.material;\n    const matrixWorld = this.matrixWorld;\n    if (material === undefined) return; // Checking boundingSphere distance to ray\n\n    if (geometry.boundingSphere === null) geometry.computeBoundingSphere();\n\n    _sphere.copy(geometry.boundingSphere);\n\n    _sphere.applyMatrix4(matrixWorld);\n\n    if (raycaster.ray.intersectsSphere(_sphere) === false) return; //\n\n    _inverseMatrix.copy(matrixWorld).invert();\n\n    _ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix); // Check boundingBox before continuing\n\n\n    if (geometry.boundingBox !== null) {\n      if (_ray.intersectsBox(geometry.boundingBox) === false) return;\n    }\n\n    let intersection;\n\n    if (geometry.isBufferGeometry) {\n      const index = geometry.index;\n      const position = geometry.attributes.position;\n      const morphPosition = geometry.morphAttributes.position;\n      const morphTargetsRelative = geometry.morphTargetsRelative;\n      const uv = geometry.attributes.uv;\n      const uv2 = geometry.attributes.uv2;\n      const groups = geometry.groups;\n      const drawRange = geometry.drawRange;\n\n      if (index !== null) {\n        // indexed buffer geometry\n        if (Array.isArray(material)) {\n          for (let i = 0, il = groups.length; i < il; i++) {\n            const group = groups[i];\n            const groupMaterial = material[group.materialIndex];\n            const start = Math.max(group.start, drawRange.start);\n            const end = Math.min(index.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));\n\n            for (let j = start, jl = end; j < jl; j += 3) {\n              const a = index.getX(j);\n              const b = index.getX(j + 1);\n              const c = index.getX(j + 2);\n              intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);\n\n              if (intersection) {\n                intersection.faceIndex = Math.floor(j / 3); // triangle number in indexed buffer semantics\n\n                intersection.face.materialIndex = group.materialIndex;\n                intersects.push(intersection);\n              }\n            }\n          }\n        } else {\n          const start = Math.max(0, drawRange.start);\n          const end = Math.min(index.count, drawRange.start + drawRange.count);\n\n          for (let i = start, il = end; i < il; i += 3) {\n            const a = index.getX(i);\n            const b = index.getX(i + 1);\n            const c = index.getX(i + 2);\n            intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);\n\n            if (intersection) {\n              intersection.faceIndex = Math.floor(i / 3); // triangle number in indexed buffer semantics\n\n              intersects.push(intersection);\n            }\n          }\n        }\n      } else if (position !== undefined) {\n        // non-indexed buffer geometry\n        if (Array.isArray(material)) {\n          for (let i = 0, il = groups.length; i < il; i++) {\n            const group = groups[i];\n            const groupMaterial = material[group.materialIndex];\n            const start = Math.max(group.start, drawRange.start);\n            const end = Math.min(position.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));\n\n            for (let j = start, jl = end; j < jl; j += 3) {\n              const a = j;\n              const b = j + 1;\n              const c = j + 2;\n              intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);\n\n              if (intersection) {\n                intersection.faceIndex = Math.floor(j / 3); // triangle number in non-indexed buffer semantics\n\n                intersection.face.materialIndex = group.materialIndex;\n                intersects.push(intersection);\n              }\n            }\n          }\n        } else {\n          const start = Math.max(0, drawRange.start);\n          const end = Math.min(position.count, drawRange.start + drawRange.count);\n\n          for (let i = start, il = end; i < il; i += 3) {\n            const a = i;\n            const b = i + 1;\n            const c = i + 2;\n            intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);\n\n            if (intersection) {\n              intersection.faceIndex = Math.floor(i / 3); // triangle number in non-indexed buffer semantics\n\n              intersects.push(intersection);\n            }\n          }\n        }\n      }\n    } else if (geometry.isGeometry) {\n      console.error('THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');\n    }\n  }\n\n}\n\nMesh.prototype.isMesh = true;\n\nfunction checkIntersection(object, material, raycaster, ray, pA, pB, pC, point) {\n  let intersect;\n\n  if (material.side === BackSide) {\n    intersect = ray.intersectTriangle(pC, pB, pA, true, point);\n  } else {\n    intersect = ray.intersectTriangle(pA, pB, pC, material.side !== DoubleSide, point);\n  }\n\n  if (intersect === null) return null;\n\n  _intersectionPointWorld.copy(point);\n\n  _intersectionPointWorld.applyMatrix4(object.matrixWorld);\n\n  const distance = raycaster.ray.origin.distanceTo(_intersectionPointWorld);\n  if (distance < raycaster.near || distance > raycaster.far) return null;\n  return {\n    distance: distance,\n    point: _intersectionPointWorld.clone(),\n    object: object\n  };\n}\n\nfunction checkBufferGeometryIntersection(object, material, raycaster, ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c) {\n  _vA.fromBufferAttribute(position, a);\n\n  _vB.fromBufferAttribute(position, b);\n\n  _vC.fromBufferAttribute(position, c);\n\n  const morphInfluences = object.morphTargetInfluences;\n\n  if (morphPosition && morphInfluences) {\n    _morphA.set(0, 0, 0);\n\n    _morphB.set(0, 0, 0);\n\n    _morphC.set(0, 0, 0);\n\n    for (let i = 0, il = morphPosition.length; i < il; i++) {\n      const influence = morphInfluences[i];\n      const morphAttribute = morphPosition[i];\n      if (influence === 0) continue;\n\n      _tempA.fromBufferAttribute(morphAttribute, a);\n\n      _tempB.fromBufferAttribute(morphAttribute, b);\n\n      _tempC.fromBufferAttribute(morphAttribute, c);\n\n      if (morphTargetsRelative) {\n        _morphA.addScaledVector(_tempA, influence);\n\n        _morphB.addScaledVector(_tempB, influence);\n\n        _morphC.addScaledVector(_tempC, influence);\n      } else {\n        _morphA.addScaledVector(_tempA.sub(_vA), influence);\n\n        _morphB.addScaledVector(_tempB.sub(_vB), influence);\n\n        _morphC.addScaledVector(_tempC.sub(_vC), influence);\n      }\n    }\n\n    _vA.add(_morphA);\n\n    _vB.add(_morphB);\n\n    _vC.add(_morphC);\n  }\n\n  if (object.isSkinnedMesh) {\n    object.boneTransform(a, _vA);\n    object.boneTransform(b, _vB);\n    object.boneTransform(c, _vC);\n  }\n\n  const intersection = checkIntersection(object, material, raycaster, ray, _vA, _vB, _vC, _intersectionPoint);\n\n  if (intersection) {\n    if (uv) {\n      _uvA.fromBufferAttribute(uv, a);\n\n      _uvB.fromBufferAttribute(uv, b);\n\n      _uvC.fromBufferAttribute(uv, c);\n\n      intersection.uv = Triangle.getUV(_intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2());\n    }\n\n    if (uv2) {\n      _uvA.fromBufferAttribute(uv2, a);\n\n      _uvB.fromBufferAttribute(uv2, b);\n\n      _uvC.fromBufferAttribute(uv2, c);\n\n      intersection.uv2 = Triangle.getUV(_intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2());\n    }\n\n    const face = {\n      a: a,\n      b: b,\n      c: c,\n      normal: new Vector3(),\n      materialIndex: 0\n    };\n    Triangle.getNormal(_vA, _vB, _vC, face.normal);\n    intersection.face = face;\n  }\n\n  return intersection;\n}\n\nexport { Mesh };","map":{"version":3,"sources":["C:/Users/dell/Desktop/projektlogin/vue-3-authentication-jwt/src/games/three/src/objects/Mesh.js"],"names":["Vector3","Vector2","Sphere","Ray","Matrix4","Object3D","Triangle","DoubleSide","BackSide","MeshBasicMaterial","BufferGeometry","_inverseMatrix","_ray","_sphere","_vA","_vB","_vC","_tempA","_tempB","_tempC","_morphA","_morphB","_morphC","_uvA","_uvB","_uvC","_intersectionPoint","_intersectionPointWorld","Mesh","constructor","geometry","material","type","updateMorphTargets","copy","source","morphTargetInfluences","undefined","slice","morphTargetDictionary","Object","assign","isBufferGeometry","morphAttributes","keys","length","morphAttribute","m","ml","name","String","push","morphTargets","console","error","raycast","raycaster","intersects","matrixWorld","boundingSphere","computeBoundingSphere","applyMatrix4","ray","intersectsSphere","invert","boundingBox","intersectsBox","intersection","index","position","attributes","morphPosition","morphTargetsRelative","uv","uv2","groups","drawRange","Array","isArray","i","il","group","groupMaterial","materialIndex","start","Math","max","end","min","count","j","jl","a","getX","b","c","checkBufferGeometryIntersection","faceIndex","floor","face","isGeometry","prototype","isMesh","checkIntersection","object","pA","pB","pC","point","intersect","side","intersectTriangle","distance","origin","distanceTo","near","far","clone","fromBufferAttribute","morphInfluences","set","influence","addScaledVector","sub","add","isSkinnedMesh","boneTransform","getUV","normal","getNormal"],"mappings":"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","sourcesContent":["import { Vector3 } from '../math/Vector3.js';\r\nimport { Vector2 } from '../math/Vector2.js';\r\nimport { Sphere } from '../math/Sphere.js';\r\nimport { Ray } from '../math/Ray.js';\r\nimport { Matrix4 } from '../math/Matrix4.js';\r\nimport { Object3D } from '../core/Object3D.js';\r\nimport { Triangle } from '../math/Triangle.js';\r\nimport { DoubleSide, BackSide } from '../constants.js';\r\nimport { MeshBasicMaterial } from '../materials/MeshBasicMaterial.js';\r\nimport { BufferGeometry } from '../core/BufferGeometry.js';\r\n\r\nconst _inverseMatrix = /*@__PURE__*/ new Matrix4();\r\nconst _ray = /*@__PURE__*/ new Ray();\r\nconst _sphere = /*@__PURE__*/ new Sphere();\r\n\r\nconst _vA = /*@__PURE__*/ new Vector3();\r\nconst _vB = /*@__PURE__*/ new Vector3();\r\nconst _vC = /*@__PURE__*/ new Vector3();\r\n\r\nconst _tempA = /*@__PURE__*/ new Vector3();\r\nconst _tempB = /*@__PURE__*/ new Vector3();\r\nconst _tempC = /*@__PURE__*/ new Vector3();\r\n\r\nconst _morphA = /*@__PURE__*/ new Vector3();\r\nconst _morphB = /*@__PURE__*/ new Vector3();\r\nconst _morphC = /*@__PURE__*/ new Vector3();\r\n\r\nconst _uvA = /*@__PURE__*/ new Vector2();\r\nconst _uvB = /*@__PURE__*/ new Vector2();\r\nconst _uvC = /*@__PURE__*/ new Vector2();\r\n\r\nconst _intersectionPoint = /*@__PURE__*/ new Vector3();\r\nconst _intersectionPointWorld = /*@__PURE__*/ new Vector3();\r\n\r\nclass Mesh extends Object3D {\r\n\r\n\tconstructor( geometry = new BufferGeometry(), material = new MeshBasicMaterial() ) {\r\n\r\n\t\tsuper();\r\n\r\n\t\tthis.type = 'Mesh';\r\n\r\n\t\tthis.geometry = geometry;\r\n\t\tthis.material = material;\r\n\r\n\t\tthis.updateMorphTargets();\r\n\r\n\t}\r\n\r\n\tcopy( source ) {\r\n\r\n\t\tsuper.copy( source );\r\n\r\n\t\tif ( source.morphTargetInfluences !== undefined ) {\r\n\r\n\t\t\tthis.morphTargetInfluences = source.morphTargetInfluences.slice();\r\n\r\n\t\t}\r\n\r\n\t\tif ( source.morphTargetDictionary !== undefined ) {\r\n\r\n\t\t\tthis.morphTargetDictionary = Object.assign( {}, source.morphTargetDictionary );\r\n\r\n\t\t}\r\n\r\n\t\tthis.material = source.material;\r\n\t\tthis.geometry = source.geometry;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tupdateMorphTargets() {\r\n\r\n\t\tconst geometry = this.geometry;\r\n\r\n\t\tif ( geometry.isBufferGeometry ) {\r\n\r\n\t\t\tconst morphAttributes = geometry.morphAttributes;\r\n\t\t\tconst keys = Object.keys( morphAttributes );\r\n\r\n\t\t\tif ( keys.length > 0 ) {\r\n\r\n\t\t\t\tconst morphAttribute = morphAttributes[ keys[ 0 ] ];\r\n\r\n\t\t\t\tif ( morphAttribute !== undefined ) {\r\n\r\n\t\t\t\t\tthis.morphTargetInfluences = [];\r\n\t\t\t\t\tthis.morphTargetDictionary = {};\r\n\r\n\t\t\t\t\tfor ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {\r\n\r\n\t\t\t\t\t\tconst name = morphAttribute[ m ].name || String( m );\r\n\r\n\t\t\t\t\t\tthis.morphTargetInfluences.push( 0 );\r\n\t\t\t\t\t\tthis.morphTargetDictionary[ name ] = m;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tconst morphTargets = geometry.morphTargets;\r\n\r\n\t\t\tif ( morphTargets !== undefined && morphTargets.length > 0 ) {\r\n\r\n\t\t\t\tconsole.error( 'THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\traycast( raycaster, intersects ) {\r\n\r\n\t\tconst geometry = this.geometry;\r\n\t\tconst material = this.material;\r\n\t\tconst matrixWorld = this.matrixWorld;\r\n\r\n\t\tif ( material === undefined ) return;\r\n\r\n\t\t// Checking boundingSphere distance to ray\r\n\r\n\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\r\n\r\n\t\t_sphere.copy( geometry.boundingSphere );\r\n\t\t_sphere.applyMatrix4( matrixWorld );\r\n\r\n\t\tif ( raycaster.ray.intersectsSphere( _sphere ) === false ) return;\r\n\r\n\t\t//\r\n\r\n\t\t_inverseMatrix.copy( matrixWorld ).invert();\r\n\t\t_ray.copy( raycaster.ray ).applyMatrix4( _inverseMatrix );\r\n\r\n\t\t// Check boundingBox before continuing\r\n\r\n\t\tif ( geometry.boundingBox !== null ) {\r\n\r\n\t\t\tif ( _ray.intersectsBox( geometry.boundingBox ) === false ) return;\r\n\r\n\t\t}\r\n\r\n\t\tlet intersection;\r\n\r\n\t\tif ( geometry.isBufferGeometry ) {\r\n\r\n\t\t\tconst index = geometry.index;\r\n\t\t\tconst position = geometry.attributes.position;\r\n\t\t\tconst morphPosition = geometry.morphAttributes.position;\r\n\t\t\tconst morphTargetsRelative = geometry.morphTargetsRelative;\r\n\t\t\tconst uv = geometry.attributes.uv;\r\n\t\t\tconst uv2 = geometry.attributes.uv2;\r\n\t\t\tconst groups = geometry.groups;\r\n\t\t\tconst drawRange = geometry.drawRange;\r\n\r\n\t\t\tif ( index !== null ) {\r\n\r\n\t\t\t\t// indexed buffer geometry\r\n\r\n\t\t\t\tif ( Array.isArray( material ) ) {\r\n\r\n\t\t\t\t\tfor ( let i = 0, il = groups.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\t\tconst group = groups[ i ];\r\n\t\t\t\t\t\tconst groupMaterial = material[ group.materialIndex ];\r\n\r\n\t\t\t\t\t\tconst start = Math.max( group.start, drawRange.start );\r\n\t\t\t\t\t\tconst end = Math.min( index.count, Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) ) );\r\n\r\n\t\t\t\t\t\tfor ( let j = start, jl = end; j < jl; j += 3 ) {\r\n\r\n\t\t\t\t\t\t\tconst a = index.getX( j );\r\n\t\t\t\t\t\t\tconst b = index.getX( j + 1 );\r\n\t\t\t\t\t\t\tconst c = index.getX( j + 2 );\r\n\r\n\t\t\t\t\t\t\tintersection = checkBufferGeometryIntersection( this, groupMaterial, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );\r\n\r\n\t\t\t\t\t\t\tif ( intersection ) {\r\n\r\n\t\t\t\t\t\t\t\tintersection.faceIndex = Math.floor( j / 3 ); // triangle number in indexed buffer semantics\r\n\t\t\t\t\t\t\t\tintersection.face.materialIndex = group.materialIndex;\r\n\t\t\t\t\t\t\t\tintersects.push( intersection );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tconst start = Math.max( 0, drawRange.start );\r\n\t\t\t\t\tconst end = Math.min( index.count, ( drawRange.start + drawRange.count ) );\r\n\r\n\t\t\t\t\tfor ( let i = start, il = end; i < il; i += 3 ) {\r\n\r\n\t\t\t\t\t\tconst a = index.getX( i );\r\n\t\t\t\t\t\tconst b = index.getX( i + 1 );\r\n\t\t\t\t\t\tconst c = index.getX( i + 2 );\r\n\r\n\t\t\t\t\t\tintersection = checkBufferGeometryIntersection( this, material, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );\r\n\r\n\t\t\t\t\t\tif ( intersection ) {\r\n\r\n\t\t\t\t\t\t\tintersection.faceIndex = Math.floor( i / 3 ); // triangle number in indexed buffer semantics\r\n\t\t\t\t\t\t\tintersects.push( intersection );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( position !== undefined ) {\r\n\r\n\t\t\t\t// non-indexed buffer geometry\r\n\r\n\t\t\t\tif ( Array.isArray( material ) ) {\r\n\r\n\t\t\t\t\tfor ( let i = 0, il = groups.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\t\tconst group = groups[ i ];\r\n\t\t\t\t\t\tconst groupMaterial = material[ group.materialIndex ];\r\n\r\n\t\t\t\t\t\tconst start = Math.max( group.start, drawRange.start );\r\n\t\t\t\t\t\tconst end = Math.min( position.count, Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) ) );\r\n\r\n\t\t\t\t\t\tfor ( let j = start, jl = end; j < jl; j += 3 ) {\r\n\r\n\t\t\t\t\t\t\tconst a = j;\r\n\t\t\t\t\t\t\tconst b = j + 1;\r\n\t\t\t\t\t\t\tconst c = j + 2;\r\n\r\n\t\t\t\t\t\t\tintersection = checkBufferGeometryIntersection( this, groupMaterial, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );\r\n\r\n\t\t\t\t\t\t\tif ( intersection ) {\r\n\r\n\t\t\t\t\t\t\t\tintersection.faceIndex = Math.floor( j / 3 ); // triangle number in non-indexed buffer semantics\r\n\t\t\t\t\t\t\t\tintersection.face.materialIndex = group.materialIndex;\r\n\t\t\t\t\t\t\t\tintersects.push( intersection );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tconst start = Math.max( 0, drawRange.start );\r\n\t\t\t\t\tconst end = Math.min( position.count, ( drawRange.start + drawRange.count ) );\r\n\r\n\t\t\t\t\tfor ( let i = start, il = end; i < il; i += 3 ) {\r\n\r\n\t\t\t\t\t\tconst a = i;\r\n\t\t\t\t\t\tconst b = i + 1;\r\n\t\t\t\t\t\tconst c = i + 2;\r\n\r\n\t\t\t\t\t\tintersection = checkBufferGeometryIntersection( this, material, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );\r\n\r\n\t\t\t\t\t\tif ( intersection ) {\r\n\r\n\t\t\t\t\t\t\tintersection.faceIndex = Math.floor( i / 3 ); // triangle number in non-indexed buffer semantics\r\n\t\t\t\t\t\t\tintersects.push( intersection );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( geometry.isGeometry ) {\r\n\r\n\t\t\tconsole.error( 'THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nMesh.prototype.isMesh = true;\r\n\r\nfunction checkIntersection( object, material, raycaster, ray, pA, pB, pC, point ) {\r\n\r\n\tlet intersect;\r\n\r\n\tif ( material.side === BackSide ) {\r\n\r\n\t\tintersect = ray.intersectTriangle( pC, pB, pA, true, point );\r\n\r\n\t} else {\r\n\r\n\t\tintersect = ray.intersectTriangle( pA, pB, pC, material.side !== DoubleSide, point );\r\n\r\n\t}\r\n\r\n\tif ( intersect === null ) return null;\r\n\r\n\t_intersectionPointWorld.copy( point );\r\n\t_intersectionPointWorld.applyMatrix4( object.matrixWorld );\r\n\r\n\tconst distance = raycaster.ray.origin.distanceTo( _intersectionPointWorld );\r\n\r\n\tif ( distance < raycaster.near || distance > raycaster.far ) return null;\r\n\r\n\treturn {\r\n\t\tdistance: distance,\r\n\t\tpoint: _intersectionPointWorld.clone(),\r\n\t\tobject: object\r\n\t};\r\n\r\n}\r\n\r\nfunction checkBufferGeometryIntersection( object, material, raycaster, ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c ) {\r\n\r\n\t_vA.fromBufferAttribute( position, a );\r\n\t_vB.fromBufferAttribute( position, b );\r\n\t_vC.fromBufferAttribute( position, c );\r\n\r\n\tconst morphInfluences = object.morphTargetInfluences;\r\n\r\n\tif ( morphPosition && morphInfluences ) {\r\n\r\n\t\t_morphA.set( 0, 0, 0 );\r\n\t\t_morphB.set( 0, 0, 0 );\r\n\t\t_morphC.set( 0, 0, 0 );\r\n\r\n\t\tfor ( let i = 0, il = morphPosition.length; i < il; i ++ ) {\r\n\r\n\t\t\tconst influence = morphInfluences[ i ];\r\n\t\t\tconst morphAttribute = morphPosition[ i ];\r\n\r\n\t\t\tif ( influence === 0 ) continue;\r\n\r\n\t\t\t_tempA.fromBufferAttribute( morphAttribute, a );\r\n\t\t\t_tempB.fromBufferAttribute( morphAttribute, b );\r\n\t\t\t_tempC.fromBufferAttribute( morphAttribute, c );\r\n\r\n\t\t\tif ( morphTargetsRelative ) {\r\n\r\n\t\t\t\t_morphA.addScaledVector( _tempA, influence );\r\n\t\t\t\t_morphB.addScaledVector( _tempB, influence );\r\n\t\t\t\t_morphC.addScaledVector( _tempC, influence );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t_morphA.addScaledVector( _tempA.sub( _vA ), influence );\r\n\t\t\t\t_morphB.addScaledVector( _tempB.sub( _vB ), influence );\r\n\t\t\t\t_morphC.addScaledVector( _tempC.sub( _vC ), influence );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t_vA.add( _morphA );\r\n\t\t_vB.add( _morphB );\r\n\t\t_vC.add( _morphC );\r\n\r\n\t}\r\n\r\n\tif ( object.isSkinnedMesh ) {\r\n\r\n\t\tobject.boneTransform( a, _vA );\r\n\t\tobject.boneTransform( b, _vB );\r\n\t\tobject.boneTransform( c, _vC );\r\n\r\n\t}\r\n\r\n\tconst intersection = checkIntersection( object, material, raycaster, ray, _vA, _vB, _vC, _intersectionPoint );\r\n\r\n\tif ( intersection ) {\r\n\r\n\t\tif ( uv ) {\r\n\r\n\t\t\t_uvA.fromBufferAttribute( uv, a );\r\n\t\t\t_uvB.fromBufferAttribute( uv, b );\r\n\t\t\t_uvC.fromBufferAttribute( uv, c );\r\n\r\n\t\t\tintersection.uv = Triangle.getUV( _intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2() );\r\n\r\n\t\t}\r\n\r\n\t\tif ( uv2 ) {\r\n\r\n\t\t\t_uvA.fromBufferAttribute( uv2, a );\r\n\t\t\t_uvB.fromBufferAttribute( uv2, b );\r\n\t\t\t_uvC.fromBufferAttribute( uv2, c );\r\n\r\n\t\t\tintersection.uv2 = Triangle.getUV( _intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2() );\r\n\r\n\t\t}\r\n\r\n\t\tconst face = {\r\n\t\t\ta: a,\r\n\t\t\tb: b,\r\n\t\t\tc: c,\r\n\t\t\tnormal: new Vector3(),\r\n\t\t\tmaterialIndex: 0\r\n\t\t};\r\n\r\n\t\tTriangle.getNormal( _vA, _vB, _vC, face.normal );\r\n\r\n\t\tintersection.face = face;\r\n\r\n\t}\r\n\r\n\treturn intersection;\r\n\r\n}\r\n\r\nexport { Mesh };\r\n"]},"metadata":{},"sourceType":"module"}