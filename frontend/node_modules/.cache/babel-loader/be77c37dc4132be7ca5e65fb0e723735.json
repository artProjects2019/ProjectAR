{"ast":null,"code":"import { BackSide, FrontSide, CubeUVReflectionMapping } from '../../constants.js';\nimport { BoxGeometry } from '../../geometries/BoxGeometry.js';\nimport { PlaneGeometry } from '../../geometries/PlaneGeometry.js';\nimport { ShaderMaterial } from '../../materials/ShaderMaterial.js';\nimport { Color } from '../../math/Color.js';\nimport { Mesh } from '../../objects/Mesh.js';\nimport { ShaderLib } from '../shaders/ShaderLib.js';\nimport { cloneUniforms } from '../shaders/UniformsUtils.js';\n\nfunction WebGLBackground(renderer, cubemaps, state, objects, alpha, premultipliedAlpha) {\n  const clearColor = new Color(0x000000);\n  let clearAlpha = alpha === true ? 0 : 1;\n  let planeMesh;\n  let boxMesh;\n  let currentBackground = null;\n  let currentBackgroundVersion = 0;\n  let currentTonemapping = null;\n\n  function render(renderList, scene) {\n    let forceClear = false;\n    let background = scene.isScene === true ? scene.background : null;\n\n    if (background && background.isTexture) {\n      background = cubemaps.get(background);\n    } // Ignore background in AR\n    // TODO: Reconsider this.\n\n\n    const xr = renderer.xr;\n    const session = xr.getSession && xr.getSession();\n\n    if (session && session.environmentBlendMode === 'additive') {\n      background = null;\n    }\n\n    if (background === null) {\n      setClear(clearColor, clearAlpha);\n    } else if (background && background.isColor) {\n      setClear(background, 1);\n      forceClear = true;\n    }\n\n    if (renderer.autoClear || forceClear) {\n      renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);\n    }\n\n    if (background && (background.isCubeTexture || background.mapping === CubeUVReflectionMapping)) {\n      if (boxMesh === undefined) {\n        boxMesh = new Mesh(new BoxGeometry(1, 1, 1), new ShaderMaterial({\n          name: 'BackgroundCubeMaterial',\n          uniforms: cloneUniforms(ShaderLib.cube.uniforms),\n          vertexShader: ShaderLib.cube.vertexShader,\n          fragmentShader: ShaderLib.cube.fragmentShader,\n          side: BackSide,\n          depthTest: false,\n          depthWrite: false,\n          fog: false\n        }));\n        boxMesh.geometry.deleteAttribute('normal');\n        boxMesh.geometry.deleteAttribute('uv');\n\n        boxMesh.onBeforeRender = function (renderer, scene, camera) {\n          this.matrixWorld.copyPosition(camera.matrixWorld);\n        }; // enable code injection for non-built-in material\n\n\n        Object.defineProperty(boxMesh.material, 'envMap', {\n          get: function () {\n            return this.uniforms.envMap.value;\n          }\n        });\n        objects.update(boxMesh);\n      }\n\n      boxMesh.material.uniforms.envMap.value = background;\n      boxMesh.material.uniforms.flipEnvMap.value = background.isCubeTexture && background.isRenderTargetTexture === false ? -1 : 1;\n\n      if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {\n        boxMesh.material.needsUpdate = true;\n        currentBackground = background;\n        currentBackgroundVersion = background.version;\n        currentTonemapping = renderer.toneMapping;\n      } // push to the pre-sorted opaque render list\n\n\n      renderList.unshift(boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null);\n    } else if (background && background.isTexture) {\n      if (planeMesh === undefined) {\n        planeMesh = new Mesh(new PlaneGeometry(2, 2), new ShaderMaterial({\n          name: 'BackgroundMaterial',\n          uniforms: cloneUniforms(ShaderLib.background.uniforms),\n          vertexShader: ShaderLib.background.vertexShader,\n          fragmentShader: ShaderLib.background.fragmentShader,\n          side: FrontSide,\n          depthTest: false,\n          depthWrite: false,\n          fog: false\n        }));\n        planeMesh.geometry.deleteAttribute('normal'); // enable code injection for non-built-in material\n\n        Object.defineProperty(planeMesh.material, 'map', {\n          get: function () {\n            return this.uniforms.t2D.value;\n          }\n        });\n        objects.update(planeMesh);\n      }\n\n      planeMesh.material.uniforms.t2D.value = background;\n\n      if (background.matrixAutoUpdate === true) {\n        background.updateMatrix();\n      }\n\n      planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);\n\n      if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {\n        planeMesh.material.needsUpdate = true;\n        currentBackground = background;\n        currentBackgroundVersion = background.version;\n        currentTonemapping = renderer.toneMapping;\n      } // push to the pre-sorted opaque render list\n\n\n      renderList.unshift(planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null);\n    }\n  }\n\n  function setClear(color, alpha) {\n    state.buffers.color.setClear(color.r, color.g, color.b, alpha, premultipliedAlpha);\n  }\n\n  return {\n    getClearColor: function () {\n      return clearColor;\n    },\n    setClearColor: function (color, alpha = 1) {\n      clearColor.set(color);\n      clearAlpha = alpha;\n      setClear(clearColor, clearAlpha);\n    },\n    getClearAlpha: function () {\n      return clearAlpha;\n    },\n    setClearAlpha: function (alpha) {\n      clearAlpha = alpha;\n      setClear(clearColor, clearAlpha);\n    },\n    render: render\n  };\n}\n\nexport { WebGLBackground };","map":{"version":3,"sources":["C:/Users/dell/Desktop/projektlogin/vue-3-authentication-jwt/src/games/three/src/renderers/webgl/WebGLBackground.js"],"names":["BackSide","FrontSide","CubeUVReflectionMapping","BoxGeometry","PlaneGeometry","ShaderMaterial","Color","Mesh","ShaderLib","cloneUniforms","WebGLBackground","renderer","cubemaps","state","objects","alpha","premultipliedAlpha","clearColor","clearAlpha","planeMesh","boxMesh","currentBackground","currentBackgroundVersion","currentTonemapping","render","renderList","scene","forceClear","background","isScene","isTexture","get","xr","session","getSession","environmentBlendMode","setClear","isColor","autoClear","clear","autoClearColor","autoClearDepth","autoClearStencil","isCubeTexture","mapping","undefined","name","uniforms","cube","vertexShader","fragmentShader","side","depthTest","depthWrite","fog","geometry","deleteAttribute","onBeforeRender","camera","matrixWorld","copyPosition","Object","defineProperty","material","envMap","value","update","flipEnvMap","isRenderTargetTexture","version","toneMapping","needsUpdate","unshift","t2D","matrixAutoUpdate","updateMatrix","uvTransform","copy","matrix","color","buffers","r","g","b","getClearColor","setClearColor","set","getClearAlpha","setClearAlpha"],"mappings":"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","sourcesContent":["import { BackSide, FrontSide, CubeUVReflectionMapping } from '../../constants.js';\r\nimport { BoxGeometry } from '../../geometries/BoxGeometry.js';\r\nimport { PlaneGeometry } from '../../geometries/PlaneGeometry.js';\r\nimport { ShaderMaterial } from '../../materials/ShaderMaterial.js';\r\nimport { Color } from '../../math/Color.js';\r\nimport { Mesh } from '../../objects/Mesh.js';\r\nimport { ShaderLib } from '../shaders/ShaderLib.js';\r\nimport { cloneUniforms } from '../shaders/UniformsUtils.js';\r\n\r\nfunction WebGLBackground( renderer, cubemaps, state, objects, alpha, premultipliedAlpha ) {\r\n\r\n\tconst clearColor = new Color( 0x000000 );\r\n\tlet clearAlpha = alpha === true ? 0 : 1;\r\n\r\n\tlet planeMesh;\r\n\tlet boxMesh;\r\n\r\n\tlet currentBackground = null;\r\n\tlet currentBackgroundVersion = 0;\r\n\tlet currentTonemapping = null;\r\n\r\n\tfunction render( renderList, scene ) {\r\n\r\n\t\tlet forceClear = false;\r\n\t\tlet background = scene.isScene === true ? scene.background : null;\r\n\r\n\t\tif ( background && background.isTexture ) {\r\n\r\n\t\t\tbackground = cubemaps.get( background );\r\n\r\n\t\t}\r\n\r\n\t\t// Ignore background in AR\r\n\t\t// TODO: Reconsider this.\r\n\r\n\t\tconst xr = renderer.xr;\r\n\t\tconst session = xr.getSession && xr.getSession();\r\n\r\n\t\tif ( session && session.environmentBlendMode === 'additive' ) {\r\n\r\n\t\t\tbackground = null;\r\n\r\n\t\t}\r\n\r\n\t\tif ( background === null ) {\r\n\r\n\t\t\tsetClear( clearColor, clearAlpha );\r\n\r\n\t\t} else if ( background && background.isColor ) {\r\n\r\n\t\t\tsetClear( background, 1 );\r\n\t\t\tforceClear = true;\r\n\r\n\t\t}\r\n\r\n\t\tif ( renderer.autoClear || forceClear ) {\r\n\r\n\t\t\trenderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );\r\n\r\n\t\t}\r\n\r\n\t\tif ( background && ( background.isCubeTexture || background.mapping === CubeUVReflectionMapping ) ) {\r\n\r\n\t\t\tif ( boxMesh === undefined ) {\r\n\r\n\t\t\t\tboxMesh = new Mesh(\r\n\t\t\t\t\tnew BoxGeometry( 1, 1, 1 ),\r\n\t\t\t\t\tnew ShaderMaterial( {\r\n\t\t\t\t\t\tname: 'BackgroundCubeMaterial',\r\n\t\t\t\t\t\tuniforms: cloneUniforms( ShaderLib.cube.uniforms ),\r\n\t\t\t\t\t\tvertexShader: ShaderLib.cube.vertexShader,\r\n\t\t\t\t\t\tfragmentShader: ShaderLib.cube.fragmentShader,\r\n\t\t\t\t\t\tside: BackSide,\r\n\t\t\t\t\t\tdepthTest: false,\r\n\t\t\t\t\t\tdepthWrite: false,\r\n\t\t\t\t\t\tfog: false\r\n\t\t\t\t\t} )\r\n\t\t\t\t);\r\n\r\n\t\t\t\tboxMesh.geometry.deleteAttribute( 'normal' );\r\n\t\t\t\tboxMesh.geometry.deleteAttribute( 'uv' );\r\n\r\n\t\t\t\tboxMesh.onBeforeRender = function ( renderer, scene, camera ) {\r\n\r\n\t\t\t\t\tthis.matrixWorld.copyPosition( camera.matrixWorld );\r\n\r\n\t\t\t\t};\r\n\r\n\t\t\t\t// enable code injection for non-built-in material\r\n\t\t\t\tObject.defineProperty( boxMesh.material, 'envMap', {\r\n\r\n\t\t\t\t\tget: function () {\r\n\r\n\t\t\t\t\t\treturn this.uniforms.envMap.value;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} );\r\n\r\n\t\t\t\tobjects.update( boxMesh );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tboxMesh.material.uniforms.envMap.value = background;\r\n\t\t\tboxMesh.material.uniforms.flipEnvMap.value = ( background.isCubeTexture && background.isRenderTargetTexture === false ) ? - 1 : 1;\r\n\r\n\t\t\tif ( currentBackground !== background ||\r\n\t\t\t\tcurrentBackgroundVersion !== background.version ||\r\n\t\t\t\tcurrentTonemapping !== renderer.toneMapping ) {\r\n\r\n\t\t\t\tboxMesh.material.needsUpdate = true;\r\n\r\n\t\t\t\tcurrentBackground = background;\r\n\t\t\t\tcurrentBackgroundVersion = background.version;\r\n\t\t\t\tcurrentTonemapping = renderer.toneMapping;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// push to the pre-sorted opaque render list\r\n\t\t\trenderList.unshift( boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null );\r\n\r\n\t\t} else if ( background && background.isTexture ) {\r\n\r\n\t\t\tif ( planeMesh === undefined ) {\r\n\r\n\t\t\t\tplaneMesh = new Mesh(\r\n\t\t\t\t\tnew PlaneGeometry( 2, 2 ),\r\n\t\t\t\t\tnew ShaderMaterial( {\r\n\t\t\t\t\t\tname: 'BackgroundMaterial',\r\n\t\t\t\t\t\tuniforms: cloneUniforms( ShaderLib.background.uniforms ),\r\n\t\t\t\t\t\tvertexShader: ShaderLib.background.vertexShader,\r\n\t\t\t\t\t\tfragmentShader: ShaderLib.background.fragmentShader,\r\n\t\t\t\t\t\tside: FrontSide,\r\n\t\t\t\t\t\tdepthTest: false,\r\n\t\t\t\t\t\tdepthWrite: false,\r\n\t\t\t\t\t\tfog: false\r\n\t\t\t\t\t} )\r\n\t\t\t\t);\r\n\r\n\t\t\t\tplaneMesh.geometry.deleteAttribute( 'normal' );\r\n\r\n\t\t\t\t// enable code injection for non-built-in material\r\n\t\t\t\tObject.defineProperty( planeMesh.material, 'map', {\r\n\r\n\t\t\t\t\tget: function () {\r\n\r\n\t\t\t\t\t\treturn this.uniforms.t2D.value;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} );\r\n\r\n\t\t\t\tobjects.update( planeMesh );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tplaneMesh.material.uniforms.t2D.value = background;\r\n\r\n\t\t\tif ( background.matrixAutoUpdate === true ) {\r\n\r\n\t\t\t\tbackground.updateMatrix();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tplaneMesh.material.uniforms.uvTransform.value.copy( background.matrix );\r\n\r\n\t\t\tif ( currentBackground !== background ||\r\n\t\t\t\tcurrentBackgroundVersion !== background.version ||\r\n\t\t\t\tcurrentTonemapping !== renderer.toneMapping ) {\r\n\r\n\t\t\t\tplaneMesh.material.needsUpdate = true;\r\n\r\n\t\t\t\tcurrentBackground = background;\r\n\t\t\t\tcurrentBackgroundVersion = background.version;\r\n\t\t\t\tcurrentTonemapping = renderer.toneMapping;\r\n\r\n\t\t\t}\r\n\r\n\r\n\t\t\t// push to the pre-sorted opaque render list\r\n\t\t\trenderList.unshift( planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction setClear( color, alpha ) {\r\n\r\n\t\tstate.buffers.color.setClear( color.r, color.g, color.b, alpha, premultipliedAlpha );\r\n\r\n\t}\r\n\r\n\treturn {\r\n\r\n\t\tgetClearColor: function () {\r\n\r\n\t\t\treturn clearColor;\r\n\r\n\t\t},\r\n\t\tsetClearColor: function ( color, alpha = 1 ) {\r\n\r\n\t\t\tclearColor.set( color );\r\n\t\t\tclearAlpha = alpha;\r\n\t\t\tsetClear( clearColor, clearAlpha );\r\n\r\n\t\t},\r\n\t\tgetClearAlpha: function () {\r\n\r\n\t\t\treturn clearAlpha;\r\n\r\n\t\t},\r\n\t\tsetClearAlpha: function ( alpha ) {\r\n\r\n\t\t\tclearAlpha = alpha;\r\n\t\t\tsetClear( clearColor, clearAlpha );\r\n\r\n\t\t},\r\n\t\trender: render\r\n\r\n\t};\r\n\r\n}\r\n\r\n\r\nexport { WebGLBackground };\r\n"]},"metadata":{},"sourceType":"module"}