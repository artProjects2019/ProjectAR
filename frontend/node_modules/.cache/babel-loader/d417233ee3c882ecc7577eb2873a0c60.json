{"ast":null,"code":"import { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport * as Curves from '../extras/curves/Curves.js';\nimport { Vector2 } from '../math/Vector2.js';\nimport { Vector3 } from '../math/Vector3.js';\n\nclass TubeGeometry extends BufferGeometry {\n  constructor(path = new Curves['QuadraticBezierCurve3'](new Vector3(-1, -1, 0), new Vector3(-1, 1, 0), new Vector3(1, 1, 0)), tubularSegments = 64, radius = 1, radialSegments = 8, closed = false) {\n    super();\n    this.type = 'TubeGeometry';\n    this.parameters = {\n      path: path,\n      tubularSegments: tubularSegments,\n      radius: radius,\n      radialSegments: radialSegments,\n      closed: closed\n    };\n    const frames = path.computeFrenetFrames(tubularSegments, closed); // expose internals\n\n    this.tangents = frames.tangents;\n    this.normals = frames.normals;\n    this.binormals = frames.binormals; // helper variables\n\n    const vertex = new Vector3();\n    const normal = new Vector3();\n    const uv = new Vector2();\n    let P = new Vector3(); // buffer\n\n    const vertices = [];\n    const normals = [];\n    const uvs = [];\n    const indices = []; // create buffer data\n\n    generateBufferData(); // build geometry\n\n    this.setIndex(indices);\n    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2)); // functions\n\n    function generateBufferData() {\n      for (let i = 0; i < tubularSegments; i++) {\n        generateSegment(i);\n      } // if the geometry is not closed, generate the last row of vertices and normals\n      // at the regular position on the given path\n      //\n      // if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)\n\n\n      generateSegment(closed === false ? tubularSegments : 0); // uvs are generated in a separate function.\n      // this makes it easy compute correct values for closed geometries\n\n      generateUVs(); // finally create faces\n\n      generateIndices();\n    }\n\n    function generateSegment(i) {\n      // we use getPointAt to sample evenly distributed points from the given path\n      P = path.getPointAt(i / tubularSegments, P); // retrieve corresponding normal and binormal\n\n      const N = frames.normals[i];\n      const B = frames.binormals[i]; // generate normals and vertices for the current segment\n\n      for (let j = 0; j <= radialSegments; j++) {\n        const v = j / radialSegments * Math.PI * 2;\n        const sin = Math.sin(v);\n        const cos = -Math.cos(v); // normal\n\n        normal.x = cos * N.x + sin * B.x;\n        normal.y = cos * N.y + sin * B.y;\n        normal.z = cos * N.z + sin * B.z;\n        normal.normalize();\n        normals.push(normal.x, normal.y, normal.z); // vertex\n\n        vertex.x = P.x + radius * normal.x;\n        vertex.y = P.y + radius * normal.y;\n        vertex.z = P.z + radius * normal.z;\n        vertices.push(vertex.x, vertex.y, vertex.z);\n      }\n    }\n\n    function generateIndices() {\n      for (let j = 1; j <= tubularSegments; j++) {\n        for (let i = 1; i <= radialSegments; i++) {\n          const a = (radialSegments + 1) * (j - 1) + (i - 1);\n          const b = (radialSegments + 1) * j + (i - 1);\n          const c = (radialSegments + 1) * j + i;\n          const d = (radialSegments + 1) * (j - 1) + i; // faces\n\n          indices.push(a, b, d);\n          indices.push(b, c, d);\n        }\n      }\n    }\n\n    function generateUVs() {\n      for (let i = 0; i <= tubularSegments; i++) {\n        for (let j = 0; j <= radialSegments; j++) {\n          uv.x = i / tubularSegments;\n          uv.y = j / radialSegments;\n          uvs.push(uv.x, uv.y);\n        }\n      }\n    }\n  }\n\n  toJSON() {\n    const data = super.toJSON();\n    data.path = this.parameters.path.toJSON();\n    return data;\n  }\n\n  static fromJSON(data) {\n    // This only works for built-in curves (e.g. CatmullRomCurve3).\n    // User defined curves or instances of CurvePath will not be deserialized.\n    return new TubeGeometry(new Curves[data.path.type]().fromJSON(data.path), data.tubularSegments, data.radius, data.radialSegments, data.closed);\n  }\n\n}\n\nexport { TubeGeometry, TubeGeometry as TubeBufferGeometry };","map":{"version":3,"sources":["C:/Users/dell/Desktop/projektlogin/vue-3-authentication-jwt/src/games/three/src/geometries/TubeGeometry.js"],"names":["BufferGeometry","Float32BufferAttribute","Curves","Vector2","Vector3","TubeGeometry","constructor","path","tubularSegments","radius","radialSegments","closed","type","parameters","frames","computeFrenetFrames","tangents","normals","binormals","vertex","normal","uv","P","vertices","uvs","indices","generateBufferData","setIndex","setAttribute","i","generateSegment","generateUVs","generateIndices","getPointAt","N","B","j","v","Math","PI","sin","cos","x","y","z","normalize","push","a","b","c","d","toJSON","data","fromJSON","TubeBufferGeometry"],"mappings":"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","sourcesContent":["import { BufferGeometry } from '../core/BufferGeometry.js';\r\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\r\nimport * as Curves from '../extras/curves/Curves.js';\r\nimport { Vector2 } from '../math/Vector2.js';\r\nimport { Vector3 } from '../math/Vector3.js';\r\n\r\nclass TubeGeometry extends BufferGeometry {\r\n\r\n\tconstructor( path = new Curves[ 'QuadraticBezierCurve3' ]( new Vector3( - 1, - 1, 0 ), new Vector3( - 1, 1, 0 ), new Vector3( 1, 1, 0 ) ), tubularSegments = 64, radius = 1, radialSegments = 8, closed = false ) {\r\n\r\n\t\tsuper();\r\n\t\tthis.type = 'TubeGeometry';\r\n\r\n\t\tthis.parameters = {\r\n\t\t\tpath: path,\r\n\t\t\ttubularSegments: tubularSegments,\r\n\t\t\tradius: radius,\r\n\t\t\tradialSegments: radialSegments,\r\n\t\t\tclosed: closed\r\n\t\t};\r\n\r\n\t\tconst frames = path.computeFrenetFrames( tubularSegments, closed );\r\n\r\n\t\t// expose internals\r\n\r\n\t\tthis.tangents = frames.tangents;\r\n\t\tthis.normals = frames.normals;\r\n\t\tthis.binormals = frames.binormals;\r\n\r\n\t\t// helper variables\r\n\r\n\t\tconst vertex = new Vector3();\r\n\t\tconst normal = new Vector3();\r\n\t\tconst uv = new Vector2();\r\n\t\tlet P = new Vector3();\r\n\r\n\t\t// buffer\r\n\r\n\t\tconst vertices = [];\r\n\t\tconst normals = [];\r\n\t\tconst uvs = [];\r\n\t\tconst indices = [];\r\n\r\n\t\t// create buffer data\r\n\r\n\t\tgenerateBufferData();\r\n\r\n\t\t// build geometry\r\n\r\n\t\tthis.setIndex( indices );\r\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\r\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\r\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\r\n\r\n\t\t// functions\r\n\r\n\t\tfunction generateBufferData() {\r\n\r\n\t\t\tfor ( let i = 0; i < tubularSegments; i ++ ) {\r\n\r\n\t\t\t\tgenerateSegment( i );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// if the geometry is not closed, generate the last row of vertices and normals\r\n\t\t\t// at the regular position on the given path\r\n\t\t\t//\r\n\t\t\t// if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)\r\n\r\n\t\t\tgenerateSegment( ( closed === false ) ? tubularSegments : 0 );\r\n\r\n\t\t\t// uvs are generated in a separate function.\r\n\t\t\t// this makes it easy compute correct values for closed geometries\r\n\r\n\t\t\tgenerateUVs();\r\n\r\n\t\t\t// finally create faces\r\n\r\n\t\t\tgenerateIndices();\r\n\r\n\t\t}\r\n\r\n\t\tfunction generateSegment( i ) {\r\n\r\n\t\t\t// we use getPointAt to sample evenly distributed points from the given path\r\n\r\n\t\t\tP = path.getPointAt( i / tubularSegments, P );\r\n\r\n\t\t\t// retrieve corresponding normal and binormal\r\n\r\n\t\t\tconst N = frames.normals[ i ];\r\n\t\t\tconst B = frames.binormals[ i ];\r\n\r\n\t\t\t// generate normals and vertices for the current segment\r\n\r\n\t\t\tfor ( let j = 0; j <= radialSegments; j ++ ) {\r\n\r\n\t\t\t\tconst v = j / radialSegments * Math.PI * 2;\r\n\r\n\t\t\t\tconst sin = Math.sin( v );\r\n\t\t\t\tconst cos = - Math.cos( v );\r\n\r\n\t\t\t\t// normal\r\n\r\n\t\t\t\tnormal.x = ( cos * N.x + sin * B.x );\r\n\t\t\t\tnormal.y = ( cos * N.y + sin * B.y );\r\n\t\t\t\tnormal.z = ( cos * N.z + sin * B.z );\r\n\t\t\t\tnormal.normalize();\r\n\r\n\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\r\n\r\n\t\t\t\t// vertex\r\n\r\n\t\t\t\tvertex.x = P.x + radius * normal.x;\r\n\t\t\t\tvertex.y = P.y + radius * normal.y;\r\n\t\t\t\tvertex.z = P.z + radius * normal.z;\r\n\r\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction generateIndices() {\r\n\r\n\t\t\tfor ( let j = 1; j <= tubularSegments; j ++ ) {\r\n\r\n\t\t\t\tfor ( let i = 1; i <= radialSegments; i ++ ) {\r\n\r\n\t\t\t\t\tconst a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );\r\n\t\t\t\t\tconst b = ( radialSegments + 1 ) * j + ( i - 1 );\r\n\t\t\t\t\tconst c = ( radialSegments + 1 ) * j + i;\r\n\t\t\t\t\tconst d = ( radialSegments + 1 ) * ( j - 1 ) + i;\r\n\r\n\t\t\t\t\t// faces\r\n\r\n\t\t\t\t\tindices.push( a, b, d );\r\n\t\t\t\t\tindices.push( b, c, d );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction generateUVs() {\r\n\r\n\t\t\tfor ( let i = 0; i <= tubularSegments; i ++ ) {\r\n\r\n\t\t\t\tfor ( let j = 0; j <= radialSegments; j ++ ) {\r\n\r\n\t\t\t\t\tuv.x = i / tubularSegments;\r\n\t\t\t\t\tuv.y = j / radialSegments;\r\n\r\n\t\t\t\t\tuvs.push( uv.x, uv.y );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\ttoJSON() {\r\n\r\n\t\tconst data = super.toJSON();\r\n\r\n\t\tdata.path = this.parameters.path.toJSON();\r\n\r\n\t\treturn data;\r\n\r\n\t}\r\n\r\n\tstatic fromJSON( data ) {\r\n\r\n\t\t// This only works for built-in curves (e.g. CatmullRomCurve3).\r\n\t\t// User defined curves or instances of CurvePath will not be deserialized.\r\n\t\treturn new TubeGeometry(\r\n\t\t\tnew Curves[ data.path.type ]().fromJSON( data.path ),\r\n\t\t\tdata.tubularSegments,\r\n\t\t\tdata.radius,\r\n\t\t\tdata.radialSegments,\r\n\t\t\tdata.closed\r\n\t\t);\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\nexport { TubeGeometry, TubeGeometry as TubeBufferGeometry };\r\n"]},"metadata":{},"sourceType":"module"}