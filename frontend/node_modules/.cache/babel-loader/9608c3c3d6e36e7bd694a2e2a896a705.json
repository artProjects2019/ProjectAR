{"ast":null,"code":"import \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport { FrontSide, BackSide, DoubleSide, RGBAFormat, NearestFilter, LinearFilter, PCFShadowMap, VSMShadowMap, RGBADepthPacking, NoBlending } from '../../constants.js';\nimport { WebGLRenderTarget } from '../WebGLRenderTarget.js';\nimport { MeshDepthMaterial } from '../../materials/MeshDepthMaterial.js';\nimport { MeshDistanceMaterial } from '../../materials/MeshDistanceMaterial.js';\nimport { ShaderMaterial } from '../../materials/ShaderMaterial.js';\nimport { BufferAttribute } from '../../core/BufferAttribute.js';\nimport { BufferGeometry } from '../../core/BufferGeometry.js';\nimport { Mesh } from '../../objects/Mesh.js';\nimport { Vector4 } from '../../math/Vector4.js';\nimport { Vector2 } from '../../math/Vector2.js';\nimport { Frustum } from '../../math/Frustum.js';\nimport * as vsm from '../shaders/ShaderLib/vsm.glsl.js';\n\nfunction WebGLShadowMap(_renderer, _objects, _capabilities) {\n  let _frustum = new Frustum();\n\n  const _shadowMapSize = new Vector2(),\n        _viewportSize = new Vector2(),\n        _viewport = new Vector4(),\n        _depthMaterial = new MeshDepthMaterial({\n    depthPacking: RGBADepthPacking\n  }),\n        _distanceMaterial = new MeshDistanceMaterial(),\n        _materialCache = {},\n        _maxTextureSize = _capabilities.maxTextureSize;\n\n  const shadowSide = {\n    0: BackSide,\n    1: FrontSide,\n    2: DoubleSide\n  };\n  const shadowMaterialVertical = new ShaderMaterial({\n    defines: {\n      VSM_SAMPLES: 8\n    },\n    uniforms: {\n      shadow_pass: {\n        value: null\n      },\n      resolution: {\n        value: new Vector2()\n      },\n      radius: {\n        value: 4.0\n      }\n    },\n    vertexShader: vsm.vertex,\n    fragmentShader: vsm.fragment\n  });\n  const shadowMaterialHorizontal = shadowMaterialVertical.clone();\n  shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;\n  const fullScreenTri = new BufferGeometry();\n  fullScreenTri.setAttribute('position', new BufferAttribute(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3));\n  const fullScreenMesh = new Mesh(fullScreenTri, shadowMaterialVertical);\n  const scope = this;\n  this.enabled = false;\n  this.autoUpdate = true;\n  this.needsUpdate = false;\n  this.type = PCFShadowMap;\n\n  this.render = function (lights, scene, camera) {\n    if (scope.enabled === false) return;\n    if (scope.autoUpdate === false && scope.needsUpdate === false) return;\n    if (lights.length === 0) return;\n\n    const currentRenderTarget = _renderer.getRenderTarget();\n\n    const activeCubeFace = _renderer.getActiveCubeFace();\n\n    const activeMipmapLevel = _renderer.getActiveMipmapLevel();\n\n    const _state = _renderer.state; // Set GL state for depth map.\n\n    _state.setBlending(NoBlending);\n\n    _state.buffers.color.setClear(1, 1, 1, 1);\n\n    _state.buffers.depth.setTest(true);\n\n    _state.setScissorTest(false); // render depth map\n\n\n    for (let i = 0, il = lights.length; i < il; i++) {\n      const light = lights[i];\n      const shadow = light.shadow;\n\n      if (shadow === undefined) {\n        console.warn('THREE.WebGLShadowMap:', light, 'has no shadow.');\n        continue;\n      }\n\n      if (shadow.autoUpdate === false && shadow.needsUpdate === false) continue;\n\n      _shadowMapSize.copy(shadow.mapSize);\n\n      const shadowFrameExtents = shadow.getFrameExtents();\n\n      _shadowMapSize.multiply(shadowFrameExtents);\n\n      _viewportSize.copy(shadow.mapSize);\n\n      if (_shadowMapSize.x > _maxTextureSize || _shadowMapSize.y > _maxTextureSize) {\n        if (_shadowMapSize.x > _maxTextureSize) {\n          _viewportSize.x = Math.floor(_maxTextureSize / shadowFrameExtents.x);\n          _shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;\n          shadow.mapSize.x = _viewportSize.x;\n        }\n\n        if (_shadowMapSize.y > _maxTextureSize) {\n          _viewportSize.y = Math.floor(_maxTextureSize / shadowFrameExtents.y);\n          _shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;\n          shadow.mapSize.y = _viewportSize.y;\n        }\n      }\n\n      if (shadow.map === null && !shadow.isPointLightShadow && this.type === VSMShadowMap) {\n        const pars = {\n          minFilter: LinearFilter,\n          magFilter: LinearFilter,\n          format: RGBAFormat\n        };\n        shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);\n        shadow.map.texture.name = light.name + '.shadowMap';\n        shadow.mapPass = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);\n        shadow.camera.updateProjectionMatrix();\n      }\n\n      if (shadow.map === null) {\n        const pars = {\n          minFilter: NearestFilter,\n          magFilter: NearestFilter,\n          format: RGBAFormat\n        };\n        shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);\n        shadow.map.texture.name = light.name + '.shadowMap';\n        shadow.camera.updateProjectionMatrix();\n      }\n\n      _renderer.setRenderTarget(shadow.map);\n\n      _renderer.clear();\n\n      const viewportCount = shadow.getViewportCount();\n\n      for (let vp = 0; vp < viewportCount; vp++) {\n        const viewport = shadow.getViewport(vp);\n\n        _viewport.set(_viewportSize.x * viewport.x, _viewportSize.y * viewport.y, _viewportSize.x * viewport.z, _viewportSize.y * viewport.w);\n\n        _state.viewport(_viewport);\n\n        shadow.updateMatrices(light, vp);\n        _frustum = shadow.getFrustum();\n        renderObject(scene, camera, shadow.camera, light, this.type);\n      } // do blur pass for VSM\n\n\n      if (!shadow.isPointLightShadow && this.type === VSMShadowMap) {\n        VSMPass(shadow, camera);\n      }\n\n      shadow.needsUpdate = false;\n    }\n\n    scope.needsUpdate = false;\n\n    _renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipmapLevel);\n  };\n\n  function VSMPass(shadow, camera) {\n    const geometry = _objects.update(fullScreenMesh);\n\n    if (shadowMaterialVertical.defines.VSM_SAMPLES !== shadow.blurSamples) {\n      shadowMaterialVertical.defines.VSM_SAMPLES = shadow.blurSamples;\n      shadowMaterialHorizontal.defines.VSM_SAMPLES = shadow.blurSamples;\n      shadowMaterialVertical.needsUpdate = true;\n      shadowMaterialHorizontal.needsUpdate = true;\n    } // vertical pass\n\n\n    shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;\n    shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;\n    shadowMaterialVertical.uniforms.radius.value = shadow.radius;\n\n    _renderer.setRenderTarget(shadow.mapPass);\n\n    _renderer.clear();\n\n    _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null); // horizontal pass\n\n\n    shadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;\n    shadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;\n    shadowMaterialHorizontal.uniforms.radius.value = shadow.radius;\n\n    _renderer.setRenderTarget(shadow.map);\n\n    _renderer.clear();\n\n    _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null);\n  }\n\n  function getDepthMaterial(object, material, light, shadowCameraNear, shadowCameraFar, type) {\n    let result = null;\n    const customMaterial = light.isPointLight === true ? object.customDistanceMaterial : object.customDepthMaterial;\n\n    if (customMaterial !== undefined) {\n      result = customMaterial;\n    } else {\n      result = light.isPointLight === true ? _distanceMaterial : _depthMaterial;\n    }\n\n    if (_renderer.localClippingEnabled && material.clipShadows === true && material.clippingPlanes.length !== 0 || material.displacementMap && material.displacementScale !== 0 || material.alphaMap && material.alphaTest > 0) {\n      // in this case we need a unique material instance reflecting the\n      // appropriate state\n      const keyA = result.uuid,\n            keyB = material.uuid;\n      let materialsForVariant = _materialCache[keyA];\n\n      if (materialsForVariant === undefined) {\n        materialsForVariant = {};\n        _materialCache[keyA] = materialsForVariant;\n      }\n\n      let cachedMaterial = materialsForVariant[keyB];\n\n      if (cachedMaterial === undefined) {\n        cachedMaterial = result.clone();\n        materialsForVariant[keyB] = cachedMaterial;\n      }\n\n      result = cachedMaterial;\n    }\n\n    result.visible = material.visible;\n    result.wireframe = material.wireframe;\n\n    if (type === VSMShadowMap) {\n      result.side = material.shadowSide !== null ? material.shadowSide : material.side;\n    } else {\n      result.side = material.shadowSide !== null ? material.shadowSide : shadowSide[material.side];\n    }\n\n    result.alphaMap = material.alphaMap;\n    result.alphaTest = material.alphaTest;\n    result.clipShadows = material.clipShadows;\n    result.clippingPlanes = material.clippingPlanes;\n    result.clipIntersection = material.clipIntersection;\n    result.displacementMap = material.displacementMap;\n    result.displacementScale = material.displacementScale;\n    result.displacementBias = material.displacementBias;\n    result.wireframeLinewidth = material.wireframeLinewidth;\n    result.linewidth = material.linewidth;\n\n    if (light.isPointLight === true && result.isMeshDistanceMaterial === true) {\n      result.referencePosition.setFromMatrixPosition(light.matrixWorld);\n      result.nearDistance = shadowCameraNear;\n      result.farDistance = shadowCameraFar;\n    }\n\n    return result;\n  }\n\n  function renderObject(object, camera, shadowCamera, light, type) {\n    if (object.visible === false) return;\n    const visible = object.layers.test(camera.layers);\n\n    if (visible && (object.isMesh || object.isLine || object.isPoints)) {\n      if ((object.castShadow || object.receiveShadow && type === VSMShadowMap) && (!object.frustumCulled || _frustum.intersectsObject(object))) {\n        object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);\n\n        const geometry = _objects.update(object);\n\n        const material = object.material;\n\n        if (Array.isArray(material)) {\n          const groups = geometry.groups;\n\n          for (let k = 0, kl = groups.length; k < kl; k++) {\n            const group = groups[k];\n            const groupMaterial = material[group.materialIndex];\n\n            if (groupMaterial && groupMaterial.visible) {\n              const depthMaterial = getDepthMaterial(object, groupMaterial, light, shadowCamera.near, shadowCamera.far, type);\n\n              _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group);\n            }\n          }\n        } else if (material.visible) {\n          const depthMaterial = getDepthMaterial(object, material, light, shadowCamera.near, shadowCamera.far, type);\n\n          _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, null);\n        }\n      }\n    }\n\n    const children = object.children;\n\n    for (let i = 0, l = children.length; i < l; i++) {\n      renderObject(children[i], camera, shadowCamera, light, type);\n    }\n  }\n}\n\nexport { WebGLShadowMap };","map":{"version":3,"sources":["C:/Users/dell/Desktop/projektlogin/vue-3-authentication-jwt/src/games/three/src/renderers/webgl/WebGLShadowMap.js"],"names":["FrontSide","BackSide","DoubleSide","RGBAFormat","NearestFilter","LinearFilter","PCFShadowMap","VSMShadowMap","RGBADepthPacking","NoBlending","WebGLRenderTarget","MeshDepthMaterial","MeshDistanceMaterial","ShaderMaterial","BufferAttribute","BufferGeometry","Mesh","Vector4","Vector2","Frustum","vsm","WebGLShadowMap","_renderer","_objects","_capabilities","_frustum","_shadowMapSize","_viewportSize","_viewport","_depthMaterial","depthPacking","_distanceMaterial","_materialCache","_maxTextureSize","maxTextureSize","shadowSide","shadowMaterialVertical","defines","VSM_SAMPLES","uniforms","shadow_pass","value","resolution","radius","vertexShader","vertex","fragmentShader","fragment","shadowMaterialHorizontal","clone","HORIZONTAL_PASS","fullScreenTri","setAttribute","Float32Array","fullScreenMesh","scope","enabled","autoUpdate","needsUpdate","type","render","lights","scene","camera","length","currentRenderTarget","getRenderTarget","activeCubeFace","getActiveCubeFace","activeMipmapLevel","getActiveMipmapLevel","_state","state","setBlending","buffers","color","setClear","depth","setTest","setScissorTest","i","il","light","shadow","undefined","console","warn","copy","mapSize","shadowFrameExtents","getFrameExtents","multiply","x","y","Math","floor","map","isPointLightShadow","pars","minFilter","magFilter","format","texture","name","mapPass","updateProjectionMatrix","setRenderTarget","clear","viewportCount","getViewportCount","vp","viewport","getViewport","set","z","w","updateMatrices","getFrustum","renderObject","VSMPass","geometry","update","blurSamples","renderBufferDirect","getDepthMaterial","object","material","shadowCameraNear","shadowCameraFar","result","customMaterial","isPointLight","customDistanceMaterial","customDepthMaterial","localClippingEnabled","clipShadows","clippingPlanes","displacementMap","displacementScale","alphaMap","alphaTest","keyA","uuid","keyB","materialsForVariant","cachedMaterial","visible","wireframe","side","clipIntersection","displacementBias","wireframeLinewidth","linewidth","isMeshDistanceMaterial","referencePosition","setFromMatrixPosition","matrixWorld","nearDistance","farDistance","shadowCamera","layers","test","isMesh","isLine","isPoints","castShadow","receiveShadow","frustumCulled","intersectsObject","modelViewMatrix","multiplyMatrices","matrixWorldInverse","Array","isArray","groups","k","kl","group","groupMaterial","materialIndex","depthMaterial","near","far","children","l"],"mappings":"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","sourcesContent":["import { FrontSide, BackSide, DoubleSide, RGBAFormat, NearestFilter, LinearFilter, PCFShadowMap, VSMShadowMap, RGBADepthPacking, NoBlending } from '../../constants.js';\r\nimport { WebGLRenderTarget } from '../WebGLRenderTarget.js';\r\nimport { MeshDepthMaterial } from '../../materials/MeshDepthMaterial.js';\r\nimport { MeshDistanceMaterial } from '../../materials/MeshDistanceMaterial.js';\r\nimport { ShaderMaterial } from '../../materials/ShaderMaterial.js';\r\nimport { BufferAttribute } from '../../core/BufferAttribute.js';\r\nimport { BufferGeometry } from '../../core/BufferGeometry.js';\r\nimport { Mesh } from '../../objects/Mesh.js';\r\nimport { Vector4 } from '../../math/Vector4.js';\r\nimport { Vector2 } from '../../math/Vector2.js';\r\nimport { Frustum } from '../../math/Frustum.js';\r\n\r\nimport * as vsm from '../shaders/ShaderLib/vsm.glsl.js';\r\n\r\nfunction WebGLShadowMap( _renderer, _objects, _capabilities ) {\r\n\r\n\tlet _frustum = new Frustum();\r\n\r\n\tconst _shadowMapSize = new Vector2(),\r\n\t\t_viewportSize = new Vector2(),\r\n\r\n\t\t_viewport = new Vector4(),\r\n\r\n\t\t_depthMaterial = new MeshDepthMaterial( { depthPacking: RGBADepthPacking } ),\r\n\t\t_distanceMaterial = new MeshDistanceMaterial(),\r\n\r\n\t\t_materialCache = {},\r\n\r\n\t\t_maxTextureSize = _capabilities.maxTextureSize;\r\n\r\n\tconst shadowSide = { 0: BackSide, 1: FrontSide, 2: DoubleSide };\r\n\r\n\tconst shadowMaterialVertical = new ShaderMaterial( {\r\n\t\tdefines: {\r\n\t\t\tVSM_SAMPLES: 8\r\n\t\t},\r\n\t\tuniforms: {\r\n\t\t\tshadow_pass: { value: null },\r\n\t\t\tresolution: { value: new Vector2() },\r\n\t\t\tradius: { value: 4.0 }\r\n\t\t},\r\n\r\n\t\tvertexShader: vsm.vertex,\r\n\t\tfragmentShader: vsm.fragment\r\n\r\n\t} );\r\n\r\n\tconst shadowMaterialHorizontal = shadowMaterialVertical.clone();\r\n\tshadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;\r\n\r\n\tconst fullScreenTri = new BufferGeometry();\r\n\tfullScreenTri.setAttribute(\r\n\t\t'position',\r\n\t\tnew BufferAttribute(\r\n\t\t\tnew Float32Array( [ - 1, - 1, 0.5, 3, - 1, 0.5, - 1, 3, 0.5 ] ),\r\n\t\t\t3\r\n\t\t)\r\n\t);\r\n\r\n\tconst fullScreenMesh = new Mesh( fullScreenTri, shadowMaterialVertical );\r\n\r\n\tconst scope = this;\r\n\r\n\tthis.enabled = false;\r\n\r\n\tthis.autoUpdate = true;\r\n\tthis.needsUpdate = false;\r\n\r\n\tthis.type = PCFShadowMap;\r\n\r\n\tthis.render = function ( lights, scene, camera ) {\r\n\r\n\t\tif ( scope.enabled === false ) return;\r\n\t\tif ( scope.autoUpdate === false && scope.needsUpdate === false ) return;\r\n\r\n\t\tif ( lights.length === 0 ) return;\r\n\r\n\t\tconst currentRenderTarget = _renderer.getRenderTarget();\r\n\t\tconst activeCubeFace = _renderer.getActiveCubeFace();\r\n\t\tconst activeMipmapLevel = _renderer.getActiveMipmapLevel();\r\n\r\n\t\tconst _state = _renderer.state;\r\n\r\n\t\t// Set GL state for depth map.\r\n\t\t_state.setBlending( NoBlending );\r\n\t\t_state.buffers.color.setClear( 1, 1, 1, 1 );\r\n\t\t_state.buffers.depth.setTest( true );\r\n\t\t_state.setScissorTest( false );\r\n\r\n\t\t// render depth map\r\n\r\n\t\tfor ( let i = 0, il = lights.length; i < il; i ++ ) {\r\n\r\n\t\t\tconst light = lights[ i ];\r\n\t\t\tconst shadow = light.shadow;\r\n\r\n\t\t\tif ( shadow === undefined ) {\r\n\r\n\t\t\t\tconsole.warn( 'THREE.WebGLShadowMap:', light, 'has no shadow.' );\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( shadow.autoUpdate === false && shadow.needsUpdate === false ) continue;\r\n\r\n\t\t\t_shadowMapSize.copy( shadow.mapSize );\r\n\r\n\t\t\tconst shadowFrameExtents = shadow.getFrameExtents();\r\n\r\n\t\t\t_shadowMapSize.multiply( shadowFrameExtents );\r\n\r\n\t\t\t_viewportSize.copy( shadow.mapSize );\r\n\r\n\t\t\tif ( _shadowMapSize.x > _maxTextureSize || _shadowMapSize.y > _maxTextureSize ) {\r\n\r\n\t\t\t\tif ( _shadowMapSize.x > _maxTextureSize ) {\r\n\r\n\t\t\t\t\t_viewportSize.x = Math.floor( _maxTextureSize / shadowFrameExtents.x );\r\n\t\t\t\t\t_shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;\r\n\t\t\t\t\tshadow.mapSize.x = _viewportSize.x;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( _shadowMapSize.y > _maxTextureSize ) {\r\n\r\n\t\t\t\t\t_viewportSize.y = Math.floor( _maxTextureSize / shadowFrameExtents.y );\r\n\t\t\t\t\t_shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;\r\n\t\t\t\t\tshadow.mapSize.y = _viewportSize.y;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( shadow.map === null && ! shadow.isPointLightShadow && this.type === VSMShadowMap ) {\r\n\r\n\t\t\t\tconst pars = { minFilter: LinearFilter, magFilter: LinearFilter, format: RGBAFormat };\r\n\r\n\t\t\t\tshadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );\r\n\t\t\t\tshadow.map.texture.name = light.name + '.shadowMap';\r\n\r\n\t\t\t\tshadow.mapPass = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );\r\n\r\n\t\t\t\tshadow.camera.updateProjectionMatrix();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( shadow.map === null ) {\r\n\r\n\t\t\t\tconst pars = { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat };\r\n\r\n\t\t\t\tshadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );\r\n\t\t\t\tshadow.map.texture.name = light.name + '.shadowMap';\r\n\r\n\t\t\t\tshadow.camera.updateProjectionMatrix();\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_renderer.setRenderTarget( shadow.map );\r\n\t\t\t_renderer.clear();\r\n\r\n\t\t\tconst viewportCount = shadow.getViewportCount();\r\n\r\n\t\t\tfor ( let vp = 0; vp < viewportCount; vp ++ ) {\r\n\r\n\t\t\t\tconst viewport = shadow.getViewport( vp );\r\n\r\n\t\t\t\t_viewport.set(\r\n\t\t\t\t\t_viewportSize.x * viewport.x,\r\n\t\t\t\t\t_viewportSize.y * viewport.y,\r\n\t\t\t\t\t_viewportSize.x * viewport.z,\r\n\t\t\t\t\t_viewportSize.y * viewport.w\r\n\t\t\t\t);\r\n\r\n\t\t\t\t_state.viewport( _viewport );\r\n\r\n\t\t\t\tshadow.updateMatrices( light, vp );\r\n\r\n\t\t\t\t_frustum = shadow.getFrustum();\r\n\r\n\t\t\t\trenderObject( scene, camera, shadow.camera, light, this.type );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// do blur pass for VSM\r\n\r\n\t\t\tif ( ! shadow.isPointLightShadow && this.type === VSMShadowMap ) {\r\n\r\n\t\t\t\tVSMPass( shadow, camera );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tshadow.needsUpdate = false;\r\n\r\n\t\t}\r\n\r\n\t\tscope.needsUpdate = false;\r\n\r\n\t\t_renderer.setRenderTarget( currentRenderTarget, activeCubeFace, activeMipmapLevel );\r\n\r\n\t};\r\n\r\n\tfunction VSMPass( shadow, camera ) {\r\n\r\n\t\tconst geometry = _objects.update( fullScreenMesh );\r\n\r\n\t\tif ( shadowMaterialVertical.defines.VSM_SAMPLES !== shadow.blurSamples ) {\r\n\r\n\t\t\tshadowMaterialVertical.defines.VSM_SAMPLES = shadow.blurSamples;\r\n\t\t\tshadowMaterialHorizontal.defines.VSM_SAMPLES = shadow.blurSamples;\r\n\r\n\t\t\tshadowMaterialVertical.needsUpdate = true;\r\n\t\t\tshadowMaterialHorizontal.needsUpdate = true;\r\n\r\n\t\t}\r\n\r\n\t\t// vertical pass\r\n\r\n\t\tshadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;\r\n\t\tshadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;\r\n\t\tshadowMaterialVertical.uniforms.radius.value = shadow.radius;\r\n\t\t_renderer.setRenderTarget( shadow.mapPass );\r\n\t\t_renderer.clear();\r\n\t\t_renderer.renderBufferDirect( camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null );\r\n\r\n\t\t// horizontal pass\r\n\r\n\t\tshadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;\r\n\t\tshadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;\r\n\t\tshadowMaterialHorizontal.uniforms.radius.value = shadow.radius;\r\n\t\t_renderer.setRenderTarget( shadow.map );\r\n\t\t_renderer.clear();\r\n\t\t_renderer.renderBufferDirect( camera, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null );\r\n\r\n\t}\r\n\r\n\tfunction getDepthMaterial( object, material, light, shadowCameraNear, shadowCameraFar, type ) {\r\n\r\n\t\tlet result = null;\r\n\r\n\t\tconst customMaterial = ( light.isPointLight === true ) ? object.customDistanceMaterial : object.customDepthMaterial;\r\n\r\n\t\tif ( customMaterial !== undefined ) {\r\n\r\n\t\t\tresult = customMaterial;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tresult = ( light.isPointLight === true ) ? _distanceMaterial : _depthMaterial;\r\n\r\n\t\t}\r\n\r\n\t\tif ( ( _renderer.localClippingEnabled && material.clipShadows === true && material.clippingPlanes.length !== 0 ) ||\r\n\t\t\t( material.displacementMap && material.displacementScale !== 0 ) ||\r\n\t\t\t( material.alphaMap && material.alphaTest > 0 ) ) {\r\n\r\n\t\t\t// in this case we need a unique material instance reflecting the\r\n\t\t\t// appropriate state\r\n\r\n\t\t\tconst keyA = result.uuid, keyB = material.uuid;\r\n\r\n\t\t\tlet materialsForVariant = _materialCache[ keyA ];\r\n\r\n\t\t\tif ( materialsForVariant === undefined ) {\r\n\r\n\t\t\t\tmaterialsForVariant = {};\r\n\t\t\t\t_materialCache[ keyA ] = materialsForVariant;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tlet cachedMaterial = materialsForVariant[ keyB ];\r\n\r\n\t\t\tif ( cachedMaterial === undefined ) {\r\n\r\n\t\t\t\tcachedMaterial = result.clone();\r\n\t\t\t\tmaterialsForVariant[ keyB ] = cachedMaterial;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tresult = cachedMaterial;\r\n\r\n\t\t}\r\n\r\n\t\tresult.visible = material.visible;\r\n\t\tresult.wireframe = material.wireframe;\r\n\r\n\t\tif ( type === VSMShadowMap ) {\r\n\r\n\t\t\tresult.side = ( material.shadowSide !== null ) ? material.shadowSide : material.side;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tresult.side = ( material.shadowSide !== null ) ? material.shadowSide : shadowSide[ material.side ];\r\n\r\n\t\t}\r\n\r\n\t\tresult.alphaMap = material.alphaMap;\r\n\t\tresult.alphaTest = material.alphaTest;\r\n\r\n\t\tresult.clipShadows = material.clipShadows;\r\n\t\tresult.clippingPlanes = material.clippingPlanes;\r\n\t\tresult.clipIntersection = material.clipIntersection;\r\n\r\n\t\tresult.displacementMap = material.displacementMap;\r\n\t\tresult.displacementScale = material.displacementScale;\r\n\t\tresult.displacementBias = material.displacementBias;\r\n\r\n\t\tresult.wireframeLinewidth = material.wireframeLinewidth;\r\n\t\tresult.linewidth = material.linewidth;\r\n\r\n\t\tif ( light.isPointLight === true && result.isMeshDistanceMaterial === true ) {\r\n\r\n\t\t\tresult.referencePosition.setFromMatrixPosition( light.matrixWorld );\r\n\t\t\tresult.nearDistance = shadowCameraNear;\r\n\t\t\tresult.farDistance = shadowCameraFar;\r\n\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n\tfunction renderObject( object, camera, shadowCamera, light, type ) {\r\n\r\n\t\tif ( object.visible === false ) return;\r\n\r\n\t\tconst visible = object.layers.test( camera.layers );\r\n\r\n\t\tif ( visible && ( object.isMesh || object.isLine || object.isPoints ) ) {\r\n\r\n\t\t\tif ( ( object.castShadow || ( object.receiveShadow && type === VSMShadowMap ) ) && ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) ) {\r\n\r\n\t\t\t\tobject.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );\r\n\r\n\t\t\t\tconst geometry = _objects.update( object );\r\n\t\t\t\tconst material = object.material;\r\n\r\n\t\t\t\tif ( Array.isArray( material ) ) {\r\n\r\n\t\t\t\t\tconst groups = geometry.groups;\r\n\r\n\t\t\t\t\tfor ( let k = 0, kl = groups.length; k < kl; k ++ ) {\r\n\r\n\t\t\t\t\t\tconst group = groups[ k ];\r\n\t\t\t\t\t\tconst groupMaterial = material[ group.materialIndex ];\r\n\r\n\t\t\t\t\t\tif ( groupMaterial && groupMaterial.visible ) {\r\n\r\n\t\t\t\t\t\t\tconst depthMaterial = getDepthMaterial( object, groupMaterial, light, shadowCamera.near, shadowCamera.far, type );\r\n\r\n\t\t\t\t\t\t\t_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else if ( material.visible ) {\r\n\r\n\t\t\t\t\tconst depthMaterial = getDepthMaterial( object, material, light, shadowCamera.near, shadowCamera.far, type );\r\n\r\n\t\t\t\t\t_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tconst children = object.children;\r\n\r\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\r\n\r\n\t\t\trenderObject( children[ i ], camera, shadowCamera, light, type );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\nexport { WebGLShadowMap };\r\n"]},"metadata":{},"sourceType":"module"}