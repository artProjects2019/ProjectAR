{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nimport { Cache } from './Cache.js';\nimport { Loader } from './Loader.js';\nconst loading = {};\n\nclass FileLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    if (url === undefined) url = '';\n    if (this.path !== undefined) url = this.path + url;\n    url = this.manager.resolveURL(url);\n    const cached = Cache.get(url);\n\n    if (cached !== undefined) {\n      this.manager.itemStart(url);\n      setTimeout(() => {\n        if (onLoad) onLoad(cached);\n        this.manager.itemEnd(url);\n      }, 0);\n      return cached;\n    } // Check if request is duplicate\n\n\n    if (loading[url] !== undefined) {\n      loading[url].push({\n        onLoad: onLoad,\n        onProgress: onProgress,\n        onError: onError\n      });\n      return;\n    } // Initialise array for duplicate requests\n\n\n    loading[url] = [];\n    loading[url].push({\n      onLoad: onLoad,\n      onProgress: onProgress,\n      onError: onError\n    }); // create request\n\n    const req = new Request(url, {\n      headers: new Headers(this.requestHeader),\n      credentials: this.withCredentials ? 'include' : 'same-origin' // An abort controller could be added within a future PR\n\n    }); // record states ( avoid data race )\n\n    const mimeType = this.mimeType;\n    const responseType = this.responseType; // start the fetch\n\n    fetch(req).then(response => {\n      if (response.status === 200 || response.status === 0) {\n        // Some browsers return HTTP Status 0 when using non-http protocol\n        // e.g. 'file://' or 'data://'. Handle as success.\n        if (response.status === 0) {\n          console.warn('THREE.FileLoader: HTTP Status 0 received.');\n        } // Workaround: Checking if response.body === undefined for Alipay browser #23548\n\n\n        if (typeof ReadableStream === 'undefined' || response.body === undefined || response.body.getReader === undefined) {\n          return response;\n        }\n\n        const callbacks = loading[url];\n        const reader = response.body.getReader();\n        const contentLength = response.headers.get('Content-Length');\n        const total = contentLength ? parseInt(contentLength) : 0;\n        const lengthComputable = total !== 0;\n        let loaded = 0; // periodically read data into the new stream tracking while download progress\n\n        const stream = new ReadableStream({\n          start(controller) {\n            readData();\n\n            function readData() {\n              reader.read().then(({\n                done,\n                value\n              }) => {\n                if (done) {\n                  controller.close();\n                } else {\n                  loaded += value.byteLength;\n                  const event = new ProgressEvent('progress', {\n                    lengthComputable,\n                    loaded,\n                    total\n                  });\n\n                  for (let i = 0, il = callbacks.length; i < il; i++) {\n                    const callback = callbacks[i];\n                    if (callback.onProgress) callback.onProgress(event);\n                  }\n\n                  controller.enqueue(value);\n                  readData();\n                }\n              });\n            }\n          }\n\n        });\n        return new Response(stream);\n      } else {\n        throw Error(`fetch for \"${response.url}\" responded with ${response.status}: ${response.statusText}`);\n      }\n    }).then(response => {\n      switch (responseType) {\n        case 'arraybuffer':\n          return response.arrayBuffer();\n\n        case 'blob':\n          return response.blob();\n\n        case 'document':\n          return response.text().then(text => {\n            const parser = new DOMParser();\n            return parser.parseFromString(text, mimeType);\n          });\n\n        case 'json':\n          return response.json();\n\n        default:\n          if (mimeType === undefined) {\n            return response.text();\n          } else {\n            // sniff encoding\n            const re = /charset=\"?([^;\"\\s]*)\"?/i;\n            const exec = re.exec(mimeType);\n            const label = exec && exec[1] ? exec[1].toLowerCase() : undefined;\n            const decoder = new TextDecoder(label);\n            return response.arrayBuffer().then(ab => decoder.decode(ab));\n          }\n\n      }\n    }).then(data => {\n      // Add to cache only on HTTP success, so that we do not cache\n      // error response bodies as proper responses to requests.\n      Cache.add(url, data);\n      const callbacks = loading[url];\n      delete loading[url];\n\n      for (let i = 0, il = callbacks.length; i < il; i++) {\n        const callback = callbacks[i];\n        if (callback.onLoad) callback.onLoad(data);\n      }\n    }).catch(err => {\n      // Abort errors and other errors are handled the same\n      const callbacks = loading[url];\n\n      if (callbacks === undefined) {\n        // When onLoad was called and url was deleted in `loading`\n        this.manager.itemError(url);\n        throw err;\n      }\n\n      delete loading[url];\n\n      for (let i = 0, il = callbacks.length; i < il; i++) {\n        const callback = callbacks[i];\n        if (callback.onError) callback.onError(err);\n      }\n\n      this.manager.itemError(url);\n    }).finally(() => {\n      this.manager.itemEnd(url);\n    });\n    this.manager.itemStart(url);\n  }\n\n  setResponseType(value) {\n    this.responseType = value;\n    return this;\n  }\n\n  setMimeType(value) {\n    this.mimeType = value;\n    return this;\n  }\n\n}\n\nexport { FileLoader };","map":{"version":3,"sources":["C:/Users/dell/Desktop/projektlogin/vue-3-authentication-jwt/src/games/three/src/loaders/FileLoader.js"],"names":["Cache","Loader","loading","FileLoader","constructor","manager","load","url","onLoad","onProgress","onError","undefined","path","resolveURL","cached","get","itemStart","setTimeout","itemEnd","push","req","Request","headers","Headers","requestHeader","credentials","withCredentials","mimeType","responseType","fetch","then","response","status","console","warn","ReadableStream","body","getReader","callbacks","reader","contentLength","total","parseInt","lengthComputable","loaded","stream","start","controller","readData","read","done","value","close","byteLength","event","ProgressEvent","i","il","length","callback","enqueue","Response","Error","statusText","arrayBuffer","blob","text","parser","DOMParser","parseFromString","json","re","exec","label","toLowerCase","decoder","TextDecoder","ab","decode","data","add","catch","err","itemError","finally","setResponseType","setMimeType"],"mappings":"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","sourcesContent":["import { Cache } from './Cache.js';\r\nimport { Loader } from './Loader.js';\r\n\r\nconst loading = {};\r\n\r\nclass FileLoader extends Loader {\r\n\r\n\tconstructor( manager ) {\r\n\r\n\t\tsuper( manager );\r\n\r\n\t}\r\n\r\n\tload( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tif ( url === undefined ) url = '';\r\n\r\n\t\tif ( this.path !== undefined ) url = this.path + url;\r\n\r\n\t\turl = this.manager.resolveURL( url );\r\n\r\n\t\tconst cached = Cache.get( url );\r\n\r\n\t\tif ( cached !== undefined ) {\r\n\r\n\t\t\tthis.manager.itemStart( url );\r\n\r\n\t\t\tsetTimeout( () => {\r\n\r\n\t\t\t\tif ( onLoad ) onLoad( cached );\r\n\r\n\t\t\t\tthis.manager.itemEnd( url );\r\n\r\n\t\t\t}, 0 );\r\n\r\n\t\t\treturn cached;\r\n\r\n\t\t}\r\n\r\n\t\t// Check if request is duplicate\r\n\r\n\t\tif ( loading[ url ] !== undefined ) {\r\n\r\n\t\t\tloading[ url ].push( {\r\n\r\n\t\t\t\tonLoad: onLoad,\r\n\t\t\t\tonProgress: onProgress,\r\n\t\t\t\tonError: onError\r\n\r\n\t\t\t} );\r\n\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\t// Initialise array for duplicate requests\r\n\t\tloading[ url ] = [];\r\n\r\n\t\tloading[ url ].push( {\r\n\t\t\tonLoad: onLoad,\r\n\t\t\tonProgress: onProgress,\r\n\t\t\tonError: onError,\r\n\t\t} );\r\n\r\n\t\t// create request\r\n\t\tconst req = new Request( url, {\r\n\t\t\theaders: new Headers( this.requestHeader ),\r\n\t\t\tcredentials: this.withCredentials ? 'include' : 'same-origin',\r\n\t\t\t// An abort controller could be added within a future PR\r\n\t\t} );\r\n\r\n\t\t// record states ( avoid data race )\r\n\t\tconst mimeType = this.mimeType;\r\n\t\tconst responseType = this.responseType;\r\n\r\n\t\t// start the fetch\r\n\t\tfetch( req )\r\n\t\t\t.then( response => {\r\n\r\n\t\t\t\tif ( response.status === 200 || response.status === 0 ) {\r\n\r\n\t\t\t\t\t// Some browsers return HTTP Status 0 when using non-http protocol\r\n\t\t\t\t\t// e.g. 'file://' or 'data://'. Handle as success.\r\n\r\n\t\t\t\t\tif ( response.status === 0 ) {\r\n\r\n\t\t\t\t\t\tconsole.warn( 'THREE.FileLoader: HTTP Status 0 received.' );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Workaround: Checking if response.body === undefined for Alipay browser #23548\r\n\r\n\t\t\t\t\tif ( typeof ReadableStream === 'undefined' || response.body === undefined || response.body.getReader === undefined ) {\r\n\r\n\t\t\t\t\t\treturn response;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tconst callbacks = loading[ url ];\r\n\t\t\t\t\tconst reader = response.body.getReader();\r\n\t\t\t\t\tconst contentLength = response.headers.get( 'Content-Length' );\r\n\t\t\t\t\tconst total = contentLength ? parseInt( contentLength ) : 0;\r\n\t\t\t\t\tconst lengthComputable = total !== 0;\r\n\t\t\t\t\tlet loaded = 0;\r\n\r\n\t\t\t\t\t// periodically read data into the new stream tracking while download progress\r\n\t\t\t\t\tconst stream = new ReadableStream( {\r\n\t\t\t\t\t\tstart( controller ) {\r\n\r\n\t\t\t\t\t\t\treadData();\r\n\r\n\t\t\t\t\t\t\tfunction readData() {\r\n\r\n\t\t\t\t\t\t\t\treader.read().then( ( { done, value } ) => {\r\n\r\n\t\t\t\t\t\t\t\t\tif ( done ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\tcontroller.close();\r\n\r\n\t\t\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\t\t\tloaded += value.byteLength;\r\n\r\n\t\t\t\t\t\t\t\t\t\tconst event = new ProgressEvent( 'progress', { lengthComputable, loaded, total } );\r\n\t\t\t\t\t\t\t\t\t\tfor ( let i = 0, il = callbacks.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tconst callback = callbacks[ i ];\r\n\t\t\t\t\t\t\t\t\t\t\tif ( callback.onProgress ) callback.onProgress( event );\r\n\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\tcontroller.enqueue( value );\r\n\t\t\t\t\t\t\t\t\t\treadData();\r\n\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t} );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} );\r\n\r\n\t\t\t\t\treturn new Response( stream );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tthrow Error( `fetch for \"${response.url}\" responded with ${response.status}: ${response.statusText}` );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} )\r\n\t\t\t.then( response => {\r\n\r\n\t\t\t\tswitch ( responseType ) {\r\n\r\n\t\t\t\t\tcase 'arraybuffer':\r\n\r\n\t\t\t\t\t\treturn response.arrayBuffer();\r\n\r\n\t\t\t\t\tcase 'blob':\r\n\r\n\t\t\t\t\t\treturn response.blob();\r\n\r\n\t\t\t\t\tcase 'document':\r\n\r\n\t\t\t\t\t\treturn response.text()\r\n\t\t\t\t\t\t\t.then( text => {\r\n\r\n\t\t\t\t\t\t\t\tconst parser = new DOMParser();\r\n\t\t\t\t\t\t\t\treturn parser.parseFromString( text, mimeType );\r\n\r\n\t\t\t\t\t\t\t} );\r\n\r\n\t\t\t\t\tcase 'json':\r\n\r\n\t\t\t\t\t\treturn response.json();\r\n\r\n\t\t\t\t\tdefault:\r\n\r\n\t\t\t\t\t\tif ( mimeType === undefined ) {\r\n\r\n\t\t\t\t\t\t\treturn response.text();\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t// sniff encoding\r\n\t\t\t\t\t\t\tconst re = /charset=\"?([^;\"\\s]*)\"?/i;\r\n\t\t\t\t\t\t\tconst exec = re.exec( mimeType );\r\n\t\t\t\t\t\t\tconst label = exec && exec[ 1 ] ? exec[ 1 ].toLowerCase() : undefined;\r\n\t\t\t\t\t\t\tconst decoder = new TextDecoder( label );\r\n\t\t\t\t\t\t\treturn response.arrayBuffer().then( ab => decoder.decode( ab ) );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} )\r\n\t\t\t.then( data => {\r\n\r\n\t\t\t\t// Add to cache only on HTTP success, so that we do not cache\r\n\t\t\t\t// error response bodies as proper responses to requests.\r\n\t\t\t\tCache.add( url, data );\r\n\r\n\t\t\t\tconst callbacks = loading[ url ];\r\n\t\t\t\tdelete loading[ url ];\r\n\r\n\t\t\t\tfor ( let i = 0, il = callbacks.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tconst callback = callbacks[ i ];\r\n\t\t\t\t\tif ( callback.onLoad ) callback.onLoad( data );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} )\r\n\t\t\t.catch( err => {\r\n\r\n\t\t\t\t// Abort errors and other errors are handled the same\r\n\r\n\t\t\t\tconst callbacks = loading[ url ];\r\n\r\n\t\t\t\tif ( callbacks === undefined ) {\r\n\r\n\t\t\t\t\t// When onLoad was called and url was deleted in `loading`\r\n\t\t\t\t\tthis.manager.itemError( url );\r\n\t\t\t\t\tthrow err;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tdelete loading[ url ];\r\n\r\n\t\t\t\tfor ( let i = 0, il = callbacks.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tconst callback = callbacks[ i ];\r\n\t\t\t\t\tif ( callback.onError ) callback.onError( err );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.manager.itemError( url );\r\n\r\n\t\t\t} )\r\n\t\t\t.finally( () => {\r\n\r\n\t\t\t\tthis.manager.itemEnd( url );\r\n\r\n\t\t\t} );\r\n\r\n\t\tthis.manager.itemStart( url );\r\n\r\n\t}\r\n\r\n\tsetResponseType( value ) {\r\n\r\n\t\tthis.responseType = value;\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tsetMimeType( value ) {\r\n\r\n\t\tthis.mimeType = value;\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\nexport { FileLoader };\r\n"]},"metadata":{},"sourceType":"module"}