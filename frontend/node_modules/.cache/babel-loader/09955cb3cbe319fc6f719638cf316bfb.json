{"ast":null,"code":"import { Sphere } from '../math/Sphere.js';\nimport { Ray } from '../math/Ray.js';\nimport { Matrix4 } from '../math/Matrix4.js';\nimport { Object3D } from '../core/Object3D.js';\nimport { Vector3 } from '../math/Vector3.js';\nimport { PointsMaterial } from '../materials/PointsMaterial.js';\nimport { BufferGeometry } from '../core/BufferGeometry.js';\n\nconst _inverseMatrix = /*@__PURE__*/new Matrix4();\n\nconst _ray = /*@__PURE__*/new Ray();\n\nconst _sphere = /*@__PURE__*/new Sphere();\n\nconst _position = /*@__PURE__*/new Vector3();\n\nclass Points extends Object3D {\n  constructor(geometry = new BufferGeometry(), material = new PointsMaterial()) {\n    super();\n    this.type = 'Points';\n    this.geometry = geometry;\n    this.material = material;\n    this.updateMorphTargets();\n  }\n\n  copy(source) {\n    super.copy(source);\n    this.material = source.material;\n    this.geometry = source.geometry;\n    return this;\n  }\n\n  raycast(raycaster, intersects) {\n    const geometry = this.geometry;\n    const matrixWorld = this.matrixWorld;\n    const threshold = raycaster.params.Points.threshold;\n    const drawRange = geometry.drawRange; // Checking boundingSphere distance to ray\n\n    if (geometry.boundingSphere === null) geometry.computeBoundingSphere();\n\n    _sphere.copy(geometry.boundingSphere);\n\n    _sphere.applyMatrix4(matrixWorld);\n\n    _sphere.radius += threshold;\n    if (raycaster.ray.intersectsSphere(_sphere) === false) return; //\n\n    _inverseMatrix.copy(matrixWorld).invert();\n\n    _ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix);\n\n    const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);\n    const localThresholdSq = localThreshold * localThreshold;\n\n    if (geometry.isBufferGeometry) {\n      const index = geometry.index;\n      const attributes = geometry.attributes;\n      const positionAttribute = attributes.position;\n\n      if (index !== null) {\n        const start = Math.max(0, drawRange.start);\n        const end = Math.min(index.count, drawRange.start + drawRange.count);\n\n        for (let i = start, il = end; i < il; i++) {\n          const a = index.getX(i);\n\n          _position.fromBufferAttribute(positionAttribute, a);\n\n          testPoint(_position, a, localThresholdSq, matrixWorld, raycaster, intersects, this);\n        }\n      } else {\n        const start = Math.max(0, drawRange.start);\n        const end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);\n\n        for (let i = start, l = end; i < l; i++) {\n          _position.fromBufferAttribute(positionAttribute, i);\n\n          testPoint(_position, i, localThresholdSq, matrixWorld, raycaster, intersects, this);\n        }\n      }\n    } else {\n      console.error('THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');\n    }\n  }\n\n  updateMorphTargets() {\n    const geometry = this.geometry;\n\n    if (geometry.isBufferGeometry) {\n      const morphAttributes = geometry.morphAttributes;\n      const keys = Object.keys(morphAttributes);\n\n      if (keys.length > 0) {\n        const morphAttribute = morphAttributes[keys[0]];\n\n        if (morphAttribute !== undefined) {\n          this.morphTargetInfluences = [];\n          this.morphTargetDictionary = {};\n\n          for (let m = 0, ml = morphAttribute.length; m < ml; m++) {\n            const name = morphAttribute[m].name || String(m);\n            this.morphTargetInfluences.push(0);\n            this.morphTargetDictionary[name] = m;\n          }\n        }\n      }\n    } else {\n      const morphTargets = geometry.morphTargets;\n\n      if (morphTargets !== undefined && morphTargets.length > 0) {\n        console.error('THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.');\n      }\n    }\n  }\n\n}\n\nPoints.prototype.isPoints = true;\n\nfunction testPoint(point, index, localThresholdSq, matrixWorld, raycaster, intersects, object) {\n  const rayPointDistanceSq = _ray.distanceSqToPoint(point);\n\n  if (rayPointDistanceSq < localThresholdSq) {\n    const intersectPoint = new Vector3();\n\n    _ray.closestPointToPoint(point, intersectPoint);\n\n    intersectPoint.applyMatrix4(matrixWorld);\n    const distance = raycaster.ray.origin.distanceTo(intersectPoint);\n    if (distance < raycaster.near || distance > raycaster.far) return;\n    intersects.push({\n      distance: distance,\n      distanceToRay: Math.sqrt(rayPointDistanceSq),\n      point: intersectPoint,\n      index: index,\n      face: null,\n      object: object\n    });\n  }\n}\n\nexport { Points };","map":{"version":3,"sources":["C:/Users/dell/Desktop/projektlogin/vue-3-authentication-jwt/src/games/three/src/objects/Points.js"],"names":["Sphere","Ray","Matrix4","Object3D","Vector3","PointsMaterial","BufferGeometry","_inverseMatrix","_ray","_sphere","_position","Points","constructor","geometry","material","type","updateMorphTargets","copy","source","raycast","raycaster","intersects","matrixWorld","threshold","params","drawRange","boundingSphere","computeBoundingSphere","applyMatrix4","radius","ray","intersectsSphere","invert","localThreshold","scale","x","y","z","localThresholdSq","isBufferGeometry","index","attributes","positionAttribute","position","start","Math","max","end","min","count","i","il","a","getX","fromBufferAttribute","testPoint","l","console","error","morphAttributes","keys","Object","length","morphAttribute","undefined","morphTargetInfluences","morphTargetDictionary","m","ml","name","String","push","morphTargets","prototype","isPoints","point","object","rayPointDistanceSq","distanceSqToPoint","intersectPoint","closestPointToPoint","distance","origin","distanceTo","near","far","distanceToRay","sqrt","face"],"mappings":"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","sourcesContent":["import { Sphere } from '../math/Sphere.js';\r\nimport { Ray } from '../math/Ray.js';\r\nimport { Matrix4 } from '../math/Matrix4.js';\r\nimport { Object3D } from '../core/Object3D.js';\r\nimport { Vector3 } from '../math/Vector3.js';\r\nimport { PointsMaterial } from '../materials/PointsMaterial.js';\r\nimport { BufferGeometry } from '../core/BufferGeometry.js';\r\n\r\nconst _inverseMatrix = /*@__PURE__*/ new Matrix4();\r\nconst _ray = /*@__PURE__*/ new Ray();\r\nconst _sphere = /*@__PURE__*/ new Sphere();\r\nconst _position = /*@__PURE__*/ new Vector3();\r\n\r\nclass Points extends Object3D {\r\n\r\n\tconstructor( geometry = new BufferGeometry(), material = new PointsMaterial() ) {\r\n\r\n\t\tsuper();\r\n\r\n\t\tthis.type = 'Points';\r\n\r\n\t\tthis.geometry = geometry;\r\n\t\tthis.material = material;\r\n\r\n\t\tthis.updateMorphTargets();\r\n\r\n\t}\r\n\r\n\tcopy( source ) {\r\n\r\n\t\tsuper.copy( source );\r\n\r\n\t\tthis.material = source.material;\r\n\t\tthis.geometry = source.geometry;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\traycast( raycaster, intersects ) {\r\n\r\n\t\tconst geometry = this.geometry;\r\n\t\tconst matrixWorld = this.matrixWorld;\r\n\t\tconst threshold = raycaster.params.Points.threshold;\r\n\t\tconst drawRange = geometry.drawRange;\r\n\r\n\t\t// Checking boundingSphere distance to ray\r\n\r\n\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\r\n\r\n\t\t_sphere.copy( geometry.boundingSphere );\r\n\t\t_sphere.applyMatrix4( matrixWorld );\r\n\t\t_sphere.radius += threshold;\r\n\r\n\t\tif ( raycaster.ray.intersectsSphere( _sphere ) === false ) return;\r\n\r\n\t\t//\r\n\r\n\t\t_inverseMatrix.copy( matrixWorld ).invert();\r\n\t\t_ray.copy( raycaster.ray ).applyMatrix4( _inverseMatrix );\r\n\r\n\t\tconst localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );\r\n\t\tconst localThresholdSq = localThreshold * localThreshold;\r\n\r\n\t\tif ( geometry.isBufferGeometry ) {\r\n\r\n\t\t\tconst index = geometry.index;\r\n\t\t\tconst attributes = geometry.attributes;\r\n\t\t\tconst positionAttribute = attributes.position;\r\n\r\n\t\t\tif ( index !== null ) {\r\n\r\n\t\t\t\tconst start = Math.max( 0, drawRange.start );\r\n\t\t\t\tconst end = Math.min( index.count, ( drawRange.start + drawRange.count ) );\r\n\r\n\t\t\t\tfor ( let i = start, il = end; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tconst a = index.getX( i );\r\n\r\n\t\t\t\t\t_position.fromBufferAttribute( positionAttribute, a );\r\n\r\n\t\t\t\t\ttestPoint( _position, a, localThresholdSq, matrixWorld, raycaster, intersects, this );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tconst start = Math.max( 0, drawRange.start );\r\n\t\t\t\tconst end = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );\r\n\r\n\t\t\t\tfor ( let i = start, l = end; i < l; i ++ ) {\r\n\r\n\t\t\t\t\t_position.fromBufferAttribute( positionAttribute, i );\r\n\r\n\t\t\t\t\ttestPoint( _position, i, localThresholdSq, matrixWorld, raycaster, intersects, this );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tconsole.error( 'THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tupdateMorphTargets() {\r\n\r\n\t\tconst geometry = this.geometry;\r\n\r\n\t\tif ( geometry.isBufferGeometry ) {\r\n\r\n\t\t\tconst morphAttributes = geometry.morphAttributes;\r\n\t\t\tconst keys = Object.keys( morphAttributes );\r\n\r\n\t\t\tif ( keys.length > 0 ) {\r\n\r\n\t\t\t\tconst morphAttribute = morphAttributes[ keys[ 0 ] ];\r\n\r\n\t\t\t\tif ( morphAttribute !== undefined ) {\r\n\r\n\t\t\t\t\tthis.morphTargetInfluences = [];\r\n\t\t\t\t\tthis.morphTargetDictionary = {};\r\n\r\n\t\t\t\t\tfor ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {\r\n\r\n\t\t\t\t\t\tconst name = morphAttribute[ m ].name || String( m );\r\n\r\n\t\t\t\t\t\tthis.morphTargetInfluences.push( 0 );\r\n\t\t\t\t\t\tthis.morphTargetDictionary[ name ] = m;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tconst morphTargets = geometry.morphTargets;\r\n\r\n\t\t\tif ( morphTargets !== undefined && morphTargets.length > 0 ) {\r\n\r\n\t\t\t\tconsole.error( 'THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nPoints.prototype.isPoints = true;\r\n\r\nfunction testPoint( point, index, localThresholdSq, matrixWorld, raycaster, intersects, object ) {\r\n\r\n\tconst rayPointDistanceSq = _ray.distanceSqToPoint( point );\r\n\r\n\tif ( rayPointDistanceSq < localThresholdSq ) {\r\n\r\n\t\tconst intersectPoint = new Vector3();\r\n\r\n\t\t_ray.closestPointToPoint( point, intersectPoint );\r\n\t\tintersectPoint.applyMatrix4( matrixWorld );\r\n\r\n\t\tconst distance = raycaster.ray.origin.distanceTo( intersectPoint );\r\n\r\n\t\tif ( distance < raycaster.near || distance > raycaster.far ) return;\r\n\r\n\t\tintersects.push( {\r\n\r\n\t\t\tdistance: distance,\r\n\t\t\tdistanceToRay: Math.sqrt( rayPointDistanceSq ),\r\n\t\t\tpoint: intersectPoint,\r\n\t\t\tindex: index,\r\n\t\t\tface: null,\r\n\t\t\tobject: object\r\n\r\n\t\t} );\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport { Points };\r\n"]},"metadata":{},"sourceType":"module"}