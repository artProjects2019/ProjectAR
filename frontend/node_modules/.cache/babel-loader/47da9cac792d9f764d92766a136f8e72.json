{"ast":null,"code":"import { PropertyBinding } from './PropertyBinding.js';\nimport * as MathUtils from '../math/MathUtils.js';\n/**\r\n *\r\n * A group of objects that receives a shared animation state.\r\n *\r\n * Usage:\r\n *\r\n *  - Add objects you would otherwise pass as 'root' to the\r\n *    constructor or the .clipAction method of AnimationMixer.\r\n *\r\n *  - Instead pass this object as 'root'.\r\n *\r\n *  - You can also add and remove objects later when the mixer\r\n *    is running.\r\n *\r\n * Note:\r\n *\r\n *    Objects of this class appear as one object to the mixer,\r\n *    so cache control of the individual objects must be done\r\n *    on the group.\r\n *\r\n * Limitation:\r\n *\r\n *  - The animated properties must be compatible among the\r\n *    all objects in the group.\r\n *\r\n *  - A single property can either be controlled through a\r\n *    target group or directly, but not both.\r\n */\n\nclass AnimationObjectGroup {\n  constructor() {\n    this.uuid = MathUtils.generateUUID(); // cached objects followed by the active ones\n\n    this._objects = Array.prototype.slice.call(arguments);\n    this.nCachedObjects_ = 0; // threshold\n    // note: read by PropertyBinding.Composite\n\n    const indices = {};\n    this._indicesByUUID = indices; // for bookkeeping\n\n    for (let i = 0, n = arguments.length; i !== n; ++i) {\n      indices[arguments[i].uuid] = i;\n    }\n\n    this._paths = []; // inside: string\n\n    this._parsedPaths = []; // inside: { we don't care, here }\n\n    this._bindings = []; // inside: Array< PropertyBinding >\n\n    this._bindingsIndicesByPath = {}; // inside: indices in these arrays\n\n    const scope = this;\n    this.stats = {\n      objects: {\n        get total() {\n          return scope._objects.length;\n        },\n\n        get inUse() {\n          return this.total - scope.nCachedObjects_;\n        }\n\n      },\n\n      get bindingsPerObject() {\n        return scope._bindings.length;\n      }\n\n    };\n  }\n\n  add() {\n    const objects = this._objects,\n          indicesByUUID = this._indicesByUUID,\n          paths = this._paths,\n          parsedPaths = this._parsedPaths,\n          bindings = this._bindings,\n          nBindings = bindings.length;\n    let knownObject = undefined,\n        nObjects = objects.length,\n        nCachedObjects = this.nCachedObjects_;\n\n    for (let i = 0, n = arguments.length; i !== n; ++i) {\n      const object = arguments[i],\n            uuid = object.uuid;\n      let index = indicesByUUID[uuid];\n\n      if (index === undefined) {\n        // unknown object -> add it to the ACTIVE region\n        index = nObjects++;\n        indicesByUUID[uuid] = index;\n        objects.push(object); // accounting is done, now do the same for all bindings\n\n        for (let j = 0, m = nBindings; j !== m; ++j) {\n          bindings[j].push(new PropertyBinding(object, paths[j], parsedPaths[j]));\n        }\n      } else if (index < nCachedObjects) {\n        knownObject = objects[index]; // move existing object to the ACTIVE region\n\n        const firstActiveIndex = --nCachedObjects,\n              lastCachedObject = objects[firstActiveIndex];\n        indicesByUUID[lastCachedObject.uuid] = index;\n        objects[index] = lastCachedObject;\n        indicesByUUID[uuid] = firstActiveIndex;\n        objects[firstActiveIndex] = object; // accounting is done, now do the same for all bindings\n\n        for (let j = 0, m = nBindings; j !== m; ++j) {\n          const bindingsForPath = bindings[j],\n                lastCached = bindingsForPath[firstActiveIndex];\n          let binding = bindingsForPath[index];\n          bindingsForPath[index] = lastCached;\n\n          if (binding === undefined) {\n            // since we do not bother to create new bindings\n            // for objects that are cached, the binding may\n            // or may not exist\n            binding = new PropertyBinding(object, paths[j], parsedPaths[j]);\n          }\n\n          bindingsForPath[firstActiveIndex] = binding;\n        }\n      } else if (objects[index] !== knownObject) {\n        console.error('THREE.AnimationObjectGroup: Different objects with the same UUID ' + 'detected. Clean the caches or recreate your infrastructure when reloading scenes.');\n      } // else the object is already where we want it to be\n\n    } // for arguments\n\n\n    this.nCachedObjects_ = nCachedObjects;\n  }\n\n  remove() {\n    const objects = this._objects,\n          indicesByUUID = this._indicesByUUID,\n          bindings = this._bindings,\n          nBindings = bindings.length;\n    let nCachedObjects = this.nCachedObjects_;\n\n    for (let i = 0, n = arguments.length; i !== n; ++i) {\n      const object = arguments[i],\n            uuid = object.uuid,\n            index = indicesByUUID[uuid];\n\n      if (index !== undefined && index >= nCachedObjects) {\n        // move existing object into the CACHED region\n        const lastCachedIndex = nCachedObjects++,\n              firstActiveObject = objects[lastCachedIndex];\n        indicesByUUID[firstActiveObject.uuid] = index;\n        objects[index] = firstActiveObject;\n        indicesByUUID[uuid] = lastCachedIndex;\n        objects[lastCachedIndex] = object; // accounting is done, now do the same for all bindings\n\n        for (let j = 0, m = nBindings; j !== m; ++j) {\n          const bindingsForPath = bindings[j],\n                firstActive = bindingsForPath[lastCachedIndex],\n                binding = bindingsForPath[index];\n          bindingsForPath[index] = firstActive;\n          bindingsForPath[lastCachedIndex] = binding;\n        }\n      }\n    } // for arguments\n\n\n    this.nCachedObjects_ = nCachedObjects;\n  } // remove & forget\n\n\n  uncache() {\n    const objects = this._objects,\n          indicesByUUID = this._indicesByUUID,\n          bindings = this._bindings,\n          nBindings = bindings.length;\n    let nCachedObjects = this.nCachedObjects_,\n        nObjects = objects.length;\n\n    for (let i = 0, n = arguments.length; i !== n; ++i) {\n      const object = arguments[i],\n            uuid = object.uuid,\n            index = indicesByUUID[uuid];\n\n      if (index !== undefined) {\n        delete indicesByUUID[uuid];\n\n        if (index < nCachedObjects) {\n          // object is cached, shrink the CACHED region\n          const firstActiveIndex = --nCachedObjects,\n                lastCachedObject = objects[firstActiveIndex],\n                lastIndex = --nObjects,\n                lastObject = objects[lastIndex]; // last cached object takes this object's place\n\n          indicesByUUID[lastCachedObject.uuid] = index;\n          objects[index] = lastCachedObject; // last object goes to the activated slot and pop\n\n          indicesByUUID[lastObject.uuid] = firstActiveIndex;\n          objects[firstActiveIndex] = lastObject;\n          objects.pop(); // accounting is done, now do the same for all bindings\n\n          for (let j = 0, m = nBindings; j !== m; ++j) {\n            const bindingsForPath = bindings[j],\n                  lastCached = bindingsForPath[firstActiveIndex],\n                  last = bindingsForPath[lastIndex];\n            bindingsForPath[index] = lastCached;\n            bindingsForPath[firstActiveIndex] = last;\n            bindingsForPath.pop();\n          }\n        } else {\n          // object is active, just swap with the last and pop\n          const lastIndex = --nObjects,\n                lastObject = objects[lastIndex];\n\n          if (lastIndex > 0) {\n            indicesByUUID[lastObject.uuid] = index;\n          }\n\n          objects[index] = lastObject;\n          objects.pop(); // accounting is done, now do the same for all bindings\n\n          for (let j = 0, m = nBindings; j !== m; ++j) {\n            const bindingsForPath = bindings[j];\n            bindingsForPath[index] = bindingsForPath[lastIndex];\n            bindingsForPath.pop();\n          }\n        } // cached or active\n\n      } // if object is known\n\n    } // for arguments\n\n\n    this.nCachedObjects_ = nCachedObjects;\n  } // Internal interface used by befriended PropertyBinding.Composite:\n\n\n  subscribe_(path, parsedPath) {\n    // returns an array of bindings for the given path that is changed\n    // according to the contained objects in the group\n    const indicesByPath = this._bindingsIndicesByPath;\n    let index = indicesByPath[path];\n    const bindings = this._bindings;\n    if (index !== undefined) return bindings[index];\n    const paths = this._paths,\n          parsedPaths = this._parsedPaths,\n          objects = this._objects,\n          nObjects = objects.length,\n          nCachedObjects = this.nCachedObjects_,\n          bindingsForPath = new Array(nObjects);\n    index = bindings.length;\n    indicesByPath[path] = index;\n    paths.push(path);\n    parsedPaths.push(parsedPath);\n    bindings.push(bindingsForPath);\n\n    for (let i = nCachedObjects, n = objects.length; i !== n; ++i) {\n      const object = objects[i];\n      bindingsForPath[i] = new PropertyBinding(object, path, parsedPath);\n    }\n\n    return bindingsForPath;\n  }\n\n  unsubscribe_(path) {\n    // tells the group to forget about a property path and no longer\n    // update the array previously obtained with 'subscribe_'\n    const indicesByPath = this._bindingsIndicesByPath,\n          index = indicesByPath[path];\n\n    if (index !== undefined) {\n      const paths = this._paths,\n            parsedPaths = this._parsedPaths,\n            bindings = this._bindings,\n            lastBindingsIndex = bindings.length - 1,\n            lastBindings = bindings[lastBindingsIndex],\n            lastBindingsPath = path[lastBindingsIndex];\n      indicesByPath[lastBindingsPath] = index;\n      bindings[index] = lastBindings;\n      bindings.pop();\n      parsedPaths[index] = parsedPaths[lastBindingsIndex];\n      parsedPaths.pop();\n      paths[index] = paths[lastBindingsIndex];\n      paths.pop();\n    }\n  }\n\n}\n\nAnimationObjectGroup.prototype.isAnimationObjectGroup = true;\nexport { AnimationObjectGroup };","map":{"version":3,"sources":["C:/Users/dell/Desktop/projektlogin/vue-3-authentication-jwt/src/games/three/src/animation/AnimationObjectGroup.js"],"names":["PropertyBinding","MathUtils","AnimationObjectGroup","constructor","uuid","generateUUID","_objects","Array","prototype","slice","call","arguments","nCachedObjects_","indices","_indicesByUUID","i","n","length","_paths","_parsedPaths","_bindings","_bindingsIndicesByPath","scope","stats","objects","total","inUse","bindingsPerObject","add","indicesByUUID","paths","parsedPaths","bindings","nBindings","knownObject","undefined","nObjects","nCachedObjects","object","index","push","j","m","firstActiveIndex","lastCachedObject","bindingsForPath","lastCached","binding","console","error","remove","lastCachedIndex","firstActiveObject","firstActive","uncache","lastIndex","lastObject","pop","last","subscribe_","path","parsedPath","indicesByPath","unsubscribe_","lastBindingsIndex","lastBindings","lastBindingsPath","isAnimationObjectGroup"],"mappings":"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","sourcesContent":["import { PropertyBinding } from './PropertyBinding.js';\r\nimport * as MathUtils from '../math/MathUtils.js';\r\n\r\n/**\r\n *\r\n * A group of objects that receives a shared animation state.\r\n *\r\n * Usage:\r\n *\r\n *  - Add objects you would otherwise pass as 'root' to the\r\n *    constructor or the .clipAction method of AnimationMixer.\r\n *\r\n *  - Instead pass this object as 'root'.\r\n *\r\n *  - You can also add and remove objects later when the mixer\r\n *    is running.\r\n *\r\n * Note:\r\n *\r\n *    Objects of this class appear as one object to the mixer,\r\n *    so cache control of the individual objects must be done\r\n *    on the group.\r\n *\r\n * Limitation:\r\n *\r\n *  - The animated properties must be compatible among the\r\n *    all objects in the group.\r\n *\r\n *  - A single property can either be controlled through a\r\n *    target group or directly, but not both.\r\n */\r\n\r\nclass AnimationObjectGroup {\r\n\r\n\tconstructor() {\r\n\r\n\t\tthis.uuid = MathUtils.generateUUID();\r\n\r\n\t\t// cached objects followed by the active ones\r\n\t\tthis._objects = Array.prototype.slice.call( arguments );\r\n\r\n\t\tthis.nCachedObjects_ = 0; // threshold\r\n\t\t// note: read by PropertyBinding.Composite\r\n\r\n\t\tconst indices = {};\r\n\t\tthis._indicesByUUID = indices; // for bookkeeping\r\n\r\n\t\tfor ( let i = 0, n = arguments.length; i !== n; ++ i ) {\r\n\r\n\t\t\tindices[ arguments[ i ].uuid ] = i;\r\n\r\n\t\t}\r\n\r\n\t\tthis._paths = []; // inside: string\r\n\t\tthis._parsedPaths = []; // inside: { we don't care, here }\r\n\t\tthis._bindings = []; // inside: Array< PropertyBinding >\r\n\t\tthis._bindingsIndicesByPath = {}; // inside: indices in these arrays\r\n\r\n\t\tconst scope = this;\r\n\r\n\t\tthis.stats = {\r\n\r\n\t\t\tobjects: {\r\n\t\t\t\tget total() {\r\n\r\n\t\t\t\t\treturn scope._objects.length;\r\n\r\n\t\t\t\t},\r\n\t\t\t\tget inUse() {\r\n\r\n\t\t\t\t\treturn this.total - scope.nCachedObjects_;\r\n\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tget bindingsPerObject() {\r\n\r\n\t\t\t\treturn scope._bindings.length;\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t}\r\n\r\n\tadd() {\r\n\r\n\t\tconst objects = this._objects,\r\n\t\t\tindicesByUUID = this._indicesByUUID,\r\n\t\t\tpaths = this._paths,\r\n\t\t\tparsedPaths = this._parsedPaths,\r\n\t\t\tbindings = this._bindings,\r\n\t\t\tnBindings = bindings.length;\r\n\r\n\t\tlet knownObject = undefined,\r\n\t\t\tnObjects = objects.length,\r\n\t\t\tnCachedObjects = this.nCachedObjects_;\r\n\r\n\t\tfor ( let i = 0, n = arguments.length; i !== n; ++ i ) {\r\n\r\n\t\t\tconst object = arguments[ i ],\r\n\t\t\t\tuuid = object.uuid;\r\n\t\t\tlet index = indicesByUUID[ uuid ];\r\n\r\n\t\t\tif ( index === undefined ) {\r\n\r\n\t\t\t\t// unknown object -> add it to the ACTIVE region\r\n\r\n\t\t\t\tindex = nObjects ++;\r\n\t\t\t\tindicesByUUID[ uuid ] = index;\r\n\t\t\t\tobjects.push( object );\r\n\r\n\t\t\t\t// accounting is done, now do the same for all bindings\r\n\r\n\t\t\t\tfor ( let j = 0, m = nBindings; j !== m; ++ j ) {\r\n\r\n\t\t\t\t\tbindings[ j ].push( new PropertyBinding( object, paths[ j ], parsedPaths[ j ] ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( index < nCachedObjects ) {\r\n\r\n\t\t\t\tknownObject = objects[ index ];\r\n\r\n\t\t\t\t// move existing object to the ACTIVE region\r\n\r\n\t\t\t\tconst firstActiveIndex = -- nCachedObjects,\r\n\t\t\t\t\tlastCachedObject = objects[ firstActiveIndex ];\r\n\r\n\t\t\t\tindicesByUUID[ lastCachedObject.uuid ] = index;\r\n\t\t\t\tobjects[ index ] = lastCachedObject;\r\n\r\n\t\t\t\tindicesByUUID[ uuid ] = firstActiveIndex;\r\n\t\t\t\tobjects[ firstActiveIndex ] = object;\r\n\r\n\t\t\t\t// accounting is done, now do the same for all bindings\r\n\r\n\t\t\t\tfor ( let j = 0, m = nBindings; j !== m; ++ j ) {\r\n\r\n\t\t\t\t\tconst bindingsForPath = bindings[ j ],\r\n\t\t\t\t\t\tlastCached = bindingsForPath[ firstActiveIndex ];\r\n\r\n\t\t\t\t\tlet binding = bindingsForPath[ index ];\r\n\r\n\t\t\t\t\tbindingsForPath[ index ] = lastCached;\r\n\r\n\t\t\t\t\tif ( binding === undefined ) {\r\n\r\n\t\t\t\t\t\t// since we do not bother to create new bindings\r\n\t\t\t\t\t\t// for objects that are cached, the binding may\r\n\t\t\t\t\t\t// or may not exist\r\n\r\n\t\t\t\t\t\tbinding = new PropertyBinding( object, paths[ j ], parsedPaths[ j ] );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tbindingsForPath[ firstActiveIndex ] = binding;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( objects[ index ] !== knownObject ) {\r\n\r\n\t\t\t\tconsole.error( 'THREE.AnimationObjectGroup: Different objects with the same UUID ' +\r\n\t\t\t\t\t'detected. Clean the caches or recreate your infrastructure when reloading scenes.' );\r\n\r\n\t\t\t} // else the object is already where we want it to be\r\n\r\n\t\t} // for arguments\r\n\r\n\t\tthis.nCachedObjects_ = nCachedObjects;\r\n\r\n\t}\r\n\r\n\tremove() {\r\n\r\n\t\tconst objects = this._objects,\r\n\t\t\tindicesByUUID = this._indicesByUUID,\r\n\t\t\tbindings = this._bindings,\r\n\t\t\tnBindings = bindings.length;\r\n\r\n\t\tlet nCachedObjects = this.nCachedObjects_;\r\n\r\n\t\tfor ( let i = 0, n = arguments.length; i !== n; ++ i ) {\r\n\r\n\t\t\tconst object = arguments[ i ],\r\n\t\t\t\tuuid = object.uuid,\r\n\t\t\t\tindex = indicesByUUID[ uuid ];\r\n\r\n\t\t\tif ( index !== undefined && index >= nCachedObjects ) {\r\n\r\n\t\t\t\t// move existing object into the CACHED region\r\n\r\n\t\t\t\tconst lastCachedIndex = nCachedObjects ++,\r\n\t\t\t\t\tfirstActiveObject = objects[ lastCachedIndex ];\r\n\r\n\t\t\t\tindicesByUUID[ firstActiveObject.uuid ] = index;\r\n\t\t\t\tobjects[ index ] = firstActiveObject;\r\n\r\n\t\t\t\tindicesByUUID[ uuid ] = lastCachedIndex;\r\n\t\t\t\tobjects[ lastCachedIndex ] = object;\r\n\r\n\t\t\t\t// accounting is done, now do the same for all bindings\r\n\r\n\t\t\t\tfor ( let j = 0, m = nBindings; j !== m; ++ j ) {\r\n\r\n\t\t\t\t\tconst bindingsForPath = bindings[ j ],\r\n\t\t\t\t\t\tfirstActive = bindingsForPath[ lastCachedIndex ],\r\n\t\t\t\t\t\tbinding = bindingsForPath[ index ];\r\n\r\n\t\t\t\t\tbindingsForPath[ index ] = firstActive;\r\n\t\t\t\t\tbindingsForPath[ lastCachedIndex ] = binding;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} // for arguments\r\n\r\n\t\tthis.nCachedObjects_ = nCachedObjects;\r\n\r\n\t}\r\n\r\n\t// remove & forget\r\n\tuncache() {\r\n\r\n\t\tconst objects = this._objects,\r\n\t\t\tindicesByUUID = this._indicesByUUID,\r\n\t\t\tbindings = this._bindings,\r\n\t\t\tnBindings = bindings.length;\r\n\r\n\t\tlet nCachedObjects = this.nCachedObjects_,\r\n\t\t\tnObjects = objects.length;\r\n\r\n\t\tfor ( let i = 0, n = arguments.length; i !== n; ++ i ) {\r\n\r\n\t\t\tconst object = arguments[ i ],\r\n\t\t\t\tuuid = object.uuid,\r\n\t\t\t\tindex = indicesByUUID[ uuid ];\r\n\r\n\t\t\tif ( index !== undefined ) {\r\n\r\n\t\t\t\tdelete indicesByUUID[ uuid ];\r\n\r\n\t\t\t\tif ( index < nCachedObjects ) {\r\n\r\n\t\t\t\t\t// object is cached, shrink the CACHED region\r\n\r\n\t\t\t\t\tconst firstActiveIndex = -- nCachedObjects,\r\n\t\t\t\t\t\tlastCachedObject = objects[ firstActiveIndex ],\r\n\t\t\t\t\t\tlastIndex = -- nObjects,\r\n\t\t\t\t\t\tlastObject = objects[ lastIndex ];\r\n\r\n\t\t\t\t\t// last cached object takes this object's place\r\n\t\t\t\t\tindicesByUUID[ lastCachedObject.uuid ] = index;\r\n\t\t\t\t\tobjects[ index ] = lastCachedObject;\r\n\r\n\t\t\t\t\t// last object goes to the activated slot and pop\r\n\t\t\t\t\tindicesByUUID[ lastObject.uuid ] = firstActiveIndex;\r\n\t\t\t\t\tobjects[ firstActiveIndex ] = lastObject;\r\n\t\t\t\t\tobjects.pop();\r\n\r\n\t\t\t\t\t// accounting is done, now do the same for all bindings\r\n\r\n\t\t\t\t\tfor ( let j = 0, m = nBindings; j !== m; ++ j ) {\r\n\r\n\t\t\t\t\t\tconst bindingsForPath = bindings[ j ],\r\n\t\t\t\t\t\t\tlastCached = bindingsForPath[ firstActiveIndex ],\r\n\t\t\t\t\t\t\tlast = bindingsForPath[ lastIndex ];\r\n\r\n\t\t\t\t\t\tbindingsForPath[ index ] = lastCached;\r\n\t\t\t\t\t\tbindingsForPath[ firstActiveIndex ] = last;\r\n\t\t\t\t\t\tbindingsForPath.pop();\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// object is active, just swap with the last and pop\r\n\r\n\t\t\t\t\tconst lastIndex = -- nObjects,\r\n\t\t\t\t\t\tlastObject = objects[ lastIndex ];\r\n\r\n\t\t\t\t\tif ( lastIndex > 0 ) {\r\n\r\n\t\t\t\t\t\tindicesByUUID[ lastObject.uuid ] = index;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tobjects[ index ] = lastObject;\r\n\t\t\t\t\tobjects.pop();\r\n\r\n\t\t\t\t\t// accounting is done, now do the same for all bindings\r\n\r\n\t\t\t\t\tfor ( let j = 0, m = nBindings; j !== m; ++ j ) {\r\n\r\n\t\t\t\t\t\tconst bindingsForPath = bindings[ j ];\r\n\r\n\t\t\t\t\t\tbindingsForPath[ index ] = bindingsForPath[ lastIndex ];\r\n\t\t\t\t\t\tbindingsForPath.pop();\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} // cached or active\r\n\r\n\t\t\t} // if object is known\r\n\r\n\t\t} // for arguments\r\n\r\n\t\tthis.nCachedObjects_ = nCachedObjects;\r\n\r\n\t}\r\n\r\n\t// Internal interface used by befriended PropertyBinding.Composite:\r\n\r\n\tsubscribe_( path, parsedPath ) {\r\n\r\n\t\t// returns an array of bindings for the given path that is changed\r\n\t\t// according to the contained objects in the group\r\n\r\n\t\tconst indicesByPath = this._bindingsIndicesByPath;\r\n\t\tlet index = indicesByPath[ path ];\r\n\t\tconst bindings = this._bindings;\r\n\r\n\t\tif ( index !== undefined ) return bindings[ index ];\r\n\r\n\t\tconst paths = this._paths,\r\n\t\t\tparsedPaths = this._parsedPaths,\r\n\t\t\tobjects = this._objects,\r\n\t\t\tnObjects = objects.length,\r\n\t\t\tnCachedObjects = this.nCachedObjects_,\r\n\t\t\tbindingsForPath = new Array( nObjects );\r\n\r\n\t\tindex = bindings.length;\r\n\r\n\t\tindicesByPath[ path ] = index;\r\n\r\n\t\tpaths.push( path );\r\n\t\tparsedPaths.push( parsedPath );\r\n\t\tbindings.push( bindingsForPath );\r\n\r\n\t\tfor ( let i = nCachedObjects, n = objects.length; i !== n; ++ i ) {\r\n\r\n\t\t\tconst object = objects[ i ];\r\n\t\t\tbindingsForPath[ i ] = new PropertyBinding( object, path, parsedPath );\r\n\r\n\t\t}\r\n\r\n\t\treturn bindingsForPath;\r\n\r\n\t}\r\n\r\n\tunsubscribe_( path ) {\r\n\r\n\t\t// tells the group to forget about a property path and no longer\r\n\t\t// update the array previously obtained with 'subscribe_'\r\n\r\n\t\tconst indicesByPath = this._bindingsIndicesByPath,\r\n\t\t\tindex = indicesByPath[ path ];\r\n\r\n\t\tif ( index !== undefined ) {\r\n\r\n\t\t\tconst paths = this._paths,\r\n\t\t\t\tparsedPaths = this._parsedPaths,\r\n\t\t\t\tbindings = this._bindings,\r\n\t\t\t\tlastBindingsIndex = bindings.length - 1,\r\n\t\t\t\tlastBindings = bindings[ lastBindingsIndex ],\r\n\t\t\t\tlastBindingsPath = path[ lastBindingsIndex ];\r\n\r\n\t\t\tindicesByPath[ lastBindingsPath ] = index;\r\n\r\n\t\t\tbindings[ index ] = lastBindings;\r\n\t\t\tbindings.pop();\r\n\r\n\t\t\tparsedPaths[ index ] = parsedPaths[ lastBindingsIndex ];\r\n\t\t\tparsedPaths.pop();\r\n\r\n\t\t\tpaths[ index ] = paths[ lastBindingsIndex ];\r\n\t\t\tpaths.pop();\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nAnimationObjectGroup.prototype.isAnimationObjectGroup = true;\r\n\r\nexport { AnimationObjectGroup };\r\n"]},"metadata":{},"sourceType":"module"}