{"ast":null,"code":"import { Matrix3 } from './Matrix3.js';\nimport { Vector3 } from './Vector3.js';\n\nconst _vector1 = /*@__PURE__*/new Vector3();\n\nconst _vector2 = /*@__PURE__*/new Vector3();\n\nconst _normalMatrix = /*@__PURE__*/new Matrix3();\n\nclass Plane {\n  constructor(normal = new Vector3(1, 0, 0), constant = 0) {\n    // normal is assumed to be normalized\n    this.normal = normal;\n    this.constant = constant;\n  }\n\n  set(normal, constant) {\n    this.normal.copy(normal);\n    this.constant = constant;\n    return this;\n  }\n\n  setComponents(x, y, z, w) {\n    this.normal.set(x, y, z);\n    this.constant = w;\n    return this;\n  }\n\n  setFromNormalAndCoplanarPoint(normal, point) {\n    this.normal.copy(normal);\n    this.constant = -point.dot(this.normal);\n    return this;\n  }\n\n  setFromCoplanarPoints(a, b, c) {\n    const normal = _vector1.subVectors(c, b).cross(_vector2.subVectors(a, b)).normalize(); // Q: should an error be thrown if normal is zero (e.g. degenerate plane)?\n\n\n    this.setFromNormalAndCoplanarPoint(normal, a);\n    return this;\n  }\n\n  copy(plane) {\n    this.normal.copy(plane.normal);\n    this.constant = plane.constant;\n    return this;\n  }\n\n  normalize() {\n    // Note: will lead to a divide by zero if the plane is invalid.\n    const inverseNormalLength = 1.0 / this.normal.length();\n    this.normal.multiplyScalar(inverseNormalLength);\n    this.constant *= inverseNormalLength;\n    return this;\n  }\n\n  negate() {\n    this.constant *= -1;\n    this.normal.negate();\n    return this;\n  }\n\n  distanceToPoint(point) {\n    return this.normal.dot(point) + this.constant;\n  }\n\n  distanceToSphere(sphere) {\n    return this.distanceToPoint(sphere.center) - sphere.radius;\n  }\n\n  projectPoint(point, target) {\n    return target.copy(this.normal).multiplyScalar(-this.distanceToPoint(point)).add(point);\n  }\n\n  intersectLine(line, target) {\n    const direction = line.delta(_vector1);\n    const denominator = this.normal.dot(direction);\n\n    if (denominator === 0) {\n      // line is coplanar, return origin\n      if (this.distanceToPoint(line.start) === 0) {\n        return target.copy(line.start);\n      } // Unsure if this is the correct method to handle this case.\n\n\n      return null;\n    }\n\n    const t = -(line.start.dot(this.normal) + this.constant) / denominator;\n\n    if (t < 0 || t > 1) {\n      return null;\n    }\n\n    return target.copy(direction).multiplyScalar(t).add(line.start);\n  }\n\n  intersectsLine(line) {\n    // Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.\n    const startSign = this.distanceToPoint(line.start);\n    const endSign = this.distanceToPoint(line.end);\n    return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;\n  }\n\n  intersectsBox(box) {\n    return box.intersectsPlane(this);\n  }\n\n  intersectsSphere(sphere) {\n    return sphere.intersectsPlane(this);\n  }\n\n  coplanarPoint(target) {\n    return target.copy(this.normal).multiplyScalar(-this.constant);\n  }\n\n  applyMatrix4(matrix, optionalNormalMatrix) {\n    const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);\n\n    const referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix);\n    const normal = this.normal.applyMatrix3(normalMatrix).normalize();\n    this.constant = -referencePoint.dot(normal);\n    return this;\n  }\n\n  translate(offset) {\n    this.constant -= offset.dot(this.normal);\n    return this;\n  }\n\n  equals(plane) {\n    return plane.normal.equals(this.normal) && plane.constant === this.constant;\n  }\n\n  clone() {\n    return new this.constructor().copy(this);\n  }\n\n}\n\nPlane.prototype.isPlane = true;\nexport { Plane };","map":{"version":3,"sources":["C:/Users/dell/Desktop/projektlogin/vue-3-authentication-jwt/src/games/three/src/math/Plane.js"],"names":["Matrix3","Vector3","_vector1","_vector2","_normalMatrix","Plane","constructor","normal","constant","set","copy","setComponents","x","y","z","w","setFromNormalAndCoplanarPoint","point","dot","setFromCoplanarPoints","a","b","c","subVectors","cross","normalize","plane","inverseNormalLength","length","multiplyScalar","negate","distanceToPoint","distanceToSphere","sphere","center","radius","projectPoint","target","add","intersectLine","line","direction","delta","denominator","start","t","intersectsLine","startSign","endSign","end","intersectsBox","box","intersectsPlane","intersectsSphere","coplanarPoint","applyMatrix4","matrix","optionalNormalMatrix","normalMatrix","getNormalMatrix","referencePoint","applyMatrix3","translate","offset","equals","clone","prototype","isPlane"],"mappings":"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","sourcesContent":["import { Matrix3 } from './Matrix3.js';\r\nimport { Vector3 } from './Vector3.js';\r\n\r\nconst _vector1 = /*@__PURE__*/ new Vector3();\r\nconst _vector2 = /*@__PURE__*/ new Vector3();\r\nconst _normalMatrix = /*@__PURE__*/ new Matrix3();\r\n\r\nclass Plane {\r\n\r\n\tconstructor( normal = new Vector3( 1, 0, 0 ), constant = 0 ) {\r\n\r\n\t\t// normal is assumed to be normalized\r\n\r\n\t\tthis.normal = normal;\r\n\t\tthis.constant = constant;\r\n\r\n\t}\r\n\r\n\tset( normal, constant ) {\r\n\r\n\t\tthis.normal.copy( normal );\r\n\t\tthis.constant = constant;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tsetComponents( x, y, z, w ) {\r\n\r\n\t\tthis.normal.set( x, y, z );\r\n\t\tthis.constant = w;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tsetFromNormalAndCoplanarPoint( normal, point ) {\r\n\r\n\t\tthis.normal.copy( normal );\r\n\t\tthis.constant = - point.dot( this.normal );\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tsetFromCoplanarPoints( a, b, c ) {\r\n\r\n\t\tconst normal = _vector1.subVectors( c, b ).cross( _vector2.subVectors( a, b ) ).normalize();\r\n\r\n\t\t// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?\r\n\r\n\t\tthis.setFromNormalAndCoplanarPoint( normal, a );\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tcopy( plane ) {\r\n\r\n\t\tthis.normal.copy( plane.normal );\r\n\t\tthis.constant = plane.constant;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tnormalize() {\r\n\r\n\t\t// Note: will lead to a divide by zero if the plane is invalid.\r\n\r\n\t\tconst inverseNormalLength = 1.0 / this.normal.length();\r\n\t\tthis.normal.multiplyScalar( inverseNormalLength );\r\n\t\tthis.constant *= inverseNormalLength;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tnegate() {\r\n\r\n\t\tthis.constant *= - 1;\r\n\t\tthis.normal.negate();\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tdistanceToPoint( point ) {\r\n\r\n\t\treturn this.normal.dot( point ) + this.constant;\r\n\r\n\t}\r\n\r\n\tdistanceToSphere( sphere ) {\r\n\r\n\t\treturn this.distanceToPoint( sphere.center ) - sphere.radius;\r\n\r\n\t}\r\n\r\n\tprojectPoint( point, target ) {\r\n\r\n\t\treturn target.copy( this.normal ).multiplyScalar( - this.distanceToPoint( point ) ).add( point );\r\n\r\n\t}\r\n\r\n\tintersectLine( line, target ) {\r\n\r\n\t\tconst direction = line.delta( _vector1 );\r\n\r\n\t\tconst denominator = this.normal.dot( direction );\r\n\r\n\t\tif ( denominator === 0 ) {\r\n\r\n\t\t\t// line is coplanar, return origin\r\n\t\t\tif ( this.distanceToPoint( line.start ) === 0 ) {\r\n\r\n\t\t\t\treturn target.copy( line.start );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Unsure if this is the correct method to handle this case.\r\n\t\t\treturn null;\r\n\r\n\t\t}\r\n\r\n\t\tconst t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;\r\n\r\n\t\tif ( t < 0 || t > 1 ) {\r\n\r\n\t\t\treturn null;\r\n\r\n\t\t}\r\n\r\n\t\treturn target.copy( direction ).multiplyScalar( t ).add( line.start );\r\n\r\n\t}\r\n\r\n\tintersectsLine( line ) {\r\n\r\n\t\t// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.\r\n\r\n\t\tconst startSign = this.distanceToPoint( line.start );\r\n\t\tconst endSign = this.distanceToPoint( line.end );\r\n\r\n\t\treturn ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );\r\n\r\n\t}\r\n\r\n\tintersectsBox( box ) {\r\n\r\n\t\treturn box.intersectsPlane( this );\r\n\r\n\t}\r\n\r\n\tintersectsSphere( sphere ) {\r\n\r\n\t\treturn sphere.intersectsPlane( this );\r\n\r\n\t}\r\n\r\n\tcoplanarPoint( target ) {\r\n\r\n\t\treturn target.copy( this.normal ).multiplyScalar( - this.constant );\r\n\r\n\t}\r\n\r\n\tapplyMatrix4( matrix, optionalNormalMatrix ) {\r\n\r\n\t\tconst normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix( matrix );\r\n\r\n\t\tconst referencePoint = this.coplanarPoint( _vector1 ).applyMatrix4( matrix );\r\n\r\n\t\tconst normal = this.normal.applyMatrix3( normalMatrix ).normalize();\r\n\r\n\t\tthis.constant = - referencePoint.dot( normal );\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\ttranslate( offset ) {\r\n\r\n\t\tthis.constant -= offset.dot( this.normal );\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tequals( plane ) {\r\n\r\n\t\treturn plane.normal.equals( this.normal ) && ( plane.constant === this.constant );\r\n\r\n\t}\r\n\r\n\tclone() {\r\n\r\n\t\treturn new this.constructor().copy( this );\r\n\r\n\t}\r\n\r\n}\r\n\r\nPlane.prototype.isPlane = true;\r\n\r\nexport { Plane };\r\n"]},"metadata":{},"sourceType":"module"}