{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport { InterpolateLinear, InterpolateSmooth, InterpolateDiscrete } from '../constants.js';\nimport { CubicInterpolant } from '../math/interpolants/CubicInterpolant.js';\nimport { LinearInterpolant } from '../math/interpolants/LinearInterpolant.js';\nimport { DiscreteInterpolant } from '../math/interpolants/DiscreteInterpolant.js';\nimport { AnimationUtils } from './AnimationUtils.js';\n\nclass KeyframeTrack {\n  constructor(name, times, values, interpolation) {\n    if (name === undefined) throw new Error('THREE.KeyframeTrack: track name is undefined');\n    if (times === undefined || times.length === 0) throw new Error('THREE.KeyframeTrack: no keyframes in track named ' + name);\n    this.name = name;\n    this.times = AnimationUtils.convertArray(times, this.TimeBufferType);\n    this.values = AnimationUtils.convertArray(values, this.ValueBufferType);\n    this.setInterpolation(interpolation || this.DefaultInterpolation);\n  } // Serialization (in static context, because of constructor invocation\n  // and automatic invocation of .toJSON):\n\n\n  static toJSON(track) {\n    const trackType = track.constructor;\n    let json; // derived classes can define a static toJSON method\n\n    if (trackType.toJSON !== this.toJSON) {\n      json = trackType.toJSON(track);\n    } else {\n      // by default, we assume the data can be serialized as-is\n      json = {\n        'name': track.name,\n        'times': AnimationUtils.convertArray(track.times, Array),\n        'values': AnimationUtils.convertArray(track.values, Array)\n      };\n      const interpolation = track.getInterpolation();\n\n      if (interpolation !== track.DefaultInterpolation) {\n        json.interpolation = interpolation;\n      }\n    }\n\n    json.type = track.ValueTypeName; // mandatory\n\n    return json;\n  }\n\n  InterpolantFactoryMethodDiscrete(result) {\n    return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);\n  }\n\n  InterpolantFactoryMethodLinear(result) {\n    return new LinearInterpolant(this.times, this.values, this.getValueSize(), result);\n  }\n\n  InterpolantFactoryMethodSmooth(result) {\n    return new CubicInterpolant(this.times, this.values, this.getValueSize(), result);\n  }\n\n  setInterpolation(interpolation) {\n    let factoryMethod;\n\n    switch (interpolation) {\n      case InterpolateDiscrete:\n        factoryMethod = this.InterpolantFactoryMethodDiscrete;\n        break;\n\n      case InterpolateLinear:\n        factoryMethod = this.InterpolantFactoryMethodLinear;\n        break;\n\n      case InterpolateSmooth:\n        factoryMethod = this.InterpolantFactoryMethodSmooth;\n        break;\n    }\n\n    if (factoryMethod === undefined) {\n      const message = 'unsupported interpolation for ' + this.ValueTypeName + ' keyframe track named ' + this.name;\n\n      if (this.createInterpolant === undefined) {\n        // fall back to default, unless the default itself is messed up\n        if (interpolation !== this.DefaultInterpolation) {\n          this.setInterpolation(this.DefaultInterpolation);\n        } else {\n          throw new Error(message); // fatal, in this case\n        }\n      }\n\n      console.warn('THREE.KeyframeTrack:', message);\n      return this;\n    }\n\n    this.createInterpolant = factoryMethod;\n    return this;\n  }\n\n  getInterpolation() {\n    switch (this.createInterpolant) {\n      case this.InterpolantFactoryMethodDiscrete:\n        return InterpolateDiscrete;\n\n      case this.InterpolantFactoryMethodLinear:\n        return InterpolateLinear;\n\n      case this.InterpolantFactoryMethodSmooth:\n        return InterpolateSmooth;\n    }\n  }\n\n  getValueSize() {\n    return this.values.length / this.times.length;\n  } // move all keyframes either forwards or backwards in time\n\n\n  shift(timeOffset) {\n    if (timeOffset !== 0.0) {\n      const times = this.times;\n\n      for (let i = 0, n = times.length; i !== n; ++i) {\n        times[i] += timeOffset;\n      }\n    }\n\n    return this;\n  } // scale all keyframe times by a factor (useful for frame <-> seconds conversions)\n\n\n  scale(timeScale) {\n    if (timeScale !== 1.0) {\n      const times = this.times;\n\n      for (let i = 0, n = times.length; i !== n; ++i) {\n        times[i] *= timeScale;\n      }\n    }\n\n    return this;\n  } // removes keyframes before and after animation without changing any values within the range [startTime, endTime].\n  // IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values\n\n\n  trim(startTime, endTime) {\n    const times = this.times,\n          nKeys = times.length;\n    let from = 0,\n        to = nKeys - 1;\n\n    while (from !== nKeys && times[from] < startTime) {\n      ++from;\n    }\n\n    while (to !== -1 && times[to] > endTime) {\n      --to;\n    }\n\n    ++to; // inclusive -> exclusive bound\n\n    if (from !== 0 || to !== nKeys) {\n      // empty tracks are forbidden, so keep at least one keyframe\n      if (from >= to) {\n        to = Math.max(to, 1);\n        from = to - 1;\n      }\n\n      const stride = this.getValueSize();\n      this.times = AnimationUtils.arraySlice(times, from, to);\n      this.values = AnimationUtils.arraySlice(this.values, from * stride, to * stride);\n    }\n\n    return this;\n  } // ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable\n\n\n  validate() {\n    let valid = true;\n    const valueSize = this.getValueSize();\n\n    if (valueSize - Math.floor(valueSize) !== 0) {\n      console.error('THREE.KeyframeTrack: Invalid value size in track.', this);\n      valid = false;\n    }\n\n    const times = this.times,\n          values = this.values,\n          nKeys = times.length;\n\n    if (nKeys === 0) {\n      console.error('THREE.KeyframeTrack: Track is empty.', this);\n      valid = false;\n    }\n\n    let prevTime = null;\n\n    for (let i = 0; i !== nKeys; i++) {\n      const currTime = times[i];\n\n      if (typeof currTime === 'number' && isNaN(currTime)) {\n        console.error('THREE.KeyframeTrack: Time is not a valid number.', this, i, currTime);\n        valid = false;\n        break;\n      }\n\n      if (prevTime !== null && prevTime > currTime) {\n        console.error('THREE.KeyframeTrack: Out of order keys.', this, i, currTime, prevTime);\n        valid = false;\n        break;\n      }\n\n      prevTime = currTime;\n    }\n\n    if (values !== undefined) {\n      if (AnimationUtils.isTypedArray(values)) {\n        for (let i = 0, n = values.length; i !== n; ++i) {\n          const value = values[i];\n\n          if (isNaN(value)) {\n            console.error('THREE.KeyframeTrack: Value is not a valid number.', this, i, value);\n            valid = false;\n            break;\n          }\n        }\n      }\n    }\n\n    return valid;\n  } // removes equivalent sequential keys as common in morph target sequences\n  // (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)\n\n\n  optimize() {\n    // times or values may be shared with other tracks, so overwriting is unsafe\n    const times = AnimationUtils.arraySlice(this.times),\n          values = AnimationUtils.arraySlice(this.values),\n          stride = this.getValueSize(),\n          smoothInterpolation = this.getInterpolation() === InterpolateSmooth,\n          lastIndex = times.length - 1;\n    let writeIndex = 1;\n\n    for (let i = 1; i < lastIndex; ++i) {\n      let keep = false;\n      const time = times[i];\n      const timeNext = times[i + 1]; // remove adjacent keyframes scheduled at the same time\n\n      if (time !== timeNext && (i !== 1 || time !== times[0])) {\n        if (!smoothInterpolation) {\n          // remove unnecessary keyframes same as their neighbors\n          const offset = i * stride,\n                offsetP = offset - stride,\n                offsetN = offset + stride;\n\n          for (let j = 0; j !== stride; ++j) {\n            const value = values[offset + j];\n\n            if (value !== values[offsetP + j] || value !== values[offsetN + j]) {\n              keep = true;\n              break;\n            }\n          }\n        } else {\n          keep = true;\n        }\n      } // in-place compaction\n\n\n      if (keep) {\n        if (i !== writeIndex) {\n          times[writeIndex] = times[i];\n          const readOffset = i * stride,\n                writeOffset = writeIndex * stride;\n\n          for (let j = 0; j !== stride; ++j) {\n            values[writeOffset + j] = values[readOffset + j];\n          }\n        }\n\n        ++writeIndex;\n      }\n    } // flush last keyframe (compaction looks ahead)\n\n\n    if (lastIndex > 0) {\n      times[writeIndex] = times[lastIndex];\n\n      for (let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++j) {\n        values[writeOffset + j] = values[readOffset + j];\n      }\n\n      ++writeIndex;\n    }\n\n    if (writeIndex !== times.length) {\n      this.times = AnimationUtils.arraySlice(times, 0, writeIndex);\n      this.values = AnimationUtils.arraySlice(values, 0, writeIndex * stride);\n    } else {\n      this.times = times;\n      this.values = values;\n    }\n\n    return this;\n  }\n\n  clone() {\n    const times = AnimationUtils.arraySlice(this.times, 0);\n    const values = AnimationUtils.arraySlice(this.values, 0);\n    const TypedKeyframeTrack = this.constructor;\n    const track = new TypedKeyframeTrack(this.name, times, values); // Interpolant argument to constructor is not saved, so copy the factory method directly.\n\n    track.createInterpolant = this.createInterpolant;\n    return track;\n  }\n\n}\n\nKeyframeTrack.prototype.TimeBufferType = Float32Array;\nKeyframeTrack.prototype.ValueBufferType = Float32Array;\nKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;\nexport { KeyframeTrack };","map":{"version":3,"sources":["C:/Users/dell/Desktop/projektlogin/vue-3-authentication-jwt/src/games/three/src/animation/KeyframeTrack.js"],"names":["InterpolateLinear","InterpolateSmooth","InterpolateDiscrete","CubicInterpolant","LinearInterpolant","DiscreteInterpolant","AnimationUtils","KeyframeTrack","constructor","name","times","values","interpolation","undefined","Error","length","convertArray","TimeBufferType","ValueBufferType","setInterpolation","DefaultInterpolation","toJSON","track","trackType","json","Array","getInterpolation","type","ValueTypeName","InterpolantFactoryMethodDiscrete","result","getValueSize","InterpolantFactoryMethodLinear","InterpolantFactoryMethodSmooth","factoryMethod","message","createInterpolant","console","warn","shift","timeOffset","i","n","scale","timeScale","trim","startTime","endTime","nKeys","from","to","Math","max","stride","arraySlice","validate","valid","valueSize","floor","error","prevTime","currTime","isNaN","isTypedArray","value","optimize","smoothInterpolation","lastIndex","writeIndex","keep","time","timeNext","offset","offsetP","offsetN","j","readOffset","writeOffset","clone","TypedKeyframeTrack","prototype","Float32Array"],"mappings":";;;AAAA,SACCA,iBADD,EAECC,iBAFD,EAGCC,mBAHD,QAIO,iBAJP;AAKA,SAASC,gBAAT,QAAiC,0CAAjC;AACA,SAASC,iBAAT,QAAkC,2CAAlC;AACA,SAASC,mBAAT,QAAoC,6CAApC;AACA,SAASC,cAAT,QAA+B,qBAA/B;;AAEA,MAAMC,aAAN,CAAoB;AAEnBC,EAAAA,WAAW,CAAEC,IAAF,EAAQC,KAAR,EAAeC,MAAf,EAAuBC,aAAvB,EAAuC;AAEjD,QAAKH,IAAI,KAAKI,SAAd,EAA0B,MAAM,IAAIC,KAAJ,CAAW,8CAAX,CAAN;AAC1B,QAAKJ,KAAK,KAAKG,SAAV,IAAuBH,KAAK,CAACK,MAAN,KAAiB,CAA7C,EAAiD,MAAM,IAAID,KAAJ,CAAW,sDAAsDL,IAAjE,CAAN;AAEjD,SAAKA,IAAL,GAAYA,IAAZ;AAEA,SAAKC,KAAL,GAAaJ,cAAc,CAACU,YAAf,CAA6BN,KAA7B,EAAoC,KAAKO,cAAzC,CAAb;AACA,SAAKN,MAAL,GAAcL,cAAc,CAACU,YAAf,CAA6BL,MAA7B,EAAqC,KAAKO,eAA1C,CAAd;AAEA,SAAKC,gBAAL,CAAuBP,aAAa,IAAI,KAAKQ,oBAA7C;AAEA,GAdkB,CAgBnB;AACA;;;AAEa,SAANC,MAAM,CAAEC,KAAF,EAAU;AAEtB,UAAMC,SAAS,GAAGD,KAAK,CAACd,WAAxB;AAEA,QAAIgB,IAAJ,CAJsB,CAMtB;;AACA,QAAKD,SAAS,CAACF,MAAV,KAAqB,KAAKA,MAA/B,EAAwC;AAEvCG,MAAAA,IAAI,GAAGD,SAAS,CAACF,MAAV,CAAkBC,KAAlB,CAAP;AAEA,KAJD,MAIO;AAEN;AACAE,MAAAA,IAAI,GAAG;AAEN,gBAAQF,KAAK,CAACb,IAFR;AAGN,iBAASH,cAAc,CAACU,YAAf,CAA6BM,KAAK,CAACZ,KAAnC,EAA0Ce,KAA1C,CAHH;AAIN,kBAAUnB,cAAc,CAACU,YAAf,CAA6BM,KAAK,CAACX,MAAnC,EAA2Cc,KAA3C;AAJJ,OAAP;AAQA,YAAMb,aAAa,GAAGU,KAAK,CAACI,gBAAN,EAAtB;;AAEA,UAAKd,aAAa,KAAKU,KAAK,CAACF,oBAA7B,EAAoD;AAEnDI,QAAAA,IAAI,CAACZ,aAAL,GAAqBA,aAArB;AAEA;AAED;;AAEDY,IAAAA,IAAI,CAACG,IAAL,GAAYL,KAAK,CAACM,aAAlB,CAhCsB,CAgCW;;AAEjC,WAAOJ,IAAP;AAEA;;AAEDK,EAAAA,gCAAgC,CAAEC,MAAF,EAAW;AAE1C,WAAO,IAAIzB,mBAAJ,CAAyB,KAAKK,KAA9B,EAAqC,KAAKC,MAA1C,EAAkD,KAAKoB,YAAL,EAAlD,EAAuED,MAAvE,CAAP;AAEA;;AAEDE,EAAAA,8BAA8B,CAAEF,MAAF,EAAW;AAExC,WAAO,IAAI1B,iBAAJ,CAAuB,KAAKM,KAA5B,EAAmC,KAAKC,MAAxC,EAAgD,KAAKoB,YAAL,EAAhD,EAAqED,MAArE,CAAP;AAEA;;AAEDG,EAAAA,8BAA8B,CAAEH,MAAF,EAAW;AAExC,WAAO,IAAI3B,gBAAJ,CAAsB,KAAKO,KAA3B,EAAkC,KAAKC,MAAvC,EAA+C,KAAKoB,YAAL,EAA/C,EAAoED,MAApE,CAAP;AAEA;;AAEDX,EAAAA,gBAAgB,CAAEP,aAAF,EAAkB;AAEjC,QAAIsB,aAAJ;;AAEA,YAAStB,aAAT;AAEC,WAAKV,mBAAL;AAECgC,QAAAA,aAAa,GAAG,KAAKL,gCAArB;AAEA;;AAED,WAAK7B,iBAAL;AAECkC,QAAAA,aAAa,GAAG,KAAKF,8BAArB;AAEA;;AAED,WAAK/B,iBAAL;AAECiC,QAAAA,aAAa,GAAG,KAAKD,8BAArB;AAEA;AAlBF;;AAsBA,QAAKC,aAAa,KAAKrB,SAAvB,EAAmC;AAElC,YAAMsB,OAAO,GAAG,mCACf,KAAKP,aADU,GACM,wBADN,GACiC,KAAKnB,IADtD;;AAGA,UAAK,KAAK2B,iBAAL,KAA2BvB,SAAhC,EAA4C;AAE3C;AACA,YAAKD,aAAa,KAAK,KAAKQ,oBAA5B,EAAmD;AAElD,eAAKD,gBAAL,CAAuB,KAAKC,oBAA5B;AAEA,SAJD,MAIO;AAEN,gBAAM,IAAIN,KAAJ,CAAWqB,OAAX,CAAN,CAFM,CAEsB;AAE5B;AAED;;AAEDE,MAAAA,OAAO,CAACC,IAAR,CAAc,sBAAd,EAAsCH,OAAtC;AACA,aAAO,IAAP;AAEA;;AAED,SAAKC,iBAAL,GAAyBF,aAAzB;AAEA,WAAO,IAAP;AAEA;;AAEDR,EAAAA,gBAAgB,GAAG;AAElB,YAAS,KAAKU,iBAAd;AAEC,WAAK,KAAKP,gCAAV;AAEC,eAAO3B,mBAAP;;AAED,WAAK,KAAK8B,8BAAV;AAEC,eAAOhC,iBAAP;;AAED,WAAK,KAAKiC,8BAAV;AAEC,eAAOhC,iBAAP;AAZF;AAgBA;;AAED8B,EAAAA,YAAY,GAAG;AAEd,WAAO,KAAKpB,MAAL,CAAYI,MAAZ,GAAqB,KAAKL,KAAL,CAAWK,MAAvC;AAEA,GA5JkB,CA8JnB;;;AACAwB,EAAAA,KAAK,CAAEC,UAAF,EAAe;AAEnB,QAAKA,UAAU,KAAK,GAApB,EAA0B;AAEzB,YAAM9B,KAAK,GAAG,KAAKA,KAAnB;;AAEA,WAAM,IAAI+B,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAGhC,KAAK,CAACK,MAA3B,EAAmC0B,CAAC,KAAKC,CAAzC,EAA4C,EAAGD,CAA/C,EAAmD;AAElD/B,QAAAA,KAAK,CAAE+B,CAAF,CAAL,IAAcD,UAAd;AAEA;AAED;;AAED,WAAO,IAAP;AAEA,GA/KkB,CAiLnB;;;AACAG,EAAAA,KAAK,CAAEC,SAAF,EAAc;AAElB,QAAKA,SAAS,KAAK,GAAnB,EAAyB;AAExB,YAAMlC,KAAK,GAAG,KAAKA,KAAnB;;AAEA,WAAM,IAAI+B,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAGhC,KAAK,CAACK,MAA3B,EAAmC0B,CAAC,KAAKC,CAAzC,EAA4C,EAAGD,CAA/C,EAAmD;AAElD/B,QAAAA,KAAK,CAAE+B,CAAF,CAAL,IAAcG,SAAd;AAEA;AAED;;AAED,WAAO,IAAP;AAEA,GAlMkB,CAoMnB;AACA;;;AACAC,EAAAA,IAAI,CAAEC,SAAF,EAAaC,OAAb,EAAuB;AAE1B,UAAMrC,KAAK,GAAG,KAAKA,KAAnB;AAAA,UACCsC,KAAK,GAAGtC,KAAK,CAACK,MADf;AAGA,QAAIkC,IAAI,GAAG,CAAX;AAAA,QACCC,EAAE,GAAGF,KAAK,GAAG,CADd;;AAGA,WAAQC,IAAI,KAAKD,KAAT,IAAkBtC,KAAK,CAAEuC,IAAF,CAAL,GAAgBH,SAA1C,EAAsD;AAErD,QAAGG,IAAH;AAEA;;AAED,WAAQC,EAAE,KAAK,CAAE,CAAT,IAAcxC,KAAK,CAAEwC,EAAF,CAAL,GAAcH,OAApC,EAA8C;AAE7C,QAAGG,EAAH;AAEA;;AAED,MAAGA,EAAH,CApB0B,CAoBnB;;AAEP,QAAKD,IAAI,KAAK,CAAT,IAAcC,EAAE,KAAKF,KAA1B,EAAkC;AAEjC;AACA,UAAKC,IAAI,IAAIC,EAAb,EAAkB;AAEjBA,QAAAA,EAAE,GAAGC,IAAI,CAACC,GAAL,CAAUF,EAAV,EAAc,CAAd,CAAL;AACAD,QAAAA,IAAI,GAAGC,EAAE,GAAG,CAAZ;AAEA;;AAED,YAAMG,MAAM,GAAG,KAAKtB,YAAL,EAAf;AACA,WAAKrB,KAAL,GAAaJ,cAAc,CAACgD,UAAf,CAA2B5C,KAA3B,EAAkCuC,IAAlC,EAAwCC,EAAxC,CAAb;AACA,WAAKvC,MAAL,GAAcL,cAAc,CAACgD,UAAf,CAA2B,KAAK3C,MAAhC,EAAwCsC,IAAI,GAAGI,MAA/C,EAAuDH,EAAE,GAAGG,MAA5D,CAAd;AAEA;;AAED,WAAO,IAAP;AAEA,GA9OkB,CAgPnB;;;AACAE,EAAAA,QAAQ,GAAG;AAEV,QAAIC,KAAK,GAAG,IAAZ;AAEA,UAAMC,SAAS,GAAG,KAAK1B,YAAL,EAAlB;;AACA,QAAK0B,SAAS,GAAGN,IAAI,CAACO,KAAL,CAAYD,SAAZ,CAAZ,KAAwC,CAA7C,EAAiD;AAEhDpB,MAAAA,OAAO,CAACsB,KAAR,CAAe,mDAAf,EAAoE,IAApE;AACAH,MAAAA,KAAK,GAAG,KAAR;AAEA;;AAED,UAAM9C,KAAK,GAAG,KAAKA,KAAnB;AAAA,UACCC,MAAM,GAAG,KAAKA,MADf;AAAA,UAGCqC,KAAK,GAAGtC,KAAK,CAACK,MAHf;;AAKA,QAAKiC,KAAK,KAAK,CAAf,EAAmB;AAElBX,MAAAA,OAAO,CAACsB,KAAR,CAAe,sCAAf,EAAuD,IAAvD;AACAH,MAAAA,KAAK,GAAG,KAAR;AAEA;;AAED,QAAII,QAAQ,GAAG,IAAf;;AAEA,SAAM,IAAInB,CAAC,GAAG,CAAd,EAAiBA,CAAC,KAAKO,KAAvB,EAA8BP,CAAC,EAA/B,EAAqC;AAEpC,YAAMoB,QAAQ,GAAGnD,KAAK,CAAE+B,CAAF,CAAtB;;AAEA,UAAK,OAAOoB,QAAP,KAAoB,QAApB,IAAgCC,KAAK,CAAED,QAAF,CAA1C,EAAyD;AAExDxB,QAAAA,OAAO,CAACsB,KAAR,CAAe,kDAAf,EAAmE,IAAnE,EAAyElB,CAAzE,EAA4EoB,QAA5E;AACAL,QAAAA,KAAK,GAAG,KAAR;AACA;AAEA;;AAED,UAAKI,QAAQ,KAAK,IAAb,IAAqBA,QAAQ,GAAGC,QAArC,EAAgD;AAE/CxB,QAAAA,OAAO,CAACsB,KAAR,CAAe,yCAAf,EAA0D,IAA1D,EAAgElB,CAAhE,EAAmEoB,QAAnE,EAA6ED,QAA7E;AACAJ,QAAAA,KAAK,GAAG,KAAR;AACA;AAEA;;AAEDI,MAAAA,QAAQ,GAAGC,QAAX;AAEA;;AAED,QAAKlD,MAAM,KAAKE,SAAhB,EAA4B;AAE3B,UAAKP,cAAc,CAACyD,YAAf,CAA6BpD,MAA7B,CAAL,EAA6C;AAE5C,aAAM,IAAI8B,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAG/B,MAAM,CAACI,MAA5B,EAAoC0B,CAAC,KAAKC,CAA1C,EAA6C,EAAGD,CAAhD,EAAoD;AAEnD,gBAAMuB,KAAK,GAAGrD,MAAM,CAAE8B,CAAF,CAApB;;AAEA,cAAKqB,KAAK,CAAEE,KAAF,CAAV,EAAsB;AAErB3B,YAAAA,OAAO,CAACsB,KAAR,CAAe,mDAAf,EAAoE,IAApE,EAA0ElB,CAA1E,EAA6EuB,KAA7E;AACAR,YAAAA,KAAK,GAAG,KAAR;AACA;AAEA;AAED;AAED;AAED;;AAED,WAAOA,KAAP;AAEA,GA3TkB,CA6TnB;AACA;;;AACAS,EAAAA,QAAQ,GAAG;AAEV;AACA,UAAMvD,KAAK,GAAGJ,cAAc,CAACgD,UAAf,CAA2B,KAAK5C,KAAhC,CAAd;AAAA,UACCC,MAAM,GAAGL,cAAc,CAACgD,UAAf,CAA2B,KAAK3C,MAAhC,CADV;AAAA,UAEC0C,MAAM,GAAG,KAAKtB,YAAL,EAFV;AAAA,UAICmC,mBAAmB,GAAG,KAAKxC,gBAAL,OAA4BzB,iBAJnD;AAAA,UAMCkE,SAAS,GAAGzD,KAAK,CAACK,MAAN,GAAe,CAN5B;AAQA,QAAIqD,UAAU,GAAG,CAAjB;;AAEA,SAAM,IAAI3B,CAAC,GAAG,CAAd,EAAiBA,CAAC,GAAG0B,SAArB,EAAgC,EAAG1B,CAAnC,EAAuC;AAEtC,UAAI4B,IAAI,GAAG,KAAX;AAEA,YAAMC,IAAI,GAAG5D,KAAK,CAAE+B,CAAF,CAAlB;AACA,YAAM8B,QAAQ,GAAG7D,KAAK,CAAE+B,CAAC,GAAG,CAAN,CAAtB,CALsC,CAOtC;;AAEA,UAAK6B,IAAI,KAAKC,QAAT,KAAuB9B,CAAC,KAAK,CAAN,IAAW6B,IAAI,KAAK5D,KAAK,CAAE,CAAF,CAAhD,CAAL,EAA+D;AAE9D,YAAK,CAAEwD,mBAAP,EAA6B;AAE5B;AAEA,gBAAMM,MAAM,GAAG/B,CAAC,GAAGY,MAAnB;AAAA,gBACCoB,OAAO,GAAGD,MAAM,GAAGnB,MADpB;AAAA,gBAECqB,OAAO,GAAGF,MAAM,GAAGnB,MAFpB;;AAIA,eAAM,IAAIsB,CAAC,GAAG,CAAd,EAAiBA,CAAC,KAAKtB,MAAvB,EAA+B,EAAGsB,CAAlC,EAAsC;AAErC,kBAAMX,KAAK,GAAGrD,MAAM,CAAE6D,MAAM,GAAGG,CAAX,CAApB;;AAEA,gBAAKX,KAAK,KAAKrD,MAAM,CAAE8D,OAAO,GAAGE,CAAZ,CAAhB,IACJX,KAAK,KAAKrD,MAAM,CAAE+D,OAAO,GAAGC,CAAZ,CADjB,EACmC;AAElCN,cAAAA,IAAI,GAAG,IAAP;AACA;AAEA;AAED;AAED,SAtBD,MAsBO;AAENA,UAAAA,IAAI,GAAG,IAAP;AAEA;AAED,OAvCqC,CAyCtC;;;AAEA,UAAKA,IAAL,EAAY;AAEX,YAAK5B,CAAC,KAAK2B,UAAX,EAAwB;AAEvB1D,UAAAA,KAAK,CAAE0D,UAAF,CAAL,GAAsB1D,KAAK,CAAE+B,CAAF,CAA3B;AAEA,gBAAMmC,UAAU,GAAGnC,CAAC,GAAGY,MAAvB;AAAA,gBACCwB,WAAW,GAAGT,UAAU,GAAGf,MAD5B;;AAGA,eAAM,IAAIsB,CAAC,GAAG,CAAd,EAAiBA,CAAC,KAAKtB,MAAvB,EAA+B,EAAGsB,CAAlC,EAAsC;AAErChE,YAAAA,MAAM,CAAEkE,WAAW,GAAGF,CAAhB,CAAN,GAA4BhE,MAAM,CAAEiE,UAAU,GAAGD,CAAf,CAAlC;AAEA;AAED;;AAED,UAAGP,UAAH;AAEA;AAED,KA7ES,CA+EV;;;AAEA,QAAKD,SAAS,GAAG,CAAjB,EAAqB;AAEpBzD,MAAAA,KAAK,CAAE0D,UAAF,CAAL,GAAsB1D,KAAK,CAAEyD,SAAF,CAA3B;;AAEA,WAAM,IAAIS,UAAU,GAAGT,SAAS,GAAGd,MAA7B,EAAqCwB,WAAW,GAAGT,UAAU,GAAGf,MAAhE,EAAwEsB,CAAC,GAAG,CAAlF,EAAqFA,CAAC,KAAKtB,MAA3F,EAAmG,EAAGsB,CAAtG,EAA0G;AAEzGhE,QAAAA,MAAM,CAAEkE,WAAW,GAAGF,CAAhB,CAAN,GAA4BhE,MAAM,CAAEiE,UAAU,GAAGD,CAAf,CAAlC;AAEA;;AAED,QAAGP,UAAH;AAEA;;AAED,QAAKA,UAAU,KAAK1D,KAAK,CAACK,MAA1B,EAAmC;AAElC,WAAKL,KAAL,GAAaJ,cAAc,CAACgD,UAAf,CAA2B5C,KAA3B,EAAkC,CAAlC,EAAqC0D,UAArC,CAAb;AACA,WAAKzD,MAAL,GAAcL,cAAc,CAACgD,UAAf,CAA2B3C,MAA3B,EAAmC,CAAnC,EAAsCyD,UAAU,GAAGf,MAAnD,CAAd;AAEA,KALD,MAKO;AAEN,WAAK3C,KAAL,GAAaA,KAAb;AACA,WAAKC,MAAL,GAAcA,MAAd;AAEA;;AAED,WAAO,IAAP;AAEA;;AAEDmE,EAAAA,KAAK,GAAG;AAEP,UAAMpE,KAAK,GAAGJ,cAAc,CAACgD,UAAf,CAA2B,KAAK5C,KAAhC,EAAuC,CAAvC,CAAd;AACA,UAAMC,MAAM,GAAGL,cAAc,CAACgD,UAAf,CAA2B,KAAK3C,MAAhC,EAAwC,CAAxC,CAAf;AAEA,UAAMoE,kBAAkB,GAAG,KAAKvE,WAAhC;AACA,UAAMc,KAAK,GAAG,IAAIyD,kBAAJ,CAAwB,KAAKtE,IAA7B,EAAmCC,KAAnC,EAA0CC,MAA1C,CAAd,CANO,CAQP;;AACAW,IAAAA,KAAK,CAACc,iBAAN,GAA0B,KAAKA,iBAA/B;AAEA,WAAOd,KAAP;AAEA;;AA3bkB;;AA+bpBf,aAAa,CAACyE,SAAd,CAAwB/D,cAAxB,GAAyCgE,YAAzC;AACA1E,aAAa,CAACyE,SAAd,CAAwB9D,eAAxB,GAA0C+D,YAA1C;AACA1E,aAAa,CAACyE,SAAd,CAAwB5D,oBAAxB,GAA+CpB,iBAA/C;AAEA,SAASO,aAAT","sourcesContent":["import {\r\n\tInterpolateLinear,\r\n\tInterpolateSmooth,\r\n\tInterpolateDiscrete\r\n} from '../constants.js';\r\nimport { CubicInterpolant } from '../math/interpolants/CubicInterpolant.js';\r\nimport { LinearInterpolant } from '../math/interpolants/LinearInterpolant.js';\r\nimport { DiscreteInterpolant } from '../math/interpolants/DiscreteInterpolant.js';\r\nimport { AnimationUtils } from './AnimationUtils.js';\r\n\r\nclass KeyframeTrack {\r\n\r\n\tconstructor( name, times, values, interpolation ) {\r\n\r\n\t\tif ( name === undefined ) throw new Error( 'THREE.KeyframeTrack: track name is undefined' );\r\n\t\tif ( times === undefined || times.length === 0 ) throw new Error( 'THREE.KeyframeTrack: no keyframes in track named ' + name );\r\n\r\n\t\tthis.name = name;\r\n\r\n\t\tthis.times = AnimationUtils.convertArray( times, this.TimeBufferType );\r\n\t\tthis.values = AnimationUtils.convertArray( values, this.ValueBufferType );\r\n\r\n\t\tthis.setInterpolation( interpolation || this.DefaultInterpolation );\r\n\r\n\t}\r\n\r\n\t// Serialization (in static context, because of constructor invocation\r\n\t// and automatic invocation of .toJSON):\r\n\r\n\tstatic toJSON( track ) {\r\n\r\n\t\tconst trackType = track.constructor;\r\n\r\n\t\tlet json;\r\n\r\n\t\t// derived classes can define a static toJSON method\r\n\t\tif ( trackType.toJSON !== this.toJSON ) {\r\n\r\n\t\t\tjson = trackType.toJSON( track );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// by default, we assume the data can be serialized as-is\r\n\t\t\tjson = {\r\n\r\n\t\t\t\t'name': track.name,\r\n\t\t\t\t'times': AnimationUtils.convertArray( track.times, Array ),\r\n\t\t\t\t'values': AnimationUtils.convertArray( track.values, Array )\r\n\r\n\t\t\t};\r\n\r\n\t\t\tconst interpolation = track.getInterpolation();\r\n\r\n\t\t\tif ( interpolation !== track.DefaultInterpolation ) {\r\n\r\n\t\t\t\tjson.interpolation = interpolation;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tjson.type = track.ValueTypeName; // mandatory\r\n\r\n\t\treturn json;\r\n\r\n\t}\r\n\r\n\tInterpolantFactoryMethodDiscrete( result ) {\r\n\r\n\t\treturn new DiscreteInterpolant( this.times, this.values, this.getValueSize(), result );\r\n\r\n\t}\r\n\r\n\tInterpolantFactoryMethodLinear( result ) {\r\n\r\n\t\treturn new LinearInterpolant( this.times, this.values, this.getValueSize(), result );\r\n\r\n\t}\r\n\r\n\tInterpolantFactoryMethodSmooth( result ) {\r\n\r\n\t\treturn new CubicInterpolant( this.times, this.values, this.getValueSize(), result );\r\n\r\n\t}\r\n\r\n\tsetInterpolation( interpolation ) {\r\n\r\n\t\tlet factoryMethod;\r\n\r\n\t\tswitch ( interpolation ) {\r\n\r\n\t\t\tcase InterpolateDiscrete:\r\n\r\n\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodDiscrete;\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase InterpolateLinear:\r\n\r\n\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodLinear;\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase InterpolateSmooth:\r\n\r\n\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodSmooth;\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t}\r\n\r\n\t\tif ( factoryMethod === undefined ) {\r\n\r\n\t\t\tconst message = 'unsupported interpolation for ' +\r\n\t\t\t\tthis.ValueTypeName + ' keyframe track named ' + this.name;\r\n\r\n\t\t\tif ( this.createInterpolant === undefined ) {\r\n\r\n\t\t\t\t// fall back to default, unless the default itself is messed up\r\n\t\t\t\tif ( interpolation !== this.DefaultInterpolation ) {\r\n\r\n\t\t\t\t\tthis.setInterpolation( this.DefaultInterpolation );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tthrow new Error( message ); // fatal, in this case\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconsole.warn( 'THREE.KeyframeTrack:', message );\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\tthis.createInterpolant = factoryMethod;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tgetInterpolation() {\r\n\r\n\t\tswitch ( this.createInterpolant ) {\r\n\r\n\t\t\tcase this.InterpolantFactoryMethodDiscrete:\r\n\r\n\t\t\t\treturn InterpolateDiscrete;\r\n\r\n\t\t\tcase this.InterpolantFactoryMethodLinear:\r\n\r\n\t\t\t\treturn InterpolateLinear;\r\n\r\n\t\t\tcase this.InterpolantFactoryMethodSmooth:\r\n\r\n\t\t\t\treturn InterpolateSmooth;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tgetValueSize() {\r\n\r\n\t\treturn this.values.length / this.times.length;\r\n\r\n\t}\r\n\r\n\t// move all keyframes either forwards or backwards in time\r\n\tshift( timeOffset ) {\r\n\r\n\t\tif ( timeOffset !== 0.0 ) {\r\n\r\n\t\t\tconst times = this.times;\r\n\r\n\t\t\tfor ( let i = 0, n = times.length; i !== n; ++ i ) {\r\n\r\n\t\t\t\ttimes[ i ] += timeOffset;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t// scale all keyframe times by a factor (useful for frame <-> seconds conversions)\r\n\tscale( timeScale ) {\r\n\r\n\t\tif ( timeScale !== 1.0 ) {\r\n\r\n\t\t\tconst times = this.times;\r\n\r\n\t\t\tfor ( let i = 0, n = times.length; i !== n; ++ i ) {\r\n\r\n\t\t\t\ttimes[ i ] *= timeScale;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t// removes keyframes before and after animation without changing any values within the range [startTime, endTime].\r\n\t// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values\r\n\ttrim( startTime, endTime ) {\r\n\r\n\t\tconst times = this.times,\r\n\t\t\tnKeys = times.length;\r\n\r\n\t\tlet from = 0,\r\n\t\t\tto = nKeys - 1;\r\n\r\n\t\twhile ( from !== nKeys && times[ from ] < startTime ) {\r\n\r\n\t\t\t++ from;\r\n\r\n\t\t}\r\n\r\n\t\twhile ( to !== - 1 && times[ to ] > endTime ) {\r\n\r\n\t\t\t-- to;\r\n\r\n\t\t}\r\n\r\n\t\t++ to; // inclusive -> exclusive bound\r\n\r\n\t\tif ( from !== 0 || to !== nKeys ) {\r\n\r\n\t\t\t// empty tracks are forbidden, so keep at least one keyframe\r\n\t\t\tif ( from >= to ) {\r\n\r\n\t\t\t\tto = Math.max( to, 1 );\r\n\t\t\t\tfrom = to - 1;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst stride = this.getValueSize();\r\n\t\t\tthis.times = AnimationUtils.arraySlice( times, from, to );\r\n\t\t\tthis.values = AnimationUtils.arraySlice( this.values, from * stride, to * stride );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable\r\n\tvalidate() {\r\n\r\n\t\tlet valid = true;\r\n\r\n\t\tconst valueSize = this.getValueSize();\r\n\t\tif ( valueSize - Math.floor( valueSize ) !== 0 ) {\r\n\r\n\t\t\tconsole.error( 'THREE.KeyframeTrack: Invalid value size in track.', this );\r\n\t\t\tvalid = false;\r\n\r\n\t\t}\r\n\r\n\t\tconst times = this.times,\r\n\t\t\tvalues = this.values,\r\n\r\n\t\t\tnKeys = times.length;\r\n\r\n\t\tif ( nKeys === 0 ) {\r\n\r\n\t\t\tconsole.error( 'THREE.KeyframeTrack: Track is empty.', this );\r\n\t\t\tvalid = false;\r\n\r\n\t\t}\r\n\r\n\t\tlet prevTime = null;\r\n\r\n\t\tfor ( let i = 0; i !== nKeys; i ++ ) {\r\n\r\n\t\t\tconst currTime = times[ i ];\r\n\r\n\t\t\tif ( typeof currTime === 'number' && isNaN( currTime ) ) {\r\n\r\n\t\t\t\tconsole.error( 'THREE.KeyframeTrack: Time is not a valid number.', this, i, currTime );\r\n\t\t\t\tvalid = false;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( prevTime !== null && prevTime > currTime ) {\r\n\r\n\t\t\t\tconsole.error( 'THREE.KeyframeTrack: Out of order keys.', this, i, currTime, prevTime );\r\n\t\t\t\tvalid = false;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tprevTime = currTime;\r\n\r\n\t\t}\r\n\r\n\t\tif ( values !== undefined ) {\r\n\r\n\t\t\tif ( AnimationUtils.isTypedArray( values ) ) {\r\n\r\n\t\t\t\tfor ( let i = 0, n = values.length; i !== n; ++ i ) {\r\n\r\n\t\t\t\t\tconst value = values[ i ];\r\n\r\n\t\t\t\t\tif ( isNaN( value ) ) {\r\n\r\n\t\t\t\t\t\tconsole.error( 'THREE.KeyframeTrack: Value is not a valid number.', this, i, value );\r\n\t\t\t\t\t\tvalid = false;\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn valid;\r\n\r\n\t}\r\n\r\n\t// removes equivalent sequential keys as common in morph target sequences\r\n\t// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)\r\n\toptimize() {\r\n\r\n\t\t// times or values may be shared with other tracks, so overwriting is unsafe\r\n\t\tconst times = AnimationUtils.arraySlice( this.times ),\r\n\t\t\tvalues = AnimationUtils.arraySlice( this.values ),\r\n\t\t\tstride = this.getValueSize(),\r\n\r\n\t\t\tsmoothInterpolation = this.getInterpolation() === InterpolateSmooth,\r\n\r\n\t\t\tlastIndex = times.length - 1;\r\n\r\n\t\tlet writeIndex = 1;\r\n\r\n\t\tfor ( let i = 1; i < lastIndex; ++ i ) {\r\n\r\n\t\t\tlet keep = false;\r\n\r\n\t\t\tconst time = times[ i ];\r\n\t\t\tconst timeNext = times[ i + 1 ];\r\n\r\n\t\t\t// remove adjacent keyframes scheduled at the same time\r\n\r\n\t\t\tif ( time !== timeNext && ( i !== 1 || time !== times[ 0 ] ) ) {\r\n\r\n\t\t\t\tif ( ! smoothInterpolation ) {\r\n\r\n\t\t\t\t\t// remove unnecessary keyframes same as their neighbors\r\n\r\n\t\t\t\t\tconst offset = i * stride,\r\n\t\t\t\t\t\toffsetP = offset - stride,\r\n\t\t\t\t\t\toffsetN = offset + stride;\r\n\r\n\t\t\t\t\tfor ( let j = 0; j !== stride; ++ j ) {\r\n\r\n\t\t\t\t\t\tconst value = values[ offset + j ];\r\n\r\n\t\t\t\t\t\tif ( value !== values[ offsetP + j ] ||\r\n\t\t\t\t\t\t\tvalue !== values[ offsetN + j ] ) {\r\n\r\n\t\t\t\t\t\t\tkeep = true;\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tkeep = true;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// in-place compaction\r\n\r\n\t\t\tif ( keep ) {\r\n\r\n\t\t\t\tif ( i !== writeIndex ) {\r\n\r\n\t\t\t\t\ttimes[ writeIndex ] = times[ i ];\r\n\r\n\t\t\t\t\tconst readOffset = i * stride,\r\n\t\t\t\t\t\twriteOffset = writeIndex * stride;\r\n\r\n\t\t\t\t\tfor ( let j = 0; j !== stride; ++ j ) {\r\n\r\n\t\t\t\t\t\tvalues[ writeOffset + j ] = values[ readOffset + j ];\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t++ writeIndex;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// flush last keyframe (compaction looks ahead)\r\n\r\n\t\tif ( lastIndex > 0 ) {\r\n\r\n\t\t\ttimes[ writeIndex ] = times[ lastIndex ];\r\n\r\n\t\t\tfor ( let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++ j ) {\r\n\r\n\t\t\t\tvalues[ writeOffset + j ] = values[ readOffset + j ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\t++ writeIndex;\r\n\r\n\t\t}\r\n\r\n\t\tif ( writeIndex !== times.length ) {\r\n\r\n\t\t\tthis.times = AnimationUtils.arraySlice( times, 0, writeIndex );\r\n\t\t\tthis.values = AnimationUtils.arraySlice( values, 0, writeIndex * stride );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.times = times;\r\n\t\t\tthis.values = values;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tclone() {\r\n\r\n\t\tconst times = AnimationUtils.arraySlice( this.times, 0 );\r\n\t\tconst values = AnimationUtils.arraySlice( this.values, 0 );\r\n\r\n\t\tconst TypedKeyframeTrack = this.constructor;\r\n\t\tconst track = new TypedKeyframeTrack( this.name, times, values );\r\n\r\n\t\t// Interpolant argument to constructor is not saved, so copy the factory method directly.\r\n\t\ttrack.createInterpolant = this.createInterpolant;\r\n\r\n\t\treturn track;\r\n\r\n\t}\r\n\r\n}\r\n\r\nKeyframeTrack.prototype.TimeBufferType = Float32Array;\r\nKeyframeTrack.prototype.ValueBufferType = Float32Array;\r\nKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;\r\n\r\nexport { KeyframeTrack };\r\n"]},"metadata":{},"sourceType":"module"}