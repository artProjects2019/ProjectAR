{"ast":null,"code":"import \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport { AnimationAction } from './AnimationAction.js';\nimport { EventDispatcher } from '../core/EventDispatcher.js';\nimport { LinearInterpolant } from '../math/interpolants/LinearInterpolant.js';\nimport { PropertyBinding } from './PropertyBinding.js';\nimport { PropertyMixer } from './PropertyMixer.js';\nimport { AnimationClip } from './AnimationClip.js';\nimport { NormalAnimationBlendMode } from '../constants.js';\n\nclass AnimationMixer extends EventDispatcher {\n  constructor(root) {\n    super();\n    this._root = root;\n\n    this._initMemoryManager();\n\n    this._accuIndex = 0;\n    this.time = 0;\n    this.timeScale = 1.0;\n  }\n\n  _bindAction(action, prototypeAction) {\n    const root = action._localRoot || this._root,\n          tracks = action._clip.tracks,\n          nTracks = tracks.length,\n          bindings = action._propertyBindings,\n          interpolants = action._interpolants,\n          rootUuid = root.uuid,\n          bindingsByRoot = this._bindingsByRootAndName;\n    let bindingsByName = bindingsByRoot[rootUuid];\n\n    if (bindingsByName === undefined) {\n      bindingsByName = {};\n      bindingsByRoot[rootUuid] = bindingsByName;\n    }\n\n    for (let i = 0; i !== nTracks; ++i) {\n      const track = tracks[i],\n            trackName = track.name;\n      let binding = bindingsByName[trackName];\n\n      if (binding !== undefined) {\n        ++binding.referenceCount;\n        bindings[i] = binding;\n      } else {\n        binding = bindings[i];\n\n        if (binding !== undefined) {\n          // existing binding, make sure the cache knows\n          if (binding._cacheIndex === null) {\n            ++binding.referenceCount;\n\n            this._addInactiveBinding(binding, rootUuid, trackName);\n          }\n\n          continue;\n        }\n\n        const path = prototypeAction && prototypeAction._propertyBindings[i].binding.parsedPath;\n        binding = new PropertyMixer(PropertyBinding.create(root, trackName, path), track.ValueTypeName, track.getValueSize());\n        ++binding.referenceCount;\n\n        this._addInactiveBinding(binding, rootUuid, trackName);\n\n        bindings[i] = binding;\n      }\n\n      interpolants[i].resultBuffer = binding.buffer;\n    }\n  }\n\n  _activateAction(action) {\n    if (!this._isActiveAction(action)) {\n      if (action._cacheIndex === null) {\n        // this action has been forgotten by the cache, but the user\n        // appears to be still using it -> rebind\n        const rootUuid = (action._localRoot || this._root).uuid,\n              clipUuid = action._clip.uuid,\n              actionsForClip = this._actionsByClip[clipUuid];\n\n        this._bindAction(action, actionsForClip && actionsForClip.knownActions[0]);\n\n        this._addInactiveAction(action, clipUuid, rootUuid);\n      }\n\n      const bindings = action._propertyBindings; // increment reference counts / sort out state\n\n      for (let i = 0, n = bindings.length; i !== n; ++i) {\n        const binding = bindings[i];\n\n        if (binding.useCount++ === 0) {\n          this._lendBinding(binding);\n\n          binding.saveOriginalState();\n        }\n      }\n\n      this._lendAction(action);\n    }\n  }\n\n  _deactivateAction(action) {\n    if (this._isActiveAction(action)) {\n      const bindings = action._propertyBindings; // decrement reference counts / sort out state\n\n      for (let i = 0, n = bindings.length; i !== n; ++i) {\n        const binding = bindings[i];\n\n        if (--binding.useCount === 0) {\n          binding.restoreOriginalState();\n\n          this._takeBackBinding(binding);\n        }\n      }\n\n      this._takeBackAction(action);\n    }\n  } // Memory manager\n\n\n  _initMemoryManager() {\n    this._actions = []; // 'nActiveActions' followed by inactive ones\n\n    this._nActiveActions = 0;\n    this._actionsByClip = {}; // inside:\n    // {\n    // \tknownActions: Array< AnimationAction > - used as prototypes\n    // \tactionByRoot: AnimationAction - lookup\n    // }\n\n    this._bindings = []; // 'nActiveBindings' followed by inactive ones\n\n    this._nActiveBindings = 0;\n    this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >\n\n    this._controlInterpolants = []; // same game as above\n\n    this._nActiveControlInterpolants = 0;\n    const scope = this;\n    this.stats = {\n      actions: {\n        get total() {\n          return scope._actions.length;\n        },\n\n        get inUse() {\n          return scope._nActiveActions;\n        }\n\n      },\n      bindings: {\n        get total() {\n          return scope._bindings.length;\n        },\n\n        get inUse() {\n          return scope._nActiveBindings;\n        }\n\n      },\n      controlInterpolants: {\n        get total() {\n          return scope._controlInterpolants.length;\n        },\n\n        get inUse() {\n          return scope._nActiveControlInterpolants;\n        }\n\n      }\n    };\n  } // Memory management for AnimationAction objects\n\n\n  _isActiveAction(action) {\n    const index = action._cacheIndex;\n    return index !== null && index < this._nActiveActions;\n  }\n\n  _addInactiveAction(action, clipUuid, rootUuid) {\n    const actions = this._actions,\n          actionsByClip = this._actionsByClip;\n    let actionsForClip = actionsByClip[clipUuid];\n\n    if (actionsForClip === undefined) {\n      actionsForClip = {\n        knownActions: [action],\n        actionByRoot: {}\n      };\n      action._byClipCacheIndex = 0;\n      actionsByClip[clipUuid] = actionsForClip;\n    } else {\n      const knownActions = actionsForClip.knownActions;\n      action._byClipCacheIndex = knownActions.length;\n      knownActions.push(action);\n    }\n\n    action._cacheIndex = actions.length;\n    actions.push(action);\n    actionsForClip.actionByRoot[rootUuid] = action;\n  }\n\n  _removeInactiveAction(action) {\n    const actions = this._actions,\n          lastInactiveAction = actions[actions.length - 1],\n          cacheIndex = action._cacheIndex;\n    lastInactiveAction._cacheIndex = cacheIndex;\n    actions[cacheIndex] = lastInactiveAction;\n    actions.pop();\n    action._cacheIndex = null;\n    const clipUuid = action._clip.uuid,\n          actionsByClip = this._actionsByClip,\n          actionsForClip = actionsByClip[clipUuid],\n          knownActionsForClip = actionsForClip.knownActions,\n          lastKnownAction = knownActionsForClip[knownActionsForClip.length - 1],\n          byClipCacheIndex = action._byClipCacheIndex;\n    lastKnownAction._byClipCacheIndex = byClipCacheIndex;\n    knownActionsForClip[byClipCacheIndex] = lastKnownAction;\n    knownActionsForClip.pop();\n    action._byClipCacheIndex = null;\n    const actionByRoot = actionsForClip.actionByRoot,\n          rootUuid = (action._localRoot || this._root).uuid;\n    delete actionByRoot[rootUuid];\n\n    if (knownActionsForClip.length === 0) {\n      delete actionsByClip[clipUuid];\n    }\n\n    this._removeInactiveBindingsForAction(action);\n  }\n\n  _removeInactiveBindingsForAction(action) {\n    const bindings = action._propertyBindings;\n\n    for (let i = 0, n = bindings.length; i !== n; ++i) {\n      const binding = bindings[i];\n\n      if (--binding.referenceCount === 0) {\n        this._removeInactiveBinding(binding);\n      }\n    }\n  }\n\n  _lendAction(action) {\n    // [ active actions |  inactive actions  ]\n    // [  active actions >| inactive actions ]\n    //                 s        a\n    //                  <-swap->\n    //                 a        s\n    const actions = this._actions,\n          prevIndex = action._cacheIndex,\n          lastActiveIndex = this._nActiveActions++,\n          firstInactiveAction = actions[lastActiveIndex];\n    action._cacheIndex = lastActiveIndex;\n    actions[lastActiveIndex] = action;\n    firstInactiveAction._cacheIndex = prevIndex;\n    actions[prevIndex] = firstInactiveAction;\n  }\n\n  _takeBackAction(action) {\n    // [  active actions  | inactive actions ]\n    // [ active actions |< inactive actions  ]\n    //        a        s\n    //         <-swap->\n    //        s        a\n    const actions = this._actions,\n          prevIndex = action._cacheIndex,\n          firstInactiveIndex = --this._nActiveActions,\n          lastActiveAction = actions[firstInactiveIndex];\n    action._cacheIndex = firstInactiveIndex;\n    actions[firstInactiveIndex] = action;\n    lastActiveAction._cacheIndex = prevIndex;\n    actions[prevIndex] = lastActiveAction;\n  } // Memory management for PropertyMixer objects\n\n\n  _addInactiveBinding(binding, rootUuid, trackName) {\n    const bindingsByRoot = this._bindingsByRootAndName,\n          bindings = this._bindings;\n    let bindingByName = bindingsByRoot[rootUuid];\n\n    if (bindingByName === undefined) {\n      bindingByName = {};\n      bindingsByRoot[rootUuid] = bindingByName;\n    }\n\n    bindingByName[trackName] = binding;\n    binding._cacheIndex = bindings.length;\n    bindings.push(binding);\n  }\n\n  _removeInactiveBinding(binding) {\n    const bindings = this._bindings,\n          propBinding = binding.binding,\n          rootUuid = propBinding.rootNode.uuid,\n          trackName = propBinding.path,\n          bindingsByRoot = this._bindingsByRootAndName,\n          bindingByName = bindingsByRoot[rootUuid],\n          lastInactiveBinding = bindings[bindings.length - 1],\n          cacheIndex = binding._cacheIndex;\n    lastInactiveBinding._cacheIndex = cacheIndex;\n    bindings[cacheIndex] = lastInactiveBinding;\n    bindings.pop();\n    delete bindingByName[trackName];\n\n    if (Object.keys(bindingByName).length === 0) {\n      delete bindingsByRoot[rootUuid];\n    }\n  }\n\n  _lendBinding(binding) {\n    const bindings = this._bindings,\n          prevIndex = binding._cacheIndex,\n          lastActiveIndex = this._nActiveBindings++,\n          firstInactiveBinding = bindings[lastActiveIndex];\n    binding._cacheIndex = lastActiveIndex;\n    bindings[lastActiveIndex] = binding;\n    firstInactiveBinding._cacheIndex = prevIndex;\n    bindings[prevIndex] = firstInactiveBinding;\n  }\n\n  _takeBackBinding(binding) {\n    const bindings = this._bindings,\n          prevIndex = binding._cacheIndex,\n          firstInactiveIndex = --this._nActiveBindings,\n          lastActiveBinding = bindings[firstInactiveIndex];\n    binding._cacheIndex = firstInactiveIndex;\n    bindings[firstInactiveIndex] = binding;\n    lastActiveBinding._cacheIndex = prevIndex;\n    bindings[prevIndex] = lastActiveBinding;\n  } // Memory management of Interpolants for weight and time scale\n\n\n  _lendControlInterpolant() {\n    const interpolants = this._controlInterpolants,\n          lastActiveIndex = this._nActiveControlInterpolants++;\n    let interpolant = interpolants[lastActiveIndex];\n\n    if (interpolant === undefined) {\n      interpolant = new LinearInterpolant(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer);\n      interpolant.__cacheIndex = lastActiveIndex;\n      interpolants[lastActiveIndex] = interpolant;\n    }\n\n    return interpolant;\n  }\n\n  _takeBackControlInterpolant(interpolant) {\n    const interpolants = this._controlInterpolants,\n          prevIndex = interpolant.__cacheIndex,\n          firstInactiveIndex = --this._nActiveControlInterpolants,\n          lastActiveInterpolant = interpolants[firstInactiveIndex];\n    interpolant.__cacheIndex = firstInactiveIndex;\n    interpolants[firstInactiveIndex] = interpolant;\n    lastActiveInterpolant.__cacheIndex = prevIndex;\n    interpolants[prevIndex] = lastActiveInterpolant;\n  } // return an action for a clip optionally using a custom root target\n  // object (this method allocates a lot of dynamic memory in case a\n  // previously unknown clip/root combination is specified)\n\n\n  clipAction(clip, optionalRoot, blendMode) {\n    const root = optionalRoot || this._root,\n          rootUuid = root.uuid;\n    let clipObject = typeof clip === 'string' ? AnimationClip.findByName(root, clip) : clip;\n    const clipUuid = clipObject !== null ? clipObject.uuid : clip;\n    const actionsForClip = this._actionsByClip[clipUuid];\n    let prototypeAction = null;\n\n    if (blendMode === undefined) {\n      if (clipObject !== null) {\n        blendMode = clipObject.blendMode;\n      } else {\n        blendMode = NormalAnimationBlendMode;\n      }\n    }\n\n    if (actionsForClip !== undefined) {\n      const existingAction = actionsForClip.actionByRoot[rootUuid];\n\n      if (existingAction !== undefined && existingAction.blendMode === blendMode) {\n        return existingAction;\n      } // we know the clip, so we don't have to parse all\n      // the bindings again but can just copy\n\n\n      prototypeAction = actionsForClip.knownActions[0]; // also, take the clip from the prototype action\n\n      if (clipObject === null) clipObject = prototypeAction._clip;\n    } // clip must be known when specified via string\n\n\n    if (clipObject === null) return null; // allocate all resources required to run it\n\n    const newAction = new AnimationAction(this, clipObject, optionalRoot, blendMode);\n\n    this._bindAction(newAction, prototypeAction); // and make the action known to the memory manager\n\n\n    this._addInactiveAction(newAction, clipUuid, rootUuid);\n\n    return newAction;\n  } // get an existing action\n\n\n  existingAction(clip, optionalRoot) {\n    const root = optionalRoot || this._root,\n          rootUuid = root.uuid,\n          clipObject = typeof clip === 'string' ? AnimationClip.findByName(root, clip) : clip,\n          clipUuid = clipObject ? clipObject.uuid : clip,\n          actionsForClip = this._actionsByClip[clipUuid];\n\n    if (actionsForClip !== undefined) {\n      return actionsForClip.actionByRoot[rootUuid] || null;\n    }\n\n    return null;\n  } // deactivates all previously scheduled actions\n\n\n  stopAllAction() {\n    const actions = this._actions,\n          nActions = this._nActiveActions;\n\n    for (let i = nActions - 1; i >= 0; --i) {\n      actions[i].stop();\n    }\n\n    return this;\n  } // advance the time and update apply the animation\n\n\n  update(deltaTime) {\n    deltaTime *= this.timeScale;\n    const actions = this._actions,\n          nActions = this._nActiveActions,\n          time = this.time += deltaTime,\n          timeDirection = Math.sign(deltaTime),\n          accuIndex = this._accuIndex ^= 1; // run active actions\n\n    for (let i = 0; i !== nActions; ++i) {\n      const action = actions[i];\n\n      action._update(time, deltaTime, timeDirection, accuIndex);\n    } // update scene graph\n\n\n    const bindings = this._bindings,\n          nBindings = this._nActiveBindings;\n\n    for (let i = 0; i !== nBindings; ++i) {\n      bindings[i].apply(accuIndex);\n    }\n\n    return this;\n  } // Allows you to seek to a specific time in an animation.\n\n\n  setTime(timeInSeconds) {\n    this.time = 0; // Zero out time attribute for AnimationMixer object;\n\n    for (let i = 0; i < this._actions.length; i++) {\n      this._actions[i].time = 0; // Zero out time attribute for all associated AnimationAction objects.\n    }\n\n    return this.update(timeInSeconds); // Update used to set exact time. Returns \"this\" AnimationMixer object.\n  } // return this mixer's root target object\n\n\n  getRoot() {\n    return this._root;\n  } // free all resources specific to a particular clip\n\n\n  uncacheClip(clip) {\n    const actions = this._actions,\n          clipUuid = clip.uuid,\n          actionsByClip = this._actionsByClip,\n          actionsForClip = actionsByClip[clipUuid];\n\n    if (actionsForClip !== undefined) {\n      // note: just calling _removeInactiveAction would mess up the\n      // iteration state and also require updating the state we can\n      // just throw away\n      const actionsToRemove = actionsForClip.knownActions;\n\n      for (let i = 0, n = actionsToRemove.length; i !== n; ++i) {\n        const action = actionsToRemove[i];\n\n        this._deactivateAction(action);\n\n        const cacheIndex = action._cacheIndex,\n              lastInactiveAction = actions[actions.length - 1];\n        action._cacheIndex = null;\n        action._byClipCacheIndex = null;\n        lastInactiveAction._cacheIndex = cacheIndex;\n        actions[cacheIndex] = lastInactiveAction;\n        actions.pop();\n\n        this._removeInactiveBindingsForAction(action);\n      }\n\n      delete actionsByClip[clipUuid];\n    }\n  } // free all resources specific to a particular root target object\n\n\n  uncacheRoot(root) {\n    const rootUuid = root.uuid,\n          actionsByClip = this._actionsByClip;\n\n    for (const clipUuid in actionsByClip) {\n      const actionByRoot = actionsByClip[clipUuid].actionByRoot,\n            action = actionByRoot[rootUuid];\n\n      if (action !== undefined) {\n        this._deactivateAction(action);\n\n        this._removeInactiveAction(action);\n      }\n    }\n\n    const bindingsByRoot = this._bindingsByRootAndName,\n          bindingByName = bindingsByRoot[rootUuid];\n\n    if (bindingByName !== undefined) {\n      for (const trackName in bindingByName) {\n        const binding = bindingByName[trackName];\n        binding.restoreOriginalState();\n\n        this._removeInactiveBinding(binding);\n      }\n    }\n  } // remove a targeted clip from the cache\n\n\n  uncacheAction(clip, optionalRoot) {\n    const action = this.existingAction(clip, optionalRoot);\n\n    if (action !== null) {\n      this._deactivateAction(action);\n\n      this._removeInactiveAction(action);\n    }\n  }\n\n}\n\nAnimationMixer.prototype._controlInterpolantsResultBuffer = new Float32Array(1);\nexport { AnimationMixer };","map":{"version":3,"sources":["C:/Users/dell/Desktop/projektlogin/vue-3-authentication-jwt/src/games/three/src/animation/AnimationMixer.js"],"names":["AnimationAction","EventDispatcher","LinearInterpolant","PropertyBinding","PropertyMixer","AnimationClip","NormalAnimationBlendMode","AnimationMixer","constructor","root","_root","_initMemoryManager","_accuIndex","time","timeScale","_bindAction","action","prototypeAction","_localRoot","tracks","_clip","nTracks","length","bindings","_propertyBindings","interpolants","_interpolants","rootUuid","uuid","bindingsByRoot","_bindingsByRootAndName","bindingsByName","undefined","i","track","trackName","name","binding","referenceCount","_cacheIndex","_addInactiveBinding","path","parsedPath","create","ValueTypeName","getValueSize","resultBuffer","buffer","_activateAction","_isActiveAction","clipUuid","actionsForClip","_actionsByClip","knownActions","_addInactiveAction","n","useCount","_lendBinding","saveOriginalState","_lendAction","_deactivateAction","restoreOriginalState","_takeBackBinding","_takeBackAction","_actions","_nActiveActions","_bindings","_nActiveBindings","_controlInterpolants","_nActiveControlInterpolants","scope","stats","actions","total","inUse","controlInterpolants","index","actionsByClip","actionByRoot","_byClipCacheIndex","push","_removeInactiveAction","lastInactiveAction","cacheIndex","pop","knownActionsForClip","lastKnownAction","byClipCacheIndex","_removeInactiveBindingsForAction","_removeInactiveBinding","prevIndex","lastActiveIndex","firstInactiveAction","firstInactiveIndex","lastActiveAction","bindingByName","propBinding","rootNode","lastInactiveBinding","Object","keys","firstInactiveBinding","lastActiveBinding","_lendControlInterpolant","interpolant","Float32Array","_controlInterpolantsResultBuffer","__cacheIndex","_takeBackControlInterpolant","lastActiveInterpolant","clipAction","clip","optionalRoot","blendMode","clipObject","findByName","existingAction","newAction","stopAllAction","nActions","stop","update","deltaTime","timeDirection","Math","sign","accuIndex","_update","nBindings","apply","setTime","timeInSeconds","getRoot","uncacheClip","actionsToRemove","uncacheRoot","uncacheAction","prototype"],"mappings":"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","sourcesContent":["import { AnimationAction } from './AnimationAction.js';\r\nimport { EventDispatcher } from '../core/EventDispatcher.js';\r\nimport { LinearInterpolant } from '../math/interpolants/LinearInterpolant.js';\r\nimport { PropertyBinding } from './PropertyBinding.js';\r\nimport { PropertyMixer } from './PropertyMixer.js';\r\nimport { AnimationClip } from './AnimationClip.js';\r\nimport { NormalAnimationBlendMode } from '../constants.js';\r\n\r\nclass AnimationMixer extends EventDispatcher {\r\n\r\n\tconstructor( root ) {\r\n\r\n\t\tsuper();\r\n\r\n\t\tthis._root = root;\r\n\t\tthis._initMemoryManager();\r\n\t\tthis._accuIndex = 0;\r\n\t\tthis.time = 0;\r\n\t\tthis.timeScale = 1.0;\r\n\r\n\t}\r\n\r\n\t_bindAction( action, prototypeAction ) {\r\n\r\n\t\tconst root = action._localRoot || this._root,\r\n\t\t\ttracks = action._clip.tracks,\r\n\t\t\tnTracks = tracks.length,\r\n\t\t\tbindings = action._propertyBindings,\r\n\t\t\tinterpolants = action._interpolants,\r\n\t\t\trootUuid = root.uuid,\r\n\t\t\tbindingsByRoot = this._bindingsByRootAndName;\r\n\r\n\t\tlet bindingsByName = bindingsByRoot[ rootUuid ];\r\n\r\n\t\tif ( bindingsByName === undefined ) {\r\n\r\n\t\t\tbindingsByName = {};\r\n\t\t\tbindingsByRoot[ rootUuid ] = bindingsByName;\r\n\r\n\t\t}\r\n\r\n\t\tfor ( let i = 0; i !== nTracks; ++ i ) {\r\n\r\n\t\t\tconst track = tracks[ i ],\r\n\t\t\t\ttrackName = track.name;\r\n\r\n\t\t\tlet binding = bindingsByName[ trackName ];\r\n\r\n\t\t\tif ( binding !== undefined ) {\r\n\r\n\t\t\t\t++ binding.referenceCount;\r\n\t\t\t\tbindings[ i ] = binding;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tbinding = bindings[ i ];\r\n\r\n\t\t\t\tif ( binding !== undefined ) {\r\n\r\n\t\t\t\t\t// existing binding, make sure the cache knows\r\n\r\n\t\t\t\t\tif ( binding._cacheIndex === null ) {\r\n\r\n\t\t\t\t\t\t++ binding.referenceCount;\r\n\t\t\t\t\t\tthis._addInactiveBinding( binding, rootUuid, trackName );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconst path = prototypeAction && prototypeAction.\r\n\t\t\t\t\t_propertyBindings[ i ].binding.parsedPath;\r\n\r\n\t\t\t\tbinding = new PropertyMixer(\r\n\t\t\t\t\tPropertyBinding.create( root, trackName, path ),\r\n\t\t\t\t\ttrack.ValueTypeName, track.getValueSize() );\r\n\r\n\t\t\t\t++ binding.referenceCount;\r\n\t\t\t\tthis._addInactiveBinding( binding, rootUuid, trackName );\r\n\r\n\t\t\t\tbindings[ i ] = binding;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tinterpolants[ i ].resultBuffer = binding.buffer;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t_activateAction( action ) {\r\n\r\n\t\tif ( ! this._isActiveAction( action ) ) {\r\n\r\n\t\t\tif ( action._cacheIndex === null ) {\r\n\r\n\t\t\t\t// this action has been forgotten by the cache, but the user\r\n\t\t\t\t// appears to be still using it -> rebind\r\n\r\n\t\t\t\tconst rootUuid = ( action._localRoot || this._root ).uuid,\r\n\t\t\t\t\tclipUuid = action._clip.uuid,\r\n\t\t\t\t\tactionsForClip = this._actionsByClip[ clipUuid ];\r\n\r\n\t\t\t\tthis._bindAction( action,\r\n\t\t\t\t\tactionsForClip && actionsForClip.knownActions[ 0 ] );\r\n\r\n\t\t\t\tthis._addInactiveAction( action, clipUuid, rootUuid );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst bindings = action._propertyBindings;\r\n\r\n\t\t\t// increment reference counts / sort out state\r\n\t\t\tfor ( let i = 0, n = bindings.length; i !== n; ++ i ) {\r\n\r\n\t\t\t\tconst binding = bindings[ i ];\r\n\r\n\t\t\t\tif ( binding.useCount ++ === 0 ) {\r\n\r\n\t\t\t\t\tthis._lendBinding( binding );\r\n\t\t\t\t\tbinding.saveOriginalState();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis._lendAction( action );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t_deactivateAction( action ) {\r\n\r\n\t\tif ( this._isActiveAction( action ) ) {\r\n\r\n\t\t\tconst bindings = action._propertyBindings;\r\n\r\n\t\t\t// decrement reference counts / sort out state\r\n\t\t\tfor ( let i = 0, n = bindings.length; i !== n; ++ i ) {\r\n\r\n\t\t\t\tconst binding = bindings[ i ];\r\n\r\n\t\t\t\tif ( -- binding.useCount === 0 ) {\r\n\r\n\t\t\t\t\tbinding.restoreOriginalState();\r\n\t\t\t\t\tthis._takeBackBinding( binding );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis._takeBackAction( action );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// Memory manager\r\n\r\n\t_initMemoryManager() {\r\n\r\n\t\tthis._actions = []; // 'nActiveActions' followed by inactive ones\r\n\t\tthis._nActiveActions = 0;\r\n\r\n\t\tthis._actionsByClip = {};\r\n\t\t// inside:\r\n\t\t// {\r\n\t\t// \tknownActions: Array< AnimationAction > - used as prototypes\r\n\t\t// \tactionByRoot: AnimationAction - lookup\r\n\t\t// }\r\n\r\n\r\n\t\tthis._bindings = []; // 'nActiveBindings' followed by inactive ones\r\n\t\tthis._nActiveBindings = 0;\r\n\r\n\t\tthis._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >\r\n\r\n\r\n\t\tthis._controlInterpolants = []; // same game as above\r\n\t\tthis._nActiveControlInterpolants = 0;\r\n\r\n\t\tconst scope = this;\r\n\r\n\t\tthis.stats = {\r\n\r\n\t\t\tactions: {\r\n\t\t\t\tget total() {\r\n\r\n\t\t\t\t\treturn scope._actions.length;\r\n\r\n\t\t\t\t},\r\n\t\t\t\tget inUse() {\r\n\r\n\t\t\t\t\treturn scope._nActiveActions;\r\n\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tbindings: {\r\n\t\t\t\tget total() {\r\n\r\n\t\t\t\t\treturn scope._bindings.length;\r\n\r\n\t\t\t\t},\r\n\t\t\t\tget inUse() {\r\n\r\n\t\t\t\t\treturn scope._nActiveBindings;\r\n\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tcontrolInterpolants: {\r\n\t\t\t\tget total() {\r\n\r\n\t\t\t\t\treturn scope._controlInterpolants.length;\r\n\r\n\t\t\t\t},\r\n\t\t\t\tget inUse() {\r\n\r\n\t\t\t\t\treturn scope._nActiveControlInterpolants;\r\n\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t}\r\n\r\n\t// Memory management for AnimationAction objects\r\n\r\n\t_isActiveAction( action ) {\r\n\r\n\t\tconst index = action._cacheIndex;\r\n\t\treturn index !== null && index < this._nActiveActions;\r\n\r\n\t}\r\n\r\n\t_addInactiveAction( action, clipUuid, rootUuid ) {\r\n\r\n\t\tconst actions = this._actions,\r\n\t\t\tactionsByClip = this._actionsByClip;\r\n\r\n\t\tlet actionsForClip = actionsByClip[ clipUuid ];\r\n\r\n\t\tif ( actionsForClip === undefined ) {\r\n\r\n\t\t\tactionsForClip = {\r\n\r\n\t\t\t\tknownActions: [ action ],\r\n\t\t\t\tactionByRoot: {}\r\n\r\n\t\t\t};\r\n\r\n\t\t\taction._byClipCacheIndex = 0;\r\n\r\n\t\t\tactionsByClip[ clipUuid ] = actionsForClip;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tconst knownActions = actionsForClip.knownActions;\r\n\r\n\t\t\taction._byClipCacheIndex = knownActions.length;\r\n\t\t\tknownActions.push( action );\r\n\r\n\t\t}\r\n\r\n\t\taction._cacheIndex = actions.length;\r\n\t\tactions.push( action );\r\n\r\n\t\tactionsForClip.actionByRoot[ rootUuid ] = action;\r\n\r\n\t}\r\n\r\n\t_removeInactiveAction( action ) {\r\n\r\n\t\tconst actions = this._actions,\r\n\t\t\tlastInactiveAction = actions[ actions.length - 1 ],\r\n\t\t\tcacheIndex = action._cacheIndex;\r\n\r\n\t\tlastInactiveAction._cacheIndex = cacheIndex;\r\n\t\tactions[ cacheIndex ] = lastInactiveAction;\r\n\t\tactions.pop();\r\n\r\n\t\taction._cacheIndex = null;\r\n\r\n\r\n\t\tconst clipUuid = action._clip.uuid,\r\n\t\t\tactionsByClip = this._actionsByClip,\r\n\t\t\tactionsForClip = actionsByClip[ clipUuid ],\r\n\t\t\tknownActionsForClip = actionsForClip.knownActions,\r\n\r\n\t\t\tlastKnownAction =\r\n\t\t\t\tknownActionsForClip[ knownActionsForClip.length - 1 ],\r\n\r\n\t\t\tbyClipCacheIndex = action._byClipCacheIndex;\r\n\r\n\t\tlastKnownAction._byClipCacheIndex = byClipCacheIndex;\r\n\t\tknownActionsForClip[ byClipCacheIndex ] = lastKnownAction;\r\n\t\tknownActionsForClip.pop();\r\n\r\n\t\taction._byClipCacheIndex = null;\r\n\r\n\r\n\t\tconst actionByRoot = actionsForClip.actionByRoot,\r\n\t\t\trootUuid = ( action._localRoot || this._root ).uuid;\r\n\r\n\t\tdelete actionByRoot[ rootUuid ];\r\n\r\n\t\tif ( knownActionsForClip.length === 0 ) {\r\n\r\n\t\t\tdelete actionsByClip[ clipUuid ];\r\n\r\n\t\t}\r\n\r\n\t\tthis._removeInactiveBindingsForAction( action );\r\n\r\n\t}\r\n\r\n\t_removeInactiveBindingsForAction( action ) {\r\n\r\n\t\tconst bindings = action._propertyBindings;\r\n\r\n\t\tfor ( let i = 0, n = bindings.length; i !== n; ++ i ) {\r\n\r\n\t\t\tconst binding = bindings[ i ];\r\n\r\n\t\t\tif ( -- binding.referenceCount === 0 ) {\r\n\r\n\t\t\t\tthis._removeInactiveBinding( binding );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t_lendAction( action ) {\r\n\r\n\t\t// [ active actions |  inactive actions  ]\r\n\t\t// [  active actions >| inactive actions ]\r\n\t\t//                 s        a\r\n\t\t//                  <-swap->\r\n\t\t//                 a        s\r\n\r\n\t\tconst actions = this._actions,\r\n\t\t\tprevIndex = action._cacheIndex,\r\n\r\n\t\t\tlastActiveIndex = this._nActiveActions ++,\r\n\r\n\t\t\tfirstInactiveAction = actions[ lastActiveIndex ];\r\n\r\n\t\taction._cacheIndex = lastActiveIndex;\r\n\t\tactions[ lastActiveIndex ] = action;\r\n\r\n\t\tfirstInactiveAction._cacheIndex = prevIndex;\r\n\t\tactions[ prevIndex ] = firstInactiveAction;\r\n\r\n\t}\r\n\r\n\t_takeBackAction( action ) {\r\n\r\n\t\t// [  active actions  | inactive actions ]\r\n\t\t// [ active actions |< inactive actions  ]\r\n\t\t//        a        s\r\n\t\t//         <-swap->\r\n\t\t//        s        a\r\n\r\n\t\tconst actions = this._actions,\r\n\t\t\tprevIndex = action._cacheIndex,\r\n\r\n\t\t\tfirstInactiveIndex = -- this._nActiveActions,\r\n\r\n\t\t\tlastActiveAction = actions[ firstInactiveIndex ];\r\n\r\n\t\taction._cacheIndex = firstInactiveIndex;\r\n\t\tactions[ firstInactiveIndex ] = action;\r\n\r\n\t\tlastActiveAction._cacheIndex = prevIndex;\r\n\t\tactions[ prevIndex ] = lastActiveAction;\r\n\r\n\t}\r\n\r\n\t// Memory management for PropertyMixer objects\r\n\r\n\t_addInactiveBinding( binding, rootUuid, trackName ) {\r\n\r\n\t\tconst bindingsByRoot = this._bindingsByRootAndName,\r\n\t\t\tbindings = this._bindings;\r\n\r\n\t\tlet bindingByName = bindingsByRoot[ rootUuid ];\r\n\r\n\t\tif ( bindingByName === undefined ) {\r\n\r\n\t\t\tbindingByName = {};\r\n\t\t\tbindingsByRoot[ rootUuid ] = bindingByName;\r\n\r\n\t\t}\r\n\r\n\t\tbindingByName[ trackName ] = binding;\r\n\r\n\t\tbinding._cacheIndex = bindings.length;\r\n\t\tbindings.push( binding );\r\n\r\n\t}\r\n\r\n\t_removeInactiveBinding( binding ) {\r\n\r\n\t\tconst bindings = this._bindings,\r\n\t\t\tpropBinding = binding.binding,\r\n\t\t\trootUuid = propBinding.rootNode.uuid,\r\n\t\t\ttrackName = propBinding.path,\r\n\t\t\tbindingsByRoot = this._bindingsByRootAndName,\r\n\t\t\tbindingByName = bindingsByRoot[ rootUuid ],\r\n\r\n\t\t\tlastInactiveBinding = bindings[ bindings.length - 1 ],\r\n\t\t\tcacheIndex = binding._cacheIndex;\r\n\r\n\t\tlastInactiveBinding._cacheIndex = cacheIndex;\r\n\t\tbindings[ cacheIndex ] = lastInactiveBinding;\r\n\t\tbindings.pop();\r\n\r\n\t\tdelete bindingByName[ trackName ];\r\n\r\n\t\tif ( Object.keys( bindingByName ).length === 0 ) {\r\n\r\n\t\t\tdelete bindingsByRoot[ rootUuid ];\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t_lendBinding( binding ) {\r\n\r\n\t\tconst bindings = this._bindings,\r\n\t\t\tprevIndex = binding._cacheIndex,\r\n\r\n\t\t\tlastActiveIndex = this._nActiveBindings ++,\r\n\r\n\t\t\tfirstInactiveBinding = bindings[ lastActiveIndex ];\r\n\r\n\t\tbinding._cacheIndex = lastActiveIndex;\r\n\t\tbindings[ lastActiveIndex ] = binding;\r\n\r\n\t\tfirstInactiveBinding._cacheIndex = prevIndex;\r\n\t\tbindings[ prevIndex ] = firstInactiveBinding;\r\n\r\n\t}\r\n\r\n\t_takeBackBinding( binding ) {\r\n\r\n\t\tconst bindings = this._bindings,\r\n\t\t\tprevIndex = binding._cacheIndex,\r\n\r\n\t\t\tfirstInactiveIndex = -- this._nActiveBindings,\r\n\r\n\t\t\tlastActiveBinding = bindings[ firstInactiveIndex ];\r\n\r\n\t\tbinding._cacheIndex = firstInactiveIndex;\r\n\t\tbindings[ firstInactiveIndex ] = binding;\r\n\r\n\t\tlastActiveBinding._cacheIndex = prevIndex;\r\n\t\tbindings[ prevIndex ] = lastActiveBinding;\r\n\r\n\t}\r\n\r\n\r\n\t// Memory management of Interpolants for weight and time scale\r\n\r\n\t_lendControlInterpolant() {\r\n\r\n\t\tconst interpolants = this._controlInterpolants,\r\n\t\t\tlastActiveIndex = this._nActiveControlInterpolants ++;\r\n\r\n\t\tlet interpolant = interpolants[ lastActiveIndex ];\r\n\r\n\t\tif ( interpolant === undefined ) {\r\n\r\n\t\t\tinterpolant = new LinearInterpolant(\r\n\t\t\t\tnew Float32Array( 2 ), new Float32Array( 2 ),\r\n\t\t\t\t1, this._controlInterpolantsResultBuffer );\r\n\r\n\t\t\tinterpolant.__cacheIndex = lastActiveIndex;\r\n\t\t\tinterpolants[ lastActiveIndex ] = interpolant;\r\n\r\n\t\t}\r\n\r\n\t\treturn interpolant;\r\n\r\n\t}\r\n\r\n\t_takeBackControlInterpolant( interpolant ) {\r\n\r\n\t\tconst interpolants = this._controlInterpolants,\r\n\t\t\tprevIndex = interpolant.__cacheIndex,\r\n\r\n\t\t\tfirstInactiveIndex = -- this._nActiveControlInterpolants,\r\n\r\n\t\t\tlastActiveInterpolant = interpolants[ firstInactiveIndex ];\r\n\r\n\t\tinterpolant.__cacheIndex = firstInactiveIndex;\r\n\t\tinterpolants[ firstInactiveIndex ] = interpolant;\r\n\r\n\t\tlastActiveInterpolant.__cacheIndex = prevIndex;\r\n\t\tinterpolants[ prevIndex ] = lastActiveInterpolant;\r\n\r\n\t}\r\n\r\n\t// return an action for a clip optionally using a custom root target\r\n\t// object (this method allocates a lot of dynamic memory in case a\r\n\t// previously unknown clip/root combination is specified)\r\n\tclipAction( clip, optionalRoot, blendMode ) {\r\n\r\n\t\tconst root = optionalRoot || this._root,\r\n\t\t\trootUuid = root.uuid;\r\n\r\n\t\tlet clipObject = typeof clip === 'string' ? AnimationClip.findByName( root, clip ) : clip;\r\n\r\n\t\tconst clipUuid = clipObject !== null ? clipObject.uuid : clip;\r\n\r\n\t\tconst actionsForClip = this._actionsByClip[ clipUuid ];\r\n\t\tlet prototypeAction = null;\r\n\r\n\t\tif ( blendMode === undefined ) {\r\n\r\n\t\t\tif ( clipObject !== null ) {\r\n\r\n\t\t\t\tblendMode = clipObject.blendMode;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tblendMode = NormalAnimationBlendMode;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( actionsForClip !== undefined ) {\r\n\r\n\t\t\tconst existingAction = actionsForClip.actionByRoot[ rootUuid ];\r\n\r\n\t\t\tif ( existingAction !== undefined && existingAction.blendMode === blendMode ) {\r\n\r\n\t\t\t\treturn existingAction;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// we know the clip, so we don't have to parse all\r\n\t\t\t// the bindings again but can just copy\r\n\t\t\tprototypeAction = actionsForClip.knownActions[ 0 ];\r\n\r\n\t\t\t// also, take the clip from the prototype action\r\n\t\t\tif ( clipObject === null )\r\n\t\t\t\tclipObject = prototypeAction._clip;\r\n\r\n\t\t}\r\n\r\n\t\t// clip must be known when specified via string\r\n\t\tif ( clipObject === null ) return null;\r\n\r\n\t\t// allocate all resources required to run it\r\n\t\tconst newAction = new AnimationAction( this, clipObject, optionalRoot, blendMode );\r\n\r\n\t\tthis._bindAction( newAction, prototypeAction );\r\n\r\n\t\t// and make the action known to the memory manager\r\n\t\tthis._addInactiveAction( newAction, clipUuid, rootUuid );\r\n\r\n\t\treturn newAction;\r\n\r\n\t}\r\n\r\n\t// get an existing action\r\n\texistingAction( clip, optionalRoot ) {\r\n\r\n\t\tconst root = optionalRoot || this._root,\r\n\t\t\trootUuid = root.uuid,\r\n\r\n\t\t\tclipObject = typeof clip === 'string' ?\r\n\t\t\t\tAnimationClip.findByName( root, clip ) : clip,\r\n\r\n\t\t\tclipUuid = clipObject ? clipObject.uuid : clip,\r\n\r\n\t\t\tactionsForClip = this._actionsByClip[ clipUuid ];\r\n\r\n\t\tif ( actionsForClip !== undefined ) {\r\n\r\n\t\t\treturn actionsForClip.actionByRoot[ rootUuid ] || null;\r\n\r\n\t\t}\r\n\r\n\t\treturn null;\r\n\r\n\t}\r\n\r\n\t// deactivates all previously scheduled actions\r\n\tstopAllAction() {\r\n\r\n\t\tconst actions = this._actions,\r\n\t\t\tnActions = this._nActiveActions;\r\n\r\n\t\tfor ( let i = nActions - 1; i >= 0; -- i ) {\r\n\r\n\t\t\tactions[ i ].stop();\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t// advance the time and update apply the animation\r\n\tupdate( deltaTime ) {\r\n\r\n\t\tdeltaTime *= this.timeScale;\r\n\r\n\t\tconst actions = this._actions,\r\n\t\t\tnActions = this._nActiveActions,\r\n\r\n\t\t\ttime = this.time += deltaTime,\r\n\t\t\ttimeDirection = Math.sign( deltaTime ),\r\n\r\n\t\t\taccuIndex = this._accuIndex ^= 1;\r\n\r\n\t\t// run active actions\r\n\r\n\t\tfor ( let i = 0; i !== nActions; ++ i ) {\r\n\r\n\t\t\tconst action = actions[ i ];\r\n\r\n\t\t\taction._update( time, deltaTime, timeDirection, accuIndex );\r\n\r\n\t\t}\r\n\r\n\t\t// update scene graph\r\n\r\n\t\tconst bindings = this._bindings,\r\n\t\t\tnBindings = this._nActiveBindings;\r\n\r\n\t\tfor ( let i = 0; i !== nBindings; ++ i ) {\r\n\r\n\t\t\tbindings[ i ].apply( accuIndex );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t// Allows you to seek to a specific time in an animation.\r\n\tsetTime( timeInSeconds ) {\r\n\r\n\t\tthis.time = 0; // Zero out time attribute for AnimationMixer object;\r\n\t\tfor ( let i = 0; i < this._actions.length; i ++ ) {\r\n\r\n\t\t\tthis._actions[ i ].time = 0; // Zero out time attribute for all associated AnimationAction objects.\r\n\r\n\t\t}\r\n\r\n\t\treturn this.update( timeInSeconds ); // Update used to set exact time. Returns \"this\" AnimationMixer object.\r\n\r\n\t}\r\n\r\n\t// return this mixer's root target object\r\n\tgetRoot() {\r\n\r\n\t\treturn this._root;\r\n\r\n\t}\r\n\r\n\t// free all resources specific to a particular clip\r\n\tuncacheClip( clip ) {\r\n\r\n\t\tconst actions = this._actions,\r\n\t\t\tclipUuid = clip.uuid,\r\n\t\t\tactionsByClip = this._actionsByClip,\r\n\t\t\tactionsForClip = actionsByClip[ clipUuid ];\r\n\r\n\t\tif ( actionsForClip !== undefined ) {\r\n\r\n\t\t\t// note: just calling _removeInactiveAction would mess up the\r\n\t\t\t// iteration state and also require updating the state we can\r\n\t\t\t// just throw away\r\n\r\n\t\t\tconst actionsToRemove = actionsForClip.knownActions;\r\n\r\n\t\t\tfor ( let i = 0, n = actionsToRemove.length; i !== n; ++ i ) {\r\n\r\n\t\t\t\tconst action = actionsToRemove[ i ];\r\n\r\n\t\t\t\tthis._deactivateAction( action );\r\n\r\n\t\t\t\tconst cacheIndex = action._cacheIndex,\r\n\t\t\t\t\tlastInactiveAction = actions[ actions.length - 1 ];\r\n\r\n\t\t\t\taction._cacheIndex = null;\r\n\t\t\t\taction._byClipCacheIndex = null;\r\n\r\n\t\t\t\tlastInactiveAction._cacheIndex = cacheIndex;\r\n\t\t\t\tactions[ cacheIndex ] = lastInactiveAction;\r\n\t\t\t\tactions.pop();\r\n\r\n\t\t\t\tthis._removeInactiveBindingsForAction( action );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tdelete actionsByClip[ clipUuid ];\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// free all resources specific to a particular root target object\r\n\tuncacheRoot( root ) {\r\n\r\n\t\tconst rootUuid = root.uuid,\r\n\t\t\tactionsByClip = this._actionsByClip;\r\n\r\n\t\tfor ( const clipUuid in actionsByClip ) {\r\n\r\n\t\t\tconst actionByRoot = actionsByClip[ clipUuid ].actionByRoot,\r\n\t\t\t\taction = actionByRoot[ rootUuid ];\r\n\r\n\t\t\tif ( action !== undefined ) {\r\n\r\n\t\t\t\tthis._deactivateAction( action );\r\n\t\t\t\tthis._removeInactiveAction( action );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tconst bindingsByRoot = this._bindingsByRootAndName,\r\n\t\t\tbindingByName = bindingsByRoot[ rootUuid ];\r\n\r\n\t\tif ( bindingByName !== undefined ) {\r\n\r\n\t\t\tfor ( const trackName in bindingByName ) {\r\n\r\n\t\t\t\tconst binding = bindingByName[ trackName ];\r\n\t\t\t\tbinding.restoreOriginalState();\r\n\t\t\t\tthis._removeInactiveBinding( binding );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// remove a targeted clip from the cache\r\n\tuncacheAction( clip, optionalRoot ) {\r\n\r\n\t\tconst action = this.existingAction( clip, optionalRoot );\r\n\r\n\t\tif ( action !== null ) {\r\n\r\n\t\t\tthis._deactivateAction( action );\r\n\t\t\tthis._removeInactiveAction( action );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nAnimationMixer.prototype._controlInterpolantsResultBuffer = new Float32Array( 1 );\r\n\r\nexport { AnimationMixer };\r\n"]},"metadata":{},"sourceType":"module"}