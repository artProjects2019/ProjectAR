{"ast":null,"code":"/**\r\n * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system\r\n *\r\n * The polar angle (phi) is measured from the positive y-axis. The positive y-axis is up.\r\n * The azimuthal angle (theta) is measured from the positive z-axis.\r\n */\nimport * as MathUtils from './MathUtils.js';\n\nclass Spherical {\n  constructor(radius = 1, phi = 0, theta = 0) {\n    this.radius = radius;\n    this.phi = phi; // polar angle\n\n    this.theta = theta; // azimuthal angle\n\n    return this;\n  }\n\n  set(radius, phi, theta) {\n    this.radius = radius;\n    this.phi = phi;\n    this.theta = theta;\n    return this;\n  }\n\n  copy(other) {\n    this.radius = other.radius;\n    this.phi = other.phi;\n    this.theta = other.theta;\n    return this;\n  } // restrict phi to be betwee EPS and PI-EPS\n\n\n  makeSafe() {\n    const EPS = 0.000001;\n    this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi));\n    return this;\n  }\n\n  setFromVector3(v) {\n    return this.setFromCartesianCoords(v.x, v.y, v.z);\n  }\n\n  setFromCartesianCoords(x, y, z) {\n    this.radius = Math.sqrt(x * x + y * y + z * z);\n\n    if (this.radius === 0) {\n      this.theta = 0;\n      this.phi = 0;\n    } else {\n      this.theta = Math.atan2(x, z);\n      this.phi = Math.acos(MathUtils.clamp(y / this.radius, -1, 1));\n    }\n\n    return this;\n  }\n\n  clone() {\n    return new this.constructor().copy(this);\n  }\n\n}\n\nexport { Spherical };","map":{"version":3,"sources":["C:/Users/dell/Desktop/projektlogin/vue-3-authentication-jwt/src/games/three/src/math/Spherical.js"],"names":["MathUtils","Spherical","constructor","radius","phi","theta","set","copy","other","makeSafe","EPS","Math","max","min","PI","setFromVector3","v","setFromCartesianCoords","x","y","z","sqrt","atan2","acos","clamp","clone"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AAEA,OAAO,KAAKA,SAAZ,MAA2B,gBAA3B;;AAEA,MAAMC,SAAN,CAAgB;AAEfC,EAAAA,WAAW,CAAEC,MAAM,GAAG,CAAX,EAAcC,GAAG,GAAG,CAApB,EAAuBC,KAAK,GAAG,CAA/B,EAAmC;AAE7C,SAAKF,MAAL,GAAcA,MAAd;AACA,SAAKC,GAAL,GAAWA,GAAX,CAH6C,CAG7B;;AAChB,SAAKC,KAAL,GAAaA,KAAb,CAJ6C,CAIzB;;AAEpB,WAAO,IAAP;AAEA;;AAEDC,EAAAA,GAAG,CAAEH,MAAF,EAAUC,GAAV,EAAeC,KAAf,EAAuB;AAEzB,SAAKF,MAAL,GAAcA,MAAd;AACA,SAAKC,GAAL,GAAWA,GAAX;AACA,SAAKC,KAAL,GAAaA,KAAb;AAEA,WAAO,IAAP;AAEA;;AAEDE,EAAAA,IAAI,CAAEC,KAAF,EAAU;AAEb,SAAKL,MAAL,GAAcK,KAAK,CAACL,MAApB;AACA,SAAKC,GAAL,GAAWI,KAAK,CAACJ,GAAjB;AACA,SAAKC,KAAL,GAAaG,KAAK,CAACH,KAAnB;AAEA,WAAO,IAAP;AAEA,GA9Bc,CAgCf;;;AACAI,EAAAA,QAAQ,GAAG;AAEV,UAAMC,GAAG,GAAG,QAAZ;AACA,SAAKN,GAAL,GAAWO,IAAI,CAACC,GAAL,CAAUF,GAAV,EAAeC,IAAI,CAACE,GAAL,CAAUF,IAAI,CAACG,EAAL,GAAUJ,GAApB,EAAyB,KAAKN,GAA9B,CAAf,CAAX;AAEA,WAAO,IAAP;AAEA;;AAEDW,EAAAA,cAAc,CAAEC,CAAF,EAAM;AAEnB,WAAO,KAAKC,sBAAL,CAA6BD,CAAC,CAACE,CAA/B,EAAkCF,CAAC,CAACG,CAApC,EAAuCH,CAAC,CAACI,CAAzC,CAAP;AAEA;;AAEDH,EAAAA,sBAAsB,CAAEC,CAAF,EAAKC,CAAL,EAAQC,CAAR,EAAY;AAEjC,SAAKjB,MAAL,GAAcQ,IAAI,CAACU,IAAL,CAAWH,CAAC,GAAGA,CAAJ,GAAQC,CAAC,GAAGA,CAAZ,GAAgBC,CAAC,GAAGA,CAA/B,CAAd;;AAEA,QAAK,KAAKjB,MAAL,KAAgB,CAArB,EAAyB;AAExB,WAAKE,KAAL,GAAa,CAAb;AACA,WAAKD,GAAL,GAAW,CAAX;AAEA,KALD,MAKO;AAEN,WAAKC,KAAL,GAAaM,IAAI,CAACW,KAAL,CAAYJ,CAAZ,EAAeE,CAAf,CAAb;AACA,WAAKhB,GAAL,GAAWO,IAAI,CAACY,IAAL,CAAWvB,SAAS,CAACwB,KAAV,CAAiBL,CAAC,GAAG,KAAKhB,MAA1B,EAAkC,CAAE,CAApC,EAAuC,CAAvC,CAAX,CAAX;AAEA;;AAED,WAAO,IAAP;AAEA;;AAEDsB,EAAAA,KAAK,GAAG;AAEP,WAAO,IAAI,KAAKvB,WAAT,GAAuBK,IAAvB,CAA6B,IAA7B,CAAP;AAEA;;AAxEc;;AA4EhB,SAASN,SAAT","sourcesContent":["/**\r\n * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system\r\n *\r\n * The polar angle (phi) is measured from the positive y-axis. The positive y-axis is up.\r\n * The azimuthal angle (theta) is measured from the positive z-axis.\r\n */\r\n\r\nimport * as MathUtils from './MathUtils.js';\r\n\r\nclass Spherical {\r\n\r\n\tconstructor( radius = 1, phi = 0, theta = 0 ) {\r\n\r\n\t\tthis.radius = radius;\r\n\t\tthis.phi = phi; // polar angle\r\n\t\tthis.theta = theta; // azimuthal angle\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tset( radius, phi, theta ) {\r\n\r\n\t\tthis.radius = radius;\r\n\t\tthis.phi = phi;\r\n\t\tthis.theta = theta;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tcopy( other ) {\r\n\r\n\t\tthis.radius = other.radius;\r\n\t\tthis.phi = other.phi;\r\n\t\tthis.theta = other.theta;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t// restrict phi to be betwee EPS and PI-EPS\r\n\tmakeSafe() {\r\n\r\n\t\tconst EPS = 0.000001;\r\n\t\tthis.phi = Math.max( EPS, Math.min( Math.PI - EPS, this.phi ) );\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tsetFromVector3( v ) {\r\n\r\n\t\treturn this.setFromCartesianCoords( v.x, v.y, v.z );\r\n\r\n\t}\r\n\r\n\tsetFromCartesianCoords( x, y, z ) {\r\n\r\n\t\tthis.radius = Math.sqrt( x * x + y * y + z * z );\r\n\r\n\t\tif ( this.radius === 0 ) {\r\n\r\n\t\t\tthis.theta = 0;\r\n\t\t\tthis.phi = 0;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.theta = Math.atan2( x, z );\r\n\t\t\tthis.phi = Math.acos( MathUtils.clamp( y / this.radius, - 1, 1 ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tclone() {\r\n\r\n\t\treturn new this.constructor().copy( this );\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport { Spherical };\r\n"]},"metadata":{},"sourceType":"module"}