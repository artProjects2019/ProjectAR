{"ast":null,"code":"import { CubeReflectionMapping, CubeRefractionMapping, EquirectangularReflectionMapping, EquirectangularRefractionMapping } from '../../constants.js';\nimport { PMREMGenerator } from '../../extras/PMREMGenerator.js';\n\nfunction WebGLCubeUVMaps(renderer) {\n  let cubeUVmaps = new WeakMap();\n  let pmremGenerator = null;\n\n  function get(texture) {\n    if (texture && texture.isTexture) {\n      const mapping = texture.mapping;\n      const isEquirectMap = mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping;\n      const isCubeMap = mapping === CubeReflectionMapping || mapping === CubeRefractionMapping; // equirect/cube map to cubeUV conversion\n\n      if (isEquirectMap || isCubeMap) {\n        if (texture.isRenderTargetTexture && texture.needsPMREMUpdate === true) {\n          texture.needsPMREMUpdate = false;\n          let renderTarget = cubeUVmaps.get(texture);\n          if (pmremGenerator === null) pmremGenerator = new PMREMGenerator(renderer);\n          renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular(texture, renderTarget) : pmremGenerator.fromCubemap(texture, renderTarget);\n          cubeUVmaps.set(texture, renderTarget);\n          return renderTarget.texture;\n        } else {\n          if (cubeUVmaps.has(texture)) {\n            return cubeUVmaps.get(texture).texture;\n          } else {\n            const image = texture.image;\n\n            if (isEquirectMap && image && image.height > 0 || isCubeMap && image && isCubeTextureComplete(image)) {\n              if (pmremGenerator === null) pmremGenerator = new PMREMGenerator(renderer);\n              const renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular(texture) : pmremGenerator.fromCubemap(texture);\n              cubeUVmaps.set(texture, renderTarget);\n              texture.addEventListener('dispose', onTextureDispose);\n              return renderTarget.texture;\n            } else {\n              // image not yet ready. try the conversion next frame\n              return null;\n            }\n          }\n        }\n      }\n    }\n\n    return texture;\n  }\n\n  function isCubeTextureComplete(image) {\n    let count = 0;\n    const length = 6;\n\n    for (let i = 0; i < length; i++) {\n      if (image[i] !== undefined) count++;\n    }\n\n    return count === length;\n  }\n\n  function onTextureDispose(event) {\n    const texture = event.target;\n    texture.removeEventListener('dispose', onTextureDispose);\n    const cubemapUV = cubeUVmaps.get(texture);\n\n    if (cubemapUV !== undefined) {\n      cubeUVmaps.delete(texture);\n      cubemapUV.dispose();\n    }\n  }\n\n  function dispose() {\n    cubeUVmaps = new WeakMap();\n\n    if (pmremGenerator !== null) {\n      pmremGenerator.dispose();\n      pmremGenerator = null;\n    }\n  }\n\n  return {\n    get: get,\n    dispose: dispose\n  };\n}\n\nexport { WebGLCubeUVMaps };","map":{"version":3,"sources":["C:/Users/dell/Desktop/projektlogin/vue-3-authentication-jwt/src/games/three/src/renderers/webgl/WebGLCubeUVMaps.js"],"names":["CubeReflectionMapping","CubeRefractionMapping","EquirectangularReflectionMapping","EquirectangularRefractionMapping","PMREMGenerator","WebGLCubeUVMaps","renderer","cubeUVmaps","WeakMap","pmremGenerator","get","texture","isTexture","mapping","isEquirectMap","isCubeMap","isRenderTargetTexture","needsPMREMUpdate","renderTarget","fromEquirectangular","fromCubemap","set","has","image","height","isCubeTextureComplete","addEventListener","onTextureDispose","count","length","i","undefined","event","target","removeEventListener","cubemapUV","delete","dispose"],"mappings":"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","sourcesContent":["import { CubeReflectionMapping, CubeRefractionMapping, EquirectangularReflectionMapping, EquirectangularRefractionMapping } from '../../constants.js';\r\nimport { PMREMGenerator } from '../../extras/PMREMGenerator.js';\r\n\r\nfunction WebGLCubeUVMaps( renderer ) {\r\n\r\n\tlet cubeUVmaps = new WeakMap();\r\n\r\n\tlet pmremGenerator = null;\r\n\r\n\tfunction get( texture ) {\r\n\r\n\t\tif ( texture && texture.isTexture ) {\r\n\r\n\t\t\tconst mapping = texture.mapping;\r\n\r\n\t\t\tconst isEquirectMap = ( mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping );\r\n\t\t\tconst isCubeMap = ( mapping === CubeReflectionMapping || mapping === CubeRefractionMapping );\r\n\r\n\t\t\t// equirect/cube map to cubeUV conversion\r\n\r\n\t\t\tif ( isEquirectMap || isCubeMap ) {\r\n\r\n\t\t\t\tif ( texture.isRenderTargetTexture && texture.needsPMREMUpdate === true ) {\r\n\r\n\t\t\t\t\ttexture.needsPMREMUpdate = false;\r\n\r\n\t\t\t\t\tlet renderTarget = cubeUVmaps.get( texture );\r\n\r\n\t\t\t\t\tif ( pmremGenerator === null ) pmremGenerator = new PMREMGenerator( renderer );\r\n\r\n\t\t\t\t\trenderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular( texture, renderTarget ) : pmremGenerator.fromCubemap( texture, renderTarget );\r\n\t\t\t\t\tcubeUVmaps.set( texture, renderTarget );\r\n\r\n\t\t\t\t\treturn renderTarget.texture;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tif ( cubeUVmaps.has( texture ) ) {\r\n\r\n\t\t\t\t\t\treturn cubeUVmaps.get( texture ).texture;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tconst image = texture.image;\r\n\r\n\t\t\t\t\t\tif ( ( isEquirectMap && image && image.height > 0 ) || ( isCubeMap && image && isCubeTextureComplete( image ) ) ) {\r\n\r\n\t\t\t\t\t\t\tif ( pmremGenerator === null ) pmremGenerator = new PMREMGenerator( renderer );\r\n\r\n\t\t\t\t\t\t\tconst renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular( texture ) : pmremGenerator.fromCubemap( texture );\r\n\t\t\t\t\t\t\tcubeUVmaps.set( texture, renderTarget );\r\n\r\n\t\t\t\t\t\t\ttexture.addEventListener( 'dispose', onTextureDispose );\r\n\r\n\t\t\t\t\t\t\treturn renderTarget.texture;\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t// image not yet ready. try the conversion next frame\r\n\r\n\t\t\t\t\t\t\treturn null;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn texture;\r\n\r\n\t}\r\n\r\n\tfunction isCubeTextureComplete( image ) {\r\n\r\n\t\tlet count = 0;\r\n\t\tconst length = 6;\r\n\r\n\t\tfor ( let i = 0; i < length; i ++ ) {\r\n\r\n\t\t\tif ( image[ i ] !== undefined ) count ++;\r\n\r\n\t\t}\r\n\r\n\t\treturn count === length;\r\n\r\n\r\n\t}\r\n\r\n\tfunction onTextureDispose( event ) {\r\n\r\n\t\tconst texture = event.target;\r\n\r\n\t\ttexture.removeEventListener( 'dispose', onTextureDispose );\r\n\r\n\t\tconst cubemapUV = cubeUVmaps.get( texture );\r\n\r\n\t\tif ( cubemapUV !== undefined ) {\r\n\r\n\t\t\tcubeUVmaps.delete( texture );\r\n\t\t\tcubemapUV.dispose();\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction dispose() {\r\n\r\n\t\tcubeUVmaps = new WeakMap();\r\n\r\n\t\tif ( pmremGenerator !== null ) {\r\n\r\n\t\t\tpmremGenerator.dispose();\r\n\t\t\tpmremGenerator = null;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn {\r\n\t\tget: get,\r\n\t\tdispose: dispose\r\n\t};\r\n\r\n}\r\n\r\nexport { WebGLCubeUVMaps };\r\n"]},"metadata":{},"sourceType":"module"}