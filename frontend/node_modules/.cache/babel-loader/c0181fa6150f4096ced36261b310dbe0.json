{"ast":null,"code":"import { Curve } from './Curve.js';\nimport * as Curves from '../curves/Curves.js';\n/**************************************************************\r\n *\tCurved Path - a curve path is simply a array of connected\r\n *  curves, but retains the api of a curve\r\n **************************************************************/\n\nclass CurvePath extends Curve {\n  constructor() {\n    super();\n    this.type = 'CurvePath';\n    this.curves = [];\n    this.autoClose = false; // Automatically closes the path\n  }\n\n  add(curve) {\n    this.curves.push(curve);\n  }\n\n  closePath() {\n    // Add a line curve if start and end of lines are not connected\n    const startPoint = this.curves[0].getPoint(0);\n    const endPoint = this.curves[this.curves.length - 1].getPoint(1);\n\n    if (!startPoint.equals(endPoint)) {\n      this.curves.push(new Curves['LineCurve'](endPoint, startPoint));\n    }\n  } // To get accurate point with reference to\n  // entire path distance at time t,\n  // following has to be done:\n  // 1. Length of each sub path have to be known\n  // 2. Locate and identify type of curve\n  // 3. Get t for the curve\n  // 4. Return curve.getPointAt(t')\n\n\n  getPoint(t, optionalTarget) {\n    const d = t * this.getLength();\n    const curveLengths = this.getCurveLengths();\n    let i = 0; // To think about boundaries points.\n\n    while (i < curveLengths.length) {\n      if (curveLengths[i] >= d) {\n        const diff = curveLengths[i] - d;\n        const curve = this.curves[i];\n        const segmentLength = curve.getLength();\n        const u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;\n        return curve.getPointAt(u, optionalTarget);\n      }\n\n      i++;\n    }\n\n    return null; // loop where sum != 0, sum > d , sum+1 <d\n  } // We cannot use the default THREE.Curve getPoint() with getLength() because in\n  // THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath\n  // getPoint() depends on getLength\n\n\n  getLength() {\n    const lens = this.getCurveLengths();\n    return lens[lens.length - 1];\n  } // cacheLengths must be recalculated.\n\n\n  updateArcLengths() {\n    this.needsUpdate = true;\n    this.cacheLengths = null;\n    this.getCurveLengths();\n  } // Compute lengths and cache them\n  // We cannot overwrite getLengths() because UtoT mapping uses it.\n\n\n  getCurveLengths() {\n    // We use cache values if curves and cache array are same length\n    if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {\n      return this.cacheLengths;\n    } // Get length of sub-curve\n    // Push sums into cached array\n\n\n    const lengths = [];\n    let sums = 0;\n\n    for (let i = 0, l = this.curves.length; i < l; i++) {\n      sums += this.curves[i].getLength();\n      lengths.push(sums);\n    }\n\n    this.cacheLengths = lengths;\n    return lengths;\n  }\n\n  getSpacedPoints(divisions = 40) {\n    const points = [];\n\n    for (let i = 0; i <= divisions; i++) {\n      points.push(this.getPoint(i / divisions));\n    }\n\n    if (this.autoClose) {\n      points.push(points[0]);\n    }\n\n    return points;\n  }\n\n  getPoints(divisions = 12) {\n    const points = [];\n    let last;\n\n    for (let i = 0, curves = this.curves; i < curves.length; i++) {\n      const curve = curves[i];\n      const resolution = curve.isEllipseCurve ? divisions * 2 : curve.isLineCurve || curve.isLineCurve3 ? 1 : curve.isSplineCurve ? divisions * curve.points.length : divisions;\n      const pts = curve.getPoints(resolution);\n\n      for (let j = 0; j < pts.length; j++) {\n        const point = pts[j];\n        if (last && last.equals(point)) continue; // ensures no consecutive points are duplicates\n\n        points.push(point);\n        last = point;\n      }\n    }\n\n    if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {\n      points.push(points[0]);\n    }\n\n    return points;\n  }\n\n  copy(source) {\n    super.copy(source);\n    this.curves = [];\n\n    for (let i = 0, l = source.curves.length; i < l; i++) {\n      const curve = source.curves[i];\n      this.curves.push(curve.clone());\n    }\n\n    this.autoClose = source.autoClose;\n    return this;\n  }\n\n  toJSON() {\n    const data = super.toJSON();\n    data.autoClose = this.autoClose;\n    data.curves = [];\n\n    for (let i = 0, l = this.curves.length; i < l; i++) {\n      const curve = this.curves[i];\n      data.curves.push(curve.toJSON());\n    }\n\n    return data;\n  }\n\n  fromJSON(json) {\n    super.fromJSON(json);\n    this.autoClose = json.autoClose;\n    this.curves = [];\n\n    for (let i = 0, l = json.curves.length; i < l; i++) {\n      const curve = json.curves[i];\n      this.curves.push(new Curves[curve.type]().fromJSON(curve));\n    }\n\n    return this;\n  }\n\n}\n\nexport { CurvePath };","map":{"version":3,"sources":["C:/Users/dell/Desktop/projektlogin/vue-3-authentication-jwt/src/games/three/src/extras/core/CurvePath.js"],"names":["Curve","Curves","CurvePath","constructor","type","curves","autoClose","add","curve","push","closePath","startPoint","getPoint","endPoint","length","equals","t","optionalTarget","d","getLength","curveLengths","getCurveLengths","i","diff","segmentLength","u","getPointAt","lens","updateArcLengths","needsUpdate","cacheLengths","lengths","sums","l","getSpacedPoints","divisions","points","getPoints","last","resolution","isEllipseCurve","isLineCurve","isLineCurve3","isSplineCurve","pts","j","point","copy","source","clone","toJSON","data","fromJSON","json"],"mappings":"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","sourcesContent":["import { Curve } from './Curve.js';\r\nimport * as Curves from '../curves/Curves.js';\r\n\r\n/**************************************************************\r\n *\tCurved Path - a curve path is simply a array of connected\r\n *  curves, but retains the api of a curve\r\n **************************************************************/\r\n\r\nclass CurvePath extends Curve {\r\n\r\n\tconstructor() {\r\n\r\n\t\tsuper();\r\n\r\n\t\tthis.type = 'CurvePath';\r\n\r\n\t\tthis.curves = [];\r\n\t\tthis.autoClose = false; // Automatically closes the path\r\n\r\n\t}\r\n\r\n\tadd( curve ) {\r\n\r\n\t\tthis.curves.push( curve );\r\n\r\n\t}\r\n\r\n\tclosePath() {\r\n\r\n\t\t// Add a line curve if start and end of lines are not connected\r\n\t\tconst startPoint = this.curves[ 0 ].getPoint( 0 );\r\n\t\tconst endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );\r\n\r\n\t\tif ( ! startPoint.equals( endPoint ) ) {\r\n\r\n\t\t\tthis.curves.push( new Curves[ 'LineCurve' ]( endPoint, startPoint ) );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// To get accurate point with reference to\r\n\t// entire path distance at time t,\r\n\t// following has to be done:\r\n\r\n\t// 1. Length of each sub path have to be known\r\n\t// 2. Locate and identify type of curve\r\n\t// 3. Get t for the curve\r\n\t// 4. Return curve.getPointAt(t')\r\n\r\n\tgetPoint( t, optionalTarget ) {\r\n\r\n\t\tconst d = t * this.getLength();\r\n\t\tconst curveLengths = this.getCurveLengths();\r\n\t\tlet i = 0;\r\n\r\n\t\t// To think about boundaries points.\r\n\r\n\t\twhile ( i < curveLengths.length ) {\r\n\r\n\t\t\tif ( curveLengths[ i ] >= d ) {\r\n\r\n\t\t\t\tconst diff = curveLengths[ i ] - d;\r\n\t\t\t\tconst curve = this.curves[ i ];\r\n\r\n\t\t\t\tconst segmentLength = curve.getLength();\r\n\t\t\t\tconst u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;\r\n\r\n\t\t\t\treturn curve.getPointAt( u, optionalTarget );\r\n\r\n\t\t\t}\r\n\r\n\t\t\ti ++;\r\n\r\n\t\t}\r\n\r\n\t\treturn null;\r\n\r\n\t\t// loop where sum != 0, sum > d , sum+1 <d\r\n\r\n\t}\r\n\r\n\t// We cannot use the default THREE.Curve getPoint() with getLength() because in\r\n\t// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath\r\n\t// getPoint() depends on getLength\r\n\r\n\tgetLength() {\r\n\r\n\t\tconst lens = this.getCurveLengths();\r\n\t\treturn lens[ lens.length - 1 ];\r\n\r\n\t}\r\n\r\n\t// cacheLengths must be recalculated.\r\n\tupdateArcLengths() {\r\n\r\n\t\tthis.needsUpdate = true;\r\n\t\tthis.cacheLengths = null;\r\n\t\tthis.getCurveLengths();\r\n\r\n\t}\r\n\r\n\t// Compute lengths and cache them\r\n\t// We cannot overwrite getLengths() because UtoT mapping uses it.\r\n\r\n\tgetCurveLengths() {\r\n\r\n\t\t// We use cache values if curves and cache array are same length\r\n\r\n\t\tif ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {\r\n\r\n\t\t\treturn this.cacheLengths;\r\n\r\n\t\t}\r\n\r\n\t\t// Get length of sub-curve\r\n\t\t// Push sums into cached array\r\n\r\n\t\tconst lengths = [];\r\n\t\tlet sums = 0;\r\n\r\n\t\tfor ( let i = 0, l = this.curves.length; i < l; i ++ ) {\r\n\r\n\t\t\tsums += this.curves[ i ].getLength();\r\n\t\t\tlengths.push( sums );\r\n\r\n\t\t}\r\n\r\n\t\tthis.cacheLengths = lengths;\r\n\r\n\t\treturn lengths;\r\n\r\n\t}\r\n\r\n\tgetSpacedPoints( divisions = 40 ) {\r\n\r\n\t\tconst points = [];\r\n\r\n\t\tfor ( let i = 0; i <= divisions; i ++ ) {\r\n\r\n\t\t\tpoints.push( this.getPoint( i / divisions ) );\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.autoClose ) {\r\n\r\n\t\t\tpoints.push( points[ 0 ] );\r\n\r\n\t\t}\r\n\r\n\t\treturn points;\r\n\r\n\t}\r\n\r\n\tgetPoints( divisions = 12 ) {\r\n\r\n\t\tconst points = [];\r\n\t\tlet last;\r\n\r\n\t\tfor ( let i = 0, curves = this.curves; i < curves.length; i ++ ) {\r\n\r\n\t\t\tconst curve = curves[ i ];\r\n\t\t\tconst resolution = curve.isEllipseCurve ? divisions * 2\r\n\t\t\t\t: ( curve.isLineCurve || curve.isLineCurve3 ) ? 1\r\n\t\t\t\t\t: curve.isSplineCurve ? divisions * curve.points.length\r\n\t\t\t\t\t\t: divisions;\r\n\r\n\t\t\tconst pts = curve.getPoints( resolution );\r\n\r\n\t\t\tfor ( let j = 0; j < pts.length; j ++ ) {\r\n\r\n\t\t\t\tconst point = pts[ j ];\r\n\r\n\t\t\t\tif ( last && last.equals( point ) ) continue; // ensures no consecutive points are duplicates\r\n\r\n\t\t\t\tpoints.push( point );\r\n\t\t\t\tlast = point;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.autoClose && points.length > 1 && ! points[ points.length - 1 ].equals( points[ 0 ] ) ) {\r\n\r\n\t\t\tpoints.push( points[ 0 ] );\r\n\r\n\t\t}\r\n\r\n\t\treturn points;\r\n\r\n\t}\r\n\r\n\tcopy( source ) {\r\n\r\n\t\tsuper.copy( source );\r\n\r\n\t\tthis.curves = [];\r\n\r\n\t\tfor ( let i = 0, l = source.curves.length; i < l; i ++ ) {\r\n\r\n\t\t\tconst curve = source.curves[ i ];\r\n\r\n\t\t\tthis.curves.push( curve.clone() );\r\n\r\n\t\t}\r\n\r\n\t\tthis.autoClose = source.autoClose;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\ttoJSON() {\r\n\r\n\t\tconst data = super.toJSON();\r\n\r\n\t\tdata.autoClose = this.autoClose;\r\n\t\tdata.curves = [];\r\n\r\n\t\tfor ( let i = 0, l = this.curves.length; i < l; i ++ ) {\r\n\r\n\t\t\tconst curve = this.curves[ i ];\r\n\t\t\tdata.curves.push( curve.toJSON() );\r\n\r\n\t\t}\r\n\r\n\t\treturn data;\r\n\r\n\t}\r\n\r\n\tfromJSON( json ) {\r\n\r\n\t\tsuper.fromJSON( json );\r\n\r\n\t\tthis.autoClose = json.autoClose;\r\n\t\tthis.curves = [];\r\n\r\n\t\tfor ( let i = 0, l = json.curves.length; i < l; i ++ ) {\r\n\r\n\t\t\tconst curve = json.curves[ i ];\r\n\t\t\tthis.curves.push( new Curves[ curve.type ]().fromJSON( curve ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\nexport { CurvePath };\r\n"]},"metadata":{},"sourceType":"module"}