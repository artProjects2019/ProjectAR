{"ast":null,"code":"import { LinearFilter } from '../constants.js';\nimport { FileLoader } from './FileLoader.js';\nimport { CompressedTexture } from '../textures/CompressedTexture.js';\nimport { Loader } from './Loader.js';\n/**\r\n * Abstract Base class to block based textures loader (dds, pvr, ...)\r\n *\r\n * Sub classes have to implement the parse() method which will be used in load().\r\n */\n\nclass CompressedTextureLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const images = [];\n    const texture = new CompressedTexture();\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setResponseType('arraybuffer');\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    let loaded = 0;\n\n    function loadTexture(i) {\n      loader.load(url[i], function (buffer) {\n        const texDatas = scope.parse(buffer, true);\n        images[i] = {\n          width: texDatas.width,\n          height: texDatas.height,\n          format: texDatas.format,\n          mipmaps: texDatas.mipmaps\n        };\n        loaded += 1;\n\n        if (loaded === 6) {\n          if (texDatas.mipmapCount === 1) texture.minFilter = LinearFilter;\n          texture.image = images;\n          texture.format = texDatas.format;\n          texture.needsUpdate = true;\n          if (onLoad) onLoad(texture);\n        }\n      }, onProgress, onError);\n    }\n\n    if (Array.isArray(url)) {\n      for (let i = 0, il = url.length; i < il; ++i) {\n        loadTexture(i);\n      }\n    } else {\n      // compressed cubemap texture stored in a single DDS file\n      loader.load(url, function (buffer) {\n        const texDatas = scope.parse(buffer, true);\n\n        if (texDatas.isCubemap) {\n          const faces = texDatas.mipmaps.length / texDatas.mipmapCount;\n\n          for (let f = 0; f < faces; f++) {\n            images[f] = {\n              mipmaps: []\n            };\n\n            for (let i = 0; i < texDatas.mipmapCount; i++) {\n              images[f].mipmaps.push(texDatas.mipmaps[f * texDatas.mipmapCount + i]);\n              images[f].format = texDatas.format;\n              images[f].width = texDatas.width;\n              images[f].height = texDatas.height;\n            }\n          }\n\n          texture.image = images;\n        } else {\n          texture.image.width = texDatas.width;\n          texture.image.height = texDatas.height;\n          texture.mipmaps = texDatas.mipmaps;\n        }\n\n        if (texDatas.mipmapCount === 1) {\n          texture.minFilter = LinearFilter;\n        }\n\n        texture.format = texDatas.format;\n        texture.needsUpdate = true;\n        if (onLoad) onLoad(texture);\n      }, onProgress, onError);\n    }\n\n    return texture;\n  }\n\n}\n\nexport { CompressedTextureLoader };","map":{"version":3,"sources":["C:/Users/dell/Desktop/projektlogin/vue-3-authentication-jwt/src/games/three/src/loaders/CompressedTextureLoader.js"],"names":["LinearFilter","FileLoader","CompressedTexture","Loader","CompressedTextureLoader","constructor","manager","load","url","onLoad","onProgress","onError","scope","images","texture","loader","setPath","path","setResponseType","setRequestHeader","requestHeader","setWithCredentials","withCredentials","loaded","loadTexture","i","buffer","texDatas","parse","width","height","format","mipmaps","mipmapCount","minFilter","image","needsUpdate","Array","isArray","il","length","isCubemap","faces","f","push"],"mappings":"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","sourcesContent":["import { LinearFilter } from '../constants.js';\r\nimport { FileLoader } from './FileLoader.js';\r\nimport { CompressedTexture } from '../textures/CompressedTexture.js';\r\nimport { Loader } from './Loader.js';\r\n\r\n/**\r\n * Abstract Base class to block based textures loader (dds, pvr, ...)\r\n *\r\n * Sub classes have to implement the parse() method which will be used in load().\r\n */\r\n\r\nclass CompressedTextureLoader extends Loader {\r\n\r\n\tconstructor( manager ) {\r\n\r\n\t\tsuper( manager );\r\n\r\n\t}\r\n\r\n\tload( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tconst scope = this;\r\n\r\n\t\tconst images = [];\r\n\r\n\t\tconst texture = new CompressedTexture();\r\n\r\n\t\tconst loader = new FileLoader( this.manager );\r\n\t\tloader.setPath( this.path );\r\n\t\tloader.setResponseType( 'arraybuffer' );\r\n\t\tloader.setRequestHeader( this.requestHeader );\r\n\t\tloader.setWithCredentials( scope.withCredentials );\r\n\r\n\t\tlet loaded = 0;\r\n\r\n\t\tfunction loadTexture( i ) {\r\n\r\n\t\t\tloader.load( url[ i ], function ( buffer ) {\r\n\r\n\t\t\t\tconst texDatas = scope.parse( buffer, true );\r\n\r\n\t\t\t\timages[ i ] = {\r\n\t\t\t\t\twidth: texDatas.width,\r\n\t\t\t\t\theight: texDatas.height,\r\n\t\t\t\t\tformat: texDatas.format,\r\n\t\t\t\t\tmipmaps: texDatas.mipmaps\r\n\t\t\t\t};\r\n\r\n\t\t\t\tloaded += 1;\r\n\r\n\t\t\t\tif ( loaded === 6 ) {\r\n\r\n\t\t\t\t\tif ( texDatas.mipmapCount === 1 ) texture.minFilter = LinearFilter;\r\n\r\n\t\t\t\t\ttexture.image = images;\r\n\t\t\t\t\ttexture.format = texDatas.format;\r\n\t\t\t\t\ttexture.needsUpdate = true;\r\n\r\n\t\t\t\t\tif ( onLoad ) onLoad( texture );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}, onProgress, onError );\r\n\r\n\t\t}\r\n\r\n\t\tif ( Array.isArray( url ) ) {\r\n\r\n\t\t\tfor ( let i = 0, il = url.length; i < il; ++ i ) {\r\n\r\n\t\t\t\tloadTexture( i );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// compressed cubemap texture stored in a single DDS file\r\n\r\n\t\t\tloader.load( url, function ( buffer ) {\r\n\r\n\t\t\t\tconst texDatas = scope.parse( buffer, true );\r\n\r\n\t\t\t\tif ( texDatas.isCubemap ) {\r\n\r\n\t\t\t\t\tconst faces = texDatas.mipmaps.length / texDatas.mipmapCount;\r\n\r\n\t\t\t\t\tfor ( let f = 0; f < faces; f ++ ) {\r\n\r\n\t\t\t\t\t\timages[ f ] = { mipmaps: [] };\r\n\r\n\t\t\t\t\t\tfor ( let i = 0; i < texDatas.mipmapCount; i ++ ) {\r\n\r\n\t\t\t\t\t\t\timages[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );\r\n\t\t\t\t\t\t\timages[ f ].format = texDatas.format;\r\n\t\t\t\t\t\t\timages[ f ].width = texDatas.width;\r\n\t\t\t\t\t\t\timages[ f ].height = texDatas.height;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\ttexture.image = images;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\ttexture.image.width = texDatas.width;\r\n\t\t\t\t\ttexture.image.height = texDatas.height;\r\n\t\t\t\t\ttexture.mipmaps = texDatas.mipmaps;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( texDatas.mipmapCount === 1 ) {\r\n\r\n\t\t\t\t\ttexture.minFilter = LinearFilter;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttexture.format = texDatas.format;\r\n\t\t\t\ttexture.needsUpdate = true;\r\n\r\n\t\t\t\tif ( onLoad ) onLoad( texture );\r\n\r\n\t\t\t}, onProgress, onError );\r\n\r\n\t\t}\r\n\r\n\t\treturn texture;\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\nexport { CompressedTextureLoader };\r\n"]},"metadata":{},"sourceType":"module"}