{"ast":null,"code":"import { Vector3 } from './Vector3.js';\n\nclass Box3 {\n  constructor(min = new Vector3(+Infinity, +Infinity, +Infinity), max = new Vector3(-Infinity, -Infinity, -Infinity)) {\n    this.min = min;\n    this.max = max;\n  }\n\n  set(min, max) {\n    this.min.copy(min);\n    this.max.copy(max);\n    return this;\n  }\n\n  setFromArray(array) {\n    let minX = +Infinity;\n    let minY = +Infinity;\n    let minZ = +Infinity;\n    let maxX = -Infinity;\n    let maxY = -Infinity;\n    let maxZ = -Infinity;\n\n    for (let i = 0, l = array.length; i < l; i += 3) {\n      const x = array[i];\n      const y = array[i + 1];\n      const z = array[i + 2];\n      if (x < minX) minX = x;\n      if (y < minY) minY = y;\n      if (z < minZ) minZ = z;\n      if (x > maxX) maxX = x;\n      if (y > maxY) maxY = y;\n      if (z > maxZ) maxZ = z;\n    }\n\n    this.min.set(minX, minY, minZ);\n    this.max.set(maxX, maxY, maxZ);\n    return this;\n  }\n\n  setFromBufferAttribute(attribute) {\n    let minX = +Infinity;\n    let minY = +Infinity;\n    let minZ = +Infinity;\n    let maxX = -Infinity;\n    let maxY = -Infinity;\n    let maxZ = -Infinity;\n\n    for (let i = 0, l = attribute.count; i < l; i++) {\n      const x = attribute.getX(i);\n      const y = attribute.getY(i);\n      const z = attribute.getZ(i);\n      if (x < minX) minX = x;\n      if (y < minY) minY = y;\n      if (z < minZ) minZ = z;\n      if (x > maxX) maxX = x;\n      if (y > maxY) maxY = y;\n      if (z > maxZ) maxZ = z;\n    }\n\n    this.min.set(minX, minY, minZ);\n    this.max.set(maxX, maxY, maxZ);\n    return this;\n  }\n\n  setFromPoints(points) {\n    this.makeEmpty();\n\n    for (let i = 0, il = points.length; i < il; i++) {\n      this.expandByPoint(points[i]);\n    }\n\n    return this;\n  }\n\n  setFromCenterAndSize(center, size) {\n    const halfSize = _vector.copy(size).multiplyScalar(0.5);\n\n    this.min.copy(center).sub(halfSize);\n    this.max.copy(center).add(halfSize);\n    return this;\n  }\n\n  setFromObject(object, precise = false) {\n    this.makeEmpty();\n    return this.expandByObject(object, precise);\n  }\n\n  clone() {\n    return new this.constructor().copy(this);\n  }\n\n  copy(box) {\n    this.min.copy(box.min);\n    this.max.copy(box.max);\n    return this;\n  }\n\n  makeEmpty() {\n    this.min.x = this.min.y = this.min.z = +Infinity;\n    this.max.x = this.max.y = this.max.z = -Infinity;\n    return this;\n  }\n\n  isEmpty() {\n    // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\n    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;\n  }\n\n  getCenter(target) {\n    return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);\n  }\n\n  getSize(target) {\n    return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);\n  }\n\n  expandByPoint(point) {\n    this.min.min(point);\n    this.max.max(point);\n    return this;\n  }\n\n  expandByVector(vector) {\n    this.min.sub(vector);\n    this.max.add(vector);\n    return this;\n  }\n\n  expandByScalar(scalar) {\n    this.min.addScalar(-scalar);\n    this.max.addScalar(scalar);\n    return this;\n  }\n\n  expandByObject(object, precise = false) {\n    // Computes the world-axis-aligned bounding box of an object (including its children),\n    // accounting for both the object's, and children's, world transforms\n    object.updateWorldMatrix(false, false);\n    const geometry = object.geometry;\n\n    if (geometry !== undefined) {\n      if (precise && geometry.attributes != undefined && geometry.attributes.position !== undefined) {\n        const position = geometry.attributes.position;\n\n        for (let i = 0, l = position.count; i < l; i++) {\n          _vector.fromBufferAttribute(position, i).applyMatrix4(object.matrixWorld);\n\n          this.expandByPoint(_vector);\n        }\n      } else {\n        if (geometry.boundingBox === null) {\n          geometry.computeBoundingBox();\n        }\n\n        _box.copy(geometry.boundingBox);\n\n        _box.applyMatrix4(object.matrixWorld);\n\n        this.union(_box);\n      }\n    }\n\n    const children = object.children;\n\n    for (let i = 0, l = children.length; i < l; i++) {\n      this.expandByObject(children[i], precise);\n    }\n\n    return this;\n  }\n\n  containsPoint(point) {\n    return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z ? false : true;\n  }\n\n  containsBox(box) {\n    return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;\n  }\n\n  getParameter(point, target) {\n    // This can potentially have a divide by zero if the box\n    // has a size dimension of 0.\n    return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));\n  }\n\n  intersectsBox(box) {\n    // using 6 splitting planes to rule out intersections.\n    return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z ? false : true;\n  }\n\n  intersectsSphere(sphere) {\n    // Find the point on the AABB closest to the sphere center.\n    this.clampPoint(sphere.center, _vector); // If that point is inside the sphere, the AABB and sphere intersect.\n\n    return _vector.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;\n  }\n\n  intersectsPlane(plane) {\n    // We compute the minimum and maximum dot product values. If those values\n    // are on the same side (back or front) of the plane, then there is no intersection.\n    let min, max;\n\n    if (plane.normal.x > 0) {\n      min = plane.normal.x * this.min.x;\n      max = plane.normal.x * this.max.x;\n    } else {\n      min = plane.normal.x * this.max.x;\n      max = plane.normal.x * this.min.x;\n    }\n\n    if (plane.normal.y > 0) {\n      min += plane.normal.y * this.min.y;\n      max += plane.normal.y * this.max.y;\n    } else {\n      min += plane.normal.y * this.max.y;\n      max += plane.normal.y * this.min.y;\n    }\n\n    if (plane.normal.z > 0) {\n      min += plane.normal.z * this.min.z;\n      max += plane.normal.z * this.max.z;\n    } else {\n      min += plane.normal.z * this.max.z;\n      max += plane.normal.z * this.min.z;\n    }\n\n    return min <= -plane.constant && max >= -plane.constant;\n  }\n\n  intersectsTriangle(triangle) {\n    if (this.isEmpty()) {\n      return false;\n    } // compute box center and extents\n\n\n    this.getCenter(_center);\n\n    _extents.subVectors(this.max, _center); // translate triangle to aabb origin\n\n\n    _v0.subVectors(triangle.a, _center);\n\n    _v1.subVectors(triangle.b, _center);\n\n    _v2.subVectors(triangle.c, _center); // compute edge vectors for triangle\n\n\n    _f0.subVectors(_v1, _v0);\n\n    _f1.subVectors(_v2, _v1);\n\n    _f2.subVectors(_v0, _v2); // test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb\n    // make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation\n    // axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)\n\n\n    let axes = [0, -_f0.z, _f0.y, 0, -_f1.z, _f1.y, 0, -_f2.z, _f2.y, _f0.z, 0, -_f0.x, _f1.z, 0, -_f1.x, _f2.z, 0, -_f2.x, -_f0.y, _f0.x, 0, -_f1.y, _f1.x, 0, -_f2.y, _f2.x, 0];\n\n    if (!satForAxes(axes, _v0, _v1, _v2, _extents)) {\n      return false;\n    } // test 3 face normals from the aabb\n\n\n    axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n\n    if (!satForAxes(axes, _v0, _v1, _v2, _extents)) {\n      return false;\n    } // finally testing the face normal of the triangle\n    // use already existing triangle edge vectors here\n\n\n    _triangleNormal.crossVectors(_f0, _f1);\n\n    axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];\n    return satForAxes(axes, _v0, _v1, _v2, _extents);\n  }\n\n  clampPoint(point, target) {\n    return target.copy(point).clamp(this.min, this.max);\n  }\n\n  distanceToPoint(point) {\n    const clampedPoint = _vector.copy(point).clamp(this.min, this.max);\n\n    return clampedPoint.sub(point).length();\n  }\n\n  getBoundingSphere(target) {\n    this.getCenter(target.center);\n    target.radius = this.getSize(_vector).length() * 0.5;\n    return target;\n  }\n\n  intersect(box) {\n    this.min.max(box.min);\n    this.max.min(box.max); // ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.\n\n    if (this.isEmpty()) this.makeEmpty();\n    return this;\n  }\n\n  union(box) {\n    this.min.min(box.min);\n    this.max.max(box.max);\n    return this;\n  }\n\n  applyMatrix4(matrix) {\n    // transform of empty box is an empty box.\n    if (this.isEmpty()) return this; // NOTE: I am using a binary pattern to specify all 2^3 combinations below\n\n    _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix); // 000\n\n\n    _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix); // 001\n\n\n    _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix); // 010\n\n\n    _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix); // 011\n\n\n    _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix); // 100\n\n\n    _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix); // 101\n\n\n    _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix); // 110\n\n\n    _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix); // 111\n\n\n    this.setFromPoints(_points);\n    return this;\n  }\n\n  translate(offset) {\n    this.min.add(offset);\n    this.max.add(offset);\n    return this;\n  }\n\n  equals(box) {\n    return box.min.equals(this.min) && box.max.equals(this.max);\n  }\n\n}\n\nBox3.prototype.isBox3 = true;\nconst _points = [/*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3()];\n\nconst _vector = /*@__PURE__*/new Vector3();\n\nconst _box = /*@__PURE__*/new Box3(); // triangle centered vertices\n\n\nconst _v0 = /*@__PURE__*/new Vector3();\n\nconst _v1 = /*@__PURE__*/new Vector3();\n\nconst _v2 = /*@__PURE__*/new Vector3(); // triangle edge vectors\n\n\nconst _f0 = /*@__PURE__*/new Vector3();\n\nconst _f1 = /*@__PURE__*/new Vector3();\n\nconst _f2 = /*@__PURE__*/new Vector3();\n\nconst _center = /*@__PURE__*/new Vector3();\n\nconst _extents = /*@__PURE__*/new Vector3();\n\nconst _triangleNormal = /*@__PURE__*/new Vector3();\n\nconst _testAxis = /*@__PURE__*/new Vector3();\n\nfunction satForAxes(axes, v0, v1, v2, extents) {\n  for (let i = 0, j = axes.length - 3; i <= j; i += 3) {\n    _testAxis.fromArray(axes, i); // project the aabb onto the seperating axis\n\n\n    const r = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z); // project all 3 vertices of the triangle onto the seperating axis\n\n    const p0 = v0.dot(_testAxis);\n    const p1 = v1.dot(_testAxis);\n    const p2 = v2.dot(_testAxis); // actual test, basically see if either of the most extreme of the triangle points intersects r\n\n    if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {\n      // points of the projected triangle are outside the projected half-length of the aabb\n      // the axis is seperating and we can exit\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexport { Box3 };","map":{"version":3,"sources":["C:/Users/dell/Desktop/projektlogin/vue-3-authentication-jwt/src/games/three/src/math/Box3.js"],"names":["Vector3","Box3","constructor","min","Infinity","max","set","copy","setFromArray","array","minX","minY","minZ","maxX","maxY","maxZ","i","l","length","x","y","z","setFromBufferAttribute","attribute","count","getX","getY","getZ","setFromPoints","points","makeEmpty","il","expandByPoint","setFromCenterAndSize","center","size","halfSize","_vector","multiplyScalar","sub","add","setFromObject","object","precise","expandByObject","clone","box","isEmpty","getCenter","target","addVectors","getSize","subVectors","point","expandByVector","vector","expandByScalar","scalar","addScalar","updateWorldMatrix","geometry","undefined","attributes","position","fromBufferAttribute","applyMatrix4","matrixWorld","boundingBox","computeBoundingBox","_box","union","children","containsPoint","containsBox","getParameter","intersectsBox","intersectsSphere","sphere","clampPoint","distanceToSquared","radius","intersectsPlane","plane","normal","constant","intersectsTriangle","triangle","_center","_extents","_v0","a","_v1","b","_v2","c","_f0","_f1","_f2","axes","satForAxes","_triangleNormal","crossVectors","clamp","distanceToPoint","clampedPoint","getBoundingSphere","intersect","matrix","_points","translate","offset","equals","prototype","isBox3","_testAxis","v0","v1","v2","extents","j","fromArray","r","Math","abs","p0","dot","p1","p2"],"mappings":"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","sourcesContent":["import { Vector3 } from './Vector3.js';\r\n\r\nclass Box3 {\r\n\r\n\tconstructor( min = new Vector3( + Infinity, + Infinity, + Infinity ), max = new Vector3( - Infinity, - Infinity, - Infinity ) ) {\r\n\r\n\t\tthis.min = min;\r\n\t\tthis.max = max;\r\n\r\n\t}\r\n\r\n\tset( min, max ) {\r\n\r\n\t\tthis.min.copy( min );\r\n\t\tthis.max.copy( max );\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tsetFromArray( array ) {\r\n\r\n\t\tlet minX = + Infinity;\r\n\t\tlet minY = + Infinity;\r\n\t\tlet minZ = + Infinity;\r\n\r\n\t\tlet maxX = - Infinity;\r\n\t\tlet maxY = - Infinity;\r\n\t\tlet maxZ = - Infinity;\r\n\r\n\t\tfor ( let i = 0, l = array.length; i < l; i += 3 ) {\r\n\r\n\t\t\tconst x = array[ i ];\r\n\t\t\tconst y = array[ i + 1 ];\r\n\t\t\tconst z = array[ i + 2 ];\r\n\r\n\t\t\tif ( x < minX ) minX = x;\r\n\t\t\tif ( y < minY ) minY = y;\r\n\t\t\tif ( z < minZ ) minZ = z;\r\n\r\n\t\t\tif ( x > maxX ) maxX = x;\r\n\t\t\tif ( y > maxY ) maxY = y;\r\n\t\t\tif ( z > maxZ ) maxZ = z;\r\n\r\n\t\t}\r\n\r\n\t\tthis.min.set( minX, minY, minZ );\r\n\t\tthis.max.set( maxX, maxY, maxZ );\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tsetFromBufferAttribute( attribute ) {\r\n\r\n\t\tlet minX = + Infinity;\r\n\t\tlet minY = + Infinity;\r\n\t\tlet minZ = + Infinity;\r\n\r\n\t\tlet maxX = - Infinity;\r\n\t\tlet maxY = - Infinity;\r\n\t\tlet maxZ = - Infinity;\r\n\r\n\t\tfor ( let i = 0, l = attribute.count; i < l; i ++ ) {\r\n\r\n\t\t\tconst x = attribute.getX( i );\r\n\t\t\tconst y = attribute.getY( i );\r\n\t\t\tconst z = attribute.getZ( i );\r\n\r\n\t\t\tif ( x < minX ) minX = x;\r\n\t\t\tif ( y < minY ) minY = y;\r\n\t\t\tif ( z < minZ ) minZ = z;\r\n\r\n\t\t\tif ( x > maxX ) maxX = x;\r\n\t\t\tif ( y > maxY ) maxY = y;\r\n\t\t\tif ( z > maxZ ) maxZ = z;\r\n\r\n\t\t}\r\n\r\n\t\tthis.min.set( minX, minY, minZ );\r\n\t\tthis.max.set( maxX, maxY, maxZ );\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tsetFromPoints( points ) {\r\n\r\n\t\tthis.makeEmpty();\r\n\r\n\t\tfor ( let i = 0, il = points.length; i < il; i ++ ) {\r\n\r\n\t\t\tthis.expandByPoint( points[ i ] );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tsetFromCenterAndSize( center, size ) {\r\n\r\n\t\tconst halfSize = _vector.copy( size ).multiplyScalar( 0.5 );\r\n\r\n\t\tthis.min.copy( center ).sub( halfSize );\r\n\t\tthis.max.copy( center ).add( halfSize );\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tsetFromObject( object, precise = false ) {\r\n\r\n\t\tthis.makeEmpty();\r\n\r\n\t\treturn this.expandByObject( object, precise );\r\n\r\n\t}\r\n\r\n\tclone() {\r\n\r\n\t\treturn new this.constructor().copy( this );\r\n\r\n\t}\r\n\r\n\tcopy( box ) {\r\n\r\n\t\tthis.min.copy( box.min );\r\n\t\tthis.max.copy( box.max );\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tmakeEmpty() {\r\n\r\n\t\tthis.min.x = this.min.y = this.min.z = + Infinity;\r\n\t\tthis.max.x = this.max.y = this.max.z = - Infinity;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tisEmpty() {\r\n\r\n\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\r\n\r\n\t\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );\r\n\r\n\t}\r\n\r\n\tgetCenter( target ) {\r\n\r\n\t\treturn this.isEmpty() ? target.set( 0, 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\r\n\r\n\t}\r\n\r\n\tgetSize( target ) {\r\n\r\n\t\treturn this.isEmpty() ? target.set( 0, 0, 0 ) : target.subVectors( this.max, this.min );\r\n\r\n\t}\r\n\r\n\texpandByPoint( point ) {\r\n\r\n\t\tthis.min.min( point );\r\n\t\tthis.max.max( point );\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\texpandByVector( vector ) {\r\n\r\n\t\tthis.min.sub( vector );\r\n\t\tthis.max.add( vector );\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\texpandByScalar( scalar ) {\r\n\r\n\t\tthis.min.addScalar( - scalar );\r\n\t\tthis.max.addScalar( scalar );\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\texpandByObject( object, precise = false ) {\r\n\r\n\t\t// Computes the world-axis-aligned bounding box of an object (including its children),\r\n\t\t// accounting for both the object's, and children's, world transforms\r\n\r\n\t\tobject.updateWorldMatrix( false, false );\r\n\r\n\t\tconst geometry = object.geometry;\r\n\r\n\t\tif ( geometry !== undefined ) {\r\n\r\n\t\t\tif ( precise && geometry.attributes != undefined && geometry.attributes.position !== undefined ) {\r\n\r\n\t\t\t\tconst position = geometry.attributes.position;\r\n\t\t\t\tfor ( let i = 0, l = position.count; i < l; i ++ ) {\r\n\r\n\t\t\t\t\t_vector.fromBufferAttribute( position, i ).applyMatrix4( object.matrixWorld );\r\n\t\t\t\t\tthis.expandByPoint( _vector );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tif ( geometry.boundingBox === null ) {\r\n\r\n\t\t\t\t\tgeometry.computeBoundingBox();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t_box.copy( geometry.boundingBox );\r\n\t\t\t\t_box.applyMatrix4( object.matrixWorld );\r\n\r\n\t\t\t\tthis.union( _box );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tconst children = object.children;\r\n\r\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\r\n\r\n\t\t\tthis.expandByObject( children[ i ], precise );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tcontainsPoint( point ) {\r\n\r\n\t\treturn point.x < this.min.x || point.x > this.max.x ||\r\n\t\t\tpoint.y < this.min.y || point.y > this.max.y ||\r\n\t\t\tpoint.z < this.min.z || point.z > this.max.z ? false : true;\r\n\r\n\t}\r\n\r\n\tcontainsBox( box ) {\r\n\r\n\t\treturn this.min.x <= box.min.x && box.max.x <= this.max.x &&\r\n\t\t\tthis.min.y <= box.min.y && box.max.y <= this.max.y &&\r\n\t\t\tthis.min.z <= box.min.z && box.max.z <= this.max.z;\r\n\r\n\t}\r\n\r\n\tgetParameter( point, target ) {\r\n\r\n\t\t// This can potentially have a divide by zero if the box\r\n\t\t// has a size dimension of 0.\r\n\r\n\t\treturn target.set(\r\n\t\t\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\r\n\t\t\t( point.y - this.min.y ) / ( this.max.y - this.min.y ),\r\n\t\t\t( point.z - this.min.z ) / ( this.max.z - this.min.z )\r\n\t\t);\r\n\r\n\t}\r\n\r\n\tintersectsBox( box ) {\r\n\r\n\t\t// using 6 splitting planes to rule out intersections.\r\n\t\treturn box.max.x < this.min.x || box.min.x > this.max.x ||\r\n\t\t\tbox.max.y < this.min.y || box.min.y > this.max.y ||\r\n\t\t\tbox.max.z < this.min.z || box.min.z > this.max.z ? false : true;\r\n\r\n\t}\r\n\r\n\tintersectsSphere( sphere ) {\r\n\r\n\t\t// Find the point on the AABB closest to the sphere center.\r\n\t\tthis.clampPoint( sphere.center, _vector );\r\n\r\n\t\t// If that point is inside the sphere, the AABB and sphere intersect.\r\n\t\treturn _vector.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );\r\n\r\n\t}\r\n\r\n\tintersectsPlane( plane ) {\r\n\r\n\t\t// We compute the minimum and maximum dot product values. If those values\r\n\t\t// are on the same side (back or front) of the plane, then there is no intersection.\r\n\r\n\t\tlet min, max;\r\n\r\n\t\tif ( plane.normal.x > 0 ) {\r\n\r\n\t\t\tmin = plane.normal.x * this.min.x;\r\n\t\t\tmax = plane.normal.x * this.max.x;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tmin = plane.normal.x * this.max.x;\r\n\t\t\tmax = plane.normal.x * this.min.x;\r\n\r\n\t\t}\r\n\r\n\t\tif ( plane.normal.y > 0 ) {\r\n\r\n\t\t\tmin += plane.normal.y * this.min.y;\r\n\t\t\tmax += plane.normal.y * this.max.y;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tmin += plane.normal.y * this.max.y;\r\n\t\t\tmax += plane.normal.y * this.min.y;\r\n\r\n\t\t}\r\n\r\n\t\tif ( plane.normal.z > 0 ) {\r\n\r\n\t\t\tmin += plane.normal.z * this.min.z;\r\n\t\t\tmax += plane.normal.z * this.max.z;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tmin += plane.normal.z * this.max.z;\r\n\t\t\tmax += plane.normal.z * this.min.z;\r\n\r\n\t\t}\r\n\r\n\t\treturn ( min <= - plane.constant && max >= - plane.constant );\r\n\r\n\t}\r\n\r\n\tintersectsTriangle( triangle ) {\r\n\r\n\t\tif ( this.isEmpty() ) {\r\n\r\n\t\t\treturn false;\r\n\r\n\t\t}\r\n\r\n\t\t// compute box center and extents\r\n\t\tthis.getCenter( _center );\r\n\t\t_extents.subVectors( this.max, _center );\r\n\r\n\t\t// translate triangle to aabb origin\r\n\t\t_v0.subVectors( triangle.a, _center );\r\n\t\t_v1.subVectors( triangle.b, _center );\r\n\t\t_v2.subVectors( triangle.c, _center );\r\n\r\n\t\t// compute edge vectors for triangle\r\n\t\t_f0.subVectors( _v1, _v0 );\r\n\t\t_f1.subVectors( _v2, _v1 );\r\n\t\t_f2.subVectors( _v0, _v2 );\r\n\r\n\t\t// test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb\r\n\t\t// make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation\r\n\t\t// axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)\r\n\t\tlet axes = [\r\n\t\t\t0, - _f0.z, _f0.y, 0, - _f1.z, _f1.y, 0, - _f2.z, _f2.y,\r\n\t\t\t_f0.z, 0, - _f0.x, _f1.z, 0, - _f1.x, _f2.z, 0, - _f2.x,\r\n\t\t\t- _f0.y, _f0.x, 0, - _f1.y, _f1.x, 0, - _f2.y, _f2.x, 0\r\n\t\t];\r\n\t\tif ( ! satForAxes( axes, _v0, _v1, _v2, _extents ) ) {\r\n\r\n\t\t\treturn false;\r\n\r\n\t\t}\r\n\r\n\t\t// test 3 face normals from the aabb\r\n\t\taxes = [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ];\r\n\t\tif ( ! satForAxes( axes, _v0, _v1, _v2, _extents ) ) {\r\n\r\n\t\t\treturn false;\r\n\r\n\t\t}\r\n\r\n\t\t// finally testing the face normal of the triangle\r\n\t\t// use already existing triangle edge vectors here\r\n\t\t_triangleNormal.crossVectors( _f0, _f1 );\r\n\t\taxes = [ _triangleNormal.x, _triangleNormal.y, _triangleNormal.z ];\r\n\r\n\t\treturn satForAxes( axes, _v0, _v1, _v2, _extents );\r\n\r\n\t}\r\n\r\n\tclampPoint( point, target ) {\r\n\r\n\t\treturn target.copy( point ).clamp( this.min, this.max );\r\n\r\n\t}\r\n\r\n\tdistanceToPoint( point ) {\r\n\r\n\t\tconst clampedPoint = _vector.copy( point ).clamp( this.min, this.max );\r\n\r\n\t\treturn clampedPoint.sub( point ).length();\r\n\r\n\t}\r\n\r\n\tgetBoundingSphere( target ) {\r\n\r\n\t\tthis.getCenter( target.center );\r\n\r\n\t\ttarget.radius = this.getSize( _vector ).length() * 0.5;\r\n\r\n\t\treturn target;\r\n\r\n\t}\r\n\r\n\tintersect( box ) {\r\n\r\n\t\tthis.min.max( box.min );\r\n\t\tthis.max.min( box.max );\r\n\r\n\t\t// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.\r\n\t\tif ( this.isEmpty() ) this.makeEmpty();\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tunion( box ) {\r\n\r\n\t\tthis.min.min( box.min );\r\n\t\tthis.max.max( box.max );\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tapplyMatrix4( matrix ) {\r\n\r\n\t\t// transform of empty box is an empty box.\r\n\t\tif ( this.isEmpty() ) return this;\r\n\r\n\t\t// NOTE: I am using a binary pattern to specify all 2^3 combinations below\r\n\t\t_points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000\r\n\t\t_points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001\r\n\t\t_points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010\r\n\t\t_points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011\r\n\t\t_points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100\r\n\t\t_points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101\r\n\t\t_points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110\r\n\t\t_points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 111\r\n\r\n\t\tthis.setFromPoints( _points );\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\ttranslate( offset ) {\r\n\r\n\t\tthis.min.add( offset );\r\n\t\tthis.max.add( offset );\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tequals( box ) {\r\n\r\n\t\treturn box.min.equals( this.min ) && box.max.equals( this.max );\r\n\r\n\t}\r\n\r\n}\r\n\r\nBox3.prototype.isBox3 = true;\r\n\r\nconst _points = [\r\n\t/*@__PURE__*/ new Vector3(),\r\n\t/*@__PURE__*/ new Vector3(),\r\n\t/*@__PURE__*/ new Vector3(),\r\n\t/*@__PURE__*/ new Vector3(),\r\n\t/*@__PURE__*/ new Vector3(),\r\n\t/*@__PURE__*/ new Vector3(),\r\n\t/*@__PURE__*/ new Vector3(),\r\n\t/*@__PURE__*/ new Vector3()\r\n];\r\n\r\nconst _vector = /*@__PURE__*/ new Vector3();\r\n\r\nconst _box = /*@__PURE__*/ new Box3();\r\n\r\n// triangle centered vertices\r\n\r\nconst _v0 = /*@__PURE__*/ new Vector3();\r\nconst _v1 = /*@__PURE__*/ new Vector3();\r\nconst _v2 = /*@__PURE__*/ new Vector3();\r\n\r\n// triangle edge vectors\r\n\r\nconst _f0 = /*@__PURE__*/ new Vector3();\r\nconst _f1 = /*@__PURE__*/ new Vector3();\r\nconst _f2 = /*@__PURE__*/ new Vector3();\r\n\r\nconst _center = /*@__PURE__*/ new Vector3();\r\nconst _extents = /*@__PURE__*/ new Vector3();\r\nconst _triangleNormal = /*@__PURE__*/ new Vector3();\r\nconst _testAxis = /*@__PURE__*/ new Vector3();\r\n\r\nfunction satForAxes( axes, v0, v1, v2, extents ) {\r\n\r\n\tfor ( let i = 0, j = axes.length - 3; i <= j; i += 3 ) {\r\n\r\n\t\t_testAxis.fromArray( axes, i );\r\n\t\t// project the aabb onto the seperating axis\r\n\t\tconst r = extents.x * Math.abs( _testAxis.x ) + extents.y * Math.abs( _testAxis.y ) + extents.z * Math.abs( _testAxis.z );\r\n\t\t// project all 3 vertices of the triangle onto the seperating axis\r\n\t\tconst p0 = v0.dot( _testAxis );\r\n\t\tconst p1 = v1.dot( _testAxis );\r\n\t\tconst p2 = v2.dot( _testAxis );\r\n\t\t// actual test, basically see if either of the most extreme of the triangle points intersects r\r\n\t\tif ( Math.max( - Math.max( p0, p1, p2 ), Math.min( p0, p1, p2 ) ) > r ) {\r\n\r\n\t\t\t// points of the projected triangle are outside the projected half-length of the aabb\r\n\t\t\t// the axis is seperating and we can exit\r\n\t\t\treturn false;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn true;\r\n\r\n}\r\n\r\nexport { Box3 };\r\n"]},"metadata":{},"sourceType":"module"}