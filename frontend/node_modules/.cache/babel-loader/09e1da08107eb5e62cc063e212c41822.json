{"ast":null,"code":"import { CubeReflectionMapping, CubeRefractionMapping, EquirectangularReflectionMapping, EquirectangularRefractionMapping } from '../../constants.js';\nimport { WebGLCubeRenderTarget } from '../WebGLCubeRenderTarget.js';\n\nfunction WebGLCubeMaps(renderer) {\n  let cubemaps = new WeakMap();\n\n  function mapTextureMapping(texture, mapping) {\n    if (mapping === EquirectangularReflectionMapping) {\n      texture.mapping = CubeReflectionMapping;\n    } else if (mapping === EquirectangularRefractionMapping) {\n      texture.mapping = CubeRefractionMapping;\n    }\n\n    return texture;\n  }\n\n  function get(texture) {\n    if (texture && texture.isTexture && texture.isRenderTargetTexture === false) {\n      const mapping = texture.mapping;\n\n      if (mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping) {\n        if (cubemaps.has(texture)) {\n          const cubemap = cubemaps.get(texture).texture;\n          return mapTextureMapping(cubemap, texture.mapping);\n        } else {\n          const image = texture.image;\n\n          if (image && image.height > 0) {\n            const renderTarget = new WebGLCubeRenderTarget(image.height / 2);\n            renderTarget.fromEquirectangularTexture(renderer, texture);\n            cubemaps.set(texture, renderTarget);\n            texture.addEventListener('dispose', onTextureDispose);\n            return mapTextureMapping(renderTarget.texture, texture.mapping);\n          } else {\n            // image not yet ready. try the conversion next frame\n            return null;\n          }\n        }\n      }\n    }\n\n    return texture;\n  }\n\n  function onTextureDispose(event) {\n    const texture = event.target;\n    texture.removeEventListener('dispose', onTextureDispose);\n    const cubemap = cubemaps.get(texture);\n\n    if (cubemap !== undefined) {\n      cubemaps.delete(texture);\n      cubemap.dispose();\n    }\n  }\n\n  function dispose() {\n    cubemaps = new WeakMap();\n  }\n\n  return {\n    get: get,\n    dispose: dispose\n  };\n}\n\nexport { WebGLCubeMaps };","map":{"version":3,"sources":["C:/Users/dell/Desktop/projektlogin/vue-3-authentication-jwt/src/games/three/src/renderers/webgl/WebGLCubeMaps.js"],"names":["CubeReflectionMapping","CubeRefractionMapping","EquirectangularReflectionMapping","EquirectangularRefractionMapping","WebGLCubeRenderTarget","WebGLCubeMaps","renderer","cubemaps","WeakMap","mapTextureMapping","texture","mapping","get","isTexture","isRenderTargetTexture","has","cubemap","image","height","renderTarget","fromEquirectangularTexture","set","addEventListener","onTextureDispose","event","target","removeEventListener","undefined","delete","dispose"],"mappings":"AAAA,SAASA,qBAAT,EAAgCC,qBAAhC,EAAuDC,gCAAvD,EAAyFC,gCAAzF,QAAiI,oBAAjI;AACA,SAASC,qBAAT,QAAsC,6BAAtC;;AAEA,SAASC,aAAT,CAAwBC,QAAxB,EAAmC;AAElC,MAAIC,QAAQ,GAAG,IAAIC,OAAJ,EAAf;;AAEA,WAASC,iBAAT,CAA4BC,OAA5B,EAAqCC,OAArC,EAA+C;AAE9C,QAAKA,OAAO,KAAKT,gCAAjB,EAAoD;AAEnDQ,MAAAA,OAAO,CAACC,OAAR,GAAkBX,qBAAlB;AAEA,KAJD,MAIO,IAAKW,OAAO,KAAKR,gCAAjB,EAAoD;AAE1DO,MAAAA,OAAO,CAACC,OAAR,GAAkBV,qBAAlB;AAEA;;AAED,WAAOS,OAAP;AAEA;;AAED,WAASE,GAAT,CAAcF,OAAd,EAAwB;AAEvB,QAAKA,OAAO,IAAIA,OAAO,CAACG,SAAnB,IAAgCH,OAAO,CAACI,qBAAR,KAAkC,KAAvE,EAA+E;AAE9E,YAAMH,OAAO,GAAGD,OAAO,CAACC,OAAxB;;AAEA,UAAKA,OAAO,KAAKT,gCAAZ,IAAgDS,OAAO,KAAKR,gCAAjE,EAAoG;AAEnG,YAAKI,QAAQ,CAACQ,GAAT,CAAcL,OAAd,CAAL,EAA+B;AAE9B,gBAAMM,OAAO,GAAGT,QAAQ,CAACK,GAAT,CAAcF,OAAd,EAAwBA,OAAxC;AACA,iBAAOD,iBAAiB,CAAEO,OAAF,EAAWN,OAAO,CAACC,OAAnB,CAAxB;AAEA,SALD,MAKO;AAEN,gBAAMM,KAAK,GAAGP,OAAO,CAACO,KAAtB;;AAEA,cAAKA,KAAK,IAAIA,KAAK,CAACC,MAAN,GAAe,CAA7B,EAAiC;AAEhC,kBAAMC,YAAY,GAAG,IAAIf,qBAAJ,CAA2Ba,KAAK,CAACC,MAAN,GAAe,CAA1C,CAArB;AACAC,YAAAA,YAAY,CAACC,0BAAb,CAAyCd,QAAzC,EAAmDI,OAAnD;AACAH,YAAAA,QAAQ,CAACc,GAAT,CAAcX,OAAd,EAAuBS,YAAvB;AAEAT,YAAAA,OAAO,CAACY,gBAAR,CAA0B,SAA1B,EAAqCC,gBAArC;AAEA,mBAAOd,iBAAiB,CAAEU,YAAY,CAACT,OAAf,EAAwBA,OAAO,CAACC,OAAhC,CAAxB;AAEA,WAVD,MAUO;AAEN;AAEA,mBAAO,IAAP;AAEA;AAED;AAED;AAED;;AAED,WAAOD,OAAP;AAEA;;AAED,WAASa,gBAAT,CAA2BC,KAA3B,EAAmC;AAElC,UAAMd,OAAO,GAAGc,KAAK,CAACC,MAAtB;AAEAf,IAAAA,OAAO,CAACgB,mBAAR,CAA6B,SAA7B,EAAwCH,gBAAxC;AAEA,UAAMP,OAAO,GAAGT,QAAQ,CAACK,GAAT,CAAcF,OAAd,CAAhB;;AAEA,QAAKM,OAAO,KAAKW,SAAjB,EAA6B;AAE5BpB,MAAAA,QAAQ,CAACqB,MAAT,CAAiBlB,OAAjB;AACAM,MAAAA,OAAO,CAACa,OAAR;AAEA;AAED;;AAED,WAASA,OAAT,GAAmB;AAElBtB,IAAAA,QAAQ,GAAG,IAAIC,OAAJ,EAAX;AAEA;;AAED,SAAO;AACNI,IAAAA,GAAG,EAAEA,GADC;AAENiB,IAAAA,OAAO,EAAEA;AAFH,GAAP;AAKA;;AAED,SAASxB,aAAT","sourcesContent":["import { CubeReflectionMapping, CubeRefractionMapping, EquirectangularReflectionMapping, EquirectangularRefractionMapping } from '../../constants.js';\r\nimport { WebGLCubeRenderTarget } from '../WebGLCubeRenderTarget.js';\r\n\r\nfunction WebGLCubeMaps( renderer ) {\r\n\r\n\tlet cubemaps = new WeakMap();\r\n\r\n\tfunction mapTextureMapping( texture, mapping ) {\r\n\r\n\t\tif ( mapping === EquirectangularReflectionMapping ) {\r\n\r\n\t\t\ttexture.mapping = CubeReflectionMapping;\r\n\r\n\t\t} else if ( mapping === EquirectangularRefractionMapping ) {\r\n\r\n\t\t\ttexture.mapping = CubeRefractionMapping;\r\n\r\n\t\t}\r\n\r\n\t\treturn texture;\r\n\r\n\t}\r\n\r\n\tfunction get( texture ) {\r\n\r\n\t\tif ( texture && texture.isTexture && texture.isRenderTargetTexture === false ) {\r\n\r\n\t\t\tconst mapping = texture.mapping;\r\n\r\n\t\t\tif ( mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping ) {\r\n\r\n\t\t\t\tif ( cubemaps.has( texture ) ) {\r\n\r\n\t\t\t\t\tconst cubemap = cubemaps.get( texture ).texture;\r\n\t\t\t\t\treturn mapTextureMapping( cubemap, texture.mapping );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tconst image = texture.image;\r\n\r\n\t\t\t\t\tif ( image && image.height > 0 ) {\r\n\r\n\t\t\t\t\t\tconst renderTarget = new WebGLCubeRenderTarget( image.height / 2 );\r\n\t\t\t\t\t\trenderTarget.fromEquirectangularTexture( renderer, texture );\r\n\t\t\t\t\t\tcubemaps.set( texture, renderTarget );\r\n\r\n\t\t\t\t\t\ttexture.addEventListener( 'dispose', onTextureDispose );\r\n\r\n\t\t\t\t\t\treturn mapTextureMapping( renderTarget.texture, texture.mapping );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t// image not yet ready. try the conversion next frame\r\n\r\n\t\t\t\t\t\treturn null;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn texture;\r\n\r\n\t}\r\n\r\n\tfunction onTextureDispose( event ) {\r\n\r\n\t\tconst texture = event.target;\r\n\r\n\t\ttexture.removeEventListener( 'dispose', onTextureDispose );\r\n\r\n\t\tconst cubemap = cubemaps.get( texture );\r\n\r\n\t\tif ( cubemap !== undefined ) {\r\n\r\n\t\t\tcubemaps.delete( texture );\r\n\t\t\tcubemap.dispose();\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction dispose() {\r\n\r\n\t\tcubemaps = new WeakMap();\r\n\r\n\t}\r\n\r\n\treturn {\r\n\t\tget: get,\r\n\t\tdispose: dispose\r\n\t};\r\n\r\n}\r\n\r\nexport { WebGLCubeMaps };\r\n"]},"metadata":{},"sourceType":"module"}