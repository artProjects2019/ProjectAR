{"ast":null,"code":"import \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport { CubeReflectionMapping, CubeRefractionMapping, CubeUVReflectionMapping, LinearEncoding, LinearFilter, NoToneMapping, NoBlending, RGBAFormat, HalfFloatType } from '../constants.js';\nimport { BufferAttribute } from '../core/BufferAttribute.js';\nimport { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Mesh } from '../objects/Mesh.js';\nimport { OrthographicCamera } from '../cameras/OrthographicCamera.js';\nimport { PerspectiveCamera } from '../cameras/PerspectiveCamera.js';\nimport { ShaderMaterial } from '../materials/ShaderMaterial.js';\nimport { Vector3 } from '../math/Vector3.js';\nimport { Color } from '../math/Color.js';\nimport { WebGLRenderTarget } from '../renderers/WebGLRenderTarget.js';\nimport { MeshBasicMaterial } from '../materials/MeshBasicMaterial.js';\nimport { BoxGeometry } from '../geometries/BoxGeometry.js';\nimport { BackSide } from '../constants.js';\nconst LOD_MIN = 4; // The standard deviations (radians) associated with the extra mips. These are\n// chosen to approximate a Trowbridge-Reitz distribution function times the\n// geometric shadowing function. These sigma values squared must match the\n// variance #defines in cube_uv_reflection_fragment.glsl.js.\n\nconst EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582]; // The maximum length of the blur for loop. Smaller sigmas will use fewer\n// samples and exit early, but not recompile the shader.\n\nconst MAX_SAMPLES = 20;\n\nconst _flatCamera = /*@__PURE__*/new OrthographicCamera();\n\nconst _clearColor = /*@__PURE__*/new Color();\n\nlet _oldTarget = null; // Golden Ratio\n\nconst PHI = (1 + Math.sqrt(5)) / 2;\nconst INV_PHI = 1 / PHI; // Vertices of a dodecahedron (except the opposites, which represent the\n// same axis), used as axis directions evenly spread on a sphere.\n\nconst _axisDirections = [/*@__PURE__*/new Vector3(1, 1, 1), /*@__PURE__*/new Vector3(-1, 1, 1), /*@__PURE__*/new Vector3(1, 1, -1), /*@__PURE__*/new Vector3(-1, 1, -1), /*@__PURE__*/new Vector3(0, PHI, INV_PHI), /*@__PURE__*/new Vector3(0, PHI, -INV_PHI), /*@__PURE__*/new Vector3(INV_PHI, 0, PHI), /*@__PURE__*/new Vector3(-INV_PHI, 0, PHI), /*@__PURE__*/new Vector3(PHI, INV_PHI, 0), /*@__PURE__*/new Vector3(-PHI, INV_PHI, 0)];\n/**\r\n * This class generates a Prefiltered, Mipmapped Radiance Environment Map\r\n * (PMREM) from a cubeMap environment texture. This allows different levels of\r\n * blur to be quickly accessed based on material roughness. It is packed into a\r\n * special CubeUV format that allows us to perform custom interpolation so that\r\n * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap\r\n * chain, it only goes down to the LOD_MIN level (above), and then creates extra\r\n * even more filtered 'mips' at the same LOD_MIN resolution, associated with\r\n * higher roughness levels. In this way we maintain resolution to smoothly\r\n * interpolate diffuse lighting while limiting sampling computation.\r\n *\r\n * Paper: Fast, Accurate Image-Based Lighting\r\n * https://drive.google.com/file/d/15y8r_UpKlU9SvV4ILb0C3qCPecS8pvLz/view\r\n*/\n\nclass PMREMGenerator {\n  constructor(renderer) {\n    this._renderer = renderer;\n    this._pingPongRenderTarget = null;\n    this._lodMax = 0;\n    this._cubeSize = 0;\n    this._lodPlanes = [];\n    this._sizeLods = [];\n    this._sigmas = [];\n    this._blurMaterial = null;\n    this._cubemapMaterial = null;\n    this._equirectMaterial = null;\n\n    this._compileMaterial(this._blurMaterial);\n  }\n  /**\r\n   * Generates a PMREM from a supplied Scene, which can be faster than using an\r\n   * image if networking bandwidth is low. Optional sigma specifies a blur radius\r\n   * in radians to be applied to the scene before PMREM generation. Optional near\r\n   * and far planes ensure the scene is rendered in its entirety (the cubeCamera\r\n   * is placed at the origin).\r\n   */\n\n\n  fromScene(scene, sigma = 0, near = 0.1, far = 100) {\n    _oldTarget = this._renderer.getRenderTarget();\n\n    this._setSize(256);\n\n    const cubeUVRenderTarget = this._allocateTargets();\n\n    cubeUVRenderTarget.depthBuffer = true;\n\n    this._sceneToCubeUV(scene, near, far, cubeUVRenderTarget);\n\n    if (sigma > 0) {\n      this._blur(cubeUVRenderTarget, 0, 0, sigma);\n    }\n\n    this._applyPMREM(cubeUVRenderTarget);\n\n    this._cleanup(cubeUVRenderTarget);\n\n    return cubeUVRenderTarget;\n  }\n  /**\r\n   * Generates a PMREM from an equirectangular texture, which can be either LDR\r\n   * or HDR. The ideal input image size is 1k (1024 x 512),\r\n   * as this matches best with the 256 x 256 cubemap output.\r\n   */\n\n\n  fromEquirectangular(equirectangular, renderTarget = null) {\n    return this._fromTexture(equirectangular, renderTarget);\n  }\n  /**\r\n   * Generates a PMREM from an cubemap texture, which can be either LDR\r\n   * or HDR. The ideal input cube size is 256 x 256,\r\n   * as this matches best with the 256 x 256 cubemap output.\r\n   */\n\n\n  fromCubemap(cubemap, renderTarget = null) {\n    return this._fromTexture(cubemap, renderTarget);\n  }\n  /**\r\n   * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during\r\n   * your texture's network fetch for increased concurrency.\r\n   */\n\n\n  compileCubemapShader() {\n    if (this._cubemapMaterial === null) {\n      this._cubemapMaterial = _getCubemapMaterial();\n\n      this._compileMaterial(this._cubemapMaterial);\n    }\n  }\n  /**\r\n   * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during\r\n   * your texture's network fetch for increased concurrency.\r\n   */\n\n\n  compileEquirectangularShader() {\n    if (this._equirectMaterial === null) {\n      this._equirectMaterial = _getEquirectMaterial();\n\n      this._compileMaterial(this._equirectMaterial);\n    }\n  }\n  /**\r\n   * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,\r\n   * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on\r\n   * one of them will cause any others to also become unusable.\r\n   */\n\n\n  dispose() {\n    this._dispose();\n\n    if (this._cubemapMaterial !== null) this._cubemapMaterial.dispose();\n    if (this._equirectMaterial !== null) this._equirectMaterial.dispose();\n  } // private interface\n\n\n  _setSize(cubeSize) {\n    this._lodMax = Math.floor(Math.log2(cubeSize));\n    this._cubeSize = Math.pow(2, this._lodMax);\n  }\n\n  _dispose() {\n    this._blurMaterial.dispose();\n\n    if (this._pingPongRenderTarget !== null) this._pingPongRenderTarget.dispose();\n\n    for (let i = 0; i < this._lodPlanes.length; i++) {\n      this._lodPlanes[i].dispose();\n    }\n  }\n\n  _cleanup(outputTarget) {\n    this._renderer.setRenderTarget(_oldTarget);\n\n    outputTarget.scissorTest = false;\n\n    _setViewport(outputTarget, 0, 0, outputTarget.width, outputTarget.height);\n  }\n\n  _fromTexture(texture, renderTarget) {\n    if (texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping) {\n      this._setSize(texture.image.length === 0 ? 16 : texture.image[0].width || texture.image[0].image.width);\n    } else {\n      // Equirectangular\n      this._setSize(texture.image.width / 4);\n    }\n\n    _oldTarget = this._renderer.getRenderTarget();\n\n    const cubeUVRenderTarget = renderTarget || this._allocateTargets();\n\n    this._textureToCubeUV(texture, cubeUVRenderTarget);\n\n    this._applyPMREM(cubeUVRenderTarget);\n\n    this._cleanup(cubeUVRenderTarget);\n\n    return cubeUVRenderTarget;\n  }\n\n  _allocateTargets() {\n    const width = 3 * Math.max(this._cubeSize, 16 * 7);\n    const height = 4 * this._cubeSize - 32;\n    const params = {\n      magFilter: LinearFilter,\n      minFilter: LinearFilter,\n      generateMipmaps: false,\n      type: HalfFloatType,\n      format: RGBAFormat,\n      encoding: LinearEncoding,\n      depthBuffer: false\n    };\n\n    const cubeUVRenderTarget = _createRenderTarget(width, height, params);\n\n    if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== width) {\n      if (this._pingPongRenderTarget !== null) {\n        this._dispose();\n      }\n\n      this._pingPongRenderTarget = _createRenderTarget(width, height, params);\n      const {\n        _lodMax\n      } = this;\n      ({\n        sizeLods: this._sizeLods,\n        lodPlanes: this._lodPlanes,\n        sigmas: this._sigmas\n      } = _createPlanes(_lodMax));\n      this._blurMaterial = _getBlurShader(_lodMax, width, height);\n    }\n\n    return cubeUVRenderTarget;\n  }\n\n  _compileMaterial(material) {\n    const tmpMesh = new Mesh(this._lodPlanes[0], material);\n\n    this._renderer.compile(tmpMesh, _flatCamera);\n  }\n\n  _sceneToCubeUV(scene, near, far, cubeUVRenderTarget) {\n    const fov = 90;\n    const aspect = 1;\n    const cubeCamera = new PerspectiveCamera(fov, aspect, near, far);\n    const upSign = [1, -1, 1, 1, 1, 1];\n    const forwardSign = [1, 1, 1, -1, -1, -1];\n    const renderer = this._renderer;\n    const originalAutoClear = renderer.autoClear;\n    const toneMapping = renderer.toneMapping;\n    renderer.getClearColor(_clearColor);\n    renderer.toneMapping = NoToneMapping;\n    renderer.autoClear = false;\n    const backgroundMaterial = new MeshBasicMaterial({\n      name: 'PMREM.Background',\n      side: BackSide,\n      depthWrite: false,\n      depthTest: false\n    });\n    const backgroundBox = new Mesh(new BoxGeometry(), backgroundMaterial);\n    let useSolidColor = false;\n    const background = scene.background;\n\n    if (background) {\n      if (background.isColor) {\n        backgroundMaterial.color.copy(background);\n        scene.background = null;\n        useSolidColor = true;\n      }\n    } else {\n      backgroundMaterial.color.copy(_clearColor);\n      useSolidColor = true;\n    }\n\n    for (let i = 0; i < 6; i++) {\n      const col = i % 3;\n\n      if (col === 0) {\n        cubeCamera.up.set(0, upSign[i], 0);\n        cubeCamera.lookAt(forwardSign[i], 0, 0);\n      } else if (col === 1) {\n        cubeCamera.up.set(0, 0, upSign[i]);\n        cubeCamera.lookAt(0, forwardSign[i], 0);\n      } else {\n        cubeCamera.up.set(0, upSign[i], 0);\n        cubeCamera.lookAt(0, 0, forwardSign[i]);\n      }\n\n      const size = this._cubeSize;\n\n      _setViewport(cubeUVRenderTarget, col * size, i > 2 ? size : 0, size, size);\n\n      renderer.setRenderTarget(cubeUVRenderTarget);\n\n      if (useSolidColor) {\n        renderer.render(backgroundBox, cubeCamera);\n      }\n\n      renderer.render(scene, cubeCamera);\n    }\n\n    backgroundBox.geometry.dispose();\n    backgroundBox.material.dispose();\n    renderer.toneMapping = toneMapping;\n    renderer.autoClear = originalAutoClear;\n    scene.background = background;\n  }\n\n  _textureToCubeUV(texture, cubeUVRenderTarget) {\n    const renderer = this._renderer;\n    const isCubeTexture = texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping;\n\n    if (isCubeTexture) {\n      if (this._cubemapMaterial === null) {\n        this._cubemapMaterial = _getCubemapMaterial();\n      }\n\n      this._cubemapMaterial.uniforms.flipEnvMap.value = texture.isRenderTargetTexture === false ? -1 : 1;\n    } else {\n      if (this._equirectMaterial === null) {\n        this._equirectMaterial = _getEquirectMaterial();\n      }\n    }\n\n    const material = isCubeTexture ? this._cubemapMaterial : this._equirectMaterial;\n    const mesh = new Mesh(this._lodPlanes[0], material);\n    const uniforms = material.uniforms;\n    uniforms['envMap'].value = texture;\n    const size = this._cubeSize;\n\n    _setViewport(cubeUVRenderTarget, 0, 0, 3 * size, 2 * size);\n\n    renderer.setRenderTarget(cubeUVRenderTarget);\n    renderer.render(mesh, _flatCamera);\n  }\n\n  _applyPMREM(cubeUVRenderTarget) {\n    const renderer = this._renderer;\n    const autoClear = renderer.autoClear;\n    renderer.autoClear = false;\n\n    for (let i = 1; i < this._lodPlanes.length; i++) {\n      const sigma = Math.sqrt(this._sigmas[i] * this._sigmas[i] - this._sigmas[i - 1] * this._sigmas[i - 1]);\n      const poleAxis = _axisDirections[(i - 1) % _axisDirections.length];\n\n      this._blur(cubeUVRenderTarget, i - 1, i, sigma, poleAxis);\n    }\n\n    renderer.autoClear = autoClear;\n  }\n  /**\r\n   * This is a two-pass Gaussian blur for a cubemap. Normally this is done\r\n   * vertically and horizontally, but this breaks down on a cube. Here we apply\r\n   * the blur latitudinally (around the poles), and then longitudinally (towards\r\n   * the poles) to approximate the orthogonally-separable blur. It is least\r\n   * accurate at the poles, but still does a decent job.\r\n   */\n\n\n  _blur(cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {\n    const pingPongRenderTarget = this._pingPongRenderTarget;\n\n    this._halfBlur(cubeUVRenderTarget, pingPongRenderTarget, lodIn, lodOut, sigma, 'latitudinal', poleAxis);\n\n    this._halfBlur(pingPongRenderTarget, cubeUVRenderTarget, lodOut, lodOut, sigma, 'longitudinal', poleAxis);\n  }\n\n  _halfBlur(targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis) {\n    const renderer = this._renderer;\n    const blurMaterial = this._blurMaterial;\n\n    if (direction !== 'latitudinal' && direction !== 'longitudinal') {\n      console.error('blur direction must be either latitudinal or longitudinal!');\n    } // Number of standard deviations at which to cut off the discrete approximation.\n\n\n    const STANDARD_DEVIATIONS = 3;\n    const blurMesh = new Mesh(this._lodPlanes[lodOut], blurMaterial);\n    const blurUniforms = blurMaterial.uniforms;\n    const pixels = this._sizeLods[lodIn] - 1;\n    const radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * MAX_SAMPLES - 1);\n    const sigmaPixels = sigmaRadians / radiansPerPixel;\n    const samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES;\n\n    if (samples > MAX_SAMPLES) {\n      console.warn(`sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to ${MAX_SAMPLES}`);\n    }\n\n    const weights = [];\n    let sum = 0;\n\n    for (let i = 0; i < MAX_SAMPLES; ++i) {\n      const x = i / sigmaPixels;\n      const weight = Math.exp(-x * x / 2);\n      weights.push(weight);\n\n      if (i === 0) {\n        sum += weight;\n      } else if (i < samples) {\n        sum += 2 * weight;\n      }\n    }\n\n    for (let i = 0; i < weights.length; i++) {\n      weights[i] = weights[i] / sum;\n    }\n\n    blurUniforms['envMap'].value = targetIn.texture;\n    blurUniforms['samples'].value = samples;\n    blurUniforms['weights'].value = weights;\n    blurUniforms['latitudinal'].value = direction === 'latitudinal';\n\n    if (poleAxis) {\n      blurUniforms['poleAxis'].value = poleAxis;\n    }\n\n    const {\n      _lodMax\n    } = this;\n    blurUniforms['dTheta'].value = radiansPerPixel;\n    blurUniforms['mipInt'].value = _lodMax - lodIn;\n    const outputSize = this._sizeLods[lodOut];\n    const x = 3 * outputSize * (lodOut > _lodMax - LOD_MIN ? lodOut - _lodMax + LOD_MIN : 0);\n    const y = 4 * (this._cubeSize - outputSize);\n\n    _setViewport(targetOut, x, y, 3 * outputSize, 2 * outputSize);\n\n    renderer.setRenderTarget(targetOut);\n    renderer.render(blurMesh, _flatCamera);\n  }\n\n}\n\nfunction _createPlanes(lodMax) {\n  const lodPlanes = [];\n  const sizeLods = [];\n  const sigmas = [];\n  let lod = lodMax;\n  const totalLods = lodMax - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;\n\n  for (let i = 0; i < totalLods; i++) {\n    const sizeLod = Math.pow(2, lod);\n    sizeLods.push(sizeLod);\n    let sigma = 1.0 / sizeLod;\n\n    if (i > lodMax - LOD_MIN) {\n      sigma = EXTRA_LOD_SIGMA[i - lodMax + LOD_MIN - 1];\n    } else if (i === 0) {\n      sigma = 0;\n    }\n\n    sigmas.push(sigma);\n    const texelSize = 1.0 / (sizeLod - 1);\n    const min = -texelSize / 2;\n    const max = 1 + texelSize / 2;\n    const uv1 = [min, min, max, min, max, max, min, min, max, max, min, max];\n    const cubeFaces = 6;\n    const vertices = 6;\n    const positionSize = 3;\n    const uvSize = 2;\n    const faceIndexSize = 1;\n    const position = new Float32Array(positionSize * vertices * cubeFaces);\n    const uv = new Float32Array(uvSize * vertices * cubeFaces);\n    const faceIndex = new Float32Array(faceIndexSize * vertices * cubeFaces);\n\n    for (let face = 0; face < cubeFaces; face++) {\n      const x = face % 3 * 2 / 3 - 1;\n      const y = face > 2 ? 0 : -1;\n      const coordinates = [x, y, 0, x + 2 / 3, y, 0, x + 2 / 3, y + 1, 0, x, y, 0, x + 2 / 3, y + 1, 0, x, y + 1, 0];\n      position.set(coordinates, positionSize * vertices * face);\n      uv.set(uv1, uvSize * vertices * face);\n      const fill = [face, face, face, face, face, face];\n      faceIndex.set(fill, faceIndexSize * vertices * face);\n    }\n\n    const planes = new BufferGeometry();\n    planes.setAttribute('position', new BufferAttribute(position, positionSize));\n    planes.setAttribute('uv', new BufferAttribute(uv, uvSize));\n    planes.setAttribute('faceIndex', new BufferAttribute(faceIndex, faceIndexSize));\n    lodPlanes.push(planes);\n\n    if (lod > LOD_MIN) {\n      lod--;\n    }\n  }\n\n  return {\n    lodPlanes,\n    sizeLods,\n    sigmas\n  };\n}\n\nfunction _createRenderTarget(width, height, params) {\n  const cubeUVRenderTarget = new WebGLRenderTarget(width, height, params);\n  cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;\n  cubeUVRenderTarget.texture.name = 'PMREM.cubeUv';\n  cubeUVRenderTarget.scissorTest = true;\n  return cubeUVRenderTarget;\n}\n\nfunction _setViewport(target, x, y, width, height) {\n  target.viewport.set(x, y, width, height);\n  target.scissor.set(x, y, width, height);\n}\n\nfunction _getBlurShader(lodMax, width, height) {\n  const weights = new Float32Array(MAX_SAMPLES);\n  const poleAxis = new Vector3(0, 1, 0);\n  const shaderMaterial = new ShaderMaterial({\n    name: 'SphericalGaussianBlur',\n    defines: {\n      'n': MAX_SAMPLES,\n      'CUBEUV_TEXEL_WIDTH': 1.0 / width,\n      'CUBEUV_TEXEL_HEIGHT': 1.0 / height,\n      'CUBEUV_MAX_MIP': `${lodMax}.0`\n    },\n    uniforms: {\n      'envMap': {\n        value: null\n      },\n      'samples': {\n        value: 1\n      },\n      'weights': {\n        value: weights\n      },\n      'latitudinal': {\n        value: false\n      },\n      'dTheta': {\n        value: 0\n      },\n      'mipInt': {\n        value: 0\n      },\n      'poleAxis': {\n        value: poleAxis\n      }\n    },\n    vertexShader: _getCommonVertexShader(),\n    fragmentShader:\n    /* glsl */\n    `\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t`,\n    blending: NoBlending,\n    depthTest: false,\n    depthWrite: false\n  });\n  return shaderMaterial;\n}\n\nfunction _getEquirectMaterial() {\n  return new ShaderMaterial({\n    name: 'EquirectangularToCubeUV',\n    uniforms: {\n      'envMap': {\n        value: null\n      }\n    },\n    vertexShader: _getCommonVertexShader(),\n    fragmentShader:\n    /* glsl */\n    `\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t`,\n    blending: NoBlending,\n    depthTest: false,\n    depthWrite: false\n  });\n}\n\nfunction _getCubemapMaterial() {\n  return new ShaderMaterial({\n    name: 'CubemapToCubeUV',\n    uniforms: {\n      'envMap': {\n        value: null\n      },\n      'flipEnvMap': {\n        value: -1\n      }\n    },\n    vertexShader: _getCommonVertexShader(),\n    fragmentShader:\n    /* glsl */\n    `\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t`,\n    blending: NoBlending,\n    depthTest: false,\n    depthWrite: false\n  });\n}\n\nfunction _getCommonVertexShader() {\n  return (\n    /* glsl */\n    `\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t`\n  );\n}\n\nexport { PMREMGenerator };","map":{"version":3,"sources":["C:/Users/dell/Desktop/projektlogin/vue-3-authentication-jwt/src/games/three/src/extras/PMREMGenerator.js"],"names":["CubeReflectionMapping","CubeRefractionMapping","CubeUVReflectionMapping","LinearEncoding","LinearFilter","NoToneMapping","NoBlending","RGBAFormat","HalfFloatType","BufferAttribute","BufferGeometry","Mesh","OrthographicCamera","PerspectiveCamera","ShaderMaterial","Vector3","Color","WebGLRenderTarget","MeshBasicMaterial","BoxGeometry","BackSide","LOD_MIN","EXTRA_LOD_SIGMA","MAX_SAMPLES","_flatCamera","_clearColor","_oldTarget","PHI","Math","sqrt","INV_PHI","_axisDirections","PMREMGenerator","constructor","renderer","_renderer","_pingPongRenderTarget","_lodMax","_cubeSize","_lodPlanes","_sizeLods","_sigmas","_blurMaterial","_cubemapMaterial","_equirectMaterial","_compileMaterial","fromScene","scene","sigma","near","far","getRenderTarget","_setSize","cubeUVRenderTarget","_allocateTargets","depthBuffer","_sceneToCubeUV","_blur","_applyPMREM","_cleanup","fromEquirectangular","equirectangular","renderTarget","_fromTexture","fromCubemap","cubemap","compileCubemapShader","_getCubemapMaterial","compileEquirectangularShader","_getEquirectMaterial","dispose","_dispose","cubeSize","floor","log2","pow","i","length","outputTarget","setRenderTarget","scissorTest","_setViewport","width","height","texture","mapping","image","_textureToCubeUV","max","params","magFilter","minFilter","generateMipmaps","type","format","encoding","_createRenderTarget","sizeLods","lodPlanes","sigmas","_createPlanes","_getBlurShader","material","tmpMesh","compile","fov","aspect","cubeCamera","upSign","forwardSign","originalAutoClear","autoClear","toneMapping","getClearColor","backgroundMaterial","name","side","depthWrite","depthTest","backgroundBox","useSolidColor","background","isColor","color","copy","col","up","set","lookAt","size","render","geometry","isCubeTexture","uniforms","flipEnvMap","value","isRenderTargetTexture","mesh","poleAxis","lodIn","lodOut","pingPongRenderTarget","_halfBlur","targetIn","targetOut","sigmaRadians","direction","blurMaterial","console","error","STANDARD_DEVIATIONS","blurMesh","blurUniforms","pixels","radiansPerPixel","isFinite","PI","sigmaPixels","samples","warn","weights","sum","x","weight","exp","push","outputSize","y","lodMax","lod","totalLods","sizeLod","texelSize","min","uv1","cubeFaces","vertices","positionSize","uvSize","faceIndexSize","position","Float32Array","uv","faceIndex","face","coordinates","fill","planes","setAttribute","target","viewport","scissor","shaderMaterial","defines","vertexShader","_getCommonVertexShader","fragmentShader","blending"],"mappings":"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","sourcesContent":["import {\r\n\tCubeReflectionMapping,\r\n\tCubeRefractionMapping,\r\n\tCubeUVReflectionMapping,\r\n\tLinearEncoding,\r\n\tLinearFilter,\r\n\tNoToneMapping,\r\n\tNoBlending,\r\n\tRGBAFormat,\r\n\tHalfFloatType\r\n} from '../constants.js';\r\n\r\nimport { BufferAttribute } from '../core/BufferAttribute.js';\r\nimport { BufferGeometry } from '../core/BufferGeometry.js';\r\nimport { Mesh } from '../objects/Mesh.js';\r\nimport { OrthographicCamera } from '../cameras/OrthographicCamera.js';\r\nimport { PerspectiveCamera } from '../cameras/PerspectiveCamera.js';\r\nimport { ShaderMaterial } from '../materials/ShaderMaterial.js';\r\nimport { Vector3 } from '../math/Vector3.js';\r\nimport { Color } from '../math/Color.js';\r\nimport { WebGLRenderTarget } from '../renderers/WebGLRenderTarget.js';\r\nimport { MeshBasicMaterial } from '../materials/MeshBasicMaterial.js';\r\nimport { BoxGeometry } from '../geometries/BoxGeometry.js';\r\nimport { BackSide } from '../constants.js';\r\n\r\nconst LOD_MIN = 4;\r\n\r\n// The standard deviations (radians) associated with the extra mips. These are\r\n// chosen to approximate a Trowbridge-Reitz distribution function times the\r\n// geometric shadowing function. These sigma values squared must match the\r\n// variance #defines in cube_uv_reflection_fragment.glsl.js.\r\nconst EXTRA_LOD_SIGMA = [ 0.125, 0.215, 0.35, 0.446, 0.526, 0.582 ];\r\n\r\n// The maximum length of the blur for loop. Smaller sigmas will use fewer\r\n// samples and exit early, but not recompile the shader.\r\nconst MAX_SAMPLES = 20;\r\n\r\nconst _flatCamera = /*@__PURE__*/ new OrthographicCamera();\r\nconst _clearColor = /*@__PURE__*/ new Color();\r\nlet _oldTarget = null;\r\n\r\n// Golden Ratio\r\nconst PHI = ( 1 + Math.sqrt( 5 ) ) / 2;\r\nconst INV_PHI = 1 / PHI;\r\n\r\n// Vertices of a dodecahedron (except the opposites, which represent the\r\n// same axis), used as axis directions evenly spread on a sphere.\r\nconst _axisDirections = [\r\n\t/*@__PURE__*/ new Vector3( 1, 1, 1 ),\r\n\t/*@__PURE__*/ new Vector3( - 1, 1, 1 ),\r\n\t/*@__PURE__*/ new Vector3( 1, 1, - 1 ),\r\n\t/*@__PURE__*/ new Vector3( - 1, 1, - 1 ),\r\n\t/*@__PURE__*/ new Vector3( 0, PHI, INV_PHI ),\r\n\t/*@__PURE__*/ new Vector3( 0, PHI, - INV_PHI ),\r\n\t/*@__PURE__*/ new Vector3( INV_PHI, 0, PHI ),\r\n\t/*@__PURE__*/ new Vector3( - INV_PHI, 0, PHI ),\r\n\t/*@__PURE__*/ new Vector3( PHI, INV_PHI, 0 ),\r\n\t/*@__PURE__*/ new Vector3( - PHI, INV_PHI, 0 ) ];\r\n\r\n/**\r\n * This class generates a Prefiltered, Mipmapped Radiance Environment Map\r\n * (PMREM) from a cubeMap environment texture. This allows different levels of\r\n * blur to be quickly accessed based on material roughness. It is packed into a\r\n * special CubeUV format that allows us to perform custom interpolation so that\r\n * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap\r\n * chain, it only goes down to the LOD_MIN level (above), and then creates extra\r\n * even more filtered 'mips' at the same LOD_MIN resolution, associated with\r\n * higher roughness levels. In this way we maintain resolution to smoothly\r\n * interpolate diffuse lighting while limiting sampling computation.\r\n *\r\n * Paper: Fast, Accurate Image-Based Lighting\r\n * https://drive.google.com/file/d/15y8r_UpKlU9SvV4ILb0C3qCPecS8pvLz/view\r\n*/\r\n\r\nclass PMREMGenerator {\r\n\r\n\tconstructor( renderer ) {\r\n\r\n\t\tthis._renderer = renderer;\r\n\t\tthis._pingPongRenderTarget = null;\r\n\r\n\t\tthis._lodMax = 0;\r\n\t\tthis._cubeSize = 0;\r\n\t\tthis._lodPlanes = [];\r\n\t\tthis._sizeLods = [];\r\n\t\tthis._sigmas = [];\r\n\r\n\t\tthis._blurMaterial = null;\r\n\t\tthis._cubemapMaterial = null;\r\n\t\tthis._equirectMaterial = null;\r\n\r\n\t\tthis._compileMaterial( this._blurMaterial );\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Generates a PMREM from a supplied Scene, which can be faster than using an\r\n\t * image if networking bandwidth is low. Optional sigma specifies a blur radius\r\n\t * in radians to be applied to the scene before PMREM generation. Optional near\r\n\t * and far planes ensure the scene is rendered in its entirety (the cubeCamera\r\n\t * is placed at the origin).\r\n\t */\r\n\tfromScene( scene, sigma = 0, near = 0.1, far = 100 ) {\r\n\r\n\t\t_oldTarget = this._renderer.getRenderTarget();\r\n\r\n\t\tthis._setSize( 256 );\r\n\r\n\t\tconst cubeUVRenderTarget = this._allocateTargets();\r\n\t\tcubeUVRenderTarget.depthBuffer = true;\r\n\r\n\t\tthis._sceneToCubeUV( scene, near, far, cubeUVRenderTarget );\r\n\r\n\t\tif ( sigma > 0 ) {\r\n\r\n\t\t\tthis._blur( cubeUVRenderTarget, 0, 0, sigma );\r\n\r\n\t\t}\r\n\r\n\t\tthis._applyPMREM( cubeUVRenderTarget );\r\n\t\tthis._cleanup( cubeUVRenderTarget );\r\n\r\n\t\treturn cubeUVRenderTarget;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Generates a PMREM from an equirectangular texture, which can be either LDR\r\n\t * or HDR. The ideal input image size is 1k (1024 x 512),\r\n\t * as this matches best with the 256 x 256 cubemap output.\r\n\t */\r\n\tfromEquirectangular( equirectangular, renderTarget = null ) {\r\n\r\n\t\treturn this._fromTexture( equirectangular, renderTarget );\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Generates a PMREM from an cubemap texture, which can be either LDR\r\n\t * or HDR. The ideal input cube size is 256 x 256,\r\n\t * as this matches best with the 256 x 256 cubemap output.\r\n\t */\r\n\tfromCubemap( cubemap, renderTarget = null ) {\r\n\r\n\t\treturn this._fromTexture( cubemap, renderTarget );\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during\r\n\t * your texture's network fetch for increased concurrency.\r\n\t */\r\n\tcompileCubemapShader() {\r\n\r\n\t\tif ( this._cubemapMaterial === null ) {\r\n\r\n\t\t\tthis._cubemapMaterial = _getCubemapMaterial();\r\n\t\t\tthis._compileMaterial( this._cubemapMaterial );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during\r\n\t * your texture's network fetch for increased concurrency.\r\n\t */\r\n\tcompileEquirectangularShader() {\r\n\r\n\t\tif ( this._equirectMaterial === null ) {\r\n\r\n\t\t\tthis._equirectMaterial = _getEquirectMaterial();\r\n\t\t\tthis._compileMaterial( this._equirectMaterial );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,\r\n\t * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on\r\n\t * one of them will cause any others to also become unusable.\r\n\t */\r\n\tdispose() {\r\n\r\n\t\tthis._dispose();\r\n\r\n\t\tif ( this._cubemapMaterial !== null ) this._cubemapMaterial.dispose();\r\n\t\tif ( this._equirectMaterial !== null ) this._equirectMaterial.dispose();\r\n\r\n\t}\r\n\r\n\t// private interface\r\n\r\n\t_setSize( cubeSize ) {\r\n\r\n\t\tthis._lodMax = Math.floor( Math.log2( cubeSize ) );\r\n\t\tthis._cubeSize = Math.pow( 2, this._lodMax );\r\n\r\n\t}\r\n\r\n\t_dispose() {\r\n\r\n\t\tthis._blurMaterial.dispose();\r\n\r\n\t\tif ( this._pingPongRenderTarget !== null ) this._pingPongRenderTarget.dispose();\r\n\r\n\t\tfor ( let i = 0; i < this._lodPlanes.length; i ++ ) {\r\n\r\n\t\t\tthis._lodPlanes[ i ].dispose();\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t_cleanup( outputTarget ) {\r\n\r\n\t\tthis._renderer.setRenderTarget( _oldTarget );\r\n\t\toutputTarget.scissorTest = false;\r\n\t\t_setViewport( outputTarget, 0, 0, outputTarget.width, outputTarget.height );\r\n\r\n\t}\r\n\r\n\t_fromTexture( texture, renderTarget ) {\r\n\r\n\t\tif ( texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping ) {\r\n\r\n\t\t\tthis._setSize( texture.image.length === 0 ? 16 : ( texture.image[ 0 ].width || texture.image[ 0 ].image.width ) );\r\n\r\n\t\t} else { // Equirectangular\r\n\r\n\t\t\tthis._setSize( texture.image.width / 4 );\r\n\r\n\t\t}\r\n\r\n\t\t_oldTarget = this._renderer.getRenderTarget();\r\n\r\n\t\tconst cubeUVRenderTarget = renderTarget || this._allocateTargets();\r\n\t\tthis._textureToCubeUV( texture, cubeUVRenderTarget );\r\n\t\tthis._applyPMREM( cubeUVRenderTarget );\r\n\t\tthis._cleanup( cubeUVRenderTarget );\r\n\r\n\t\treturn cubeUVRenderTarget;\r\n\r\n\t}\r\n\r\n\t_allocateTargets() {\r\n\r\n\t\tconst width = 3 * Math.max( this._cubeSize, 16 * 7 );\r\n\t\tconst height = 4 * this._cubeSize - 32;\r\n\r\n\t\tconst params = {\r\n\t\t\tmagFilter: LinearFilter,\r\n\t\t\tminFilter: LinearFilter,\r\n\t\t\tgenerateMipmaps: false,\r\n\t\t\ttype: HalfFloatType,\r\n\t\t\tformat: RGBAFormat,\r\n\t\t\tencoding: LinearEncoding,\r\n\t\t\tdepthBuffer: false\r\n\t\t};\r\n\r\n\t\tconst cubeUVRenderTarget = _createRenderTarget( width, height, params );\r\n\r\n\t\tif ( this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== width ) {\r\n\r\n\t\t\tif ( this._pingPongRenderTarget !== null ) {\r\n\r\n\t\t\t\tthis._dispose();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis._pingPongRenderTarget = _createRenderTarget( width, height, params );\r\n\r\n\t\t\tconst { _lodMax } = this;\r\n\t\t\t( { sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = _createPlanes( _lodMax ) );\r\n\r\n\t\t\tthis._blurMaterial = _getBlurShader( _lodMax, width, height );\r\n\r\n\t\t}\r\n\r\n\t\treturn cubeUVRenderTarget;\r\n\r\n\t}\r\n\r\n\t_compileMaterial( material ) {\r\n\r\n\t\tconst tmpMesh = new Mesh( this._lodPlanes[ 0 ], material );\r\n\t\tthis._renderer.compile( tmpMesh, _flatCamera );\r\n\r\n\t}\r\n\r\n\t_sceneToCubeUV( scene, near, far, cubeUVRenderTarget ) {\r\n\r\n\t\tconst fov = 90;\r\n\t\tconst aspect = 1;\r\n\t\tconst cubeCamera = new PerspectiveCamera( fov, aspect, near, far );\r\n\t\tconst upSign = [ 1, - 1, 1, 1, 1, 1 ];\r\n\t\tconst forwardSign = [ 1, 1, 1, - 1, - 1, - 1 ];\r\n\t\tconst renderer = this._renderer;\r\n\r\n\t\tconst originalAutoClear = renderer.autoClear;\r\n\t\tconst toneMapping = renderer.toneMapping;\r\n\t\trenderer.getClearColor( _clearColor );\r\n\r\n\t\trenderer.toneMapping = NoToneMapping;\r\n\t\trenderer.autoClear = false;\r\n\r\n\t\tconst backgroundMaterial = new MeshBasicMaterial( {\r\n\t\t\tname: 'PMREM.Background',\r\n\t\t\tside: BackSide,\r\n\t\t\tdepthWrite: false,\r\n\t\t\tdepthTest: false,\r\n\t\t} );\r\n\r\n\t\tconst backgroundBox = new Mesh( new BoxGeometry(), backgroundMaterial );\r\n\r\n\t\tlet useSolidColor = false;\r\n\t\tconst background = scene.background;\r\n\r\n\t\tif ( background ) {\r\n\r\n\t\t\tif ( background.isColor ) {\r\n\r\n\t\t\t\tbackgroundMaterial.color.copy( background );\r\n\t\t\t\tscene.background = null;\r\n\t\t\t\tuseSolidColor = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tbackgroundMaterial.color.copy( _clearColor );\r\n\t\t\tuseSolidColor = true;\r\n\r\n\t\t}\r\n\r\n\t\tfor ( let i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\tconst col = i % 3;\r\n\r\n\t\t\tif ( col === 0 ) {\r\n\r\n\t\t\t\tcubeCamera.up.set( 0, upSign[ i ], 0 );\r\n\t\t\t\tcubeCamera.lookAt( forwardSign[ i ], 0, 0 );\r\n\r\n\t\t\t} else if ( col === 1 ) {\r\n\r\n\t\t\t\tcubeCamera.up.set( 0, 0, upSign[ i ] );\r\n\t\t\t\tcubeCamera.lookAt( 0, forwardSign[ i ], 0 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tcubeCamera.up.set( 0, upSign[ i ], 0 );\r\n\t\t\t\tcubeCamera.lookAt( 0, 0, forwardSign[ i ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst size = this._cubeSize;\r\n\r\n\t\t\t_setViewport( cubeUVRenderTarget, col * size, i > 2 ? size : 0, size, size );\r\n\r\n\t\t\trenderer.setRenderTarget( cubeUVRenderTarget );\r\n\r\n\t\t\tif ( useSolidColor ) {\r\n\r\n\t\t\t\trenderer.render( backgroundBox, cubeCamera );\r\n\r\n\t\t\t}\r\n\r\n\t\t\trenderer.render( scene, cubeCamera );\r\n\r\n\t\t}\r\n\r\n\t\tbackgroundBox.geometry.dispose();\r\n\t\tbackgroundBox.material.dispose();\r\n\r\n\t\trenderer.toneMapping = toneMapping;\r\n\t\trenderer.autoClear = originalAutoClear;\r\n\t\tscene.background = background;\r\n\r\n\t}\r\n\r\n\t_textureToCubeUV( texture, cubeUVRenderTarget ) {\r\n\r\n\t\tconst renderer = this._renderer;\r\n\r\n\t\tconst isCubeTexture = ( texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping );\r\n\r\n\t\tif ( isCubeTexture ) {\r\n\r\n\t\t\tif ( this._cubemapMaterial === null ) {\r\n\r\n\t\t\t\tthis._cubemapMaterial = _getCubemapMaterial();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis._cubemapMaterial.uniforms.flipEnvMap.value = ( texture.isRenderTargetTexture === false ) ? - 1 : 1;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tif ( this._equirectMaterial === null ) {\r\n\r\n\t\t\t\tthis._equirectMaterial = _getEquirectMaterial();\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tconst material = isCubeTexture ? this._cubemapMaterial : this._equirectMaterial;\r\n\t\tconst mesh = new Mesh( this._lodPlanes[ 0 ], material );\r\n\r\n\t\tconst uniforms = material.uniforms;\r\n\r\n\t\tuniforms[ 'envMap' ].value = texture;\r\n\r\n\t\tconst size = this._cubeSize;\r\n\r\n\t\t_setViewport( cubeUVRenderTarget, 0, 0, 3 * size, 2 * size );\r\n\r\n\t\trenderer.setRenderTarget( cubeUVRenderTarget );\r\n\t\trenderer.render( mesh, _flatCamera );\r\n\r\n\t}\r\n\r\n\t_applyPMREM( cubeUVRenderTarget ) {\r\n\r\n\t\tconst renderer = this._renderer;\r\n\t\tconst autoClear = renderer.autoClear;\r\n\t\trenderer.autoClear = false;\r\n\r\n\t\tfor ( let i = 1; i < this._lodPlanes.length; i ++ ) {\r\n\r\n\t\t\tconst sigma = Math.sqrt( this._sigmas[ i ] * this._sigmas[ i ] - this._sigmas[ i - 1 ] * this._sigmas[ i - 1 ] );\r\n\r\n\t\t\tconst poleAxis = _axisDirections[ ( i - 1 ) % _axisDirections.length ];\r\n\r\n\t\t\tthis._blur( cubeUVRenderTarget, i - 1, i, sigma, poleAxis );\r\n\r\n\t\t}\r\n\r\n\t\trenderer.autoClear = autoClear;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * This is a two-pass Gaussian blur for a cubemap. Normally this is done\r\n\t * vertically and horizontally, but this breaks down on a cube. Here we apply\r\n\t * the blur latitudinally (around the poles), and then longitudinally (towards\r\n\t * the poles) to approximate the orthogonally-separable blur. It is least\r\n\t * accurate at the poles, but still does a decent job.\r\n\t */\r\n\t_blur( cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis ) {\r\n\r\n\t\tconst pingPongRenderTarget = this._pingPongRenderTarget;\r\n\r\n\t\tthis._halfBlur(\r\n\t\t\tcubeUVRenderTarget,\r\n\t\t\tpingPongRenderTarget,\r\n\t\t\tlodIn,\r\n\t\t\tlodOut,\r\n\t\t\tsigma,\r\n\t\t\t'latitudinal',\r\n\t\t\tpoleAxis );\r\n\r\n\t\tthis._halfBlur(\r\n\t\t\tpingPongRenderTarget,\r\n\t\t\tcubeUVRenderTarget,\r\n\t\t\tlodOut,\r\n\t\t\tlodOut,\r\n\t\t\tsigma,\r\n\t\t\t'longitudinal',\r\n\t\t\tpoleAxis );\r\n\r\n\t}\r\n\r\n\t_halfBlur( targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis ) {\r\n\r\n\t\tconst renderer = this._renderer;\r\n\t\tconst blurMaterial = this._blurMaterial;\r\n\r\n\t\tif ( direction !== 'latitudinal' && direction !== 'longitudinal' ) {\r\n\r\n\t\t\tconsole.error(\r\n\t\t\t\t'blur direction must be either latitudinal or longitudinal!' );\r\n\r\n\t\t}\r\n\r\n\t\t// Number of standard deviations at which to cut off the discrete approximation.\r\n\t\tconst STANDARD_DEVIATIONS = 3;\r\n\r\n\t\tconst blurMesh = new Mesh( this._lodPlanes[ lodOut ], blurMaterial );\r\n\t\tconst blurUniforms = blurMaterial.uniforms;\r\n\r\n\t\tconst pixels = this._sizeLods[ lodIn ] - 1;\r\n\t\tconst radiansPerPixel = isFinite( sigmaRadians ) ? Math.PI / ( 2 * pixels ) : 2 * Math.PI / ( 2 * MAX_SAMPLES - 1 );\r\n\t\tconst sigmaPixels = sigmaRadians / radiansPerPixel;\r\n\t\tconst samples = isFinite( sigmaRadians ) ? 1 + Math.floor( STANDARD_DEVIATIONS * sigmaPixels ) : MAX_SAMPLES;\r\n\r\n\t\tif ( samples > MAX_SAMPLES ) {\r\n\r\n\t\t\tconsole.warn( `sigmaRadians, ${\r\n\t\t\t\tsigmaRadians}, is too large and will clip, as it requested ${\r\n\t\t\t\tsamples} samples when the maximum is set to ${MAX_SAMPLES}` );\r\n\r\n\t\t}\r\n\r\n\t\tconst weights = [];\r\n\t\tlet sum = 0;\r\n\r\n\t\tfor ( let i = 0; i < MAX_SAMPLES; ++ i ) {\r\n\r\n\t\t\tconst x = i / sigmaPixels;\r\n\t\t\tconst weight = Math.exp( - x * x / 2 );\r\n\t\t\tweights.push( weight );\r\n\r\n\t\t\tif ( i === 0 ) {\r\n\r\n\t\t\t\tsum += weight;\r\n\r\n\t\t\t} else if ( i < samples ) {\r\n\r\n\t\t\t\tsum += 2 * weight;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfor ( let i = 0; i < weights.length; i ++ ) {\r\n\r\n\t\t\tweights[ i ] = weights[ i ] / sum;\r\n\r\n\t\t}\r\n\r\n\t\tblurUniforms[ 'envMap' ].value = targetIn.texture;\r\n\t\tblurUniforms[ 'samples' ].value = samples;\r\n\t\tblurUniforms[ 'weights' ].value = weights;\r\n\t\tblurUniforms[ 'latitudinal' ].value = direction === 'latitudinal';\r\n\r\n\t\tif ( poleAxis ) {\r\n\r\n\t\t\tblurUniforms[ 'poleAxis' ].value = poleAxis;\r\n\r\n\t\t}\r\n\r\n\t\tconst { _lodMax } = this;\r\n\t\tblurUniforms[ 'dTheta' ].value = radiansPerPixel;\r\n\t\tblurUniforms[ 'mipInt' ].value = _lodMax - lodIn;\r\n\r\n\t\tconst outputSize = this._sizeLods[ lodOut ];\r\n\t\tconst x = 3 * outputSize * ( lodOut > _lodMax - LOD_MIN ? lodOut - _lodMax + LOD_MIN : 0 );\r\n\t\tconst y = 4 * ( this._cubeSize - outputSize );\r\n\r\n\t\t_setViewport( targetOut, x, y, 3 * outputSize, 2 * outputSize );\r\n\t\trenderer.setRenderTarget( targetOut );\r\n\t\trenderer.render( blurMesh, _flatCamera );\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nfunction _createPlanes( lodMax ) {\r\n\r\n\tconst lodPlanes = [];\r\n\tconst sizeLods = [];\r\n\tconst sigmas = [];\r\n\r\n\tlet lod = lodMax;\r\n\r\n\tconst totalLods = lodMax - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;\r\n\r\n\tfor ( let i = 0; i < totalLods; i ++ ) {\r\n\r\n\t\tconst sizeLod = Math.pow( 2, lod );\r\n\t\tsizeLods.push( sizeLod );\r\n\t\tlet sigma = 1.0 / sizeLod;\r\n\r\n\t\tif ( i > lodMax - LOD_MIN ) {\r\n\r\n\t\t\tsigma = EXTRA_LOD_SIGMA[ i - lodMax + LOD_MIN - 1 ];\r\n\r\n\t\t} else if ( i === 0 ) {\r\n\r\n\t\t\tsigma = 0;\r\n\r\n\t\t}\r\n\r\n\t\tsigmas.push( sigma );\r\n\r\n\t\tconst texelSize = 1.0 / ( sizeLod - 1 );\r\n\t\tconst min = - texelSize / 2;\r\n\t\tconst max = 1 + texelSize / 2;\r\n\t\tconst uv1 = [ min, min, max, min, max, max, min, min, max, max, min, max ];\r\n\r\n\t\tconst cubeFaces = 6;\r\n\t\tconst vertices = 6;\r\n\t\tconst positionSize = 3;\r\n\t\tconst uvSize = 2;\r\n\t\tconst faceIndexSize = 1;\r\n\r\n\t\tconst position = new Float32Array( positionSize * vertices * cubeFaces );\r\n\t\tconst uv = new Float32Array( uvSize * vertices * cubeFaces );\r\n\t\tconst faceIndex = new Float32Array( faceIndexSize * vertices * cubeFaces );\r\n\r\n\t\tfor ( let face = 0; face < cubeFaces; face ++ ) {\r\n\r\n\t\t\tconst x = ( face % 3 ) * 2 / 3 - 1;\r\n\t\t\tconst y = face > 2 ? 0 : - 1;\r\n\t\t\tconst coordinates = [\r\n\t\t\t\tx, y, 0,\r\n\t\t\t\tx + 2 / 3, y, 0,\r\n\t\t\t\tx + 2 / 3, y + 1, 0,\r\n\t\t\t\tx, y, 0,\r\n\t\t\t\tx + 2 / 3, y + 1, 0,\r\n\t\t\t\tx, y + 1, 0\r\n\t\t\t];\r\n\t\t\tposition.set( coordinates, positionSize * vertices * face );\r\n\t\t\tuv.set( uv1, uvSize * vertices * face );\r\n\t\t\tconst fill = [ face, face, face, face, face, face ];\r\n\t\t\tfaceIndex.set( fill, faceIndexSize * vertices * face );\r\n\r\n\t\t}\r\n\r\n\t\tconst planes = new BufferGeometry();\r\n\t\tplanes.setAttribute( 'position', new BufferAttribute( position, positionSize ) );\r\n\t\tplanes.setAttribute( 'uv', new BufferAttribute( uv, uvSize ) );\r\n\t\tplanes.setAttribute( 'faceIndex', new BufferAttribute( faceIndex, faceIndexSize ) );\r\n\t\tlodPlanes.push( planes );\r\n\r\n\t\tif ( lod > LOD_MIN ) {\r\n\r\n\t\t\tlod --;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn { lodPlanes, sizeLods, sigmas };\r\n\r\n}\r\n\r\nfunction _createRenderTarget( width, height, params ) {\r\n\r\n\tconst cubeUVRenderTarget = new WebGLRenderTarget( width, height, params );\r\n\tcubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;\r\n\tcubeUVRenderTarget.texture.name = 'PMREM.cubeUv';\r\n\tcubeUVRenderTarget.scissorTest = true;\r\n\treturn cubeUVRenderTarget;\r\n\r\n}\r\n\r\nfunction _setViewport( target, x, y, width, height ) {\r\n\r\n\ttarget.viewport.set( x, y, width, height );\r\n\ttarget.scissor.set( x, y, width, height );\r\n\r\n}\r\n\r\nfunction _getBlurShader( lodMax, width, height ) {\r\n\r\n\tconst weights = new Float32Array( MAX_SAMPLES );\r\n\tconst poleAxis = new Vector3( 0, 1, 0 );\r\n\tconst shaderMaterial = new ShaderMaterial( {\r\n\r\n\t\tname: 'SphericalGaussianBlur',\r\n\r\n\t\tdefines: {\r\n\t\t\t'n': MAX_SAMPLES,\r\n\t\t\t'CUBEUV_TEXEL_WIDTH': 1.0 / width,\r\n\t\t\t'CUBEUV_TEXEL_HEIGHT': 1.0 / height,\r\n\t\t\t'CUBEUV_MAX_MIP': `${lodMax}.0`,\r\n\t\t},\r\n\r\n\t\tuniforms: {\r\n\t\t\t'envMap': { value: null },\r\n\t\t\t'samples': { value: 1 },\r\n\t\t\t'weights': { value: weights },\r\n\t\t\t'latitudinal': { value: false },\r\n\t\t\t'dTheta': { value: 0 },\r\n\t\t\t'mipInt': { value: 0 },\r\n\t\t\t'poleAxis': { value: poleAxis }\r\n\t\t},\r\n\r\n\t\tvertexShader: _getCommonVertexShader(),\r\n\r\n\t\tfragmentShader: /* glsl */`\r\n\r\n\t\t\tprecision mediump float;\r\n\t\t\tprecision mediump int;\r\n\r\n\t\t\tvarying vec3 vOutputDirection;\r\n\r\n\t\t\tuniform sampler2D envMap;\r\n\t\t\tuniform int samples;\r\n\t\t\tuniform float weights[ n ];\r\n\t\t\tuniform bool latitudinal;\r\n\t\t\tuniform float dTheta;\r\n\t\t\tuniform float mipInt;\r\n\t\t\tuniform vec3 poleAxis;\r\n\r\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\r\n\t\t\t#include <cube_uv_reflection_fragment>\r\n\r\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\r\n\r\n\t\t\t\tfloat cosTheta = cos( theta );\r\n\t\t\t\t// Rodrigues' axis-angle rotation\r\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\r\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\r\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\r\n\r\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvoid main() {\r\n\r\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\r\n\r\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\r\n\r\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\taxis = normalize( axis );\r\n\r\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\r\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\r\n\r\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\r\n\r\n\t\t\t\t\tif ( i >= samples ) {\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tfloat theta = dTheta * float( i );\r\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\r\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t`,\r\n\r\n\t\tblending: NoBlending,\r\n\t\tdepthTest: false,\r\n\t\tdepthWrite: false\r\n\r\n\t} );\r\n\r\n\treturn shaderMaterial;\r\n\r\n}\r\n\r\nfunction _getEquirectMaterial() {\r\n\r\n\treturn new ShaderMaterial( {\r\n\r\n\t\tname: 'EquirectangularToCubeUV',\r\n\r\n\t\tuniforms: {\r\n\t\t\t'envMap': { value: null }\r\n\t\t},\r\n\r\n\t\tvertexShader: _getCommonVertexShader(),\r\n\r\n\t\tfragmentShader: /* glsl */`\r\n\r\n\t\t\tprecision mediump float;\r\n\t\t\tprecision mediump int;\r\n\r\n\t\t\tvarying vec3 vOutputDirection;\r\n\r\n\t\t\tuniform sampler2D envMap;\r\n\r\n\t\t\t#include <common>\r\n\r\n\t\t\tvoid main() {\r\n\r\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\r\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\r\n\r\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\r\n\r\n\t\t\t}\r\n\t\t`,\r\n\r\n\t\tblending: NoBlending,\r\n\t\tdepthTest: false,\r\n\t\tdepthWrite: false\r\n\r\n\t} );\r\n\r\n}\r\n\r\nfunction _getCubemapMaterial() {\r\n\r\n\treturn new ShaderMaterial( {\r\n\r\n\t\tname: 'CubemapToCubeUV',\r\n\r\n\t\tuniforms: {\r\n\t\t\t'envMap': { value: null },\r\n\t\t\t'flipEnvMap': { value: - 1 }\r\n\t\t},\r\n\r\n\t\tvertexShader: _getCommonVertexShader(),\r\n\r\n\t\tfragmentShader: /* glsl */`\r\n\r\n\t\t\tprecision mediump float;\r\n\t\t\tprecision mediump int;\r\n\r\n\t\t\tuniform float flipEnvMap;\r\n\r\n\t\t\tvarying vec3 vOutputDirection;\r\n\r\n\t\t\tuniform samplerCube envMap;\r\n\r\n\t\t\tvoid main() {\r\n\r\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\r\n\r\n\t\t\t}\r\n\t\t`,\r\n\r\n\t\tblending: NoBlending,\r\n\t\tdepthTest: false,\r\n\t\tdepthWrite: false\r\n\r\n\t} );\r\n\r\n}\r\n\r\nfunction _getCommonVertexShader() {\r\n\r\n\treturn /* glsl */`\r\n\r\n\t\tprecision mediump float;\r\n\t\tprecision mediump int;\r\n\r\n\t\tattribute float faceIndex;\r\n\r\n\t\tvarying vec3 vOutputDirection;\r\n\r\n\t\t// RH coordinate system; PMREM face-indexing convention\r\n\t\tvec3 getDirection( vec2 uv, float face ) {\r\n\r\n\t\t\tuv = 2.0 * uv - 1.0;\r\n\r\n\t\t\tvec3 direction = vec3( uv, 1.0 );\r\n\r\n\t\t\tif ( face == 0.0 ) {\r\n\r\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\r\n\r\n\t\t\t} else if ( face == 1.0 ) {\r\n\r\n\t\t\t\tdirection = direction.xzy;\r\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\r\n\r\n\t\t\t} else if ( face == 2.0 ) {\r\n\r\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\r\n\r\n\t\t\t} else if ( face == 3.0 ) {\r\n\r\n\t\t\t\tdirection = direction.zyx;\r\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\r\n\r\n\t\t\t} else if ( face == 4.0 ) {\r\n\r\n\t\t\t\tdirection = direction.xzy;\r\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\r\n\r\n\t\t\t} else if ( face == 5.0 ) {\r\n\r\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn direction;\r\n\r\n\t\t}\r\n\r\n\t\tvoid main() {\r\n\r\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\r\n\t\t\tgl_Position = vec4( position, 1.0 );\r\n\r\n\t\t}\r\n\t`;\r\n\r\n}\r\n\r\nexport { PMREMGenerator };\r\n"]},"metadata":{},"sourceType":"module"}