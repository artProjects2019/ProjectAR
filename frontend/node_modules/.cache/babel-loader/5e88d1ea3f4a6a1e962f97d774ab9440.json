{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\n\n/**\r\n * Abstract base class of interpolants over parametric samples.\r\n *\r\n * The parameter domain is one dimensional, typically the time or a path\r\n * along a curve defined by the data.\r\n *\r\n * The sample values can have any dimensionality and derived classes may\r\n * apply special interpretations to the data.\r\n *\r\n * This class provides the interval seek in a Template Method, deferring\r\n * the actual interpolation to derived classes.\r\n *\r\n * Time complexity is O(1) for linear access crossing at most two points\r\n * and O(log N) for random access, where N is the number of positions.\r\n *\r\n * References:\r\n *\r\n * \t\thttp://www.oodesign.com/template-method-pattern.html\r\n *\r\n */\nclass Interpolant {\n  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {\n    this.parameterPositions = parameterPositions;\n    this._cachedIndex = 0;\n    this.resultBuffer = resultBuffer !== undefined ? resultBuffer : new sampleValues.constructor(sampleSize);\n    this.sampleValues = sampleValues;\n    this.valueSize = sampleSize;\n    this.settings = null;\n    this.DefaultSettings_ = {};\n  }\n\n  evaluate(t) {\n    const pp = this.parameterPositions;\n    let i1 = this._cachedIndex,\n        t1 = pp[i1],\n        t0 = pp[i1 - 1];\n\n    validate_interval: {\n      seek: {\n        let right;\n\n        linear_scan: {\n          //- See http://jsperf.com/comparison-to-undefined/3\n          //- slower code:\n          //-\n          //- \t\t\t\tif ( t >= t1 || t1 === undefined ) {\n          forward_scan: if (!(t < t1)) {\n            for (let giveUpAt = i1 + 2;;) {\n              if (t1 === undefined) {\n                if (t < t0) break forward_scan; // after end\n\n                i1 = pp.length;\n                this._cachedIndex = i1;\n                return this.afterEnd_(i1 - 1, t, t0);\n              }\n\n              if (i1 === giveUpAt) break; // this loop\n\n              t0 = t1;\n              t1 = pp[++i1];\n\n              if (t < t1) {\n                // we have arrived at the sought interval\n                break seek;\n              }\n            } // prepare binary search on the right side of the index\n\n\n            right = pp.length;\n            break linear_scan;\n          } //- slower code:\n          //-\t\t\t\t\tif ( t < t0 || t0 === undefined ) {\n\n\n          if (!(t >= t0)) {\n            // looping?\n            const t1global = pp[1];\n\n            if (t < t1global) {\n              i1 = 2; // + 1, using the scan for the details\n\n              t0 = t1global;\n            } // linear reverse scan\n\n\n            for (let giveUpAt = i1 - 2;;) {\n              if (t0 === undefined) {\n                // before start\n                this._cachedIndex = 0;\n                return this.beforeStart_(0, t, t1);\n              }\n\n              if (i1 === giveUpAt) break; // this loop\n\n              t1 = t0;\n              t0 = pp[--i1 - 1];\n\n              if (t >= t0) {\n                // we have arrived at the sought interval\n                break seek;\n              }\n            } // prepare binary search on the left side of the index\n\n\n            right = i1;\n            i1 = 0;\n            break linear_scan;\n          } // the interval is valid\n\n\n          break validate_interval;\n        } // linear scan\n        // binary search\n\n\n        while (i1 < right) {\n          const mid = i1 + right >>> 1;\n\n          if (t < pp[mid]) {\n            right = mid;\n          } else {\n            i1 = mid + 1;\n          }\n        }\n\n        t1 = pp[i1];\n        t0 = pp[i1 - 1]; // check boundary cases, again\n\n        if (t0 === undefined) {\n          this._cachedIndex = 0;\n          return this.beforeStart_(0, t, t1);\n        }\n\n        if (t1 === undefined) {\n          i1 = pp.length;\n          this._cachedIndex = i1;\n          return this.afterEnd_(i1 - 1, t0, t);\n        }\n      } // seek\n\n\n      this._cachedIndex = i1;\n      this.intervalChanged_(i1, t0, t1);\n    } // validate_interval\n\n\n    return this.interpolate_(i1, t0, t, t1);\n  }\n\n  getSettings_() {\n    return this.settings || this.DefaultSettings_;\n  }\n\n  copySampleValue_(index) {\n    // copies a sample value to the result buffer\n    const result = this.resultBuffer,\n          values = this.sampleValues,\n          stride = this.valueSize,\n          offset = index * stride;\n\n    for (let i = 0; i !== stride; ++i) {\n      result[i] = values[offset + i];\n    }\n\n    return result;\n  } // Template methods for derived classes:\n\n\n  interpolate_() {\n    throw new Error('call to abstract method'); // implementations shall return this.resultBuffer\n  }\n\n  intervalChanged_() {// empty\n  }\n\n} // ALIAS DEFINITIONS\n\n\nInterpolant.prototype.beforeStart_ = Interpolant.prototype.copySampleValue_;\nInterpolant.prototype.afterEnd_ = Interpolant.prototype.copySampleValue_;\nexport { Interpolant };","map":{"version":3,"sources":["C:/Users/dell/Desktop/projektlogin/vue-3-authentication-jwt/src/games/three/src/math/Interpolant.js"],"names":["Interpolant","constructor","parameterPositions","sampleValues","sampleSize","resultBuffer","_cachedIndex","undefined","valueSize","settings","DefaultSettings_","evaluate","t","pp","i1","t1","t0","validate_interval","seek","right","linear_scan","forward_scan","giveUpAt","length","afterEnd_","t1global","beforeStart_","mid","intervalChanged_","interpolate_","getSettings_","copySampleValue_","index","result","values","stride","offset","i","Error","prototype"],"mappings":"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","sourcesContent":["/**\r\n * Abstract base class of interpolants over parametric samples.\r\n *\r\n * The parameter domain is one dimensional, typically the time or a path\r\n * along a curve defined by the data.\r\n *\r\n * The sample values can have any dimensionality and derived classes may\r\n * apply special interpretations to the data.\r\n *\r\n * This class provides the interval seek in a Template Method, deferring\r\n * the actual interpolation to derived classes.\r\n *\r\n * Time complexity is O(1) for linear access crossing at most two points\r\n * and O(log N) for random access, where N is the number of positions.\r\n *\r\n * References:\r\n *\r\n * \t\thttp://www.oodesign.com/template-method-pattern.html\r\n *\r\n */\r\n\r\nclass Interpolant {\r\n\r\n\tconstructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\r\n\r\n\t\tthis.parameterPositions = parameterPositions;\r\n\t\tthis._cachedIndex = 0;\r\n\r\n\t\tthis.resultBuffer = resultBuffer !== undefined ?\r\n\t\t\tresultBuffer : new sampleValues.constructor( sampleSize );\r\n\t\tthis.sampleValues = sampleValues;\r\n\t\tthis.valueSize = sampleSize;\r\n\r\n\t\tthis.settings = null;\r\n\t\tthis.DefaultSettings_ = {};\r\n\r\n\t}\r\n\r\n\tevaluate( t ) {\r\n\r\n\t\tconst pp = this.parameterPositions;\r\n\t\tlet i1 = this._cachedIndex,\r\n\t\t\tt1 = pp[ i1 ],\r\n\t\t\tt0 = pp[ i1 - 1 ];\r\n\r\n\t\tvalidate_interval: {\r\n\r\n\t\t\tseek: {\r\n\r\n\t\t\t\tlet right;\r\n\r\n\t\t\t\tlinear_scan: {\r\n\r\n\t\t\t\t\t//- See http://jsperf.com/comparison-to-undefined/3\r\n\t\t\t\t\t//- slower code:\r\n\t\t\t\t\t//-\r\n\t\t\t\t\t//- \t\t\t\tif ( t >= t1 || t1 === undefined ) {\r\n\t\t\t\t\tforward_scan: if ( ! ( t < t1 ) ) {\r\n\r\n\t\t\t\t\t\tfor ( let giveUpAt = i1 + 2; ; ) {\r\n\r\n\t\t\t\t\t\t\tif ( t1 === undefined ) {\r\n\r\n\t\t\t\t\t\t\t\tif ( t < t0 ) break forward_scan;\r\n\r\n\t\t\t\t\t\t\t\t// after end\r\n\r\n\t\t\t\t\t\t\t\ti1 = pp.length;\r\n\t\t\t\t\t\t\t\tthis._cachedIndex = i1;\r\n\t\t\t\t\t\t\t\treturn this.afterEnd_( i1 - 1, t, t0 );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif ( i1 === giveUpAt ) break; // this loop\r\n\r\n\t\t\t\t\t\t\tt0 = t1;\r\n\t\t\t\t\t\t\tt1 = pp[ ++ i1 ];\r\n\r\n\t\t\t\t\t\t\tif ( t < t1 ) {\r\n\r\n\t\t\t\t\t\t\t\t// we have arrived at the sought interval\r\n\t\t\t\t\t\t\t\tbreak seek;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// prepare binary search on the right side of the index\r\n\t\t\t\t\t\tright = pp.length;\r\n\t\t\t\t\t\tbreak linear_scan;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t//- slower code:\r\n\t\t\t\t\t//-\t\t\t\t\tif ( t < t0 || t0 === undefined ) {\r\n\t\t\t\t\tif ( ! ( t >= t0 ) ) {\r\n\r\n\t\t\t\t\t\t// looping?\r\n\r\n\t\t\t\t\t\tconst t1global = pp[ 1 ];\r\n\r\n\t\t\t\t\t\tif ( t < t1global ) {\r\n\r\n\t\t\t\t\t\t\ti1 = 2; // + 1, using the scan for the details\r\n\t\t\t\t\t\t\tt0 = t1global;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// linear reverse scan\r\n\r\n\t\t\t\t\t\tfor ( let giveUpAt = i1 - 2; ; ) {\r\n\r\n\t\t\t\t\t\t\tif ( t0 === undefined ) {\r\n\r\n\t\t\t\t\t\t\t\t// before start\r\n\r\n\t\t\t\t\t\t\t\tthis._cachedIndex = 0;\r\n\t\t\t\t\t\t\t\treturn this.beforeStart_( 0, t, t1 );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif ( i1 === giveUpAt ) break; // this loop\r\n\r\n\t\t\t\t\t\t\tt1 = t0;\r\n\t\t\t\t\t\t\tt0 = pp[ -- i1 - 1 ];\r\n\r\n\t\t\t\t\t\t\tif ( t >= t0 ) {\r\n\r\n\t\t\t\t\t\t\t\t// we have arrived at the sought interval\r\n\t\t\t\t\t\t\t\tbreak seek;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// prepare binary search on the left side of the index\r\n\t\t\t\t\t\tright = i1;\r\n\t\t\t\t\t\ti1 = 0;\r\n\t\t\t\t\t\tbreak linear_scan;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// the interval is valid\r\n\r\n\t\t\t\t\tbreak validate_interval;\r\n\r\n\t\t\t\t} // linear scan\r\n\r\n\t\t\t\t// binary search\r\n\r\n\t\t\t\twhile ( i1 < right ) {\r\n\r\n\t\t\t\t\tconst mid = ( i1 + right ) >>> 1;\r\n\r\n\t\t\t\t\tif ( t < pp[ mid ] ) {\r\n\r\n\t\t\t\t\t\tright = mid;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\ti1 = mid + 1;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tt1 = pp[ i1 ];\r\n\t\t\t\tt0 = pp[ i1 - 1 ];\r\n\r\n\t\t\t\t// check boundary cases, again\r\n\r\n\t\t\t\tif ( t0 === undefined ) {\r\n\r\n\t\t\t\t\tthis._cachedIndex = 0;\r\n\t\t\t\t\treturn this.beforeStart_( 0, t, t1 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( t1 === undefined ) {\r\n\r\n\t\t\t\t\ti1 = pp.length;\r\n\t\t\t\t\tthis._cachedIndex = i1;\r\n\t\t\t\t\treturn this.afterEnd_( i1 - 1, t0, t );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} // seek\r\n\r\n\t\t\tthis._cachedIndex = i1;\r\n\r\n\t\t\tthis.intervalChanged_( i1, t0, t1 );\r\n\r\n\t\t} // validate_interval\r\n\r\n\t\treturn this.interpolate_( i1, t0, t, t1 );\r\n\r\n\t}\r\n\r\n\tgetSettings_() {\r\n\r\n\t\treturn this.settings || this.DefaultSettings_;\r\n\r\n\t}\r\n\r\n\tcopySampleValue_( index ) {\r\n\r\n\t\t// copies a sample value to the result buffer\r\n\r\n\t\tconst result = this.resultBuffer,\r\n\t\t\tvalues = this.sampleValues,\r\n\t\t\tstride = this.valueSize,\r\n\t\t\toffset = index * stride;\r\n\r\n\t\tfor ( let i = 0; i !== stride; ++ i ) {\r\n\r\n\t\t\tresult[ i ] = values[ offset + i ];\r\n\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n\t// Template methods for derived classes:\r\n\r\n\tinterpolate_( /* i1, t0, t, t1 */ ) {\r\n\r\n\t\tthrow new Error( 'call to abstract method' );\r\n\t\t// implementations shall return this.resultBuffer\r\n\r\n\t}\r\n\r\n\tintervalChanged_( /* i1, t0, t1 */ ) {\r\n\r\n\t\t// empty\r\n\r\n\t}\r\n\r\n}\r\n\r\n// ALIAS DEFINITIONS\r\n\r\nInterpolant.prototype.beforeStart_ = Interpolant.prototype.copySampleValue_;\r\nInterpolant.prototype.afterEnd_ = Interpolant.prototype.copySampleValue_;\r\n\r\nexport { Interpolant };\r\n"]},"metadata":{},"sourceType":"module"}