{"ast":null,"code":"import { Camera } from './Camera.js';\nimport * as MathUtils from '../math/MathUtils.js';\n\nclass PerspectiveCamera extends Camera {\n  constructor(fov = 50, aspect = 1, near = 0.1, far = 2000) {\n    super();\n    this.type = 'PerspectiveCamera';\n    this.fov = fov;\n    this.zoom = 1;\n    this.near = near;\n    this.far = far;\n    this.focus = 10;\n    this.aspect = aspect;\n    this.view = null;\n    this.filmGauge = 35; // width of the film (default in millimeters)\n\n    this.filmOffset = 0; // horizontal film offset (same unit as gauge)\n\n    this.updateProjectionMatrix();\n  }\n\n  copy(source, recursive) {\n    super.copy(source, recursive);\n    this.fov = source.fov;\n    this.zoom = source.zoom;\n    this.near = source.near;\n    this.far = source.far;\n    this.focus = source.focus;\n    this.aspect = source.aspect;\n    this.view = source.view === null ? null : Object.assign({}, source.view);\n    this.filmGauge = source.filmGauge;\n    this.filmOffset = source.filmOffset;\n    return this;\n  }\n  /**\r\n   * Sets the FOV by focal length in respect to the current .filmGauge.\r\n   *\r\n   * The default film gauge is 35, so that the focal length can be specified for\r\n   * a 35mm (full frame) camera.\r\n   *\r\n   * Values for focal length and film gauge must have the same unit.\r\n   */\n\n\n  setFocalLength(focalLength) {\n    /** see {@link http://www.bobatkins.com/photography/technical/field_of_view.html} */\n    const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;\n    this.fov = MathUtils.RAD2DEG * 2 * Math.atan(vExtentSlope);\n    this.updateProjectionMatrix();\n  }\n  /**\r\n   * Calculates the focal length from the current .fov and .filmGauge.\r\n   */\n\n\n  getFocalLength() {\n    const vExtentSlope = Math.tan(MathUtils.DEG2RAD * 0.5 * this.fov);\n    return 0.5 * this.getFilmHeight() / vExtentSlope;\n  }\n\n  getEffectiveFOV() {\n    return MathUtils.RAD2DEG * 2 * Math.atan(Math.tan(MathUtils.DEG2RAD * 0.5 * this.fov) / this.zoom);\n  }\n\n  getFilmWidth() {\n    // film not completely covered in portrait format (aspect < 1)\n    return this.filmGauge * Math.min(this.aspect, 1);\n  }\n\n  getFilmHeight() {\n    // film not completely covered in landscape format (aspect > 1)\n    return this.filmGauge / Math.max(this.aspect, 1);\n  }\n  /**\r\n   * Sets an offset in a larger frustum. This is useful for multi-window or\r\n   * multi-monitor/multi-machine setups.\r\n   *\r\n   * For example, if you have 3x2 monitors and each monitor is 1920x1080 and\r\n   * the monitors are in grid like this\r\n   *\r\n   *   +---+---+---+\r\n   *   | A | B | C |\r\n   *   +---+---+---+\r\n   *   | D | E | F |\r\n   *   +---+---+---+\r\n   *\r\n   * then for each monitor you would call it like this\r\n   *\r\n   *   const w = 1920;\r\n   *   const h = 1080;\r\n   *   const fullWidth = w * 3;\r\n   *   const fullHeight = h * 2;\r\n   *\r\n   *   --A--\r\n   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );\r\n   *   --B--\r\n   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );\r\n   *   --C--\r\n   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );\r\n   *   --D--\r\n   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );\r\n   *   --E--\r\n   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );\r\n   *   --F--\r\n   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );\r\n   *\r\n   *   Note there is no reason monitors have to be the same size or in a grid.\r\n   */\n\n\n  setViewOffset(fullWidth, fullHeight, x, y, width, height) {\n    this.aspect = fullWidth / fullHeight;\n\n    if (this.view === null) {\n      this.view = {\n        enabled: true,\n        fullWidth: 1,\n        fullHeight: 1,\n        offsetX: 0,\n        offsetY: 0,\n        width: 1,\n        height: 1\n      };\n    }\n\n    this.view.enabled = true;\n    this.view.fullWidth = fullWidth;\n    this.view.fullHeight = fullHeight;\n    this.view.offsetX = x;\n    this.view.offsetY = y;\n    this.view.width = width;\n    this.view.height = height;\n    this.updateProjectionMatrix();\n  }\n\n  clearViewOffset() {\n    if (this.view !== null) {\n      this.view.enabled = false;\n    }\n\n    this.updateProjectionMatrix();\n  }\n\n  updateProjectionMatrix() {\n    const near = this.near;\n    let top = near * Math.tan(MathUtils.DEG2RAD * 0.5 * this.fov) / this.zoom;\n    let height = 2 * top;\n    let width = this.aspect * height;\n    let left = -0.5 * width;\n    const view = this.view;\n\n    if (this.view !== null && this.view.enabled) {\n      const fullWidth = view.fullWidth,\n            fullHeight = view.fullHeight;\n      left += view.offsetX * width / fullWidth;\n      top -= view.offsetY * height / fullHeight;\n      width *= view.width / fullWidth;\n      height *= view.height / fullHeight;\n    }\n\n    const skew = this.filmOffset;\n    if (skew !== 0) left += near * skew / this.getFilmWidth();\n    this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far);\n    this.projectionMatrixInverse.copy(this.projectionMatrix).invert();\n  }\n\n  toJSON(meta) {\n    const data = super.toJSON(meta);\n    data.object.fov = this.fov;\n    data.object.zoom = this.zoom;\n    data.object.near = this.near;\n    data.object.far = this.far;\n    data.object.focus = this.focus;\n    data.object.aspect = this.aspect;\n    if (this.view !== null) data.object.view = Object.assign({}, this.view);\n    data.object.filmGauge = this.filmGauge;\n    data.object.filmOffset = this.filmOffset;\n    return data;\n  }\n\n}\n\nPerspectiveCamera.prototype.isPerspectiveCamera = true;\nexport { PerspectiveCamera };","map":{"version":3,"sources":["C:/Users/dell/Desktop/projektlogin/vue-3-authentication-jwt/src/games/three/src/cameras/PerspectiveCamera.js"],"names":["Camera","MathUtils","PerspectiveCamera","constructor","fov","aspect","near","far","type","zoom","focus","view","filmGauge","filmOffset","updateProjectionMatrix","copy","source","recursive","Object","assign","setFocalLength","focalLength","vExtentSlope","getFilmHeight","RAD2DEG","Math","atan","getFocalLength","tan","DEG2RAD","getEffectiveFOV","getFilmWidth","min","max","setViewOffset","fullWidth","fullHeight","x","y","width","height","enabled","offsetX","offsetY","clearViewOffset","top","left","skew","projectionMatrix","makePerspective","projectionMatrixInverse","invert","toJSON","meta","data","object","prototype","isPerspectiveCamera"],"mappings":"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","sourcesContent":["import { Camera } from './Camera.js';\r\nimport * as MathUtils from '../math/MathUtils.js';\r\n\r\nclass PerspectiveCamera extends Camera {\r\n\r\n\tconstructor( fov = 50, aspect = 1, near = 0.1, far = 2000 ) {\r\n\r\n\t\tsuper();\r\n\r\n\t\tthis.type = 'PerspectiveCamera';\r\n\r\n\t\tthis.fov = fov;\r\n\t\tthis.zoom = 1;\r\n\r\n\t\tthis.near = near;\r\n\t\tthis.far = far;\r\n\t\tthis.focus = 10;\r\n\r\n\t\tthis.aspect = aspect;\r\n\t\tthis.view = null;\r\n\r\n\t\tthis.filmGauge = 35;\t// width of the film (default in millimeters)\r\n\t\tthis.filmOffset = 0;\t// horizontal film offset (same unit as gauge)\r\n\r\n\t\tthis.updateProjectionMatrix();\r\n\r\n\t}\r\n\r\n\tcopy( source, recursive ) {\r\n\r\n\t\tsuper.copy( source, recursive );\r\n\r\n\t\tthis.fov = source.fov;\r\n\t\tthis.zoom = source.zoom;\r\n\r\n\t\tthis.near = source.near;\r\n\t\tthis.far = source.far;\r\n\t\tthis.focus = source.focus;\r\n\r\n\t\tthis.aspect = source.aspect;\r\n\t\tthis.view = source.view === null ? null : Object.assign( {}, source.view );\r\n\r\n\t\tthis.filmGauge = source.filmGauge;\r\n\t\tthis.filmOffset = source.filmOffset;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the FOV by focal length in respect to the current .filmGauge.\r\n\t *\r\n\t * The default film gauge is 35, so that the focal length can be specified for\r\n\t * a 35mm (full frame) camera.\r\n\t *\r\n\t * Values for focal length and film gauge must have the same unit.\r\n\t */\r\n\tsetFocalLength( focalLength ) {\r\n\r\n\t\t/** see {@link http://www.bobatkins.com/photography/technical/field_of_view.html} */\r\n\t\tconst vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;\r\n\r\n\t\tthis.fov = MathUtils.RAD2DEG * 2 * Math.atan( vExtentSlope );\r\n\t\tthis.updateProjectionMatrix();\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Calculates the focal length from the current .fov and .filmGauge.\r\n\t */\r\n\tgetFocalLength() {\r\n\r\n\t\tconst vExtentSlope = Math.tan( MathUtils.DEG2RAD * 0.5 * this.fov );\r\n\r\n\t\treturn 0.5 * this.getFilmHeight() / vExtentSlope;\r\n\r\n\t}\r\n\r\n\tgetEffectiveFOV() {\r\n\r\n\t\treturn MathUtils.RAD2DEG * 2 * Math.atan(\r\n\t\t\tMath.tan( MathUtils.DEG2RAD * 0.5 * this.fov ) / this.zoom );\r\n\r\n\t}\r\n\r\n\tgetFilmWidth() {\r\n\r\n\t\t// film not completely covered in portrait format (aspect < 1)\r\n\t\treturn this.filmGauge * Math.min( this.aspect, 1 );\r\n\r\n\t}\r\n\r\n\tgetFilmHeight() {\r\n\r\n\t\t// film not completely covered in landscape format (aspect > 1)\r\n\t\treturn this.filmGauge / Math.max( this.aspect, 1 );\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Sets an offset in a larger frustum. This is useful for multi-window or\r\n\t * multi-monitor/multi-machine setups.\r\n\t *\r\n\t * For example, if you have 3x2 monitors and each monitor is 1920x1080 and\r\n\t * the monitors are in grid like this\r\n\t *\r\n\t *   +---+---+---+\r\n\t *   | A | B | C |\r\n\t *   +---+---+---+\r\n\t *   | D | E | F |\r\n\t *   +---+---+---+\r\n\t *\r\n\t * then for each monitor you would call it like this\r\n\t *\r\n\t *   const w = 1920;\r\n\t *   const h = 1080;\r\n\t *   const fullWidth = w * 3;\r\n\t *   const fullHeight = h * 2;\r\n\t *\r\n\t *   --A--\r\n\t *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );\r\n\t *   --B--\r\n\t *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );\r\n\t *   --C--\r\n\t *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );\r\n\t *   --D--\r\n\t *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );\r\n\t *   --E--\r\n\t *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );\r\n\t *   --F--\r\n\t *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );\r\n\t *\r\n\t *   Note there is no reason monitors have to be the same size or in a grid.\r\n\t */\r\n\tsetViewOffset( fullWidth, fullHeight, x, y, width, height ) {\r\n\r\n\t\tthis.aspect = fullWidth / fullHeight;\r\n\r\n\t\tif ( this.view === null ) {\r\n\r\n\t\t\tthis.view = {\r\n\t\t\t\tenabled: true,\r\n\t\t\t\tfullWidth: 1,\r\n\t\t\t\tfullHeight: 1,\r\n\t\t\t\toffsetX: 0,\r\n\t\t\t\toffsetY: 0,\r\n\t\t\t\twidth: 1,\r\n\t\t\t\theight: 1\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t\tthis.view.enabled = true;\r\n\t\tthis.view.fullWidth = fullWidth;\r\n\t\tthis.view.fullHeight = fullHeight;\r\n\t\tthis.view.offsetX = x;\r\n\t\tthis.view.offsetY = y;\r\n\t\tthis.view.width = width;\r\n\t\tthis.view.height = height;\r\n\r\n\t\tthis.updateProjectionMatrix();\r\n\r\n\t}\r\n\r\n\tclearViewOffset() {\r\n\r\n\t\tif ( this.view !== null ) {\r\n\r\n\t\t\tthis.view.enabled = false;\r\n\r\n\t\t}\r\n\r\n\t\tthis.updateProjectionMatrix();\r\n\r\n\t}\r\n\r\n\tupdateProjectionMatrix() {\r\n\r\n\t\tconst near = this.near;\r\n\t\tlet top = near * Math.tan( MathUtils.DEG2RAD * 0.5 * this.fov ) / this.zoom;\r\n\t\tlet height = 2 * top;\r\n\t\tlet width = this.aspect * height;\r\n\t\tlet left = - 0.5 * width;\r\n\t\tconst view = this.view;\r\n\r\n\t\tif ( this.view !== null && this.view.enabled ) {\r\n\r\n\t\t\tconst fullWidth = view.fullWidth,\r\n\t\t\t\tfullHeight = view.fullHeight;\r\n\r\n\t\t\tleft += view.offsetX * width / fullWidth;\r\n\t\t\ttop -= view.offsetY * height / fullHeight;\r\n\t\t\twidth *= view.width / fullWidth;\r\n\t\t\theight *= view.height / fullHeight;\r\n\r\n\t\t}\r\n\r\n\t\tconst skew = this.filmOffset;\r\n\t\tif ( skew !== 0 ) left += near * skew / this.getFilmWidth();\r\n\r\n\t\tthis.projectionMatrix.makePerspective( left, left + width, top, top - height, near, this.far );\r\n\r\n\t\tthis.projectionMatrixInverse.copy( this.projectionMatrix ).invert();\r\n\r\n\t}\r\n\r\n\ttoJSON( meta ) {\r\n\r\n\t\tconst data = super.toJSON( meta );\r\n\r\n\t\tdata.object.fov = this.fov;\r\n\t\tdata.object.zoom = this.zoom;\r\n\r\n\t\tdata.object.near = this.near;\r\n\t\tdata.object.far = this.far;\r\n\t\tdata.object.focus = this.focus;\r\n\r\n\t\tdata.object.aspect = this.aspect;\r\n\r\n\t\tif ( this.view !== null ) data.object.view = Object.assign( {}, this.view );\r\n\r\n\t\tdata.object.filmGauge = this.filmGauge;\r\n\t\tdata.object.filmOffset = this.filmOffset;\r\n\r\n\t\treturn data;\r\n\r\n\t}\r\n\r\n}\r\n\r\nPerspectiveCamera.prototype.isPerspectiveCamera = true;\r\n\r\nexport { PerspectiveCamera };\r\n"]},"metadata":{},"sourceType":"module"}