{"ast":null,"code":"import \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport { RGBAFormat, FloatType } from '../constants.js';\nimport { Bone } from './Bone.js';\nimport { Matrix4 } from '../math/Matrix4.js';\nimport { DataTexture } from '../textures/DataTexture.js';\nimport * as MathUtils from '../math/MathUtils.js';\n\nconst _offsetMatrix = /*@__PURE__*/new Matrix4();\n\nconst _identityMatrix = /*@__PURE__*/new Matrix4();\n\nclass Skeleton {\n  constructor(bones = [], boneInverses = []) {\n    this.uuid = MathUtils.generateUUID();\n    this.bones = bones.slice(0);\n    this.boneInverses = boneInverses;\n    this.boneMatrices = null;\n    this.boneTexture = null;\n    this.boneTextureSize = 0;\n    this.frame = -1;\n    this.init();\n  }\n\n  init() {\n    const bones = this.bones;\n    const boneInverses = this.boneInverses;\n    this.boneMatrices = new Float32Array(bones.length * 16); // calculate inverse bone matrices if necessary\n\n    if (boneInverses.length === 0) {\n      this.calculateInverses();\n    } else {\n      // handle special case\n      if (bones.length !== boneInverses.length) {\n        console.warn('THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.');\n        this.boneInverses = [];\n\n        for (let i = 0, il = this.bones.length; i < il; i++) {\n          this.boneInverses.push(new Matrix4());\n        }\n      }\n    }\n  }\n\n  calculateInverses() {\n    this.boneInverses.length = 0;\n\n    for (let i = 0, il = this.bones.length; i < il; i++) {\n      const inverse = new Matrix4();\n\n      if (this.bones[i]) {\n        inverse.copy(this.bones[i].matrixWorld).invert();\n      }\n\n      this.boneInverses.push(inverse);\n    }\n  }\n\n  pose() {\n    // recover the bind-time world matrices\n    for (let i = 0, il = this.bones.length; i < il; i++) {\n      const bone = this.bones[i];\n\n      if (bone) {\n        bone.matrixWorld.copy(this.boneInverses[i]).invert();\n      }\n    } // compute the local matrices, positions, rotations and scales\n\n\n    for (let i = 0, il = this.bones.length; i < il; i++) {\n      const bone = this.bones[i];\n\n      if (bone) {\n        if (bone.parent && bone.parent.isBone) {\n          bone.matrix.copy(bone.parent.matrixWorld).invert();\n          bone.matrix.multiply(bone.matrixWorld);\n        } else {\n          bone.matrix.copy(bone.matrixWorld);\n        }\n\n        bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\n      }\n    }\n  }\n\n  update() {\n    const bones = this.bones;\n    const boneInverses = this.boneInverses;\n    const boneMatrices = this.boneMatrices;\n    const boneTexture = this.boneTexture; // flatten bone matrices to array\n\n    for (let i = 0, il = bones.length; i < il; i++) {\n      // compute the offset between the current and the original transform\n      const matrix = bones[i] ? bones[i].matrixWorld : _identityMatrix;\n\n      _offsetMatrix.multiplyMatrices(matrix, boneInverses[i]);\n\n      _offsetMatrix.toArray(boneMatrices, i * 16);\n    }\n\n    if (boneTexture !== null) {\n      boneTexture.needsUpdate = true;\n    }\n  }\n\n  clone() {\n    return new Skeleton(this.bones, this.boneInverses);\n  }\n\n  computeBoneTexture() {\n    // layout (1 matrix = 4 pixels)\n    //      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)\n    //  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)\n    //       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)\n    //       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)\n    //       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)\n    let size = Math.sqrt(this.bones.length * 4); // 4 pixels needed for 1 matrix\n\n    size = MathUtils.ceilPowerOfTwo(size);\n    size = Math.max(size, 4);\n    const boneMatrices = new Float32Array(size * size * 4); // 4 floats per RGBA pixel\n\n    boneMatrices.set(this.boneMatrices); // copy current values\n\n    const boneTexture = new DataTexture(boneMatrices, size, size, RGBAFormat, FloatType);\n    boneTexture.needsUpdate = true;\n    this.boneMatrices = boneMatrices;\n    this.boneTexture = boneTexture;\n    this.boneTextureSize = size;\n    return this;\n  }\n\n  getBoneByName(name) {\n    for (let i = 0, il = this.bones.length; i < il; i++) {\n      const bone = this.bones[i];\n\n      if (bone.name === name) {\n        return bone;\n      }\n    }\n\n    return undefined;\n  }\n\n  dispose() {\n    if (this.boneTexture !== null) {\n      this.boneTexture.dispose();\n      this.boneTexture = null;\n    }\n  }\n\n  fromJSON(json, bones) {\n    this.uuid = json.uuid;\n\n    for (let i = 0, l = json.bones.length; i < l; i++) {\n      const uuid = json.bones[i];\n      let bone = bones[uuid];\n\n      if (bone === undefined) {\n        console.warn('THREE.Skeleton: No bone found with UUID:', uuid);\n        bone = new Bone();\n      }\n\n      this.bones.push(bone);\n      this.boneInverses.push(new Matrix4().fromArray(json.boneInverses[i]));\n    }\n\n    this.init();\n    return this;\n  }\n\n  toJSON() {\n    const data = {\n      metadata: {\n        version: 4.5,\n        type: 'Skeleton',\n        generator: 'Skeleton.toJSON'\n      },\n      bones: [],\n      boneInverses: []\n    };\n    data.uuid = this.uuid;\n    const bones = this.bones;\n    const boneInverses = this.boneInverses;\n\n    for (let i = 0, l = bones.length; i < l; i++) {\n      const bone = bones[i];\n      data.bones.push(bone.uuid);\n      const boneInverse = boneInverses[i];\n      data.boneInverses.push(boneInverse.toArray());\n    }\n\n    return data;\n  }\n\n}\n\nexport { Skeleton };","map":{"version":3,"sources":["C:/Users/dell/Desktop/projektlogin/vue-3-authentication-jwt/src/games/three/src/objects/Skeleton.js"],"names":["RGBAFormat","FloatType","Bone","Matrix4","DataTexture","MathUtils","_offsetMatrix","_identityMatrix","Skeleton","constructor","bones","boneInverses","uuid","generateUUID","slice","boneMatrices","boneTexture","boneTextureSize","frame","init","Float32Array","length","calculateInverses","console","warn","i","il","push","inverse","copy","matrixWorld","invert","pose","bone","parent","isBone","matrix","multiply","decompose","position","quaternion","scale","update","multiplyMatrices","toArray","needsUpdate","clone","computeBoneTexture","size","Math","sqrt","ceilPowerOfTwo","max","set","getBoneByName","name","undefined","dispose","fromJSON","json","l","fromArray","toJSON","data","metadata","version","type","generator","boneInverse"],"mappings":"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","sourcesContent":["import {\r\n\tRGBAFormat,\r\n\tFloatType\r\n} from '../constants.js';\r\nimport { Bone } from './Bone.js';\r\nimport { Matrix4 } from '../math/Matrix4.js';\r\nimport { DataTexture } from '../textures/DataTexture.js';\r\nimport * as MathUtils from '../math/MathUtils.js';\r\n\r\nconst _offsetMatrix = /*@__PURE__*/ new Matrix4();\r\nconst _identityMatrix = /*@__PURE__*/ new Matrix4();\r\n\r\nclass Skeleton {\r\n\r\n\tconstructor( bones = [], boneInverses = [] ) {\r\n\r\n\t\tthis.uuid = MathUtils.generateUUID();\r\n\r\n\t\tthis.bones = bones.slice( 0 );\r\n\t\tthis.boneInverses = boneInverses;\r\n\t\tthis.boneMatrices = null;\r\n\r\n\t\tthis.boneTexture = null;\r\n\t\tthis.boneTextureSize = 0;\r\n\r\n\t\tthis.frame = - 1;\r\n\r\n\t\tthis.init();\r\n\r\n\t}\r\n\r\n\tinit() {\r\n\r\n\t\tconst bones = this.bones;\r\n\t\tconst boneInverses = this.boneInverses;\r\n\r\n\t\tthis.boneMatrices = new Float32Array( bones.length * 16 );\r\n\r\n\t\t// calculate inverse bone matrices if necessary\r\n\r\n\t\tif ( boneInverses.length === 0 ) {\r\n\r\n\t\t\tthis.calculateInverses();\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// handle special case\r\n\r\n\t\t\tif ( bones.length !== boneInverses.length ) {\r\n\r\n\t\t\t\tconsole.warn( 'THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.' );\r\n\r\n\t\t\t\tthis.boneInverses = [];\r\n\r\n\t\t\t\tfor ( let i = 0, il = this.bones.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tthis.boneInverses.push( new Matrix4() );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tcalculateInverses() {\r\n\r\n\t\tthis.boneInverses.length = 0;\r\n\r\n\t\tfor ( let i = 0, il = this.bones.length; i < il; i ++ ) {\r\n\r\n\t\t\tconst inverse = new Matrix4();\r\n\r\n\t\t\tif ( this.bones[ i ] ) {\r\n\r\n\t\t\t\tinverse.copy( this.bones[ i ].matrixWorld ).invert();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.boneInverses.push( inverse );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tpose() {\r\n\r\n\t\t// recover the bind-time world matrices\r\n\r\n\t\tfor ( let i = 0, il = this.bones.length; i < il; i ++ ) {\r\n\r\n\t\t\tconst bone = this.bones[ i ];\r\n\r\n\t\t\tif ( bone ) {\r\n\r\n\t\t\t\tbone.matrixWorld.copy( this.boneInverses[ i ] ).invert();\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// compute the local matrices, positions, rotations and scales\r\n\r\n\t\tfor ( let i = 0, il = this.bones.length; i < il; i ++ ) {\r\n\r\n\t\t\tconst bone = this.bones[ i ];\r\n\r\n\t\t\tif ( bone ) {\r\n\r\n\t\t\t\tif ( bone.parent && bone.parent.isBone ) {\r\n\r\n\t\t\t\t\tbone.matrix.copy( bone.parent.matrixWorld ).invert();\r\n\t\t\t\t\tbone.matrix.multiply( bone.matrixWorld );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tbone.matrix.copy( bone.matrixWorld );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tbone.matrix.decompose( bone.position, bone.quaternion, bone.scale );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tupdate() {\r\n\r\n\t\tconst bones = this.bones;\r\n\t\tconst boneInverses = this.boneInverses;\r\n\t\tconst boneMatrices = this.boneMatrices;\r\n\t\tconst boneTexture = this.boneTexture;\r\n\r\n\t\t// flatten bone matrices to array\r\n\r\n\t\tfor ( let i = 0, il = bones.length; i < il; i ++ ) {\r\n\r\n\t\t\t// compute the offset between the current and the original transform\r\n\r\n\t\t\tconst matrix = bones[ i ] ? bones[ i ].matrixWorld : _identityMatrix;\r\n\r\n\t\t\t_offsetMatrix.multiplyMatrices( matrix, boneInverses[ i ] );\r\n\t\t\t_offsetMatrix.toArray( boneMatrices, i * 16 );\r\n\r\n\t\t}\r\n\r\n\t\tif ( boneTexture !== null ) {\r\n\r\n\t\t\tboneTexture.needsUpdate = true;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tclone() {\r\n\r\n\t\treturn new Skeleton( this.bones, this.boneInverses );\r\n\r\n\t}\r\n\r\n\tcomputeBoneTexture() {\r\n\r\n\t\t// layout (1 matrix = 4 pixels)\r\n\t\t//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)\r\n\t\t//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)\r\n\t\t//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)\r\n\t\t//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)\r\n\t\t//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)\r\n\r\n\t\tlet size = Math.sqrt( this.bones.length * 4 ); // 4 pixels needed for 1 matrix\r\n\t\tsize = MathUtils.ceilPowerOfTwo( size );\r\n\t\tsize = Math.max( size, 4 );\r\n\r\n\t\tconst boneMatrices = new Float32Array( size * size * 4 ); // 4 floats per RGBA pixel\r\n\t\tboneMatrices.set( this.boneMatrices ); // copy current values\r\n\r\n\t\tconst boneTexture = new DataTexture( boneMatrices, size, size, RGBAFormat, FloatType );\r\n\t\tboneTexture.needsUpdate = true;\r\n\r\n\t\tthis.boneMatrices = boneMatrices;\r\n\t\tthis.boneTexture = boneTexture;\r\n\t\tthis.boneTextureSize = size;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tgetBoneByName( name ) {\r\n\r\n\t\tfor ( let i = 0, il = this.bones.length; i < il; i ++ ) {\r\n\r\n\t\t\tconst bone = this.bones[ i ];\r\n\r\n\t\t\tif ( bone.name === name ) {\r\n\r\n\t\t\t\treturn bone;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn undefined;\r\n\r\n\t}\r\n\r\n\tdispose( ) {\r\n\r\n\t\tif ( this.boneTexture !== null ) {\r\n\r\n\t\t\tthis.boneTexture.dispose();\r\n\r\n\t\t\tthis.boneTexture = null;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfromJSON( json, bones ) {\r\n\r\n\t\tthis.uuid = json.uuid;\r\n\r\n\t\tfor ( let i = 0, l = json.bones.length; i < l; i ++ ) {\r\n\r\n\t\t\tconst uuid = json.bones[ i ];\r\n\t\t\tlet bone = bones[ uuid ];\r\n\r\n\t\t\tif ( bone === undefined ) {\r\n\r\n\t\t\t\tconsole.warn( 'THREE.Skeleton: No bone found with UUID:', uuid );\r\n\t\t\t\tbone = new Bone();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.bones.push( bone );\r\n\t\t\tthis.boneInverses.push( new Matrix4().fromArray( json.boneInverses[ i ] ) );\r\n\r\n\t\t}\r\n\r\n\t\tthis.init();\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\ttoJSON() {\r\n\r\n\t\tconst data = {\r\n\t\t\tmetadata: {\r\n\t\t\t\tversion: 4.5,\r\n\t\t\t\ttype: 'Skeleton',\r\n\t\t\t\tgenerator: 'Skeleton.toJSON'\r\n\t\t\t},\r\n\t\t\tbones: [],\r\n\t\t\tboneInverses: []\r\n\t\t};\r\n\r\n\t\tdata.uuid = this.uuid;\r\n\r\n\t\tconst bones = this.bones;\r\n\t\tconst boneInverses = this.boneInverses;\r\n\r\n\t\tfor ( let i = 0, l = bones.length; i < l; i ++ ) {\r\n\r\n\t\t\tconst bone = bones[ i ];\r\n\t\t\tdata.bones.push( bone.uuid );\r\n\r\n\t\t\tconst boneInverse = boneInverses[ i ];\r\n\t\t\tdata.boneInverses.push( boneInverse.toArray() );\r\n\r\n\t\t}\r\n\r\n\t\treturn data;\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport { Skeleton };\r\n"]},"metadata":{},"sourceType":"module"}