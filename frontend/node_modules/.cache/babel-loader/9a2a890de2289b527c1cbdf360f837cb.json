{"ast":null,"code":"import { ArrayCamera } from '../../cameras/ArrayCamera.js';\nimport { EventDispatcher } from '../../core/EventDispatcher.js';\nimport { PerspectiveCamera } from '../../cameras/PerspectiveCamera.js';\nimport { Vector3 } from '../../math/Vector3.js';\nimport { Vector4 } from '../../math/Vector4.js';\nimport { WebGLAnimation } from '../webgl/WebGLAnimation.js';\nimport { WebGLRenderTarget } from '../WebGLRenderTarget.js';\nimport { WebXRController } from './WebXRController.js';\nimport { DepthTexture } from '../../textures/DepthTexture.js';\nimport { DepthFormat, DepthStencilFormat, RGBAFormat, sRGBEncoding, UnsignedByteType, UnsignedShortType, UnsignedInt248Type } from '../../constants.js';\n\nclass WebXRManager extends EventDispatcher {\n  constructor(renderer, gl) {\n    super();\n    const scope = this;\n    let session = null;\n    let framebufferScaleFactor = 1.0;\n    let referenceSpace = null;\n    let referenceSpaceType = 'local-floor';\n    let pose = null;\n    let glBinding = null;\n    let glProjLayer = null;\n    let glBaseLayer = null;\n    let xrFrame = null;\n    const attributes = gl.getContextAttributes();\n    let initialRenderTarget = null;\n    let newRenderTarget = null;\n    const controllers = [];\n    const inputSourcesMap = new Map(); //\n\n    const cameraL = new PerspectiveCamera();\n    cameraL.layers.enable(1);\n    cameraL.viewport = new Vector4();\n    const cameraR = new PerspectiveCamera();\n    cameraR.layers.enable(2);\n    cameraR.viewport = new Vector4();\n    const cameras = [cameraL, cameraR];\n    const cameraVR = new ArrayCamera();\n    cameraVR.layers.enable(1);\n    cameraVR.layers.enable(2);\n    let _currentDepthNear = null;\n    let _currentDepthFar = null; //\n\n    this.cameraAutoUpdate = true;\n    this.enabled = false;\n    this.isPresenting = false;\n\n    this.getController = function (index) {\n      let controller = controllers[index];\n\n      if (controller === undefined) {\n        controller = new WebXRController();\n        controllers[index] = controller;\n      }\n\n      return controller.getTargetRaySpace();\n    };\n\n    this.getControllerGrip = function (index) {\n      let controller = controllers[index];\n\n      if (controller === undefined) {\n        controller = new WebXRController();\n        controllers[index] = controller;\n      }\n\n      return controller.getGripSpace();\n    };\n\n    this.getHand = function (index) {\n      let controller = controllers[index];\n\n      if (controller === undefined) {\n        controller = new WebXRController();\n        controllers[index] = controller;\n      }\n\n      return controller.getHandSpace();\n    }; //\n\n\n    function onSessionEvent(event) {\n      const controller = inputSourcesMap.get(event.inputSource);\n\n      if (controller) {\n        controller.dispatchEvent({\n          type: event.type,\n          data: event.inputSource\n        });\n      }\n    }\n\n    function onSessionEnd() {\n      inputSourcesMap.forEach(function (controller, inputSource) {\n        controller.disconnect(inputSource);\n      });\n      inputSourcesMap.clear();\n      _currentDepthNear = null;\n      _currentDepthFar = null; // restore framebuffer/rendering state\n\n      renderer.setRenderTarget(initialRenderTarget);\n      glBaseLayer = null;\n      glProjLayer = null;\n      glBinding = null;\n      session = null;\n      newRenderTarget = null; //\n\n      animation.stop();\n      scope.isPresenting = false;\n      scope.dispatchEvent({\n        type: 'sessionend'\n      });\n    }\n\n    this.setFramebufferScaleFactor = function (value) {\n      framebufferScaleFactor = value;\n\n      if (scope.isPresenting === true) {\n        console.warn('THREE.WebXRManager: Cannot change framebuffer scale while presenting.');\n      }\n    };\n\n    this.setReferenceSpaceType = function (value) {\n      referenceSpaceType = value;\n\n      if (scope.isPresenting === true) {\n        console.warn('THREE.WebXRManager: Cannot change reference space type while presenting.');\n      }\n    };\n\n    this.getReferenceSpace = function () {\n      return referenceSpace;\n    };\n\n    this.getBaseLayer = function () {\n      return glProjLayer !== null ? glProjLayer : glBaseLayer;\n    };\n\n    this.getBinding = function () {\n      return glBinding;\n    };\n\n    this.getFrame = function () {\n      return xrFrame;\n    };\n\n    this.getSession = function () {\n      return session;\n    };\n\n    this.setSession = async function (value) {\n      session = value;\n\n      if (session !== null) {\n        initialRenderTarget = renderer.getRenderTarget();\n        session.addEventListener('select', onSessionEvent);\n        session.addEventListener('selectstart', onSessionEvent);\n        session.addEventListener('selectend', onSessionEvent);\n        session.addEventListener('squeeze', onSessionEvent);\n        session.addEventListener('squeezestart', onSessionEvent);\n        session.addEventListener('squeezeend', onSessionEvent);\n        session.addEventListener('end', onSessionEnd);\n        session.addEventListener('inputsourceschange', onInputSourcesChange);\n\n        if (attributes.xrCompatible !== true) {\n          await gl.makeXRCompatible();\n        }\n\n        if (session.renderState.layers === undefined || renderer.capabilities.isWebGL2 === false) {\n          const layerInit = {\n            antialias: session.renderState.layers === undefined ? attributes.antialias : true,\n            alpha: attributes.alpha,\n            depth: attributes.depth,\n            stencil: attributes.stencil,\n            framebufferScaleFactor: framebufferScaleFactor\n          };\n          glBaseLayer = new XRWebGLLayer(session, gl, layerInit);\n          session.updateRenderState({\n            baseLayer: glBaseLayer\n          });\n          newRenderTarget = new WebGLRenderTarget(glBaseLayer.framebufferWidth, glBaseLayer.framebufferHeight, {\n            format: RGBAFormat,\n            type: UnsignedByteType,\n            encoding: renderer.outputEncoding\n          });\n        } else {\n          let depthFormat = null;\n          let depthType = null;\n          let glDepthFormat = null;\n\n          if (attributes.depth) {\n            glDepthFormat = attributes.stencil ? gl.DEPTH24_STENCIL8 : gl.DEPTH_COMPONENT24;\n            depthFormat = attributes.stencil ? DepthStencilFormat : DepthFormat;\n            depthType = attributes.stencil ? UnsignedInt248Type : UnsignedShortType;\n          }\n\n          const projectionlayerInit = {\n            colorFormat: renderer.outputEncoding === sRGBEncoding ? gl.SRGB8_ALPHA8 : gl.RGBA8,\n            depthFormat: glDepthFormat,\n            scaleFactor: framebufferScaleFactor\n          };\n          glBinding = new XRWebGLBinding(session, gl);\n          glProjLayer = glBinding.createProjectionLayer(projectionlayerInit);\n          session.updateRenderState({\n            layers: [glProjLayer]\n          });\n          newRenderTarget = new WebGLRenderTarget(glProjLayer.textureWidth, glProjLayer.textureHeight, {\n            format: RGBAFormat,\n            type: UnsignedByteType,\n            depthTexture: new DepthTexture(glProjLayer.textureWidth, glProjLayer.textureHeight, depthType, undefined, undefined, undefined, undefined, undefined, undefined, depthFormat),\n            stencilBuffer: attributes.stencil,\n            encoding: renderer.outputEncoding,\n            samples: attributes.antialias ? 4 : 0\n          });\n          const renderTargetProperties = renderer.properties.get(newRenderTarget);\n          renderTargetProperties.__ignoreDepthValues = glProjLayer.ignoreDepthValues;\n        }\n\n        newRenderTarget.isXRRenderTarget = true; // TODO Remove this when possible, see #23278\n        // Set foveation to maximum.\n\n        this.setFoveation(1.0);\n        referenceSpace = await session.requestReferenceSpace(referenceSpaceType);\n        animation.setContext(session);\n        animation.start();\n        scope.isPresenting = true;\n        scope.dispatchEvent({\n          type: 'sessionstart'\n        });\n      }\n    };\n\n    function onInputSourcesChange(event) {\n      const inputSources = session.inputSources; // Assign inputSources to available controllers\n\n      for (let i = 0; i < controllers.length; i++) {\n        inputSourcesMap.set(inputSources[i], controllers[i]);\n      } // Notify disconnected\n\n\n      for (let i = 0; i < event.removed.length; i++) {\n        const inputSource = event.removed[i];\n        const controller = inputSourcesMap.get(inputSource);\n\n        if (controller) {\n          controller.dispatchEvent({\n            type: 'disconnected',\n            data: inputSource\n          });\n          inputSourcesMap.delete(inputSource);\n        }\n      } // Notify connected\n\n\n      for (let i = 0; i < event.added.length; i++) {\n        const inputSource = event.added[i];\n        const controller = inputSourcesMap.get(inputSource);\n\n        if (controller) {\n          controller.dispatchEvent({\n            type: 'connected',\n            data: inputSource\n          });\n        }\n      }\n    } //\n\n\n    const cameraLPos = new Vector3();\n    const cameraRPos = new Vector3();\n    /**\r\n     * Assumes 2 cameras that are parallel and share an X-axis, and that\r\n     * the cameras' projection and world matrices have already been set.\r\n     * And that near and far planes are identical for both cameras.\r\n     * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765\r\n     */\n\n    function setProjectionFromUnion(camera, cameraL, cameraR) {\n      cameraLPos.setFromMatrixPosition(cameraL.matrixWorld);\n      cameraRPos.setFromMatrixPosition(cameraR.matrixWorld);\n      const ipd = cameraLPos.distanceTo(cameraRPos);\n      const projL = cameraL.projectionMatrix.elements;\n      const projR = cameraR.projectionMatrix.elements; // VR systems will have identical far and near planes, and\n      // most likely identical top and bottom frustum extents.\n      // Use the left camera for these values.\n\n      const near = projL[14] / (projL[10] - 1);\n      const far = projL[14] / (projL[10] + 1);\n      const topFov = (projL[9] + 1) / projL[5];\n      const bottomFov = (projL[9] - 1) / projL[5];\n      const leftFov = (projL[8] - 1) / projL[0];\n      const rightFov = (projR[8] + 1) / projR[0];\n      const left = near * leftFov;\n      const right = near * rightFov; // Calculate the new camera's position offset from the\n      // left camera. xOffset should be roughly half `ipd`.\n\n      const zOffset = ipd / (-leftFov + rightFov);\n      const xOffset = zOffset * -leftFov; // TODO: Better way to apply this offset?\n\n      cameraL.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale);\n      camera.translateX(xOffset);\n      camera.translateZ(zOffset);\n      camera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale);\n      camera.matrixWorldInverse.copy(camera.matrixWorld).invert(); // Find the union of the frustum values of the cameras and scale\n      // the values so that the near plane's position does not change in world space,\n      // although must now be relative to the new union camera.\n\n      const near2 = near + zOffset;\n      const far2 = far + zOffset;\n      const left2 = left - xOffset;\n      const right2 = right + (ipd - xOffset);\n      const top2 = topFov * far / far2 * near2;\n      const bottom2 = bottomFov * far / far2 * near2;\n      camera.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);\n    }\n\n    function updateCamera(camera, parent) {\n      if (parent === null) {\n        camera.matrixWorld.copy(camera.matrix);\n      } else {\n        camera.matrixWorld.multiplyMatrices(parent.matrixWorld, camera.matrix);\n      }\n\n      camera.matrixWorldInverse.copy(camera.matrixWorld).invert();\n    }\n\n    this.updateCamera = function (camera) {\n      if (session === null) return;\n      cameraVR.near = cameraR.near = cameraL.near = camera.near;\n      cameraVR.far = cameraR.far = cameraL.far = camera.far;\n\n      if (_currentDepthNear !== cameraVR.near || _currentDepthFar !== cameraVR.far) {\n        // Note that the new renderState won't apply until the next frame. See #18320\n        session.updateRenderState({\n          depthNear: cameraVR.near,\n          depthFar: cameraVR.far\n        });\n        _currentDepthNear = cameraVR.near;\n        _currentDepthFar = cameraVR.far;\n      }\n\n      const parent = camera.parent;\n      const cameras = cameraVR.cameras;\n      updateCamera(cameraVR, parent);\n\n      for (let i = 0; i < cameras.length; i++) {\n        updateCamera(cameras[i], parent);\n      }\n\n      cameraVR.matrixWorld.decompose(cameraVR.position, cameraVR.quaternion, cameraVR.scale); // update user camera and its children\n\n      camera.position.copy(cameraVR.position);\n      camera.quaternion.copy(cameraVR.quaternion);\n      camera.scale.copy(cameraVR.scale);\n      camera.matrix.copy(cameraVR.matrix);\n      camera.matrixWorld.copy(cameraVR.matrixWorld);\n      const children = camera.children;\n\n      for (let i = 0, l = children.length; i < l; i++) {\n        children[i].updateMatrixWorld(true);\n      } // update projection matrix for proper view frustum culling\n\n\n      if (cameras.length === 2) {\n        setProjectionFromUnion(cameraVR, cameraL, cameraR);\n      } else {\n        // assume single camera setup (AR)\n        cameraVR.projectionMatrix.copy(cameraL.projectionMatrix);\n      }\n    };\n\n    this.getCamera = function () {\n      return cameraVR;\n    };\n\n    this.getFoveation = function () {\n      if (glProjLayer !== null) {\n        return glProjLayer.fixedFoveation;\n      }\n\n      if (glBaseLayer !== null) {\n        return glBaseLayer.fixedFoveation;\n      }\n\n      return undefined;\n    };\n\n    this.setFoveation = function (foveation) {\n      // 0 = no foveation = full resolution\n      // 1 = maximum foveation = the edges render at lower resolution\n      if (glProjLayer !== null) {\n        glProjLayer.fixedFoveation = foveation;\n      }\n\n      if (glBaseLayer !== null && glBaseLayer.fixedFoveation !== undefined) {\n        glBaseLayer.fixedFoveation = foveation;\n      }\n    }; // Animation Loop\n\n\n    let onAnimationFrameCallback = null;\n\n    function onAnimationFrame(time, frame) {\n      pose = frame.getViewerPose(referenceSpace);\n      xrFrame = frame;\n\n      if (pose !== null) {\n        const views = pose.views;\n\n        if (glBaseLayer !== null) {\n          renderer.setRenderTargetFramebuffer(newRenderTarget, glBaseLayer.framebuffer);\n          renderer.setRenderTarget(newRenderTarget);\n        }\n\n        let cameraVRNeedsUpdate = false; // check if it's necessary to rebuild cameraVR's camera list\n\n        if (views.length !== cameraVR.cameras.length) {\n          cameraVR.cameras.length = 0;\n          cameraVRNeedsUpdate = true;\n        }\n\n        for (let i = 0; i < views.length; i++) {\n          const view = views[i];\n          let viewport = null;\n\n          if (glBaseLayer !== null) {\n            viewport = glBaseLayer.getViewport(view);\n          } else {\n            const glSubImage = glBinding.getViewSubImage(glProjLayer, view);\n            viewport = glSubImage.viewport; // For side-by-side projection, we only produce a single texture for both eyes.\n\n            if (i === 0) {\n              renderer.setRenderTargetTextures(newRenderTarget, glSubImage.colorTexture, glProjLayer.ignoreDepthValues ? undefined : glSubImage.depthStencilTexture);\n              renderer.setRenderTarget(newRenderTarget);\n            }\n          }\n\n          const camera = cameras[i];\n          camera.matrix.fromArray(view.transform.matrix);\n          camera.projectionMatrix.fromArray(view.projectionMatrix);\n          camera.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);\n\n          if (i === 0) {\n            cameraVR.matrix.copy(camera.matrix);\n          }\n\n          if (cameraVRNeedsUpdate === true) {\n            cameraVR.cameras.push(camera);\n          }\n        }\n      } //\n\n\n      const inputSources = session.inputSources;\n\n      for (let i = 0; i < controllers.length; i++) {\n        const controller = controllers[i];\n        const inputSource = inputSources[i];\n        controller.update(inputSource, frame, referenceSpace);\n      }\n\n      if (onAnimationFrameCallback) onAnimationFrameCallback(time, frame);\n      xrFrame = null;\n    }\n\n    const animation = new WebGLAnimation();\n    animation.setAnimationLoop(onAnimationFrame);\n\n    this.setAnimationLoop = function (callback) {\n      onAnimationFrameCallback = callback;\n    };\n\n    this.dispose = function () {};\n  }\n\n}\n\nexport { WebXRManager };","map":{"version":3,"sources":["C:/Users/dell/Desktop/projektlogin/vue-3-authentication-jwt/src/games/three/src/renderers/webxr/WebXRManager.js"],"names":["ArrayCamera","EventDispatcher","PerspectiveCamera","Vector3","Vector4","WebGLAnimation","WebGLRenderTarget","WebXRController","DepthTexture","DepthFormat","DepthStencilFormat","RGBAFormat","sRGBEncoding","UnsignedByteType","UnsignedShortType","UnsignedInt248Type","WebXRManager","constructor","renderer","gl","scope","session","framebufferScaleFactor","referenceSpace","referenceSpaceType","pose","glBinding","glProjLayer","glBaseLayer","xrFrame","attributes","getContextAttributes","initialRenderTarget","newRenderTarget","controllers","inputSourcesMap","Map","cameraL","layers","enable","viewport","cameraR","cameras","cameraVR","_currentDepthNear","_currentDepthFar","cameraAutoUpdate","enabled","isPresenting","getController","index","controller","undefined","getTargetRaySpace","getControllerGrip","getGripSpace","getHand","getHandSpace","onSessionEvent","event","get","inputSource","dispatchEvent","type","data","onSessionEnd","forEach","disconnect","clear","setRenderTarget","animation","stop","setFramebufferScaleFactor","value","console","warn","setReferenceSpaceType","getReferenceSpace","getBaseLayer","getBinding","getFrame","getSession","setSession","getRenderTarget","addEventListener","onInputSourcesChange","xrCompatible","makeXRCompatible","renderState","capabilities","isWebGL2","layerInit","antialias","alpha","depth","stencil","XRWebGLLayer","updateRenderState","baseLayer","framebufferWidth","framebufferHeight","format","encoding","outputEncoding","depthFormat","depthType","glDepthFormat","DEPTH24_STENCIL8","DEPTH_COMPONENT24","projectionlayerInit","colorFormat","SRGB8_ALPHA8","RGBA8","scaleFactor","XRWebGLBinding","createProjectionLayer","textureWidth","textureHeight","depthTexture","stencilBuffer","samples","renderTargetProperties","properties","__ignoreDepthValues","ignoreDepthValues","isXRRenderTarget","setFoveation","requestReferenceSpace","setContext","start","inputSources","i","length","set","removed","delete","added","cameraLPos","cameraRPos","setProjectionFromUnion","camera","setFromMatrixPosition","matrixWorld","ipd","distanceTo","projL","projectionMatrix","elements","projR","near","far","topFov","bottomFov","leftFov","rightFov","left","right","zOffset","xOffset","decompose","position","quaternion","scale","translateX","translateZ","compose","matrixWorldInverse","copy","invert","near2","far2","left2","right2","top2","bottom2","makePerspective","updateCamera","parent","matrix","multiplyMatrices","depthNear","depthFar","children","l","updateMatrixWorld","getCamera","getFoveation","fixedFoveation","foveation","onAnimationFrameCallback","onAnimationFrame","time","frame","getViewerPose","views","setRenderTargetFramebuffer","framebuffer","cameraVRNeedsUpdate","view","getViewport","glSubImage","getViewSubImage","setRenderTargetTextures","colorTexture","depthStencilTexture","fromArray","transform","x","y","width","height","push","update","setAnimationLoop","callback","dispose"],"mappings":"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","sourcesContent":["import { ArrayCamera } from '../../cameras/ArrayCamera.js';\r\nimport { EventDispatcher } from '../../core/EventDispatcher.js';\r\nimport { PerspectiveCamera } from '../../cameras/PerspectiveCamera.js';\r\nimport { Vector3 } from '../../math/Vector3.js';\r\nimport { Vector4 } from '../../math/Vector4.js';\r\nimport { WebGLAnimation } from '../webgl/WebGLAnimation.js';\r\nimport { WebGLRenderTarget } from '../WebGLRenderTarget.js';\r\nimport { WebXRController } from './WebXRController.js';\r\nimport { DepthTexture } from '../../textures/DepthTexture.js';\r\nimport {\r\n\tDepthFormat,\r\n\tDepthStencilFormat,\r\n\tRGBAFormat,\r\n\tsRGBEncoding,\r\n\tUnsignedByteType,\r\n\tUnsignedShortType,\r\n\tUnsignedInt248Type,\r\n} from '../../constants.js';\r\n\r\nclass WebXRManager extends EventDispatcher {\r\n\r\n\tconstructor( renderer, gl ) {\r\n\r\n\t\tsuper();\r\n\r\n\t\tconst scope = this;\r\n\r\n\t\tlet session = null;\r\n\t\tlet framebufferScaleFactor = 1.0;\r\n\r\n\t\tlet referenceSpace = null;\r\n\t\tlet referenceSpaceType = 'local-floor';\r\n\r\n\t\tlet pose = null;\r\n\t\tlet glBinding = null;\r\n\t\tlet glProjLayer = null;\r\n\t\tlet glBaseLayer = null;\r\n\t\tlet xrFrame = null;\r\n\t\tconst attributes = gl.getContextAttributes();\r\n\t\tlet initialRenderTarget = null;\r\n\t\tlet newRenderTarget = null;\r\n\r\n\t\tconst controllers = [];\r\n\t\tconst inputSourcesMap = new Map();\r\n\r\n\t\t//\r\n\r\n\t\tconst cameraL = new PerspectiveCamera();\r\n\t\tcameraL.layers.enable( 1 );\r\n\t\tcameraL.viewport = new Vector4();\r\n\r\n\t\tconst cameraR = new PerspectiveCamera();\r\n\t\tcameraR.layers.enable( 2 );\r\n\t\tcameraR.viewport = new Vector4();\r\n\r\n\t\tconst cameras = [ cameraL, cameraR ];\r\n\r\n\t\tconst cameraVR = new ArrayCamera();\r\n\t\tcameraVR.layers.enable( 1 );\r\n\t\tcameraVR.layers.enable( 2 );\r\n\r\n\t\tlet _currentDepthNear = null;\r\n\t\tlet _currentDepthFar = null;\r\n\r\n\t\t//\r\n\r\n\t\tthis.cameraAutoUpdate = true;\r\n\t\tthis.enabled = false;\r\n\r\n\t\tthis.isPresenting = false;\r\n\r\n\t\tthis.getController = function ( index ) {\r\n\r\n\t\t\tlet controller = controllers[ index ];\r\n\r\n\t\t\tif ( controller === undefined ) {\r\n\r\n\t\t\t\tcontroller = new WebXRController();\r\n\t\t\t\tcontrollers[ index ] = controller;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn controller.getTargetRaySpace();\r\n\r\n\t\t};\r\n\r\n\t\tthis.getControllerGrip = function ( index ) {\r\n\r\n\t\t\tlet controller = controllers[ index ];\r\n\r\n\t\t\tif ( controller === undefined ) {\r\n\r\n\t\t\t\tcontroller = new WebXRController();\r\n\t\t\t\tcontrollers[ index ] = controller;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn controller.getGripSpace();\r\n\r\n\t\t};\r\n\r\n\t\tthis.getHand = function ( index ) {\r\n\r\n\t\t\tlet controller = controllers[ index ];\r\n\r\n\t\t\tif ( controller === undefined ) {\r\n\r\n\t\t\t\tcontroller = new WebXRController();\r\n\t\t\t\tcontrollers[ index ] = controller;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn controller.getHandSpace();\r\n\r\n\t\t};\r\n\r\n\t\t//\r\n\r\n\t\tfunction onSessionEvent( event ) {\r\n\r\n\t\t\tconst controller = inputSourcesMap.get( event.inputSource );\r\n\r\n\t\t\tif ( controller ) {\r\n\r\n\t\t\t\tcontroller.dispatchEvent( { type: event.type, data: event.inputSource } );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction onSessionEnd() {\r\n\r\n\t\t\tinputSourcesMap.forEach( function ( controller, inputSource ) {\r\n\r\n\t\t\t\tcontroller.disconnect( inputSource );\r\n\r\n\t\t\t} );\r\n\r\n\t\t\tinputSourcesMap.clear();\r\n\r\n\t\t\t_currentDepthNear = null;\r\n\t\t\t_currentDepthFar = null;\r\n\r\n\t\t\t// restore framebuffer/rendering state\r\n\r\n\t\t\trenderer.setRenderTarget( initialRenderTarget );\r\n\r\n\t\t\tglBaseLayer = null;\r\n\t\t\tglProjLayer = null;\r\n\t\t\tglBinding = null;\r\n\t\t\tsession = null;\r\n\t\t\tnewRenderTarget = null;\r\n\r\n\t\t\t//\r\n\r\n\t\t\tanimation.stop();\r\n\r\n\t\t\tscope.isPresenting = false;\r\n\r\n\t\t\tscope.dispatchEvent( { type: 'sessionend' } );\r\n\r\n\t\t}\r\n\r\n\t\tthis.setFramebufferScaleFactor = function ( value ) {\r\n\r\n\t\t\tframebufferScaleFactor = value;\r\n\r\n\t\t\tif ( scope.isPresenting === true ) {\r\n\r\n\t\t\t\tconsole.warn( 'THREE.WebXRManager: Cannot change framebuffer scale while presenting.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t\tthis.setReferenceSpaceType = function ( value ) {\r\n\r\n\t\t\treferenceSpaceType = value;\r\n\r\n\t\t\tif ( scope.isPresenting === true ) {\r\n\r\n\t\t\t\tconsole.warn( 'THREE.WebXRManager: Cannot change reference space type while presenting.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t\tthis.getReferenceSpace = function () {\r\n\r\n\t\t\treturn referenceSpace;\r\n\r\n\t\t};\r\n\r\n\t\tthis.getBaseLayer = function () {\r\n\r\n\t\t\treturn glProjLayer !== null ? glProjLayer : glBaseLayer;\r\n\r\n\t\t};\r\n\r\n\t\tthis.getBinding = function () {\r\n\r\n\t\t\treturn glBinding;\r\n\r\n\t\t};\r\n\r\n\t\tthis.getFrame = function () {\r\n\r\n\t\t\treturn xrFrame;\r\n\r\n\t\t};\r\n\r\n\t\tthis.getSession = function () {\r\n\r\n\t\t\treturn session;\r\n\r\n\t\t};\r\n\r\n\t\tthis.setSession = async function ( value ) {\r\n\r\n\t\t\tsession = value;\r\n\r\n\t\t\tif ( session !== null ) {\r\n\r\n\t\t\t\tinitialRenderTarget = renderer.getRenderTarget();\r\n\r\n\t\t\t\tsession.addEventListener( 'select', onSessionEvent );\r\n\t\t\t\tsession.addEventListener( 'selectstart', onSessionEvent );\r\n\t\t\t\tsession.addEventListener( 'selectend', onSessionEvent );\r\n\t\t\t\tsession.addEventListener( 'squeeze', onSessionEvent );\r\n\t\t\t\tsession.addEventListener( 'squeezestart', onSessionEvent );\r\n\t\t\t\tsession.addEventListener( 'squeezeend', onSessionEvent );\r\n\t\t\t\tsession.addEventListener( 'end', onSessionEnd );\r\n\t\t\t\tsession.addEventListener( 'inputsourceschange', onInputSourcesChange );\r\n\r\n\t\t\t\tif ( attributes.xrCompatible !== true ) {\r\n\r\n\t\t\t\t\tawait gl.makeXRCompatible();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( ( session.renderState.layers === undefined ) || ( renderer.capabilities.isWebGL2 === false ) ) {\r\n\r\n\t\t\t\t\tconst layerInit = {\r\n\t\t\t\t\t\tantialias: ( session.renderState.layers === undefined ) ? attributes.antialias : true,\r\n\t\t\t\t\t\talpha: attributes.alpha,\r\n\t\t\t\t\t\tdepth: attributes.depth,\r\n\t\t\t\t\t\tstencil: attributes.stencil,\r\n\t\t\t\t\t\tframebufferScaleFactor: framebufferScaleFactor\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\tglBaseLayer = new XRWebGLLayer( session, gl, layerInit );\r\n\r\n\t\t\t\t\tsession.updateRenderState( { baseLayer: glBaseLayer } );\r\n\r\n\t\t\t\t\tnewRenderTarget = new WebGLRenderTarget(\r\n\t\t\t\t\t\tglBaseLayer.framebufferWidth,\r\n\t\t\t\t\t\tglBaseLayer.framebufferHeight,\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tformat: RGBAFormat,\r\n\t\t\t\t\t\t\ttype: UnsignedByteType,\r\n\t\t\t\t\t\t\tencoding: renderer.outputEncoding\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tlet depthFormat = null;\r\n\t\t\t\t\tlet depthType = null;\r\n\t\t\t\t\tlet glDepthFormat = null;\r\n\r\n\t\t\t\t\tif ( attributes.depth ) {\r\n\r\n\t\t\t\t\t\tglDepthFormat = attributes.stencil ? gl.DEPTH24_STENCIL8 : gl.DEPTH_COMPONENT24;\r\n\t\t\t\t\t\tdepthFormat = attributes.stencil ? DepthStencilFormat : DepthFormat;\r\n\t\t\t\t\t\tdepthType = attributes.stencil ? UnsignedInt248Type : UnsignedShortType;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tconst projectionlayerInit = {\r\n\t\t\t\t\t\tcolorFormat: ( renderer.outputEncoding === sRGBEncoding ) ? gl.SRGB8_ALPHA8 : gl.RGBA8,\r\n\t\t\t\t\t\tdepthFormat: glDepthFormat,\r\n\t\t\t\t\t\tscaleFactor: framebufferScaleFactor\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\tglBinding = new XRWebGLBinding( session, gl );\r\n\r\n\t\t\t\t\tglProjLayer = glBinding.createProjectionLayer( projectionlayerInit );\r\n\r\n\t\t\t\t\tsession.updateRenderState( { layers: [ glProjLayer ] } );\r\n\r\n\t\t\t\t\tnewRenderTarget = new WebGLRenderTarget(\r\n\t\t\t\t\t\tglProjLayer.textureWidth,\r\n\t\t\t\t\t\tglProjLayer.textureHeight,\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tformat: RGBAFormat,\r\n\t\t\t\t\t\t\ttype: UnsignedByteType,\r\n\t\t\t\t\t\t\tdepthTexture: new DepthTexture( glProjLayer.textureWidth, glProjLayer.textureHeight, depthType, undefined, undefined, undefined, undefined, undefined, undefined, depthFormat ),\r\n\t\t\t\t\t\t\tstencilBuffer: attributes.stencil,\r\n\t\t\t\t\t\t\tencoding: renderer.outputEncoding,\r\n\t\t\t\t\t\t\tsamples: attributes.antialias ? 4 : 0\r\n\t\t\t\t\t\t} );\r\n\r\n\t\t\t\t\tconst renderTargetProperties = renderer.properties.get( newRenderTarget );\r\n\t\t\t\t\trenderTargetProperties.__ignoreDepthValues = glProjLayer.ignoreDepthValues;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tnewRenderTarget.isXRRenderTarget = true; // TODO Remove this when possible, see #23278\r\n\r\n\t\t\t\t// Set foveation to maximum.\r\n\t\t\t\tthis.setFoveation( 1.0 );\r\n\r\n\t\t\t\treferenceSpace = await session.requestReferenceSpace( referenceSpaceType );\r\n\r\n\t\t\t\tanimation.setContext( session );\r\n\t\t\t\tanimation.start();\r\n\r\n\t\t\t\tscope.isPresenting = true;\r\n\r\n\t\t\t\tscope.dispatchEvent( { type: 'sessionstart' } );\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t\tfunction onInputSourcesChange( event ) {\r\n\r\n\t\t\tconst inputSources = session.inputSources;\r\n\r\n\t\t\t// Assign inputSources to available controllers\r\n\r\n\t\t\tfor ( let i = 0; i < controllers.length; i ++ ) {\r\n\r\n\t\t\t\tinputSourcesMap.set( inputSources[ i ], controllers[ i ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Notify disconnected\r\n\r\n\t\t\tfor ( let i = 0; i < event.removed.length; i ++ ) {\r\n\r\n\t\t\t\tconst inputSource = event.removed[ i ];\r\n\t\t\t\tconst controller = inputSourcesMap.get( inputSource );\r\n\r\n\t\t\t\tif ( controller ) {\r\n\r\n\t\t\t\t\tcontroller.dispatchEvent( { type: 'disconnected', data: inputSource } );\r\n\t\t\t\t\tinputSourcesMap.delete( inputSource );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Notify connected\r\n\r\n\t\t\tfor ( let i = 0; i < event.added.length; i ++ ) {\r\n\r\n\t\t\t\tconst inputSource = event.added[ i ];\r\n\t\t\t\tconst controller = inputSourcesMap.get( inputSource );\r\n\r\n\t\t\t\tif ( controller ) {\r\n\r\n\t\t\t\t\tcontroller.dispatchEvent( { type: 'connected', data: inputSource } );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\r\n\t\tconst cameraLPos = new Vector3();\r\n\t\tconst cameraRPos = new Vector3();\r\n\r\n\t\t/**\r\n\t\t * Assumes 2 cameras that are parallel and share an X-axis, and that\r\n\t\t * the cameras' projection and world matrices have already been set.\r\n\t\t * And that near and far planes are identical for both cameras.\r\n\t\t * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765\r\n\t\t */\r\n\t\tfunction setProjectionFromUnion( camera, cameraL, cameraR ) {\r\n\r\n\t\t\tcameraLPos.setFromMatrixPosition( cameraL.matrixWorld );\r\n\t\t\tcameraRPos.setFromMatrixPosition( cameraR.matrixWorld );\r\n\r\n\t\t\tconst ipd = cameraLPos.distanceTo( cameraRPos );\r\n\r\n\t\t\tconst projL = cameraL.projectionMatrix.elements;\r\n\t\t\tconst projR = cameraR.projectionMatrix.elements;\r\n\r\n\t\t\t// VR systems will have identical far and near planes, and\r\n\t\t\t// most likely identical top and bottom frustum extents.\r\n\t\t\t// Use the left camera for these values.\r\n\t\t\tconst near = projL[ 14 ] / ( projL[ 10 ] - 1 );\r\n\t\t\tconst far = projL[ 14 ] / ( projL[ 10 ] + 1 );\r\n\t\t\tconst topFov = ( projL[ 9 ] + 1 ) / projL[ 5 ];\r\n\t\t\tconst bottomFov = ( projL[ 9 ] - 1 ) / projL[ 5 ];\r\n\r\n\t\t\tconst leftFov = ( projL[ 8 ] - 1 ) / projL[ 0 ];\r\n\t\t\tconst rightFov = ( projR[ 8 ] + 1 ) / projR[ 0 ];\r\n\t\t\tconst left = near * leftFov;\r\n\t\t\tconst right = near * rightFov;\r\n\r\n\t\t\t// Calculate the new camera's position offset from the\r\n\t\t\t// left camera. xOffset should be roughly half `ipd`.\r\n\t\t\tconst zOffset = ipd / ( - leftFov + rightFov );\r\n\t\t\tconst xOffset = zOffset * - leftFov;\r\n\r\n\t\t\t// TODO: Better way to apply this offset?\r\n\t\t\tcameraL.matrixWorld.decompose( camera.position, camera.quaternion, camera.scale );\r\n\t\t\tcamera.translateX( xOffset );\r\n\t\t\tcamera.translateZ( zOffset );\r\n\t\t\tcamera.matrixWorld.compose( camera.position, camera.quaternion, camera.scale );\r\n\t\t\tcamera.matrixWorldInverse.copy( camera.matrixWorld ).invert();\r\n\r\n\t\t\t// Find the union of the frustum values of the cameras and scale\r\n\t\t\t// the values so that the near plane's position does not change in world space,\r\n\t\t\t// although must now be relative to the new union camera.\r\n\t\t\tconst near2 = near + zOffset;\r\n\t\t\tconst far2 = far + zOffset;\r\n\t\t\tconst left2 = left - xOffset;\r\n\t\t\tconst right2 = right + ( ipd - xOffset );\r\n\t\t\tconst top2 = topFov * far / far2 * near2;\r\n\t\t\tconst bottom2 = bottomFov * far / far2 * near2;\r\n\r\n\t\t\tcamera.projectionMatrix.makePerspective( left2, right2, top2, bottom2, near2, far2 );\r\n\r\n\t\t}\r\n\r\n\t\tfunction updateCamera( camera, parent ) {\r\n\r\n\t\t\tif ( parent === null ) {\r\n\r\n\t\t\t\tcamera.matrixWorld.copy( camera.matrix );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tcamera.matrixWorld.multiplyMatrices( parent.matrixWorld, camera.matrix );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tcamera.matrixWorldInverse.copy( camera.matrixWorld ).invert();\r\n\r\n\t\t}\r\n\r\n\t\tthis.updateCamera = function ( camera ) {\r\n\r\n\t\t\tif ( session === null ) return;\r\n\r\n\t\t\tcameraVR.near = cameraR.near = cameraL.near = camera.near;\r\n\t\t\tcameraVR.far = cameraR.far = cameraL.far = camera.far;\r\n\r\n\t\t\tif ( _currentDepthNear !== cameraVR.near || _currentDepthFar !== cameraVR.far ) {\r\n\r\n\t\t\t\t// Note that the new renderState won't apply until the next frame. See #18320\r\n\r\n\t\t\t\tsession.updateRenderState( {\r\n\t\t\t\t\tdepthNear: cameraVR.near,\r\n\t\t\t\t\tdepthFar: cameraVR.far\r\n\t\t\t\t} );\r\n\r\n\t\t\t\t_currentDepthNear = cameraVR.near;\r\n\t\t\t\t_currentDepthFar = cameraVR.far;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst parent = camera.parent;\r\n\t\t\tconst cameras = cameraVR.cameras;\r\n\r\n\t\t\tupdateCamera( cameraVR, parent );\r\n\r\n\t\t\tfor ( let i = 0; i < cameras.length; i ++ ) {\r\n\r\n\t\t\t\tupdateCamera( cameras[ i ], parent );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tcameraVR.matrixWorld.decompose( cameraVR.position, cameraVR.quaternion, cameraVR.scale );\r\n\r\n\t\t\t// update user camera and its children\r\n\r\n\t\t\tcamera.position.copy( cameraVR.position );\r\n\t\t\tcamera.quaternion.copy( cameraVR.quaternion );\r\n\t\t\tcamera.scale.copy( cameraVR.scale );\r\n\t\t\tcamera.matrix.copy( cameraVR.matrix );\r\n\t\t\tcamera.matrixWorld.copy( cameraVR.matrixWorld );\r\n\r\n\t\t\tconst children = camera.children;\r\n\r\n\t\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tchildren[ i ].updateMatrixWorld( true );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// update projection matrix for proper view frustum culling\r\n\r\n\t\t\tif ( cameras.length === 2 ) {\r\n\r\n\t\t\t\tsetProjectionFromUnion( cameraVR, cameraL, cameraR );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// assume single camera setup (AR)\r\n\r\n\t\t\t\tcameraVR.projectionMatrix.copy( cameraL.projectionMatrix );\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t\tthis.getCamera = function () {\r\n\r\n\t\t\treturn cameraVR;\r\n\r\n\t\t};\r\n\r\n\t\tthis.getFoveation = function () {\r\n\r\n\t\t\tif ( glProjLayer !== null ) {\r\n\r\n\t\t\t\treturn glProjLayer.fixedFoveation;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( glBaseLayer !== null ) {\r\n\r\n\t\t\t\treturn glBaseLayer.fixedFoveation;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn undefined;\r\n\r\n\t\t};\r\n\r\n\t\tthis.setFoveation = function ( foveation ) {\r\n\r\n\t\t\t// 0 = no foveation = full resolution\r\n\t\t\t// 1 = maximum foveation = the edges render at lower resolution\r\n\r\n\t\t\tif ( glProjLayer !== null ) {\r\n\r\n\t\t\t\tglProjLayer.fixedFoveation = foveation;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( glBaseLayer !== null && glBaseLayer.fixedFoveation !== undefined ) {\r\n\r\n\t\t\t\tglBaseLayer.fixedFoveation = foveation;\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t\t// Animation Loop\r\n\r\n\t\tlet onAnimationFrameCallback = null;\r\n\r\n\t\tfunction onAnimationFrame( time, frame ) {\r\n\r\n\t\t\tpose = frame.getViewerPose( referenceSpace );\r\n\t\t\txrFrame = frame;\r\n\r\n\t\t\tif ( pose !== null ) {\r\n\r\n\t\t\t\tconst views = pose.views;\r\n\r\n\t\t\t\tif ( glBaseLayer !== null ) {\r\n\r\n\t\t\t\t\trenderer.setRenderTargetFramebuffer( newRenderTarget, glBaseLayer.framebuffer );\r\n\t\t\t\t\trenderer.setRenderTarget( newRenderTarget );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet cameraVRNeedsUpdate = false;\r\n\r\n\t\t\t\t// check if it's necessary to rebuild cameraVR's camera list\r\n\r\n\t\t\t\tif ( views.length !== cameraVR.cameras.length ) {\r\n\r\n\t\t\t\t\tcameraVR.cameras.length = 0;\r\n\t\t\t\t\tcameraVRNeedsUpdate = true;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor ( let i = 0; i < views.length; i ++ ) {\r\n\r\n\t\t\t\t\tconst view = views[ i ];\r\n\r\n\t\t\t\t\tlet viewport = null;\r\n\r\n\t\t\t\t\tif ( glBaseLayer !== null ) {\r\n\r\n\t\t\t\t\t\tviewport = glBaseLayer.getViewport( view );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tconst glSubImage = glBinding.getViewSubImage( glProjLayer, view );\r\n\t\t\t\t\t\tviewport = glSubImage.viewport;\r\n\r\n\t\t\t\t\t\t// For side-by-side projection, we only produce a single texture for both eyes.\r\n\t\t\t\t\t\tif ( i === 0 ) {\r\n\r\n\t\t\t\t\t\t\trenderer.setRenderTargetTextures(\r\n\t\t\t\t\t\t\t\tnewRenderTarget,\r\n\t\t\t\t\t\t\t\tglSubImage.colorTexture,\r\n\t\t\t\t\t\t\t\tglProjLayer.ignoreDepthValues ? undefined : glSubImage.depthStencilTexture );\r\n\r\n\t\t\t\t\t\t\trenderer.setRenderTarget( newRenderTarget );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tconst camera = cameras[ i ];\r\n\r\n\t\t\t\t\tcamera.matrix.fromArray( view.transform.matrix );\r\n\t\t\t\t\tcamera.projectionMatrix.fromArray( view.projectionMatrix );\r\n\t\t\t\t\tcamera.viewport.set( viewport.x, viewport.y, viewport.width, viewport.height );\r\n\r\n\t\t\t\t\tif ( i === 0 ) {\r\n\r\n\t\t\t\t\t\tcameraVR.matrix.copy( camera.matrix );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( cameraVRNeedsUpdate === true ) {\r\n\r\n\t\t\t\t\t\tcameraVR.cameras.push( camera );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t//\r\n\r\n\t\t\tconst inputSources = session.inputSources;\r\n\r\n\t\t\tfor ( let i = 0; i < controllers.length; i ++ ) {\r\n\r\n\t\t\t\tconst controller = controllers[ i ];\r\n\t\t\t\tconst inputSource = inputSources[ i ];\r\n\r\n\t\t\t\tcontroller.update( inputSource, frame, referenceSpace );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( onAnimationFrameCallback ) onAnimationFrameCallback( time, frame );\r\n\r\n\t\t\txrFrame = null;\r\n\r\n\t\t}\r\n\r\n\t\tconst animation = new WebGLAnimation();\r\n\r\n\t\tanimation.setAnimationLoop( onAnimationFrame );\r\n\r\n\t\tthis.setAnimationLoop = function ( callback ) {\r\n\r\n\t\t\tonAnimationFrameCallback = callback;\r\n\r\n\t\t};\r\n\r\n\t\tthis.dispose = function () {};\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport { WebXRManager };\r\n"]},"metadata":{},"sourceType":"module"}