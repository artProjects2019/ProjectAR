{"ast":null,"code":"import { Color } from '../../math/Color.js';\nimport { Path } from './Path.js';\nimport { Shape } from './Shape.js';\nimport { ShapeUtils } from '../ShapeUtils.js';\n\nclass ShapePath {\n  constructor() {\n    this.type = 'ShapePath';\n    this.color = new Color();\n    this.subPaths = [];\n    this.currentPath = null;\n  }\n\n  moveTo(x, y) {\n    this.currentPath = new Path();\n    this.subPaths.push(this.currentPath);\n    this.currentPath.moveTo(x, y);\n    return this;\n  }\n\n  lineTo(x, y) {\n    this.currentPath.lineTo(x, y);\n    return this;\n  }\n\n  quadraticCurveTo(aCPx, aCPy, aX, aY) {\n    this.currentPath.quadraticCurveTo(aCPx, aCPy, aX, aY);\n    return this;\n  }\n\n  bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {\n    this.currentPath.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY);\n    return this;\n  }\n\n  splineThru(pts) {\n    this.currentPath.splineThru(pts);\n    return this;\n  }\n\n  toShapes(isCCW, noHoles) {\n    function toShapesNoHoles(inSubpaths) {\n      const shapes = [];\n\n      for (let i = 0, l = inSubpaths.length; i < l; i++) {\n        const tmpPath = inSubpaths[i];\n        const tmpShape = new Shape();\n        tmpShape.curves = tmpPath.curves;\n        shapes.push(tmpShape);\n      }\n\n      return shapes;\n    }\n\n    function isPointInsidePolygon(inPt, inPolygon) {\n      const polyLen = inPolygon.length; // inPt on polygon contour => immediate success    or\n      // toggling of inside/outside at every single! intersection point of an edge\n      //  with the horizontal line through inPt, left of inPt\n      //  not counting lowerY endpoints of edges and whole edges on that line\n\n      let inside = false;\n\n      for (let p = polyLen - 1, q = 0; q < polyLen; p = q++) {\n        let edgeLowPt = inPolygon[p];\n        let edgeHighPt = inPolygon[q];\n        let edgeDx = edgeHighPt.x - edgeLowPt.x;\n        let edgeDy = edgeHighPt.y - edgeLowPt.y;\n\n        if (Math.abs(edgeDy) > Number.EPSILON) {\n          // not parallel\n          if (edgeDy < 0) {\n            edgeLowPt = inPolygon[q];\n            edgeDx = -edgeDx;\n            edgeHighPt = inPolygon[p];\n            edgeDy = -edgeDy;\n          }\n\n          if (inPt.y < edgeLowPt.y || inPt.y > edgeHighPt.y) continue;\n\n          if (inPt.y === edgeLowPt.y) {\n            if (inPt.x === edgeLowPt.x) return true; // inPt is on contour ?\n            // continue;\t\t\t\t// no intersection or edgeLowPt => doesn't count !!!\n          } else {\n            const perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);\n            if (perpEdge === 0) return true; // inPt is on contour ?\n\n            if (perpEdge < 0) continue;\n            inside = !inside; // true intersection left of inPt\n          }\n        } else {\n          // parallel or collinear\n          if (inPt.y !== edgeLowPt.y) continue; // parallel\n          // edge lies on the same horizontal line as inPt\n\n          if (edgeHighPt.x <= inPt.x && inPt.x <= edgeLowPt.x || edgeLowPt.x <= inPt.x && inPt.x <= edgeHighPt.x) return true; // inPt: Point on contour !\n          // continue;\n        }\n      }\n\n      return inside;\n    }\n\n    const isClockWise = ShapeUtils.isClockWise;\n    const subPaths = this.subPaths;\n    if (subPaths.length === 0) return [];\n    if (noHoles === true) return toShapesNoHoles(subPaths);\n    let solid, tmpPath, tmpShape;\n    const shapes = [];\n\n    if (subPaths.length === 1) {\n      tmpPath = subPaths[0];\n      tmpShape = new Shape();\n      tmpShape.curves = tmpPath.curves;\n      shapes.push(tmpShape);\n      return shapes;\n    }\n\n    let holesFirst = !isClockWise(subPaths[0].getPoints());\n    holesFirst = isCCW ? !holesFirst : holesFirst; // console.log(\"Holes first\", holesFirst);\n\n    const betterShapeHoles = [];\n    const newShapes = [];\n    let newShapeHoles = [];\n    let mainIdx = 0;\n    let tmpPoints;\n    newShapes[mainIdx] = undefined;\n    newShapeHoles[mainIdx] = [];\n\n    for (let i = 0, l = subPaths.length; i < l; i++) {\n      tmpPath = subPaths[i];\n      tmpPoints = tmpPath.getPoints();\n      solid = isClockWise(tmpPoints);\n      solid = isCCW ? !solid : solid;\n\n      if (solid) {\n        if (!holesFirst && newShapes[mainIdx]) mainIdx++;\n        newShapes[mainIdx] = {\n          s: new Shape(),\n          p: tmpPoints\n        };\n        newShapes[mainIdx].s.curves = tmpPath.curves;\n        if (holesFirst) mainIdx++;\n        newShapeHoles[mainIdx] = []; //console.log('cw', i);\n      } else {\n        newShapeHoles[mainIdx].push({\n          h: tmpPath,\n          p: tmpPoints[0]\n        }); //console.log('ccw', i);\n      }\n    } // only Holes? -> probably all Shapes with wrong orientation\n\n\n    if (!newShapes[0]) return toShapesNoHoles(subPaths);\n\n    if (newShapes.length > 1) {\n      let ambiguous = false;\n      let toChange = 0;\n\n      for (let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {\n        betterShapeHoles[sIdx] = [];\n      }\n\n      for (let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {\n        const sho = newShapeHoles[sIdx];\n\n        for (let hIdx = 0; hIdx < sho.length; hIdx++) {\n          const ho = sho[hIdx];\n          let hole_unassigned = true;\n\n          for (let s2Idx = 0; s2Idx < newShapes.length; s2Idx++) {\n            if (isPointInsidePolygon(ho.p, newShapes[s2Idx].p)) {\n              if (sIdx !== s2Idx) toChange++;\n\n              if (hole_unassigned) {\n                hole_unassigned = false;\n                betterShapeHoles[s2Idx].push(ho);\n              } else {\n                ambiguous = true;\n              }\n            }\n          }\n\n          if (hole_unassigned) {\n            betterShapeHoles[sIdx].push(ho);\n          }\n        }\n      }\n\n      if (toChange > 0 && ambiguous === false) {\n        newShapeHoles = betterShapeHoles;\n      }\n    }\n\n    let tmpHoles;\n\n    for (let i = 0, il = newShapes.length; i < il; i++) {\n      tmpShape = newShapes[i].s;\n      shapes.push(tmpShape);\n      tmpHoles = newShapeHoles[i];\n\n      for (let j = 0, jl = tmpHoles.length; j < jl; j++) {\n        tmpShape.holes.push(tmpHoles[j].h);\n      }\n    } //console.log(\"shape\", shapes);\n\n\n    return shapes;\n  }\n\n}\n\nexport { ShapePath };","map":{"version":3,"sources":["C:/Users/dell/Desktop/projektlogin/vue-3-authentication-jwt/src/games/three/src/extras/core/ShapePath.js"],"names":["Color","Path","Shape","ShapeUtils","ShapePath","constructor","type","color","subPaths","currentPath","moveTo","x","y","push","lineTo","quadraticCurveTo","aCPx","aCPy","aX","aY","bezierCurveTo","aCP1x","aCP1y","aCP2x","aCP2y","splineThru","pts","toShapes","isCCW","noHoles","toShapesNoHoles","inSubpaths","shapes","i","l","length","tmpPath","tmpShape","curves","isPointInsidePolygon","inPt","inPolygon","polyLen","inside","p","q","edgeLowPt","edgeHighPt","edgeDx","edgeDy","Math","abs","Number","EPSILON","perpEdge","isClockWise","solid","holesFirst","getPoints","betterShapeHoles","newShapes","newShapeHoles","mainIdx","tmpPoints","undefined","s","h","ambiguous","toChange","sIdx","sLen","sho","hIdx","ho","hole_unassigned","s2Idx","tmpHoles","il","j","jl","holes"],"mappings":"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","sourcesContent":["import { Color } from '../../math/Color.js';\r\nimport { Path } from './Path.js';\r\nimport { Shape } from './Shape.js';\r\nimport { ShapeUtils } from '../ShapeUtils.js';\r\n\r\nclass ShapePath {\r\n\r\n\tconstructor() {\r\n\r\n\t\tthis.type = 'ShapePath';\r\n\r\n\t\tthis.color = new Color();\r\n\r\n\t\tthis.subPaths = [];\r\n\t\tthis.currentPath = null;\r\n\r\n\t}\r\n\r\n\tmoveTo( x, y ) {\r\n\r\n\t\tthis.currentPath = new Path();\r\n\t\tthis.subPaths.push( this.currentPath );\r\n\t\tthis.currentPath.moveTo( x, y );\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tlineTo( x, y ) {\r\n\r\n\t\tthis.currentPath.lineTo( x, y );\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tquadraticCurveTo( aCPx, aCPy, aX, aY ) {\r\n\r\n\t\tthis.currentPath.quadraticCurveTo( aCPx, aCPy, aX, aY );\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tbezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {\r\n\r\n\t\tthis.currentPath.bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY );\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tsplineThru( pts ) {\r\n\r\n\t\tthis.currentPath.splineThru( pts );\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\ttoShapes( isCCW, noHoles ) {\r\n\r\n\t\tfunction toShapesNoHoles( inSubpaths ) {\r\n\r\n\t\t\tconst shapes = [];\r\n\r\n\t\t\tfor ( let i = 0, l = inSubpaths.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tconst tmpPath = inSubpaths[ i ];\r\n\r\n\t\t\t\tconst tmpShape = new Shape();\r\n\t\t\t\ttmpShape.curves = tmpPath.curves;\r\n\r\n\t\t\t\tshapes.push( tmpShape );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shapes;\r\n\r\n\t\t}\r\n\r\n\t\tfunction isPointInsidePolygon( inPt, inPolygon ) {\r\n\r\n\t\t\tconst polyLen = inPolygon.length;\r\n\r\n\t\t\t// inPt on polygon contour => immediate success    or\r\n\t\t\t// toggling of inside/outside at every single! intersection point of an edge\r\n\t\t\t//  with the horizontal line through inPt, left of inPt\r\n\t\t\t//  not counting lowerY endpoints of edges and whole edges on that line\r\n\t\t\tlet inside = false;\r\n\t\t\tfor ( let p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {\r\n\r\n\t\t\t\tlet edgeLowPt = inPolygon[ p ];\r\n\t\t\t\tlet edgeHighPt = inPolygon[ q ];\r\n\r\n\t\t\t\tlet edgeDx = edgeHighPt.x - edgeLowPt.x;\r\n\t\t\t\tlet edgeDy = edgeHighPt.y - edgeLowPt.y;\r\n\r\n\t\t\t\tif ( Math.abs( edgeDy ) > Number.EPSILON ) {\r\n\r\n\t\t\t\t\t// not parallel\r\n\t\t\t\t\tif ( edgeDy < 0 ) {\r\n\r\n\t\t\t\t\t\tedgeLowPt = inPolygon[ q ]; edgeDx = - edgeDx;\r\n\t\t\t\t\t\tedgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) \t\tcontinue;\r\n\r\n\t\t\t\t\tif ( inPt.y === edgeLowPt.y ) {\r\n\r\n\t\t\t\t\t\tif ( inPt.x === edgeLowPt.x )\t\treturn\ttrue;\t\t// inPt is on contour ?\r\n\t\t\t\t\t\t// continue;\t\t\t\t// no intersection or edgeLowPt => doesn't count !!!\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tconst perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );\r\n\t\t\t\t\t\tif ( perpEdge === 0 )\t\t\t\treturn\ttrue;\t\t// inPt is on contour ?\r\n\t\t\t\t\t\tif ( perpEdge < 0 ) \t\t\t\tcontinue;\r\n\t\t\t\t\t\tinside = ! inside;\t\t// true intersection left of inPt\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// parallel or collinear\r\n\t\t\t\t\tif ( inPt.y !== edgeLowPt.y ) \t\tcontinue;\t\t\t// parallel\r\n\t\t\t\t\t// edge lies on the same horizontal line as inPt\r\n\t\t\t\t\tif ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||\r\n\t\t\t\t\t\t ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )\t\treturn\ttrue;\t// inPt: Point on contour !\r\n\t\t\t\t\t// continue;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn\tinside;\r\n\r\n\t\t}\r\n\r\n\t\tconst isClockWise = ShapeUtils.isClockWise;\r\n\r\n\t\tconst subPaths = this.subPaths;\r\n\t\tif ( subPaths.length === 0 ) return [];\r\n\r\n\t\tif ( noHoles === true )\treturn\ttoShapesNoHoles( subPaths );\r\n\r\n\r\n\t\tlet solid, tmpPath, tmpShape;\r\n\t\tconst shapes = [];\r\n\r\n\t\tif ( subPaths.length === 1 ) {\r\n\r\n\t\t\ttmpPath = subPaths[ 0 ];\r\n\t\t\ttmpShape = new Shape();\r\n\t\t\ttmpShape.curves = tmpPath.curves;\r\n\t\t\tshapes.push( tmpShape );\r\n\t\t\treturn shapes;\r\n\r\n\t\t}\r\n\r\n\t\tlet holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );\r\n\t\tholesFirst = isCCW ? ! holesFirst : holesFirst;\r\n\r\n\t\t// console.log(\"Holes first\", holesFirst);\r\n\r\n\t\tconst betterShapeHoles = [];\r\n\t\tconst newShapes = [];\r\n\t\tlet newShapeHoles = [];\r\n\t\tlet mainIdx = 0;\r\n\t\tlet tmpPoints;\r\n\r\n\t\tnewShapes[ mainIdx ] = undefined;\r\n\t\tnewShapeHoles[ mainIdx ] = [];\r\n\r\n\t\tfor ( let i = 0, l = subPaths.length; i < l; i ++ ) {\r\n\r\n\t\t\ttmpPath = subPaths[ i ];\r\n\t\t\ttmpPoints = tmpPath.getPoints();\r\n\t\t\tsolid = isClockWise( tmpPoints );\r\n\t\t\tsolid = isCCW ? ! solid : solid;\r\n\r\n\t\t\tif ( solid ) {\r\n\r\n\t\t\t\tif ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )\tmainIdx ++;\r\n\r\n\t\t\t\tnewShapes[ mainIdx ] = { s: new Shape(), p: tmpPoints };\r\n\t\t\t\tnewShapes[ mainIdx ].s.curves = tmpPath.curves;\r\n\r\n\t\t\t\tif ( holesFirst )\tmainIdx ++;\r\n\t\t\t\tnewShapeHoles[ mainIdx ] = [];\r\n\r\n\t\t\t\t//console.log('cw', i);\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tnewShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );\r\n\r\n\t\t\t\t//console.log('ccw', i);\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// only Holes? -> probably all Shapes with wrong orientation\r\n\t\tif ( ! newShapes[ 0 ] )\treturn\ttoShapesNoHoles( subPaths );\r\n\r\n\r\n\t\tif ( newShapes.length > 1 ) {\r\n\r\n\t\t\tlet ambiguous = false;\r\n\t\t\tlet toChange = 0;\r\n\r\n\t\t\tfor ( let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\r\n\r\n\t\t\t\tbetterShapeHoles[ sIdx ] = [];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\r\n\r\n\t\t\t\tconst sho = newShapeHoles[ sIdx ];\r\n\r\n\t\t\t\tfor ( let hIdx = 0; hIdx < sho.length; hIdx ++ ) {\r\n\r\n\t\t\t\t\tconst ho = sho[ hIdx ];\r\n\t\t\t\t\tlet hole_unassigned = true;\r\n\r\n\t\t\t\t\tfor ( let s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {\r\n\r\n\t\t\t\t\t\tif ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {\r\n\r\n\t\t\t\t\t\t\tif ( sIdx !== s2Idx )\ttoChange ++;\r\n\r\n\t\t\t\t\t\t\tif ( hole_unassigned ) {\r\n\r\n\t\t\t\t\t\t\t\thole_unassigned = false;\r\n\t\t\t\t\t\t\t\tbetterShapeHoles[ s2Idx ].push( ho );\r\n\r\n\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\tambiguous = true;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( hole_unassigned ) {\r\n\r\n\t\t\t\t\t\tbetterShapeHoles[ sIdx ].push( ho );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( toChange > 0 && ambiguous === false ) {\r\n\r\n\t\t\t\tnewShapeHoles = betterShapeHoles;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tlet tmpHoles;\r\n\r\n\t\tfor ( let i = 0, il = newShapes.length; i < il; i ++ ) {\r\n\r\n\t\t\ttmpShape = newShapes[ i ].s;\r\n\t\t\tshapes.push( tmpShape );\r\n\t\t\ttmpHoles = newShapeHoles[ i ];\r\n\r\n\t\t\tfor ( let j = 0, jl = tmpHoles.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\ttmpShape.holes.push( tmpHoles[ j ].h );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t//console.log(\"shape\", shapes);\r\n\r\n\t\treturn shapes;\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\nexport { ShapePath };\r\n"]},"metadata":{},"sourceType":"module"}