{"ast":null,"code":"import \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport { Vector3 } from '../math/Vector3.js';\nimport { Vector2 } from '../math/Vector2.js';\nimport { Box3 } from '../math/Box3.js';\nimport { EventDispatcher } from './EventDispatcher.js';\nimport { BufferAttribute, Float32BufferAttribute, Uint16BufferAttribute, Uint32BufferAttribute } from './BufferAttribute.js';\nimport { Sphere } from '../math/Sphere.js';\nimport { Object3D } from './Object3D.js';\nimport { Matrix4 } from '../math/Matrix4.js';\nimport { Matrix3 } from '../math/Matrix3.js';\nimport * as MathUtils from '../math/MathUtils.js';\nimport { arrayNeedsUint32 } from '../utils.js';\nlet _id = 0;\n\nconst _m1 = /*@__PURE__*/new Matrix4();\n\nconst _obj = /*@__PURE__*/new Object3D();\n\nconst _offset = /*@__PURE__*/new Vector3();\n\nconst _box = /*@__PURE__*/new Box3();\n\nconst _boxMorphTargets = /*@__PURE__*/new Box3();\n\nconst _vector = /*@__PURE__*/new Vector3();\n\nclass BufferGeometry extends EventDispatcher {\n  constructor() {\n    super();\n    Object.defineProperty(this, 'id', {\n      value: _id++\n    });\n    this.uuid = MathUtils.generateUUID();\n    this.name = '';\n    this.type = 'BufferGeometry';\n    this.index = null;\n    this.attributes = {};\n    this.morphAttributes = {};\n    this.morphTargetsRelative = false;\n    this.groups = [];\n    this.boundingBox = null;\n    this.boundingSphere = null;\n    this.drawRange = {\n      start: 0,\n      count: Infinity\n    };\n    this.userData = {};\n  }\n\n  getIndex() {\n    return this.index;\n  }\n\n  setIndex(index) {\n    if (Array.isArray(index)) {\n      this.index = new (arrayNeedsUint32(index) ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);\n    } else {\n      this.index = index;\n    }\n\n    return this;\n  }\n\n  getAttribute(name) {\n    return this.attributes[name];\n  }\n\n  setAttribute(name, attribute) {\n    this.attributes[name] = attribute;\n    return this;\n  }\n\n  deleteAttribute(name) {\n    delete this.attributes[name];\n    return this;\n  }\n\n  hasAttribute(name) {\n    return this.attributes[name] !== undefined;\n  }\n\n  addGroup(start, count, materialIndex = 0) {\n    this.groups.push({\n      start: start,\n      count: count,\n      materialIndex: materialIndex\n    });\n  }\n\n  clearGroups() {\n    this.groups = [];\n  }\n\n  setDrawRange(start, count) {\n    this.drawRange.start = start;\n    this.drawRange.count = count;\n  }\n\n  applyMatrix4(matrix) {\n    const position = this.attributes.position;\n\n    if (position !== undefined) {\n      position.applyMatrix4(matrix);\n      position.needsUpdate = true;\n    }\n\n    const normal = this.attributes.normal;\n\n    if (normal !== undefined) {\n      const normalMatrix = new Matrix3().getNormalMatrix(matrix);\n      normal.applyNormalMatrix(normalMatrix);\n      normal.needsUpdate = true;\n    }\n\n    const tangent = this.attributes.tangent;\n\n    if (tangent !== undefined) {\n      tangent.transformDirection(matrix);\n      tangent.needsUpdate = true;\n    }\n\n    if (this.boundingBox !== null) {\n      this.computeBoundingBox();\n    }\n\n    if (this.boundingSphere !== null) {\n      this.computeBoundingSphere();\n    }\n\n    return this;\n  }\n\n  applyQuaternion(q) {\n    _m1.makeRotationFromQuaternion(q);\n\n    this.applyMatrix4(_m1);\n    return this;\n  }\n\n  rotateX(angle) {\n    // rotate geometry around world x-axis\n    _m1.makeRotationX(angle);\n\n    this.applyMatrix4(_m1);\n    return this;\n  }\n\n  rotateY(angle) {\n    // rotate geometry around world y-axis\n    _m1.makeRotationY(angle);\n\n    this.applyMatrix4(_m1);\n    return this;\n  }\n\n  rotateZ(angle) {\n    // rotate geometry around world z-axis\n    _m1.makeRotationZ(angle);\n\n    this.applyMatrix4(_m1);\n    return this;\n  }\n\n  translate(x, y, z) {\n    // translate geometry\n    _m1.makeTranslation(x, y, z);\n\n    this.applyMatrix4(_m1);\n    return this;\n  }\n\n  scale(x, y, z) {\n    // scale geometry\n    _m1.makeScale(x, y, z);\n\n    this.applyMatrix4(_m1);\n    return this;\n  }\n\n  lookAt(vector) {\n    _obj.lookAt(vector);\n\n    _obj.updateMatrix();\n\n    this.applyMatrix4(_obj.matrix);\n    return this;\n  }\n\n  center() {\n    this.computeBoundingBox();\n    this.boundingBox.getCenter(_offset).negate();\n    this.translate(_offset.x, _offset.y, _offset.z);\n    return this;\n  }\n\n  setFromPoints(points) {\n    const position = [];\n\n    for (let i = 0, l = points.length; i < l; i++) {\n      const point = points[i];\n      position.push(point.x, point.y, point.z || 0);\n    }\n\n    this.setAttribute('position', new Float32BufferAttribute(position, 3));\n    return this;\n  }\n\n  computeBoundingBox() {\n    if (this.boundingBox === null) {\n      this.boundingBox = new Box3();\n    }\n\n    const position = this.attributes.position;\n    const morphAttributesPosition = this.morphAttributes.position;\n\n    if (position && position.isGLBufferAttribute) {\n      console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set \"mesh.frustumCulled\" to \"false\".', this);\n      this.boundingBox.set(new Vector3(-Infinity, -Infinity, -Infinity), new Vector3(+Infinity, +Infinity, +Infinity));\n      return;\n    }\n\n    if (position !== undefined) {\n      this.boundingBox.setFromBufferAttribute(position); // process morph attributes if present\n\n      if (morphAttributesPosition) {\n        for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {\n          const morphAttribute = morphAttributesPosition[i];\n\n          _box.setFromBufferAttribute(morphAttribute);\n\n          if (this.morphTargetsRelative) {\n            _vector.addVectors(this.boundingBox.min, _box.min);\n\n            this.boundingBox.expandByPoint(_vector);\n\n            _vector.addVectors(this.boundingBox.max, _box.max);\n\n            this.boundingBox.expandByPoint(_vector);\n          } else {\n            this.boundingBox.expandByPoint(_box.min);\n            this.boundingBox.expandByPoint(_box.max);\n          }\n        }\n      }\n    } else {\n      this.boundingBox.makeEmpty();\n    }\n\n    if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {\n      console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The \"position\" attribute is likely to have NaN values.', this);\n    }\n  }\n\n  computeBoundingSphere() {\n    if (this.boundingSphere === null) {\n      this.boundingSphere = new Sphere();\n    }\n\n    const position = this.attributes.position;\n    const morphAttributesPosition = this.morphAttributes.position;\n\n    if (position && position.isGLBufferAttribute) {\n      console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set \"mesh.frustumCulled\" to \"false\".', this);\n      this.boundingSphere.set(new Vector3(), Infinity);\n      return;\n    }\n\n    if (position) {\n      // first, find the center of the bounding sphere\n      const center = this.boundingSphere.center;\n\n      _box.setFromBufferAttribute(position); // process morph attributes if present\n\n\n      if (morphAttributesPosition) {\n        for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {\n          const morphAttribute = morphAttributesPosition[i];\n\n          _boxMorphTargets.setFromBufferAttribute(morphAttribute);\n\n          if (this.morphTargetsRelative) {\n            _vector.addVectors(_box.min, _boxMorphTargets.min);\n\n            _box.expandByPoint(_vector);\n\n            _vector.addVectors(_box.max, _boxMorphTargets.max);\n\n            _box.expandByPoint(_vector);\n          } else {\n            _box.expandByPoint(_boxMorphTargets.min);\n\n            _box.expandByPoint(_boxMorphTargets.max);\n          }\n        }\n      }\n\n      _box.getCenter(center); // second, try to find a boundingSphere with a radius smaller than the\n      // boundingSphere of the boundingBox: sqrt(3) smaller in the best case\n\n\n      let maxRadiusSq = 0;\n\n      for (let i = 0, il = position.count; i < il; i++) {\n        _vector.fromBufferAttribute(position, i);\n\n        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector));\n      } // process morph attributes if present\n\n\n      if (morphAttributesPosition) {\n        for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {\n          const morphAttribute = morphAttributesPosition[i];\n          const morphTargetsRelative = this.morphTargetsRelative;\n\n          for (let j = 0, jl = morphAttribute.count; j < jl; j++) {\n            _vector.fromBufferAttribute(morphAttribute, j);\n\n            if (morphTargetsRelative) {\n              _offset.fromBufferAttribute(position, j);\n\n              _vector.add(_offset);\n            }\n\n            maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector));\n          }\n        }\n      }\n\n      this.boundingSphere.radius = Math.sqrt(maxRadiusSq);\n\n      if (isNaN(this.boundingSphere.radius)) {\n        console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \"position\" attribute is likely to have NaN values.', this);\n      }\n    }\n  }\n\n  computeTangents() {\n    const index = this.index;\n    const attributes = this.attributes; // based on http://www.terathon.com/code/tangent.html\n    // (per vertex tangents)\n\n    if (index === null || attributes.position === undefined || attributes.normal === undefined || attributes.uv === undefined) {\n      console.error('THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)');\n      return;\n    }\n\n    const indices = index.array;\n    const positions = attributes.position.array;\n    const normals = attributes.normal.array;\n    const uvs = attributes.uv.array;\n    const nVertices = positions.length / 3;\n\n    if (this.hasAttribute('tangent') === false) {\n      this.setAttribute('tangent', new BufferAttribute(new Float32Array(4 * nVertices), 4));\n    }\n\n    const tangents = this.getAttribute('tangent').array;\n    const tan1 = [],\n          tan2 = [];\n\n    for (let i = 0; i < nVertices; i++) {\n      tan1[i] = new Vector3();\n      tan2[i] = new Vector3();\n    }\n\n    const vA = new Vector3(),\n          vB = new Vector3(),\n          vC = new Vector3(),\n          uvA = new Vector2(),\n          uvB = new Vector2(),\n          uvC = new Vector2(),\n          sdir = new Vector3(),\n          tdir = new Vector3();\n\n    function handleTriangle(a, b, c) {\n      vA.fromArray(positions, a * 3);\n      vB.fromArray(positions, b * 3);\n      vC.fromArray(positions, c * 3);\n      uvA.fromArray(uvs, a * 2);\n      uvB.fromArray(uvs, b * 2);\n      uvC.fromArray(uvs, c * 2);\n      vB.sub(vA);\n      vC.sub(vA);\n      uvB.sub(uvA);\n      uvC.sub(uvA);\n      const r = 1.0 / (uvB.x * uvC.y - uvC.x * uvB.y); // silently ignore degenerate uv triangles having coincident or colinear vertices\n\n      if (!isFinite(r)) return;\n      sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, -uvB.y).multiplyScalar(r);\n      tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, -uvC.x).multiplyScalar(r);\n      tan1[a].add(sdir);\n      tan1[b].add(sdir);\n      tan1[c].add(sdir);\n      tan2[a].add(tdir);\n      tan2[b].add(tdir);\n      tan2[c].add(tdir);\n    }\n\n    let groups = this.groups;\n\n    if (groups.length === 0) {\n      groups = [{\n        start: 0,\n        count: indices.length\n      }];\n    }\n\n    for (let i = 0, il = groups.length; i < il; ++i) {\n      const group = groups[i];\n      const start = group.start;\n      const count = group.count;\n\n      for (let j = start, jl = start + count; j < jl; j += 3) {\n        handleTriangle(indices[j + 0], indices[j + 1], indices[j + 2]);\n      }\n    }\n\n    const tmp = new Vector3(),\n          tmp2 = new Vector3();\n    const n = new Vector3(),\n          n2 = new Vector3();\n\n    function handleVertex(v) {\n      n.fromArray(normals, v * 3);\n      n2.copy(n);\n      const t = tan1[v]; // Gram-Schmidt orthogonalize\n\n      tmp.copy(t);\n      tmp.sub(n.multiplyScalar(n.dot(t))).normalize(); // Calculate handedness\n\n      tmp2.crossVectors(n2, t);\n      const test = tmp2.dot(tan2[v]);\n      const w = test < 0.0 ? -1.0 : 1.0;\n      tangents[v * 4] = tmp.x;\n      tangents[v * 4 + 1] = tmp.y;\n      tangents[v * 4 + 2] = tmp.z;\n      tangents[v * 4 + 3] = w;\n    }\n\n    for (let i = 0, il = groups.length; i < il; ++i) {\n      const group = groups[i];\n      const start = group.start;\n      const count = group.count;\n\n      for (let j = start, jl = start + count; j < jl; j += 3) {\n        handleVertex(indices[j + 0]);\n        handleVertex(indices[j + 1]);\n        handleVertex(indices[j + 2]);\n      }\n    }\n  }\n\n  computeVertexNormals() {\n    const index = this.index;\n    const positionAttribute = this.getAttribute('position');\n\n    if (positionAttribute !== undefined) {\n      let normalAttribute = this.getAttribute('normal');\n\n      if (normalAttribute === undefined) {\n        normalAttribute = new BufferAttribute(new Float32Array(positionAttribute.count * 3), 3);\n        this.setAttribute('normal', normalAttribute);\n      } else {\n        // reset existing normals to zero\n        for (let i = 0, il = normalAttribute.count; i < il; i++) {\n          normalAttribute.setXYZ(i, 0, 0, 0);\n        }\n      }\n\n      const pA = new Vector3(),\n            pB = new Vector3(),\n            pC = new Vector3();\n      const nA = new Vector3(),\n            nB = new Vector3(),\n            nC = new Vector3();\n      const cb = new Vector3(),\n            ab = new Vector3(); // indexed elements\n\n      if (index) {\n        for (let i = 0, il = index.count; i < il; i += 3) {\n          const vA = index.getX(i + 0);\n          const vB = index.getX(i + 1);\n          const vC = index.getX(i + 2);\n          pA.fromBufferAttribute(positionAttribute, vA);\n          pB.fromBufferAttribute(positionAttribute, vB);\n          pC.fromBufferAttribute(positionAttribute, vC);\n          cb.subVectors(pC, pB);\n          ab.subVectors(pA, pB);\n          cb.cross(ab);\n          nA.fromBufferAttribute(normalAttribute, vA);\n          nB.fromBufferAttribute(normalAttribute, vB);\n          nC.fromBufferAttribute(normalAttribute, vC);\n          nA.add(cb);\n          nB.add(cb);\n          nC.add(cb);\n          normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);\n          normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);\n          normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);\n        }\n      } else {\n        // non-indexed elements (unconnected triangle soup)\n        for (let i = 0, il = positionAttribute.count; i < il; i += 3) {\n          pA.fromBufferAttribute(positionAttribute, i + 0);\n          pB.fromBufferAttribute(positionAttribute, i + 1);\n          pC.fromBufferAttribute(positionAttribute, i + 2);\n          cb.subVectors(pC, pB);\n          ab.subVectors(pA, pB);\n          cb.cross(ab);\n          normalAttribute.setXYZ(i + 0, cb.x, cb.y, cb.z);\n          normalAttribute.setXYZ(i + 1, cb.x, cb.y, cb.z);\n          normalAttribute.setXYZ(i + 2, cb.x, cb.y, cb.z);\n        }\n      }\n\n      this.normalizeNormals();\n      normalAttribute.needsUpdate = true;\n    }\n  }\n\n  merge(geometry, offset) {\n    if (!(geometry && geometry.isBufferGeometry)) {\n      console.error('THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry);\n      return;\n    }\n\n    if (offset === undefined) {\n      offset = 0;\n      console.warn('THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. ' + 'Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.');\n    }\n\n    const attributes = this.attributes;\n\n    for (const key in attributes) {\n      if (geometry.attributes[key] === undefined) continue;\n      const attribute1 = attributes[key];\n      const attributeArray1 = attribute1.array;\n      const attribute2 = geometry.attributes[key];\n      const attributeArray2 = attribute2.array;\n      const attributeOffset = attribute2.itemSize * offset;\n      const length = Math.min(attributeArray2.length, attributeArray1.length - attributeOffset);\n\n      for (let i = 0, j = attributeOffset; i < length; i++, j++) {\n        attributeArray1[j] = attributeArray2[i];\n      }\n    }\n\n    return this;\n  }\n\n  normalizeNormals() {\n    const normals = this.attributes.normal;\n\n    for (let i = 0, il = normals.count; i < il; i++) {\n      _vector.fromBufferAttribute(normals, i);\n\n      _vector.normalize();\n\n      normals.setXYZ(i, _vector.x, _vector.y, _vector.z);\n    }\n  }\n\n  toNonIndexed() {\n    function convertBufferAttribute(attribute, indices) {\n      const array = attribute.array;\n      const itemSize = attribute.itemSize;\n      const normalized = attribute.normalized;\n      const array2 = new array.constructor(indices.length * itemSize);\n      let index = 0,\n          index2 = 0;\n\n      for (let i = 0, l = indices.length; i < l; i++) {\n        if (attribute.isInterleavedBufferAttribute) {\n          index = indices[i] * attribute.data.stride + attribute.offset;\n        } else {\n          index = indices[i] * itemSize;\n        }\n\n        for (let j = 0; j < itemSize; j++) {\n          array2[index2++] = array[index++];\n        }\n      }\n\n      return new BufferAttribute(array2, itemSize, normalized);\n    } //\n\n\n    if (this.index === null) {\n      console.warn('THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.');\n      return this;\n    }\n\n    const geometry2 = new BufferGeometry();\n    const indices = this.index.array;\n    const attributes = this.attributes; // attributes\n\n    for (const name in attributes) {\n      const attribute = attributes[name];\n      const newAttribute = convertBufferAttribute(attribute, indices);\n      geometry2.setAttribute(name, newAttribute);\n    } // morph attributes\n\n\n    const morphAttributes = this.morphAttributes;\n\n    for (const name in morphAttributes) {\n      const morphArray = [];\n      const morphAttribute = morphAttributes[name]; // morphAttribute: array of Float32BufferAttributes\n\n      for (let i = 0, il = morphAttribute.length; i < il; i++) {\n        const attribute = morphAttribute[i];\n        const newAttribute = convertBufferAttribute(attribute, indices);\n        morphArray.push(newAttribute);\n      }\n\n      geometry2.morphAttributes[name] = morphArray;\n    }\n\n    geometry2.morphTargetsRelative = this.morphTargetsRelative; // groups\n\n    const groups = this.groups;\n\n    for (let i = 0, l = groups.length; i < l; i++) {\n      const group = groups[i];\n      geometry2.addGroup(group.start, group.count, group.materialIndex);\n    }\n\n    return geometry2;\n  }\n\n  toJSON() {\n    const data = {\n      metadata: {\n        version: 4.5,\n        type: 'BufferGeometry',\n        generator: 'BufferGeometry.toJSON'\n      }\n    }; // standard BufferGeometry serialization\n\n    data.uuid = this.uuid;\n    data.type = this.type;\n    if (this.name !== '') data.name = this.name;\n    if (Object.keys(this.userData).length > 0) data.userData = this.userData;\n\n    if (this.parameters !== undefined) {\n      const parameters = this.parameters;\n\n      for (const key in parameters) {\n        if (parameters[key] !== undefined) data[key] = parameters[key];\n      }\n\n      return data;\n    } // for simplicity the code assumes attributes are not shared across geometries, see #15811\n\n\n    data.data = {\n      attributes: {}\n    };\n    const index = this.index;\n\n    if (index !== null) {\n      data.data.index = {\n        type: index.array.constructor.name,\n        array: Array.prototype.slice.call(index.array)\n      };\n    }\n\n    const attributes = this.attributes;\n\n    for (const key in attributes) {\n      const attribute = attributes[key];\n      data.data.attributes[key] = attribute.toJSON(data.data);\n    }\n\n    const morphAttributes = {};\n    let hasMorphAttributes = false;\n\n    for (const key in this.morphAttributes) {\n      const attributeArray = this.morphAttributes[key];\n      const array = [];\n\n      for (let i = 0, il = attributeArray.length; i < il; i++) {\n        const attribute = attributeArray[i];\n        array.push(attribute.toJSON(data.data));\n      }\n\n      if (array.length > 0) {\n        morphAttributes[key] = array;\n        hasMorphAttributes = true;\n      }\n    }\n\n    if (hasMorphAttributes) {\n      data.data.morphAttributes = morphAttributes;\n      data.data.morphTargetsRelative = this.morphTargetsRelative;\n    }\n\n    const groups = this.groups;\n\n    if (groups.length > 0) {\n      data.data.groups = JSON.parse(JSON.stringify(groups));\n    }\n\n    const boundingSphere = this.boundingSphere;\n\n    if (boundingSphere !== null) {\n      data.data.boundingSphere = {\n        center: boundingSphere.center.toArray(),\n        radius: boundingSphere.radius\n      };\n    }\n\n    return data;\n  }\n\n  clone() {\n    return new this.constructor().copy(this);\n  }\n\n  copy(source) {\n    // reset\n    this.index = null;\n    this.attributes = {};\n    this.morphAttributes = {};\n    this.groups = [];\n    this.boundingBox = null;\n    this.boundingSphere = null; // used for storing cloned, shared data\n\n    const data = {}; // name\n\n    this.name = source.name; // index\n\n    const index = source.index;\n\n    if (index !== null) {\n      this.setIndex(index.clone(data));\n    } // attributes\n\n\n    const attributes = source.attributes;\n\n    for (const name in attributes) {\n      const attribute = attributes[name];\n      this.setAttribute(name, attribute.clone(data));\n    } // morph attributes\n\n\n    const morphAttributes = source.morphAttributes;\n\n    for (const name in morphAttributes) {\n      const array = [];\n      const morphAttribute = morphAttributes[name]; // morphAttribute: array of Float32BufferAttributes\n\n      for (let i = 0, l = morphAttribute.length; i < l; i++) {\n        array.push(morphAttribute[i].clone(data));\n      }\n\n      this.morphAttributes[name] = array;\n    }\n\n    this.morphTargetsRelative = source.morphTargetsRelative; // groups\n\n    const groups = source.groups;\n\n    for (let i = 0, l = groups.length; i < l; i++) {\n      const group = groups[i];\n      this.addGroup(group.start, group.count, group.materialIndex);\n    } // bounding box\n\n\n    const boundingBox = source.boundingBox;\n\n    if (boundingBox !== null) {\n      this.boundingBox = boundingBox.clone();\n    } // bounding sphere\n\n\n    const boundingSphere = source.boundingSphere;\n\n    if (boundingSphere !== null) {\n      this.boundingSphere = boundingSphere.clone();\n    } // draw range\n\n\n    this.drawRange.start = source.drawRange.start;\n    this.drawRange.count = source.drawRange.count; // user data\n\n    this.userData = source.userData; // geometry generator parameters\n\n    if (source.parameters !== undefined) this.parameters = Object.assign({}, source.parameters);\n    return this;\n  }\n\n  dispose() {\n    this.dispatchEvent({\n      type: 'dispose'\n    });\n  }\n\n}\n\nBufferGeometry.prototype.isBufferGeometry = true;\nexport { BufferGeometry };","map":{"version":3,"sources":["C:/Users/dell/Desktop/projektlogin/vue-3-authentication-jwt/src/games/three/src/core/BufferGeometry.js"],"names":["Vector3","Vector2","Box3","EventDispatcher","BufferAttribute","Float32BufferAttribute","Uint16BufferAttribute","Uint32BufferAttribute","Sphere","Object3D","Matrix4","Matrix3","MathUtils","arrayNeedsUint32","_id","_m1","_obj","_offset","_box","_boxMorphTargets","_vector","BufferGeometry","constructor","Object","defineProperty","value","uuid","generateUUID","name","type","index","attributes","morphAttributes","morphTargetsRelative","groups","boundingBox","boundingSphere","drawRange","start","count","Infinity","userData","getIndex","setIndex","Array","isArray","getAttribute","setAttribute","attribute","deleteAttribute","hasAttribute","undefined","addGroup","materialIndex","push","clearGroups","setDrawRange","applyMatrix4","matrix","position","needsUpdate","normal","normalMatrix","getNormalMatrix","applyNormalMatrix","tangent","transformDirection","computeBoundingBox","computeBoundingSphere","applyQuaternion","q","makeRotationFromQuaternion","rotateX","angle","makeRotationX","rotateY","makeRotationY","rotateZ","makeRotationZ","translate","x","y","z","makeTranslation","scale","makeScale","lookAt","vector","updateMatrix","center","getCenter","negate","setFromPoints","points","i","l","length","point","morphAttributesPosition","isGLBufferAttribute","console","error","set","setFromBufferAttribute","il","morphAttribute","addVectors","min","expandByPoint","max","makeEmpty","isNaN","maxRadiusSq","fromBufferAttribute","Math","distanceToSquared","j","jl","add","radius","sqrt","computeTangents","uv","indices","array","positions","normals","uvs","nVertices","Float32Array","tangents","tan1","tan2","vA","vB","vC","uvA","uvB","uvC","sdir","tdir","handleTriangle","a","b","c","fromArray","sub","r","isFinite","copy","multiplyScalar","addScaledVector","group","tmp","tmp2","n","n2","handleVertex","v","t","dot","normalize","crossVectors","test","w","computeVertexNormals","positionAttribute","normalAttribute","setXYZ","pA","pB","pC","nA","nB","nC","cb","ab","getX","subVectors","cross","normalizeNormals","merge","geometry","offset","isBufferGeometry","warn","key","attribute1","attributeArray1","attribute2","attributeArray2","attributeOffset","itemSize","toNonIndexed","convertBufferAttribute","normalized","array2","index2","isInterleavedBufferAttribute","data","stride","geometry2","newAttribute","morphArray","toJSON","metadata","version","generator","keys","parameters","prototype","slice","call","hasMorphAttributes","attributeArray","JSON","parse","stringify","toArray","clone","source","assign","dispose","dispatchEvent"],"mappings":"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","sourcesContent":["import { Vector3 } from '../math/Vector3.js';\r\nimport { Vector2 } from '../math/Vector2.js';\r\nimport { Box3 } from '../math/Box3.js';\r\nimport { EventDispatcher } from './EventDispatcher.js';\r\nimport { BufferAttribute, Float32BufferAttribute, Uint16BufferAttribute, Uint32BufferAttribute } from './BufferAttribute.js';\r\nimport { Sphere } from '../math/Sphere.js';\r\nimport { Object3D } from './Object3D.js';\r\nimport { Matrix4 } from '../math/Matrix4.js';\r\nimport { Matrix3 } from '../math/Matrix3.js';\r\nimport * as MathUtils from '../math/MathUtils.js';\r\nimport { arrayNeedsUint32 } from '../utils.js';\r\n\r\nlet _id = 0;\r\n\r\nconst _m1 = /*@__PURE__*/ new Matrix4();\r\nconst _obj = /*@__PURE__*/ new Object3D();\r\nconst _offset = /*@__PURE__*/ new Vector3();\r\nconst _box = /*@__PURE__*/ new Box3();\r\nconst _boxMorphTargets = /*@__PURE__*/ new Box3();\r\nconst _vector = /*@__PURE__*/ new Vector3();\r\n\r\nclass BufferGeometry extends EventDispatcher {\r\n\r\n\tconstructor() {\r\n\r\n\t\tsuper();\r\n\r\n\t\tObject.defineProperty( this, 'id', { value: _id ++ } );\r\n\r\n\t\tthis.uuid = MathUtils.generateUUID();\r\n\r\n\t\tthis.name = '';\r\n\t\tthis.type = 'BufferGeometry';\r\n\r\n\t\tthis.index = null;\r\n\t\tthis.attributes = {};\r\n\r\n\t\tthis.morphAttributes = {};\r\n\t\tthis.morphTargetsRelative = false;\r\n\r\n\t\tthis.groups = [];\r\n\r\n\t\tthis.boundingBox = null;\r\n\t\tthis.boundingSphere = null;\r\n\r\n\t\tthis.drawRange = { start: 0, count: Infinity };\r\n\r\n\t\tthis.userData = {};\r\n\r\n\t}\r\n\r\n\tgetIndex() {\r\n\r\n\t\treturn this.index;\r\n\r\n\t}\r\n\r\n\tsetIndex( index ) {\r\n\r\n\t\tif ( Array.isArray( index ) ) {\r\n\r\n\t\t\tthis.index = new ( arrayNeedsUint32( index ) ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.index = index;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tgetAttribute( name ) {\r\n\r\n\t\treturn this.attributes[ name ];\r\n\r\n\t}\r\n\r\n\tsetAttribute( name, attribute ) {\r\n\r\n\t\tthis.attributes[ name ] = attribute;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tdeleteAttribute( name ) {\r\n\r\n\t\tdelete this.attributes[ name ];\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\thasAttribute( name ) {\r\n\r\n\t\treturn this.attributes[ name ] !== undefined;\r\n\r\n\t}\r\n\r\n\taddGroup( start, count, materialIndex = 0 ) {\r\n\r\n\t\tthis.groups.push( {\r\n\r\n\t\t\tstart: start,\r\n\t\t\tcount: count,\r\n\t\t\tmaterialIndex: materialIndex\r\n\r\n\t\t} );\r\n\r\n\t}\r\n\r\n\tclearGroups() {\r\n\r\n\t\tthis.groups = [];\r\n\r\n\t}\r\n\r\n\tsetDrawRange( start, count ) {\r\n\r\n\t\tthis.drawRange.start = start;\r\n\t\tthis.drawRange.count = count;\r\n\r\n\t}\r\n\r\n\tapplyMatrix4( matrix ) {\r\n\r\n\t\tconst position = this.attributes.position;\r\n\r\n\t\tif ( position !== undefined ) {\r\n\r\n\t\t\tposition.applyMatrix4( matrix );\r\n\r\n\t\t\tposition.needsUpdate = true;\r\n\r\n\t\t}\r\n\r\n\t\tconst normal = this.attributes.normal;\r\n\r\n\t\tif ( normal !== undefined ) {\r\n\r\n\t\t\tconst normalMatrix = new Matrix3().getNormalMatrix( matrix );\r\n\r\n\t\t\tnormal.applyNormalMatrix( normalMatrix );\r\n\r\n\t\t\tnormal.needsUpdate = true;\r\n\r\n\t\t}\r\n\r\n\t\tconst tangent = this.attributes.tangent;\r\n\r\n\t\tif ( tangent !== undefined ) {\r\n\r\n\t\t\ttangent.transformDirection( matrix );\r\n\r\n\t\t\ttangent.needsUpdate = true;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.boundingBox !== null ) {\r\n\r\n\t\t\tthis.computeBoundingBox();\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.boundingSphere !== null ) {\r\n\r\n\t\t\tthis.computeBoundingSphere();\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tapplyQuaternion( q ) {\r\n\r\n\t\t_m1.makeRotationFromQuaternion( q );\r\n\r\n\t\tthis.applyMatrix4( _m1 );\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\trotateX( angle ) {\r\n\r\n\t\t// rotate geometry around world x-axis\r\n\r\n\t\t_m1.makeRotationX( angle );\r\n\r\n\t\tthis.applyMatrix4( _m1 );\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\trotateY( angle ) {\r\n\r\n\t\t// rotate geometry around world y-axis\r\n\r\n\t\t_m1.makeRotationY( angle );\r\n\r\n\t\tthis.applyMatrix4( _m1 );\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\trotateZ( angle ) {\r\n\r\n\t\t// rotate geometry around world z-axis\r\n\r\n\t\t_m1.makeRotationZ( angle );\r\n\r\n\t\tthis.applyMatrix4( _m1 );\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\ttranslate( x, y, z ) {\r\n\r\n\t\t// translate geometry\r\n\r\n\t\t_m1.makeTranslation( x, y, z );\r\n\r\n\t\tthis.applyMatrix4( _m1 );\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tscale( x, y, z ) {\r\n\r\n\t\t// scale geometry\r\n\r\n\t\t_m1.makeScale( x, y, z );\r\n\r\n\t\tthis.applyMatrix4( _m1 );\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tlookAt( vector ) {\r\n\r\n\t\t_obj.lookAt( vector );\r\n\r\n\t\t_obj.updateMatrix();\r\n\r\n\t\tthis.applyMatrix4( _obj.matrix );\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tcenter() {\r\n\r\n\t\tthis.computeBoundingBox();\r\n\r\n\t\tthis.boundingBox.getCenter( _offset ).negate();\r\n\r\n\t\tthis.translate( _offset.x, _offset.y, _offset.z );\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tsetFromPoints( points ) {\r\n\r\n\t\tconst position = [];\r\n\r\n\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\r\n\r\n\t\t\tconst point = points[ i ];\r\n\t\t\tposition.push( point.x, point.y, point.z || 0 );\r\n\r\n\t\t}\r\n\r\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( position, 3 ) );\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tcomputeBoundingBox() {\r\n\r\n\t\tif ( this.boundingBox === null ) {\r\n\r\n\t\t\tthis.boundingBox = new Box3();\r\n\r\n\t\t}\r\n\r\n\t\tconst position = this.attributes.position;\r\n\t\tconst morphAttributesPosition = this.morphAttributes.position;\r\n\r\n\t\tif ( position && position.isGLBufferAttribute ) {\r\n\r\n\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set \"mesh.frustumCulled\" to \"false\".', this );\r\n\r\n\t\t\tthis.boundingBox.set(\r\n\t\t\t\tnew Vector3( - Infinity, - Infinity, - Infinity ),\r\n\t\t\t\tnew Vector3( + Infinity, + Infinity, + Infinity )\r\n\t\t\t);\r\n\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tif ( position !== undefined ) {\r\n\r\n\t\t\tthis.boundingBox.setFromBufferAttribute( position );\r\n\r\n\t\t\t// process morph attributes if present\r\n\r\n\t\t\tif ( morphAttributesPosition ) {\r\n\r\n\t\t\t\tfor ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tconst morphAttribute = morphAttributesPosition[ i ];\r\n\t\t\t\t\t_box.setFromBufferAttribute( morphAttribute );\r\n\r\n\t\t\t\t\tif ( this.morphTargetsRelative ) {\r\n\r\n\t\t\t\t\t\t_vector.addVectors( this.boundingBox.min, _box.min );\r\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _vector );\r\n\r\n\t\t\t\t\t\t_vector.addVectors( this.boundingBox.max, _box.max );\r\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _vector );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _box.min );\r\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _box.max );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.boundingBox.makeEmpty();\r\n\r\n\t\t}\r\n\r\n\t\tif ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {\r\n\r\n\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The \"position\" attribute is likely to have NaN values.', this );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tcomputeBoundingSphere() {\r\n\r\n\t\tif ( this.boundingSphere === null ) {\r\n\r\n\t\t\tthis.boundingSphere = new Sphere();\r\n\r\n\t\t}\r\n\r\n\t\tconst position = this.attributes.position;\r\n\t\tconst morphAttributesPosition = this.morphAttributes.position;\r\n\r\n\t\tif ( position && position.isGLBufferAttribute ) {\r\n\r\n\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set \"mesh.frustumCulled\" to \"false\".', this );\r\n\r\n\t\t\tthis.boundingSphere.set( new Vector3(), Infinity );\r\n\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tif ( position ) {\r\n\r\n\t\t\t// first, find the center of the bounding sphere\r\n\r\n\t\t\tconst center = this.boundingSphere.center;\r\n\r\n\t\t\t_box.setFromBufferAttribute( position );\r\n\r\n\t\t\t// process morph attributes if present\r\n\r\n\t\t\tif ( morphAttributesPosition ) {\r\n\r\n\t\t\t\tfor ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tconst morphAttribute = morphAttributesPosition[ i ];\r\n\t\t\t\t\t_boxMorphTargets.setFromBufferAttribute( morphAttribute );\r\n\r\n\t\t\t\t\tif ( this.morphTargetsRelative ) {\r\n\r\n\t\t\t\t\t\t_vector.addVectors( _box.min, _boxMorphTargets.min );\r\n\t\t\t\t\t\t_box.expandByPoint( _vector );\r\n\r\n\t\t\t\t\t\t_vector.addVectors( _box.max, _boxMorphTargets.max );\r\n\t\t\t\t\t\t_box.expandByPoint( _vector );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t_box.expandByPoint( _boxMorphTargets.min );\r\n\t\t\t\t\t\t_box.expandByPoint( _boxMorphTargets.max );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_box.getCenter( center );\r\n\r\n\t\t\t// second, try to find a boundingSphere with a radius smaller than the\r\n\t\t\t// boundingSphere of the boundingBox: sqrt(3) smaller in the best case\r\n\r\n\t\t\tlet maxRadiusSq = 0;\r\n\r\n\t\t\tfor ( let i = 0, il = position.count; i < il; i ++ ) {\r\n\r\n\t\t\t\t_vector.fromBufferAttribute( position, i );\r\n\r\n\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// process morph attributes if present\r\n\r\n\t\t\tif ( morphAttributesPosition ) {\r\n\r\n\t\t\t\tfor ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tconst morphAttribute = morphAttributesPosition[ i ];\r\n\t\t\t\t\tconst morphTargetsRelative = this.morphTargetsRelative;\r\n\r\n\t\t\t\t\tfor ( let j = 0, jl = morphAttribute.count; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\t\t_vector.fromBufferAttribute( morphAttribute, j );\r\n\r\n\t\t\t\t\t\tif ( morphTargetsRelative ) {\r\n\r\n\t\t\t\t\t\t\t_offset.fromBufferAttribute( position, j );\r\n\t\t\t\t\t\t\t_vector.add( _offset );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector ) );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.boundingSphere.radius = Math.sqrt( maxRadiusSq );\r\n\r\n\t\t\tif ( isNaN( this.boundingSphere.radius ) ) {\r\n\r\n\t\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \"position\" attribute is likely to have NaN values.', this );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tcomputeTangents() {\r\n\r\n\t\tconst index = this.index;\r\n\t\tconst attributes = this.attributes;\r\n\r\n\t\t// based on http://www.terathon.com/code/tangent.html\r\n\t\t// (per vertex tangents)\r\n\r\n\t\tif ( index === null ||\r\n\t\t\t attributes.position === undefined ||\r\n\t\t\t attributes.normal === undefined ||\r\n\t\t\t attributes.uv === undefined ) {\r\n\r\n\t\t\tconsole.error( 'THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)' );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tconst indices = index.array;\r\n\t\tconst positions = attributes.position.array;\r\n\t\tconst normals = attributes.normal.array;\r\n\t\tconst uvs = attributes.uv.array;\r\n\r\n\t\tconst nVertices = positions.length / 3;\r\n\r\n\t\tif ( this.hasAttribute( 'tangent' ) === false ) {\r\n\r\n\t\t\tthis.setAttribute( 'tangent', new BufferAttribute( new Float32Array( 4 * nVertices ), 4 ) );\r\n\r\n\t\t}\r\n\r\n\t\tconst tangents = this.getAttribute( 'tangent' ).array;\r\n\r\n\t\tconst tan1 = [], tan2 = [];\r\n\r\n\t\tfor ( let i = 0; i < nVertices; i ++ ) {\r\n\r\n\t\t\ttan1[ i ] = new Vector3();\r\n\t\t\ttan2[ i ] = new Vector3();\r\n\r\n\t\t}\r\n\r\n\t\tconst vA = new Vector3(),\r\n\t\t\tvB = new Vector3(),\r\n\t\t\tvC = new Vector3(),\r\n\r\n\t\t\tuvA = new Vector2(),\r\n\t\t\tuvB = new Vector2(),\r\n\t\t\tuvC = new Vector2(),\r\n\r\n\t\t\tsdir = new Vector3(),\r\n\t\t\ttdir = new Vector3();\r\n\r\n\t\tfunction handleTriangle( a, b, c ) {\r\n\r\n\t\t\tvA.fromArray( positions, a * 3 );\r\n\t\t\tvB.fromArray( positions, b * 3 );\r\n\t\t\tvC.fromArray( positions, c * 3 );\r\n\r\n\t\t\tuvA.fromArray( uvs, a * 2 );\r\n\t\t\tuvB.fromArray( uvs, b * 2 );\r\n\t\t\tuvC.fromArray( uvs, c * 2 );\r\n\r\n\t\t\tvB.sub( vA );\r\n\t\t\tvC.sub( vA );\r\n\r\n\t\t\tuvB.sub( uvA );\r\n\t\t\tuvC.sub( uvA );\r\n\r\n\t\t\tconst r = 1.0 / ( uvB.x * uvC.y - uvC.x * uvB.y );\r\n\r\n\t\t\t// silently ignore degenerate uv triangles having coincident or colinear vertices\r\n\r\n\t\t\tif ( ! isFinite( r ) ) return;\r\n\r\n\t\t\tsdir.copy( vB ).multiplyScalar( uvC.y ).addScaledVector( vC, - uvB.y ).multiplyScalar( r );\r\n\t\t\ttdir.copy( vC ).multiplyScalar( uvB.x ).addScaledVector( vB, - uvC.x ).multiplyScalar( r );\r\n\r\n\t\t\ttan1[ a ].add( sdir );\r\n\t\t\ttan1[ b ].add( sdir );\r\n\t\t\ttan1[ c ].add( sdir );\r\n\r\n\t\t\ttan2[ a ].add( tdir );\r\n\t\t\ttan2[ b ].add( tdir );\r\n\t\t\ttan2[ c ].add( tdir );\r\n\r\n\t\t}\r\n\r\n\t\tlet groups = this.groups;\r\n\r\n\t\tif ( groups.length === 0 ) {\r\n\r\n\t\t\tgroups = [ {\r\n\t\t\t\tstart: 0,\r\n\t\t\t\tcount: indices.length\r\n\t\t\t} ];\r\n\r\n\t\t}\r\n\r\n\t\tfor ( let i = 0, il = groups.length; i < il; ++ i ) {\r\n\r\n\t\t\tconst group = groups[ i ];\r\n\r\n\t\t\tconst start = group.start;\r\n\t\t\tconst count = group.count;\r\n\r\n\t\t\tfor ( let j = start, jl = start + count; j < jl; j += 3 ) {\r\n\r\n\t\t\t\thandleTriangle(\r\n\t\t\t\t\tindices[ j + 0 ],\r\n\t\t\t\t\tindices[ j + 1 ],\r\n\t\t\t\t\tindices[ j + 2 ]\r\n\t\t\t\t);\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tconst tmp = new Vector3(), tmp2 = new Vector3();\r\n\t\tconst n = new Vector3(), n2 = new Vector3();\r\n\r\n\t\tfunction handleVertex( v ) {\r\n\r\n\t\t\tn.fromArray( normals, v * 3 );\r\n\t\t\tn2.copy( n );\r\n\r\n\t\t\tconst t = tan1[ v ];\r\n\r\n\t\t\t// Gram-Schmidt orthogonalize\r\n\r\n\t\t\ttmp.copy( t );\r\n\t\t\ttmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();\r\n\r\n\t\t\t// Calculate handedness\r\n\r\n\t\t\ttmp2.crossVectors( n2, t );\r\n\t\t\tconst test = tmp2.dot( tan2[ v ] );\r\n\t\t\tconst w = ( test < 0.0 ) ? - 1.0 : 1.0;\r\n\r\n\t\t\ttangents[ v * 4 ] = tmp.x;\r\n\t\t\ttangents[ v * 4 + 1 ] = tmp.y;\r\n\t\t\ttangents[ v * 4 + 2 ] = tmp.z;\r\n\t\t\ttangents[ v * 4 + 3 ] = w;\r\n\r\n\t\t}\r\n\r\n\t\tfor ( let i = 0, il = groups.length; i < il; ++ i ) {\r\n\r\n\t\t\tconst group = groups[ i ];\r\n\r\n\t\t\tconst start = group.start;\r\n\t\t\tconst count = group.count;\r\n\r\n\t\t\tfor ( let j = start, jl = start + count; j < jl; j += 3 ) {\r\n\r\n\t\t\t\thandleVertex( indices[ j + 0 ] );\r\n\t\t\t\thandleVertex( indices[ j + 1 ] );\r\n\t\t\t\thandleVertex( indices[ j + 2 ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tcomputeVertexNormals() {\r\n\r\n\t\tconst index = this.index;\r\n\t\tconst positionAttribute = this.getAttribute( 'position' );\r\n\r\n\t\tif ( positionAttribute !== undefined ) {\r\n\r\n\t\t\tlet normalAttribute = this.getAttribute( 'normal' );\r\n\r\n\t\t\tif ( normalAttribute === undefined ) {\r\n\r\n\t\t\t\tnormalAttribute = new BufferAttribute( new Float32Array( positionAttribute.count * 3 ), 3 );\r\n\t\t\t\tthis.setAttribute( 'normal', normalAttribute );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// reset existing normals to zero\r\n\r\n\t\t\t\tfor ( let i = 0, il = normalAttribute.count; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tnormalAttribute.setXYZ( i, 0, 0, 0 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst pA = new Vector3(), pB = new Vector3(), pC = new Vector3();\r\n\t\t\tconst nA = new Vector3(), nB = new Vector3(), nC = new Vector3();\r\n\t\t\tconst cb = new Vector3(), ab = new Vector3();\r\n\r\n\t\t\t// indexed elements\r\n\r\n\t\t\tif ( index ) {\r\n\r\n\t\t\t\tfor ( let i = 0, il = index.count; i < il; i += 3 ) {\r\n\r\n\t\t\t\t\tconst vA = index.getX( i + 0 );\r\n\t\t\t\t\tconst vB = index.getX( i + 1 );\r\n\t\t\t\t\tconst vC = index.getX( i + 2 );\r\n\r\n\t\t\t\t\tpA.fromBufferAttribute( positionAttribute, vA );\r\n\t\t\t\t\tpB.fromBufferAttribute( positionAttribute, vB );\r\n\t\t\t\t\tpC.fromBufferAttribute( positionAttribute, vC );\r\n\r\n\t\t\t\t\tcb.subVectors( pC, pB );\r\n\t\t\t\t\tab.subVectors( pA, pB );\r\n\t\t\t\t\tcb.cross( ab );\r\n\r\n\t\t\t\t\tnA.fromBufferAttribute( normalAttribute, vA );\r\n\t\t\t\t\tnB.fromBufferAttribute( normalAttribute, vB );\r\n\t\t\t\t\tnC.fromBufferAttribute( normalAttribute, vC );\r\n\r\n\t\t\t\t\tnA.add( cb );\r\n\t\t\t\t\tnB.add( cb );\r\n\t\t\t\t\tnC.add( cb );\r\n\r\n\t\t\t\t\tnormalAttribute.setXYZ( vA, nA.x, nA.y, nA.z );\r\n\t\t\t\t\tnormalAttribute.setXYZ( vB, nB.x, nB.y, nB.z );\r\n\t\t\t\t\tnormalAttribute.setXYZ( vC, nC.x, nC.y, nC.z );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// non-indexed elements (unconnected triangle soup)\r\n\r\n\t\t\t\tfor ( let i = 0, il = positionAttribute.count; i < il; i += 3 ) {\r\n\r\n\t\t\t\t\tpA.fromBufferAttribute( positionAttribute, i + 0 );\r\n\t\t\t\t\tpB.fromBufferAttribute( positionAttribute, i + 1 );\r\n\t\t\t\t\tpC.fromBufferAttribute( positionAttribute, i + 2 );\r\n\r\n\t\t\t\t\tcb.subVectors( pC, pB );\r\n\t\t\t\t\tab.subVectors( pA, pB );\r\n\t\t\t\t\tcb.cross( ab );\r\n\r\n\t\t\t\t\tnormalAttribute.setXYZ( i + 0, cb.x, cb.y, cb.z );\r\n\t\t\t\t\tnormalAttribute.setXYZ( i + 1, cb.x, cb.y, cb.z );\r\n\t\t\t\t\tnormalAttribute.setXYZ( i + 2, cb.x, cb.y, cb.z );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.normalizeNormals();\r\n\r\n\t\t\tnormalAttribute.needsUpdate = true;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tmerge( geometry, offset ) {\r\n\r\n\t\tif ( ! ( geometry && geometry.isBufferGeometry ) ) {\r\n\r\n\t\t\tconsole.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tif ( offset === undefined ) {\r\n\r\n\t\t\toffset = 0;\r\n\r\n\t\t\tconsole.warn(\r\n\t\t\t\t'THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. '\r\n\t\t\t\t+ 'Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.'\r\n\t\t\t);\r\n\r\n\t\t}\r\n\r\n\t\tconst attributes = this.attributes;\r\n\r\n\t\tfor ( const key in attributes ) {\r\n\r\n\t\t\tif ( geometry.attributes[ key ] === undefined ) continue;\r\n\r\n\t\t\tconst attribute1 = attributes[ key ];\r\n\t\t\tconst attributeArray1 = attribute1.array;\r\n\r\n\t\t\tconst attribute2 = geometry.attributes[ key ];\r\n\t\t\tconst attributeArray2 = attribute2.array;\r\n\r\n\t\t\tconst attributeOffset = attribute2.itemSize * offset;\r\n\t\t\tconst length = Math.min( attributeArray2.length, attributeArray1.length - attributeOffset );\r\n\r\n\t\t\tfor ( let i = 0, j = attributeOffset; i < length; i ++, j ++ ) {\r\n\r\n\t\t\t\tattributeArray1[ j ] = attributeArray2[ i ];\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tnormalizeNormals() {\r\n\r\n\t\tconst normals = this.attributes.normal;\r\n\r\n\t\tfor ( let i = 0, il = normals.count; i < il; i ++ ) {\r\n\r\n\t\t\t_vector.fromBufferAttribute( normals, i );\r\n\r\n\t\t\t_vector.normalize();\r\n\r\n\t\t\tnormals.setXYZ( i, _vector.x, _vector.y, _vector.z );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\ttoNonIndexed() {\r\n\r\n\t\tfunction convertBufferAttribute( attribute, indices ) {\r\n\r\n\t\t\tconst array = attribute.array;\r\n\t\t\tconst itemSize = attribute.itemSize;\r\n\t\t\tconst normalized = attribute.normalized;\r\n\r\n\t\t\tconst array2 = new array.constructor( indices.length * itemSize );\r\n\r\n\t\t\tlet index = 0, index2 = 0;\r\n\r\n\t\t\tfor ( let i = 0, l = indices.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tif ( attribute.isInterleavedBufferAttribute ) {\r\n\r\n\t\t\t\t\tindex = indices[ i ] * attribute.data.stride + attribute.offset;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tindex = indices[ i ] * itemSize;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor ( let j = 0; j < itemSize; j ++ ) {\r\n\r\n\t\t\t\t\tarray2[ index2 ++ ] = array[ index ++ ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn new BufferAttribute( array2, itemSize, normalized );\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\r\n\t\tif ( this.index === null ) {\r\n\r\n\t\t\tconsole.warn( 'THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.' );\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\tconst geometry2 = new BufferGeometry();\r\n\r\n\t\tconst indices = this.index.array;\r\n\t\tconst attributes = this.attributes;\r\n\r\n\t\t// attributes\r\n\r\n\t\tfor ( const name in attributes ) {\r\n\r\n\t\t\tconst attribute = attributes[ name ];\r\n\r\n\t\t\tconst newAttribute = convertBufferAttribute( attribute, indices );\r\n\r\n\t\t\tgeometry2.setAttribute( name, newAttribute );\r\n\r\n\t\t}\r\n\r\n\t\t// morph attributes\r\n\r\n\t\tconst morphAttributes = this.morphAttributes;\r\n\r\n\t\tfor ( const name in morphAttributes ) {\r\n\r\n\t\t\tconst morphArray = [];\r\n\t\t\tconst morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes\r\n\r\n\t\t\tfor ( let i = 0, il = morphAttribute.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tconst attribute = morphAttribute[ i ];\r\n\r\n\t\t\t\tconst newAttribute = convertBufferAttribute( attribute, indices );\r\n\r\n\t\t\t\tmorphArray.push( newAttribute );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgeometry2.morphAttributes[ name ] = morphArray;\r\n\r\n\t\t}\r\n\r\n\t\tgeometry2.morphTargetsRelative = this.morphTargetsRelative;\r\n\r\n\t\t// groups\r\n\r\n\t\tconst groups = this.groups;\r\n\r\n\t\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\r\n\r\n\t\t\tconst group = groups[ i ];\r\n\t\t\tgeometry2.addGroup( group.start, group.count, group.materialIndex );\r\n\r\n\t\t}\r\n\r\n\t\treturn geometry2;\r\n\r\n\t}\r\n\r\n\ttoJSON() {\r\n\r\n\t\tconst data = {\r\n\t\t\tmetadata: {\r\n\t\t\t\tversion: 4.5,\r\n\t\t\t\ttype: 'BufferGeometry',\r\n\t\t\t\tgenerator: 'BufferGeometry.toJSON'\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t// standard BufferGeometry serialization\r\n\r\n\t\tdata.uuid = this.uuid;\r\n\t\tdata.type = this.type;\r\n\t\tif ( this.name !== '' ) data.name = this.name;\r\n\t\tif ( Object.keys( this.userData ).length > 0 ) data.userData = this.userData;\r\n\r\n\t\tif ( this.parameters !== undefined ) {\r\n\r\n\t\t\tconst parameters = this.parameters;\r\n\r\n\t\t\tfor ( const key in parameters ) {\r\n\r\n\t\t\t\tif ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn data;\r\n\r\n\t\t}\r\n\r\n\t\t// for simplicity the code assumes attributes are not shared across geometries, see #15811\r\n\r\n\t\tdata.data = { attributes: {} };\r\n\r\n\t\tconst index = this.index;\r\n\r\n\t\tif ( index !== null ) {\r\n\r\n\t\t\tdata.data.index = {\r\n\t\t\t\ttype: index.array.constructor.name,\r\n\t\t\t\tarray: Array.prototype.slice.call( index.array )\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t\tconst attributes = this.attributes;\r\n\r\n\t\tfor ( const key in attributes ) {\r\n\r\n\t\t\tconst attribute = attributes[ key ];\r\n\r\n\t\t\tdata.data.attributes[ key ] = attribute.toJSON( data.data );\r\n\r\n\t\t}\r\n\r\n\t\tconst morphAttributes = {};\r\n\t\tlet hasMorphAttributes = false;\r\n\r\n\t\tfor ( const key in this.morphAttributes ) {\r\n\r\n\t\t\tconst attributeArray = this.morphAttributes[ key ];\r\n\r\n\t\t\tconst array = [];\r\n\r\n\t\t\tfor ( let i = 0, il = attributeArray.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tconst attribute = attributeArray[ i ];\r\n\r\n\t\t\t\tarray.push( attribute.toJSON( data.data ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( array.length > 0 ) {\r\n\r\n\t\t\t\tmorphAttributes[ key ] = array;\r\n\r\n\t\t\t\thasMorphAttributes = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( hasMorphAttributes ) {\r\n\r\n\t\t\tdata.data.morphAttributes = morphAttributes;\r\n\t\t\tdata.data.morphTargetsRelative = this.morphTargetsRelative;\r\n\r\n\t\t}\r\n\r\n\t\tconst groups = this.groups;\r\n\r\n\t\tif ( groups.length > 0 ) {\r\n\r\n\t\t\tdata.data.groups = JSON.parse( JSON.stringify( groups ) );\r\n\r\n\t\t}\r\n\r\n\t\tconst boundingSphere = this.boundingSphere;\r\n\r\n\t\tif ( boundingSphere !== null ) {\r\n\r\n\t\t\tdata.data.boundingSphere = {\r\n\t\t\t\tcenter: boundingSphere.center.toArray(),\r\n\t\t\t\tradius: boundingSphere.radius\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t\treturn data;\r\n\r\n\t}\r\n\r\n\tclone() {\r\n\r\n\t\t return new this.constructor().copy( this );\r\n\r\n\t}\r\n\r\n\tcopy( source ) {\r\n\r\n\t\t// reset\r\n\r\n\t\tthis.index = null;\r\n\t\tthis.attributes = {};\r\n\t\tthis.morphAttributes = {};\r\n\t\tthis.groups = [];\r\n\t\tthis.boundingBox = null;\r\n\t\tthis.boundingSphere = null;\r\n\r\n\t\t// used for storing cloned, shared data\r\n\r\n\t\tconst data = {};\r\n\r\n\t\t// name\r\n\r\n\t\tthis.name = source.name;\r\n\r\n\t\t// index\r\n\r\n\t\tconst index = source.index;\r\n\r\n\t\tif ( index !== null ) {\r\n\r\n\t\t\tthis.setIndex( index.clone( data ) );\r\n\r\n\t\t}\r\n\r\n\t\t// attributes\r\n\r\n\t\tconst attributes = source.attributes;\r\n\r\n\t\tfor ( const name in attributes ) {\r\n\r\n\t\t\tconst attribute = attributes[ name ];\r\n\t\t\tthis.setAttribute( name, attribute.clone( data ) );\r\n\r\n\t\t}\r\n\r\n\t\t// morph attributes\r\n\r\n\t\tconst morphAttributes = source.morphAttributes;\r\n\r\n\t\tfor ( const name in morphAttributes ) {\r\n\r\n\t\t\tconst array = [];\r\n\t\t\tconst morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes\r\n\r\n\t\t\tfor ( let i = 0, l = morphAttribute.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tarray.push( morphAttribute[ i ].clone( data ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.morphAttributes[ name ] = array;\r\n\r\n\t\t}\r\n\r\n\t\tthis.morphTargetsRelative = source.morphTargetsRelative;\r\n\r\n\t\t// groups\r\n\r\n\t\tconst groups = source.groups;\r\n\r\n\t\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\r\n\r\n\t\t\tconst group = groups[ i ];\r\n\t\t\tthis.addGroup( group.start, group.count, group.materialIndex );\r\n\r\n\t\t}\r\n\r\n\t\t// bounding box\r\n\r\n\t\tconst boundingBox = source.boundingBox;\r\n\r\n\t\tif ( boundingBox !== null ) {\r\n\r\n\t\t\tthis.boundingBox = boundingBox.clone();\r\n\r\n\t\t}\r\n\r\n\t\t// bounding sphere\r\n\r\n\t\tconst boundingSphere = source.boundingSphere;\r\n\r\n\t\tif ( boundingSphere !== null ) {\r\n\r\n\t\t\tthis.boundingSphere = boundingSphere.clone();\r\n\r\n\t\t}\r\n\r\n\t\t// draw range\r\n\r\n\t\tthis.drawRange.start = source.drawRange.start;\r\n\t\tthis.drawRange.count = source.drawRange.count;\r\n\r\n\t\t// user data\r\n\r\n\t\tthis.userData = source.userData;\r\n\r\n\t\t// geometry generator parameters\r\n\r\n\t\tif ( source.parameters !== undefined ) this.parameters = Object.assign( {}, source.parameters );\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tdispose() {\r\n\r\n\t\tthis.dispatchEvent( { type: 'dispose' } );\r\n\r\n\t}\r\n\r\n}\r\n\r\nBufferGeometry.prototype.isBufferGeometry = true;\r\n\r\nexport { BufferGeometry };\r\n"]},"metadata":{},"sourceType":"module"}