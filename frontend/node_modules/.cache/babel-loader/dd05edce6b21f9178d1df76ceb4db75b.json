{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\n// Characters [].:/ are reserved for track binding syntax.\nconst _RESERVED_CHARS_RE = '\\\\[\\\\]\\\\.:\\\\/';\n\nconst _reservedRe = new RegExp('[' + _RESERVED_CHARS_RE + ']', 'g'); // Attempts to allow node names from any language. ES5's `\\w` regexp matches\n// only latin characters, and the unicode \\p{L} is not yet supported. So\n// instead, we exclude reserved characters and match everything else.\n\n\nconst _wordChar = '[^' + _RESERVED_CHARS_RE + ']';\n\nconst _wordCharOrDot = '[^' + _RESERVED_CHARS_RE.replace('\\\\.', '') + ']'; // Parent directories, delimited by '/' or ':'. Currently unused, but must\n// be matched to parse the rest of the track name.\n\n\nconst _directoryRe = /((?:WC+[\\/:])*)/.source.replace('WC', _wordChar); // Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.\n\n\nconst _nodeRe = /(WCOD+)?/.source.replace('WCOD', _wordCharOrDot); // Object on target node, and accessor. May not contain reserved\n// characters. Accessor may contain any character except closing bracket.\n\n\nconst _objectRe = /(?:\\.(WC+)(?:\\[(.+)\\])?)?/.source.replace('WC', _wordChar); // Property and accessor. May not contain reserved characters. Accessor may\n// contain any non-bracket characters.\n\n\nconst _propertyRe = /\\.(WC+)(?:\\[(.+)\\])?/.source.replace('WC', _wordChar);\n\nconst _trackRe = new RegExp('' + '^' + _directoryRe + _nodeRe + _objectRe + _propertyRe + '$');\n\nconst _supportedObjectNames = ['material', 'materials', 'bones'];\n\nclass Composite {\n  constructor(targetGroup, path, optionalParsedPath) {\n    const parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);\n    this._targetGroup = targetGroup;\n    this._bindings = targetGroup.subscribe_(path, parsedPath);\n  }\n\n  getValue(array, offset) {\n    this.bind(); // bind all binding\n\n    const firstValidIndex = this._targetGroup.nCachedObjects_,\n          binding = this._bindings[firstValidIndex]; // and only call .getValue on the first\n\n    if (binding !== undefined) binding.getValue(array, offset);\n  }\n\n  setValue(array, offset) {\n    const bindings = this._bindings;\n\n    for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {\n      bindings[i].setValue(array, offset);\n    }\n  }\n\n  bind() {\n    const bindings = this._bindings;\n\n    for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {\n      bindings[i].bind();\n    }\n  }\n\n  unbind() {\n    const bindings = this._bindings;\n\n    for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {\n      bindings[i].unbind();\n    }\n  }\n\n} // Note: This class uses a State pattern on a per-method basis:\n// 'bind' sets 'this.getValue' / 'setValue' and shadows the\n// prototype version of these methods with one that represents\n// the bound state. When the property is not found, the methods\n// become no-ops.\n\n\nclass PropertyBinding {\n  constructor(rootNode, path, parsedPath) {\n    this.path = path;\n    this.parsedPath = parsedPath || PropertyBinding.parseTrackName(path);\n    this.node = PropertyBinding.findNode(rootNode, this.parsedPath.nodeName) || rootNode;\n    this.rootNode = rootNode; // initial state of these methods that calls 'bind'\n\n    this.getValue = this._getValue_unbound;\n    this.setValue = this._setValue_unbound;\n  }\n\n  static create(root, path, parsedPath) {\n    if (!(root && root.isAnimationObjectGroup)) {\n      return new PropertyBinding(root, path, parsedPath);\n    } else {\n      return new PropertyBinding.Composite(root, path, parsedPath);\n    }\n  }\n  /**\r\n   * Replaces spaces with underscores and removes unsupported characters from\r\n   * node names, to ensure compatibility with parseTrackName().\r\n   *\r\n   * @param {string} name Node name to be sanitized.\r\n   * @return {string}\r\n   */\n\n\n  static sanitizeNodeName(name) {\n    return name.replace(/\\s/g, '_').replace(_reservedRe, '');\n  }\n\n  static parseTrackName(trackName) {\n    const matches = _trackRe.exec(trackName);\n\n    if (matches === null) {\n      throw new Error('PropertyBinding: Cannot parse trackName: ' + trackName);\n    }\n\n    const results = {\n      // directoryName: matches[ 1 ], // (tschw) currently unused\n      nodeName: matches[2],\n      objectName: matches[3],\n      objectIndex: matches[4],\n      propertyName: matches[5],\n      // required\n      propertyIndex: matches[6]\n    };\n    const lastDot = results.nodeName && results.nodeName.lastIndexOf('.');\n\n    if (lastDot !== undefined && lastDot !== -1) {\n      const objectName = results.nodeName.substring(lastDot + 1); // Object names must be checked against an allowlist. Otherwise, there\n      // is no way to parse 'foo.bar.baz': 'baz' must be a property, but\n      // 'bar' could be the objectName, or part of a nodeName (which can\n      // include '.' characters).\n\n      if (_supportedObjectNames.indexOf(objectName) !== -1) {\n        results.nodeName = results.nodeName.substring(0, lastDot);\n        results.objectName = objectName;\n      }\n    }\n\n    if (results.propertyName === null || results.propertyName.length === 0) {\n      throw new Error('PropertyBinding: can not parse propertyName from trackName: ' + trackName);\n    }\n\n    return results;\n  }\n\n  static findNode(root, nodeName) {\n    if (nodeName === undefined || nodeName === '' || nodeName === '.' || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) {\n      return root;\n    } // search into skeleton bones.\n\n\n    if (root.skeleton) {\n      const bone = root.skeleton.getBoneByName(nodeName);\n\n      if (bone !== undefined) {\n        return bone;\n      }\n    } // search into node subtree.\n\n\n    if (root.children) {\n      const searchNodeSubtree = function (children) {\n        for (let i = 0; i < children.length; i++) {\n          const childNode = children[i];\n\n          if (childNode.name === nodeName || childNode.uuid === nodeName) {\n            return childNode;\n          }\n\n          const result = searchNodeSubtree(childNode.children);\n          if (result) return result;\n        }\n\n        return null;\n      };\n\n      const subTreeNode = searchNodeSubtree(root.children);\n\n      if (subTreeNode) {\n        return subTreeNode;\n      }\n    }\n\n    return null;\n  } // these are used to \"bind\" a nonexistent property\n\n\n  _getValue_unavailable() {}\n\n  _setValue_unavailable() {} // Getters\n\n\n  _getValue_direct(buffer, offset) {\n    buffer[offset] = this.targetObject[this.propertyName];\n  }\n\n  _getValue_array(buffer, offset) {\n    const source = this.resolvedProperty;\n\n    for (let i = 0, n = source.length; i !== n; ++i) {\n      buffer[offset++] = source[i];\n    }\n  }\n\n  _getValue_arrayElement(buffer, offset) {\n    buffer[offset] = this.resolvedProperty[this.propertyIndex];\n  }\n\n  _getValue_toArray(buffer, offset) {\n    this.resolvedProperty.toArray(buffer, offset);\n  } // Direct\n\n\n  _setValue_direct(buffer, offset) {\n    this.targetObject[this.propertyName] = buffer[offset];\n  }\n\n  _setValue_direct_setNeedsUpdate(buffer, offset) {\n    this.targetObject[this.propertyName] = buffer[offset];\n    this.targetObject.needsUpdate = true;\n  }\n\n  _setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset) {\n    this.targetObject[this.propertyName] = buffer[offset];\n    this.targetObject.matrixWorldNeedsUpdate = true;\n  } // EntireArray\n\n\n  _setValue_array(buffer, offset) {\n    const dest = this.resolvedProperty;\n\n    for (let i = 0, n = dest.length; i !== n; ++i) {\n      dest[i] = buffer[offset++];\n    }\n  }\n\n  _setValue_array_setNeedsUpdate(buffer, offset) {\n    const dest = this.resolvedProperty;\n\n    for (let i = 0, n = dest.length; i !== n; ++i) {\n      dest[i] = buffer[offset++];\n    }\n\n    this.targetObject.needsUpdate = true;\n  }\n\n  _setValue_array_setMatrixWorldNeedsUpdate(buffer, offset) {\n    const dest = this.resolvedProperty;\n\n    for (let i = 0, n = dest.length; i !== n; ++i) {\n      dest[i] = buffer[offset++];\n    }\n\n    this.targetObject.matrixWorldNeedsUpdate = true;\n  } // ArrayElement\n\n\n  _setValue_arrayElement(buffer, offset) {\n    this.resolvedProperty[this.propertyIndex] = buffer[offset];\n  }\n\n  _setValue_arrayElement_setNeedsUpdate(buffer, offset) {\n    this.resolvedProperty[this.propertyIndex] = buffer[offset];\n    this.targetObject.needsUpdate = true;\n  }\n\n  _setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset) {\n    this.resolvedProperty[this.propertyIndex] = buffer[offset];\n    this.targetObject.matrixWorldNeedsUpdate = true;\n  } // HasToFromArray\n\n\n  _setValue_fromArray(buffer, offset) {\n    this.resolvedProperty.fromArray(buffer, offset);\n  }\n\n  _setValue_fromArray_setNeedsUpdate(buffer, offset) {\n    this.resolvedProperty.fromArray(buffer, offset);\n    this.targetObject.needsUpdate = true;\n  }\n\n  _setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset) {\n    this.resolvedProperty.fromArray(buffer, offset);\n    this.targetObject.matrixWorldNeedsUpdate = true;\n  }\n\n  _getValue_unbound(targetArray, offset) {\n    this.bind();\n    this.getValue(targetArray, offset);\n  }\n\n  _setValue_unbound(sourceArray, offset) {\n    this.bind();\n    this.setValue(sourceArray, offset);\n  } // create getter / setter pair for a property in the scene graph\n\n\n  bind() {\n    let targetObject = this.node;\n    const parsedPath = this.parsedPath;\n    const objectName = parsedPath.objectName;\n    const propertyName = parsedPath.propertyName;\n    let propertyIndex = parsedPath.propertyIndex;\n\n    if (!targetObject) {\n      targetObject = PropertyBinding.findNode(this.rootNode, parsedPath.nodeName) || this.rootNode;\n      this.node = targetObject;\n    } // set fail state so we can just 'return' on error\n\n\n    this.getValue = this._getValue_unavailable;\n    this.setValue = this._setValue_unavailable; // ensure there is a value node\n\n    if (!targetObject) {\n      console.error('THREE.PropertyBinding: Trying to update node for track: ' + this.path + ' but it wasn\\'t found.');\n      return;\n    }\n\n    if (objectName) {\n      let objectIndex = parsedPath.objectIndex; // special cases were we need to reach deeper into the hierarchy to get the face materials....\n\n      switch (objectName) {\n        case 'materials':\n          if (!targetObject.material) {\n            console.error('THREE.PropertyBinding: Can not bind to material as node does not have a material.', this);\n            return;\n          }\n\n          if (!targetObject.material.materials) {\n            console.error('THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this);\n            return;\n          }\n\n          targetObject = targetObject.material.materials;\n          break;\n\n        case 'bones':\n          if (!targetObject.skeleton) {\n            console.error('THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this);\n            return;\n          } // potential future optimization: skip this if propertyIndex is already an integer\n          // and convert the integer string to a true integer.\n\n\n          targetObject = targetObject.skeleton.bones; // support resolving morphTarget names into indices.\n\n          for (let i = 0; i < targetObject.length; i++) {\n            if (targetObject[i].name === objectIndex) {\n              objectIndex = i;\n              break;\n            }\n          }\n\n          break;\n\n        default:\n          if (targetObject[objectName] === undefined) {\n            console.error('THREE.PropertyBinding: Can not bind to objectName of node undefined.', this);\n            return;\n          }\n\n          targetObject = targetObject[objectName];\n      }\n\n      if (objectIndex !== undefined) {\n        if (targetObject[objectIndex] === undefined) {\n          console.error('THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject);\n          return;\n        }\n\n        targetObject = targetObject[objectIndex];\n      }\n    } // resolve property\n\n\n    const nodeProperty = targetObject[propertyName];\n\n    if (nodeProperty === undefined) {\n      const nodeName = parsedPath.nodeName;\n      console.error('THREE.PropertyBinding: Trying to update property for track: ' + nodeName + '.' + propertyName + ' but it wasn\\'t found.', targetObject);\n      return;\n    } // determine versioning scheme\n\n\n    let versioning = this.Versioning.None;\n    this.targetObject = targetObject;\n\n    if (targetObject.needsUpdate !== undefined) {\n      // material\n      versioning = this.Versioning.NeedsUpdate;\n    } else if (targetObject.matrixWorldNeedsUpdate !== undefined) {\n      // node transform\n      versioning = this.Versioning.MatrixWorldNeedsUpdate;\n    } // determine how the property gets bound\n\n\n    let bindingType = this.BindingType.Direct;\n\n    if (propertyIndex !== undefined) {\n      // access a sub element of the property array (only primitives are supported right now)\n      if (propertyName === 'morphTargetInfluences') {\n        // potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.\n        // support resolving morphTarget names into indices.\n        if (!targetObject.geometry) {\n          console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this);\n          return;\n        }\n\n        if (targetObject.geometry.isBufferGeometry) {\n          if (!targetObject.geometry.morphAttributes) {\n            console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this);\n            return;\n          }\n\n          if (targetObject.morphTargetDictionary[propertyIndex] !== undefined) {\n            propertyIndex = targetObject.morphTargetDictionary[propertyIndex];\n          }\n        } else {\n          console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.', this);\n          return;\n        }\n      }\n\n      bindingType = this.BindingType.ArrayElement;\n      this.resolvedProperty = nodeProperty;\n      this.propertyIndex = propertyIndex;\n    } else if (nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined) {\n      // must use copy for Object3D.Euler/Quaternion\n      bindingType = this.BindingType.HasFromToArray;\n      this.resolvedProperty = nodeProperty;\n    } else if (Array.isArray(nodeProperty)) {\n      bindingType = this.BindingType.EntireArray;\n      this.resolvedProperty = nodeProperty;\n    } else {\n      this.propertyName = propertyName;\n    } // select getter / setter\n\n\n    this.getValue = this.GetterByBindingType[bindingType];\n    this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];\n  }\n\n  unbind() {\n    this.node = null; // back to the prototype version of getValue / setValue\n    // note: avoiding to mutate the shape of 'this' via 'delete'\n\n    this.getValue = this._getValue_unbound;\n    this.setValue = this._setValue_unbound;\n  }\n\n}\n\nPropertyBinding.Composite = Composite;\nPropertyBinding.prototype.BindingType = {\n  Direct: 0,\n  EntireArray: 1,\n  ArrayElement: 2,\n  HasFromToArray: 3\n};\nPropertyBinding.prototype.Versioning = {\n  None: 0,\n  NeedsUpdate: 1,\n  MatrixWorldNeedsUpdate: 2\n};\nPropertyBinding.prototype.GetterByBindingType = [PropertyBinding.prototype._getValue_direct, PropertyBinding.prototype._getValue_array, PropertyBinding.prototype._getValue_arrayElement, PropertyBinding.prototype._getValue_toArray];\nPropertyBinding.prototype.SetterByBindingTypeAndVersioning = [[// Direct\nPropertyBinding.prototype._setValue_direct, PropertyBinding.prototype._setValue_direct_setNeedsUpdate, PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [// EntireArray\nPropertyBinding.prototype._setValue_array, PropertyBinding.prototype._setValue_array_setNeedsUpdate, PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate], [// ArrayElement\nPropertyBinding.prototype._setValue_arrayElement, PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate, PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [// HasToFromArray\nPropertyBinding.prototype._setValue_fromArray, PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate, PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];\nexport { PropertyBinding };","map":{"version":3,"sources":["C:/Users/dell/Desktop/projektlogin/vue-3-authentication-jwt/src/games/three/src/animation/PropertyBinding.js"],"names":["_RESERVED_CHARS_RE","_reservedRe","RegExp","_wordChar","_wordCharOrDot","replace","_directoryRe","source","_nodeRe","_objectRe","_propertyRe","_trackRe","_supportedObjectNames","Composite","constructor","targetGroup","path","optionalParsedPath","parsedPath","PropertyBinding","parseTrackName","_targetGroup","_bindings","subscribe_","getValue","array","offset","bind","firstValidIndex","nCachedObjects_","binding","undefined","setValue","bindings","i","n","length","unbind","rootNode","node","findNode","nodeName","_getValue_unbound","_setValue_unbound","create","root","isAnimationObjectGroup","sanitizeNodeName","name","trackName","matches","exec","Error","results","objectName","objectIndex","propertyName","propertyIndex","lastDot","lastIndexOf","substring","indexOf","uuid","skeleton","bone","getBoneByName","children","searchNodeSubtree","childNode","result","subTreeNode","_getValue_unavailable","_setValue_unavailable","_getValue_direct","buffer","targetObject","_getValue_array","resolvedProperty","_getValue_arrayElement","_getValue_toArray","toArray","_setValue_direct","_setValue_direct_setNeedsUpdate","needsUpdate","_setValue_direct_setMatrixWorldNeedsUpdate","matrixWorldNeedsUpdate","_setValue_array","dest","_setValue_array_setNeedsUpdate","_setValue_array_setMatrixWorldNeedsUpdate","_setValue_arrayElement","_setValue_arrayElement_setNeedsUpdate","_setValue_arrayElement_setMatrixWorldNeedsUpdate","_setValue_fromArray","fromArray","_setValue_fromArray_setNeedsUpdate","_setValue_fromArray_setMatrixWorldNeedsUpdate","targetArray","sourceArray","console","error","material","materials","bones","nodeProperty","versioning","Versioning","None","NeedsUpdate","MatrixWorldNeedsUpdate","bindingType","BindingType","Direct","geometry","isBufferGeometry","morphAttributes","morphTargetDictionary","ArrayElement","HasFromToArray","Array","isArray","EntireArray","GetterByBindingType","SetterByBindingTypeAndVersioning","prototype"],"mappings":"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","sourcesContent":["// Characters [].:/ are reserved for track binding syntax.\r\nconst _RESERVED_CHARS_RE = '\\\\[\\\\]\\\\.:\\\\/';\r\nconst _reservedRe = new RegExp( '[' + _RESERVED_CHARS_RE + ']', 'g' );\r\n\r\n// Attempts to allow node names from any language. ES5's `\\w` regexp matches\r\n// only latin characters, and the unicode \\p{L} is not yet supported. So\r\n// instead, we exclude reserved characters and match everything else.\r\nconst _wordChar = '[^' + _RESERVED_CHARS_RE + ']';\r\nconst _wordCharOrDot = '[^' + _RESERVED_CHARS_RE.replace( '\\\\.', '' ) + ']';\r\n\r\n// Parent directories, delimited by '/' or ':'. Currently unused, but must\r\n// be matched to parse the rest of the track name.\r\nconst _directoryRe = /((?:WC+[\\/:])*)/.source.replace( 'WC', _wordChar );\r\n\r\n// Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.\r\nconst _nodeRe = /(WCOD+)?/.source.replace( 'WCOD', _wordCharOrDot );\r\n\r\n// Object on target node, and accessor. May not contain reserved\r\n// characters. Accessor may contain any character except closing bracket.\r\nconst _objectRe = /(?:\\.(WC+)(?:\\[(.+)\\])?)?/.source.replace( 'WC', _wordChar );\r\n\r\n// Property and accessor. May not contain reserved characters. Accessor may\r\n// contain any non-bracket characters.\r\nconst _propertyRe = /\\.(WC+)(?:\\[(.+)\\])?/.source.replace( 'WC', _wordChar );\r\n\r\nconst _trackRe = new RegExp( ''\r\n\t+ '^'\r\n\t+ _directoryRe\r\n\t+ _nodeRe\r\n\t+ _objectRe\r\n\t+ _propertyRe\r\n\t+ '$'\r\n);\r\n\r\nconst _supportedObjectNames = [ 'material', 'materials', 'bones' ];\r\n\r\nclass Composite {\r\n\r\n\tconstructor( targetGroup, path, optionalParsedPath ) {\r\n\r\n\t\tconst parsedPath = optionalParsedPath || PropertyBinding.parseTrackName( path );\r\n\r\n\t\tthis._targetGroup = targetGroup;\r\n\t\tthis._bindings = targetGroup.subscribe_( path, parsedPath );\r\n\r\n\t}\r\n\r\n\tgetValue( array, offset ) {\r\n\r\n\t\tthis.bind(); // bind all binding\r\n\r\n\t\tconst firstValidIndex = this._targetGroup.nCachedObjects_,\r\n\t\t\tbinding = this._bindings[ firstValidIndex ];\r\n\r\n\t\t// and only call .getValue on the first\r\n\t\tif ( binding !== undefined ) binding.getValue( array, offset );\r\n\r\n\t}\r\n\r\n\tsetValue( array, offset ) {\r\n\r\n\t\tconst bindings = this._bindings;\r\n\r\n\t\tfor ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {\r\n\r\n\t\t\tbindings[ i ].setValue( array, offset );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tbind() {\r\n\r\n\t\tconst bindings = this._bindings;\r\n\r\n\t\tfor ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {\r\n\r\n\t\t\tbindings[ i ].bind();\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tunbind() {\r\n\r\n\t\tconst bindings = this._bindings;\r\n\r\n\t\tfor ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {\r\n\r\n\t\t\tbindings[ i ].unbind();\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\n// Note: This class uses a State pattern on a per-method basis:\r\n// 'bind' sets 'this.getValue' / 'setValue' and shadows the\r\n// prototype version of these methods with one that represents\r\n// the bound state. When the property is not found, the methods\r\n// become no-ops.\r\nclass PropertyBinding {\r\n\r\n\tconstructor( rootNode, path, parsedPath ) {\r\n\r\n\t\tthis.path = path;\r\n\t\tthis.parsedPath = parsedPath || PropertyBinding.parseTrackName( path );\r\n\r\n\t\tthis.node = PropertyBinding.findNode( rootNode, this.parsedPath.nodeName ) || rootNode;\r\n\r\n\t\tthis.rootNode = rootNode;\r\n\r\n\t\t// initial state of these methods that calls 'bind'\r\n\t\tthis.getValue = this._getValue_unbound;\r\n\t\tthis.setValue = this._setValue_unbound;\r\n\r\n\t}\r\n\r\n\r\n\tstatic create( root, path, parsedPath ) {\r\n\r\n\t\tif ( ! ( root && root.isAnimationObjectGroup ) ) {\r\n\r\n\t\t\treturn new PropertyBinding( root, path, parsedPath );\r\n\r\n\t\t} else {\r\n\r\n\t\t\treturn new PropertyBinding.Composite( root, path, parsedPath );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Replaces spaces with underscores and removes unsupported characters from\r\n\t * node names, to ensure compatibility with parseTrackName().\r\n\t *\r\n\t * @param {string} name Node name to be sanitized.\r\n\t * @return {string}\r\n\t */\r\n\tstatic sanitizeNodeName( name ) {\r\n\r\n\t\treturn name.replace( /\\s/g, '_' ).replace( _reservedRe, '' );\r\n\r\n\t}\r\n\r\n\tstatic parseTrackName( trackName ) {\r\n\r\n\t\tconst matches = _trackRe.exec( trackName );\r\n\r\n\t\tif ( matches === null ) {\r\n\r\n\t\t\tthrow new Error( 'PropertyBinding: Cannot parse trackName: ' + trackName );\r\n\r\n\t\t}\r\n\r\n\t\tconst results = {\r\n\t\t\t// directoryName: matches[ 1 ], // (tschw) currently unused\r\n\t\t\tnodeName: matches[ 2 ],\r\n\t\t\tobjectName: matches[ 3 ],\r\n\t\t\tobjectIndex: matches[ 4 ],\r\n\t\t\tpropertyName: matches[ 5 ], // required\r\n\t\t\tpropertyIndex: matches[ 6 ]\r\n\t\t};\r\n\r\n\t\tconst lastDot = results.nodeName && results.nodeName.lastIndexOf( '.' );\r\n\r\n\t\tif ( lastDot !== undefined && lastDot !== - 1 ) {\r\n\r\n\t\t\tconst objectName = results.nodeName.substring( lastDot + 1 );\r\n\r\n\t\t\t// Object names must be checked against an allowlist. Otherwise, there\r\n\t\t\t// is no way to parse 'foo.bar.baz': 'baz' must be a property, but\r\n\t\t\t// 'bar' could be the objectName, or part of a nodeName (which can\r\n\t\t\t// include '.' characters).\r\n\t\t\tif ( _supportedObjectNames.indexOf( objectName ) !== - 1 ) {\r\n\r\n\t\t\t\tresults.nodeName = results.nodeName.substring( 0, lastDot );\r\n\t\t\t\tresults.objectName = objectName;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( results.propertyName === null || results.propertyName.length === 0 ) {\r\n\r\n\t\t\tthrow new Error( 'PropertyBinding: can not parse propertyName from trackName: ' + trackName );\r\n\r\n\t\t}\r\n\r\n\t\treturn results;\r\n\r\n\t}\r\n\r\n\tstatic findNode( root, nodeName ) {\r\n\r\n\t\tif ( nodeName === undefined || nodeName === '' || nodeName === '.' || nodeName === - 1 || nodeName === root.name || nodeName === root.uuid ) {\r\n\r\n\t\t\treturn root;\r\n\r\n\t\t}\r\n\r\n\t\t// search into skeleton bones.\r\n\t\tif ( root.skeleton ) {\r\n\r\n\t\t\tconst bone = root.skeleton.getBoneByName( nodeName );\r\n\r\n\t\t\tif ( bone !== undefined ) {\r\n\r\n\t\t\t\treturn bone;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// search into node subtree.\r\n\t\tif ( root.children ) {\r\n\r\n\t\t\tconst searchNodeSubtree = function ( children ) {\r\n\r\n\t\t\t\tfor ( let i = 0; i < children.length; i ++ ) {\r\n\r\n\t\t\t\t\tconst childNode = children[ i ];\r\n\r\n\t\t\t\t\tif ( childNode.name === nodeName || childNode.uuid === nodeName ) {\r\n\r\n\t\t\t\t\t\treturn childNode;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tconst result = searchNodeSubtree( childNode.children );\r\n\r\n\t\t\t\t\tif ( result ) return result;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn null;\r\n\r\n\t\t\t};\r\n\r\n\t\t\tconst subTreeNode = searchNodeSubtree( root.children );\r\n\r\n\t\t\tif ( subTreeNode ) {\r\n\r\n\t\t\t\treturn subTreeNode;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn null;\r\n\r\n\t}\r\n\r\n\t// these are used to \"bind\" a nonexistent property\r\n\t_getValue_unavailable() {}\r\n\t_setValue_unavailable() {}\r\n\r\n\t// Getters\r\n\r\n\t_getValue_direct( buffer, offset ) {\r\n\r\n\t\tbuffer[ offset ] = this.targetObject[ this.propertyName ];\r\n\r\n\t}\r\n\r\n\t_getValue_array( buffer, offset ) {\r\n\r\n\t\tconst source = this.resolvedProperty;\r\n\r\n\t\tfor ( let i = 0, n = source.length; i !== n; ++ i ) {\r\n\r\n\t\t\tbuffer[ offset ++ ] = source[ i ];\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t_getValue_arrayElement( buffer, offset ) {\r\n\r\n\t\tbuffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];\r\n\r\n\t}\r\n\r\n\t_getValue_toArray( buffer, offset ) {\r\n\r\n\t\tthis.resolvedProperty.toArray( buffer, offset );\r\n\r\n\t}\r\n\r\n\t// Direct\r\n\r\n\t_setValue_direct( buffer, offset ) {\r\n\r\n\t\tthis.targetObject[ this.propertyName ] = buffer[ offset ];\r\n\r\n\t}\r\n\r\n\t_setValue_direct_setNeedsUpdate( buffer, offset ) {\r\n\r\n\t\tthis.targetObject[ this.propertyName ] = buffer[ offset ];\r\n\t\tthis.targetObject.needsUpdate = true;\r\n\r\n\t}\r\n\r\n\t_setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {\r\n\r\n\t\tthis.targetObject[ this.propertyName ] = buffer[ offset ];\r\n\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\r\n\r\n\t}\r\n\r\n\t// EntireArray\r\n\r\n\t_setValue_array( buffer, offset ) {\r\n\r\n\t\tconst dest = this.resolvedProperty;\r\n\r\n\t\tfor ( let i = 0, n = dest.length; i !== n; ++ i ) {\r\n\r\n\t\t\tdest[ i ] = buffer[ offset ++ ];\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t_setValue_array_setNeedsUpdate( buffer, offset ) {\r\n\r\n\t\tconst dest = this.resolvedProperty;\r\n\r\n\t\tfor ( let i = 0, n = dest.length; i !== n; ++ i ) {\r\n\r\n\t\t\tdest[ i ] = buffer[ offset ++ ];\r\n\r\n\t\t}\r\n\r\n\t\tthis.targetObject.needsUpdate = true;\r\n\r\n\t}\r\n\r\n\t_setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {\r\n\r\n\t\tconst dest = this.resolvedProperty;\r\n\r\n\t\tfor ( let i = 0, n = dest.length; i !== n; ++ i ) {\r\n\r\n\t\t\tdest[ i ] = buffer[ offset ++ ];\r\n\r\n\t\t}\r\n\r\n\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\r\n\r\n\t}\r\n\r\n\t// ArrayElement\r\n\r\n\t_setValue_arrayElement( buffer, offset ) {\r\n\r\n\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\r\n\r\n\t}\r\n\r\n\t_setValue_arrayElement_setNeedsUpdate( buffer, offset ) {\r\n\r\n\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\r\n\t\tthis.targetObject.needsUpdate = true;\r\n\r\n\t}\r\n\r\n\t_setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {\r\n\r\n\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\r\n\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\r\n\r\n\t}\r\n\r\n\t// HasToFromArray\r\n\r\n\t_setValue_fromArray( buffer, offset ) {\r\n\r\n\t\tthis.resolvedProperty.fromArray( buffer, offset );\r\n\r\n\t}\r\n\r\n\t_setValue_fromArray_setNeedsUpdate( buffer, offset ) {\r\n\r\n\t\tthis.resolvedProperty.fromArray( buffer, offset );\r\n\t\tthis.targetObject.needsUpdate = true;\r\n\r\n\t}\r\n\r\n\t_setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {\r\n\r\n\t\tthis.resolvedProperty.fromArray( buffer, offset );\r\n\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\r\n\r\n\t}\r\n\r\n\t_getValue_unbound( targetArray, offset ) {\r\n\r\n\t\tthis.bind();\r\n\t\tthis.getValue( targetArray, offset );\r\n\r\n\t}\r\n\r\n\t_setValue_unbound( sourceArray, offset ) {\r\n\r\n\t\tthis.bind();\r\n\t\tthis.setValue( sourceArray, offset );\r\n\r\n\t}\r\n\r\n\t// create getter / setter pair for a property in the scene graph\r\n\tbind() {\r\n\r\n\t\tlet targetObject = this.node;\r\n\t\tconst parsedPath = this.parsedPath;\r\n\r\n\t\tconst objectName = parsedPath.objectName;\r\n\t\tconst propertyName = parsedPath.propertyName;\r\n\t\tlet propertyIndex = parsedPath.propertyIndex;\r\n\r\n\t\tif ( ! targetObject ) {\r\n\r\n\t\t\ttargetObject = PropertyBinding.findNode( this.rootNode, parsedPath.nodeName ) || this.rootNode;\r\n\r\n\t\t\tthis.node = targetObject;\r\n\r\n\t\t}\r\n\r\n\t\t// set fail state so we can just 'return' on error\r\n\t\tthis.getValue = this._getValue_unavailable;\r\n\t\tthis.setValue = this._setValue_unavailable;\r\n\r\n\t\t// ensure there is a value node\r\n\t\tif ( ! targetObject ) {\r\n\r\n\t\t\tconsole.error( 'THREE.PropertyBinding: Trying to update node for track: ' + this.path + ' but it wasn\\'t found.' );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tif ( objectName ) {\r\n\r\n\t\t\tlet objectIndex = parsedPath.objectIndex;\r\n\r\n\t\t\t// special cases were we need to reach deeper into the hierarchy to get the face materials....\r\n\t\t\tswitch ( objectName ) {\r\n\r\n\t\t\t\tcase 'materials':\r\n\r\n\t\t\t\t\tif ( ! targetObject.material ) {\r\n\r\n\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to material as node does not have a material.', this );\r\n\t\t\t\t\t\treturn;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( ! targetObject.material.materials ) {\r\n\r\n\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this );\r\n\t\t\t\t\t\treturn;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\ttargetObject = targetObject.material.materials;\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'bones':\r\n\r\n\t\t\t\t\tif ( ! targetObject.skeleton ) {\r\n\r\n\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this );\r\n\t\t\t\t\t\treturn;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// potential future optimization: skip this if propertyIndex is already an integer\r\n\t\t\t\t\t// and convert the integer string to a true integer.\r\n\r\n\t\t\t\t\ttargetObject = targetObject.skeleton.bones;\r\n\r\n\t\t\t\t\t// support resolving morphTarget names into indices.\r\n\t\t\t\t\tfor ( let i = 0; i < targetObject.length; i ++ ) {\r\n\r\n\t\t\t\t\t\tif ( targetObject[ i ].name === objectIndex ) {\r\n\r\n\t\t\t\t\t\t\tobjectIndex = i;\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tdefault:\r\n\r\n\t\t\t\t\tif ( targetObject[ objectName ] === undefined ) {\r\n\r\n\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to objectName of node undefined.', this );\r\n\t\t\t\t\t\treturn;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\ttargetObject = targetObject[ objectName ];\r\n\r\n\t\t\t}\r\n\r\n\r\n\t\t\tif ( objectIndex !== undefined ) {\r\n\r\n\t\t\t\tif ( targetObject[ objectIndex ] === undefined ) {\r\n\r\n\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject );\r\n\t\t\t\t\treturn;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttargetObject = targetObject[ objectIndex ];\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// resolve property\r\n\t\tconst nodeProperty = targetObject[ propertyName ];\r\n\r\n\t\tif ( nodeProperty === undefined ) {\r\n\r\n\t\t\tconst nodeName = parsedPath.nodeName;\r\n\r\n\t\t\tconsole.error( 'THREE.PropertyBinding: Trying to update property for track: ' + nodeName +\r\n\t\t\t\t'.' + propertyName + ' but it wasn\\'t found.', targetObject );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\t// determine versioning scheme\r\n\t\tlet versioning = this.Versioning.None;\r\n\r\n\t\tthis.targetObject = targetObject;\r\n\r\n\t\tif ( targetObject.needsUpdate !== undefined ) { // material\r\n\r\n\t\t\tversioning = this.Versioning.NeedsUpdate;\r\n\r\n\t\t} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform\r\n\r\n\t\t\tversioning = this.Versioning.MatrixWorldNeedsUpdate;\r\n\r\n\t\t}\r\n\r\n\t\t// determine how the property gets bound\r\n\t\tlet bindingType = this.BindingType.Direct;\r\n\r\n\t\tif ( propertyIndex !== undefined ) {\r\n\r\n\t\t\t// access a sub element of the property array (only primitives are supported right now)\r\n\r\n\t\t\tif ( propertyName === 'morphTargetInfluences' ) {\r\n\r\n\t\t\t\t// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.\r\n\r\n\t\t\t\t// support resolving morphTarget names into indices.\r\n\t\t\t\tif ( ! targetObject.geometry ) {\r\n\r\n\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this );\r\n\t\t\t\t\treturn;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( targetObject.geometry.isBufferGeometry ) {\r\n\r\n\t\t\t\t\tif ( ! targetObject.geometry.morphAttributes ) {\r\n\r\n\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this );\r\n\t\t\t\t\t\treturn;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( targetObject.morphTargetDictionary[ propertyIndex ] !== undefined ) {\r\n\r\n\t\t\t\t\t\tpropertyIndex = targetObject.morphTargetDictionary[ propertyIndex ];\r\n\r\n\t\t\t\t\t}\r\n\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.', this );\r\n\t\t\t\t\treturn;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tbindingType = this.BindingType.ArrayElement;\r\n\r\n\t\t\tthis.resolvedProperty = nodeProperty;\r\n\t\t\tthis.propertyIndex = propertyIndex;\r\n\r\n\t\t} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {\r\n\r\n\t\t\t// must use copy for Object3D.Euler/Quaternion\r\n\r\n\t\t\tbindingType = this.BindingType.HasFromToArray;\r\n\r\n\t\t\tthis.resolvedProperty = nodeProperty;\r\n\r\n\t\t} else if ( Array.isArray( nodeProperty ) ) {\r\n\r\n\t\t\tbindingType = this.BindingType.EntireArray;\r\n\r\n\t\t\tthis.resolvedProperty = nodeProperty;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.propertyName = propertyName;\r\n\r\n\t\t}\r\n\r\n\t\t// select getter / setter\r\n\t\tthis.getValue = this.GetterByBindingType[ bindingType ];\r\n\t\tthis.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];\r\n\r\n\t}\r\n\r\n\tunbind() {\r\n\r\n\t\tthis.node = null;\r\n\r\n\t\t// back to the prototype version of getValue / setValue\r\n\t\t// note: avoiding to mutate the shape of 'this' via 'delete'\r\n\t\tthis.getValue = this._getValue_unbound;\r\n\t\tthis.setValue = this._setValue_unbound;\r\n\r\n\t}\r\n\r\n}\r\n\r\nPropertyBinding.Composite = Composite;\r\n\r\nPropertyBinding.prototype.BindingType = {\r\n\tDirect: 0,\r\n\tEntireArray: 1,\r\n\tArrayElement: 2,\r\n\tHasFromToArray: 3\r\n};\r\n\r\nPropertyBinding.prototype.Versioning = {\r\n\tNone: 0,\r\n\tNeedsUpdate: 1,\r\n\tMatrixWorldNeedsUpdate: 2\r\n};\r\n\r\nPropertyBinding.prototype.GetterByBindingType = [\r\n\r\n\tPropertyBinding.prototype._getValue_direct,\r\n\tPropertyBinding.prototype._getValue_array,\r\n\tPropertyBinding.prototype._getValue_arrayElement,\r\n\tPropertyBinding.prototype._getValue_toArray,\r\n\r\n];\r\n\r\nPropertyBinding.prototype.SetterByBindingTypeAndVersioning = [\r\n\r\n\t[\r\n\t\t// Direct\r\n\t\tPropertyBinding.prototype._setValue_direct,\r\n\t\tPropertyBinding.prototype._setValue_direct_setNeedsUpdate,\r\n\t\tPropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate,\r\n\r\n\t], [\r\n\r\n\t\t// EntireArray\r\n\r\n\t\tPropertyBinding.prototype._setValue_array,\r\n\t\tPropertyBinding.prototype._setValue_array_setNeedsUpdate,\r\n\t\tPropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate,\r\n\r\n\t], [\r\n\r\n\t\t// ArrayElement\r\n\t\tPropertyBinding.prototype._setValue_arrayElement,\r\n\t\tPropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate,\r\n\t\tPropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,\r\n\r\n\t], [\r\n\r\n\t\t// HasToFromArray\r\n\t\tPropertyBinding.prototype._setValue_fromArray,\r\n\t\tPropertyBinding.prototype._setValue_fromArray_setNeedsUpdate,\r\n\t\tPropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,\r\n\r\n\t]\r\n\r\n];\r\n\r\n\r\nexport { PropertyBinding };\r\n"]},"metadata":{},"sourceType":"module"}