{"ast":null,"code":"import { Ray } from '../math/Ray.js';\nimport { Layers } from './Layers.js';\n\nclass Raycaster {\n  constructor(origin, direction, near = 0, far = Infinity) {\n    this.ray = new Ray(origin, direction); // direction is assumed to be normalized (for accurate distance calculations)\n\n    this.near = near;\n    this.far = far;\n    this.camera = null;\n    this.layers = new Layers();\n    this.params = {\n      Mesh: {},\n      Line: {\n        threshold: 1\n      },\n      LOD: {},\n      Points: {\n        threshold: 1\n      },\n      Sprite: {}\n    };\n  }\n\n  set(origin, direction) {\n    // direction is assumed to be normalized (for accurate distance calculations)\n    this.ray.set(origin, direction);\n  }\n\n  setFromCamera(coords, camera) {\n    if (camera.isPerspectiveCamera) {\n      this.ray.origin.setFromMatrixPosition(camera.matrixWorld);\n      this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(this.ray.origin).normalize();\n      this.camera = camera;\n    } else if (camera.isOrthographicCamera) {\n      this.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera); // set origin in plane of camera\n\n      this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);\n      this.camera = camera;\n    } else {\n      console.error('THREE.Raycaster: Unsupported camera type: ' + camera.type);\n    }\n  }\n\n  intersectObject(object, recursive = true, intersects = []) {\n    intersectObject(object, this, intersects, recursive);\n    intersects.sort(ascSort);\n    return intersects;\n  }\n\n  intersectObjects(objects, recursive = true, intersects = []) {\n    for (let i = 0, l = objects.length; i < l; i++) {\n      intersectObject(objects[i], this, intersects, recursive);\n    }\n\n    intersects.sort(ascSort);\n    return intersects;\n  }\n\n}\n\nfunction ascSort(a, b) {\n  return a.distance - b.distance;\n}\n\nfunction intersectObject(object, raycaster, intersects, recursive) {\n  if (object.layers.test(raycaster.layers)) {\n    object.raycast(raycaster, intersects);\n  }\n\n  if (recursive === true) {\n    const children = object.children;\n\n    for (let i = 0, l = children.length; i < l; i++) {\n      intersectObject(children[i], raycaster, intersects, true);\n    }\n  }\n}\n\nexport { Raycaster };","map":{"version":3,"sources":["C:/Users/dell/Desktop/projektlogin/vue-3-authentication-jwt/src/games/three/src/core/Raycaster.js"],"names":["Ray","Layers","Raycaster","constructor","origin","direction","near","far","Infinity","ray","camera","layers","params","Mesh","Line","threshold","LOD","Points","Sprite","set","setFromCamera","coords","isPerspectiveCamera","setFromMatrixPosition","matrixWorld","x","y","unproject","sub","normalize","isOrthographicCamera","transformDirection","console","error","type","intersectObject","object","recursive","intersects","sort","ascSort","intersectObjects","objects","i","l","length","a","b","distance","raycaster","test","raycast","children"],"mappings":"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","sourcesContent":["import { Ray } from '../math/Ray.js';\r\nimport { Layers } from './Layers.js';\r\n\r\nclass Raycaster {\r\n\r\n\tconstructor( origin, direction, near = 0, far = Infinity ) {\r\n\r\n\t\tthis.ray = new Ray( origin, direction );\r\n\t\t// direction is assumed to be normalized (for accurate distance calculations)\r\n\r\n\t\tthis.near = near;\r\n\t\tthis.far = far;\r\n\t\tthis.camera = null;\r\n\t\tthis.layers = new Layers();\r\n\r\n\t\tthis.params = {\r\n\t\t\tMesh: {},\r\n\t\t\tLine: { threshold: 1 },\r\n\t\t\tLOD: {},\r\n\t\t\tPoints: { threshold: 1 },\r\n\t\t\tSprite: {}\r\n\t\t};\r\n\r\n\t}\r\n\r\n\tset( origin, direction ) {\r\n\r\n\t\t// direction is assumed to be normalized (for accurate distance calculations)\r\n\r\n\t\tthis.ray.set( origin, direction );\r\n\r\n\t}\r\n\r\n\tsetFromCamera( coords, camera ) {\r\n\r\n\t\tif ( camera.isPerspectiveCamera ) {\r\n\r\n\t\t\tthis.ray.origin.setFromMatrixPosition( camera.matrixWorld );\r\n\t\t\tthis.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();\r\n\t\t\tthis.camera = camera;\r\n\r\n\t\t} else if ( camera.isOrthographicCamera ) {\r\n\r\n\t\t\tthis.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera\r\n\t\t\tthis.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );\r\n\t\t\tthis.camera = camera;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tconsole.error( 'THREE.Raycaster: Unsupported camera type: ' + camera.type );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tintersectObject( object, recursive = true, intersects = [] ) {\r\n\r\n\t\tintersectObject( object, this, intersects, recursive );\r\n\r\n\t\tintersects.sort( ascSort );\r\n\r\n\t\treturn intersects;\r\n\r\n\t}\r\n\r\n\tintersectObjects( objects, recursive = true, intersects = [] ) {\r\n\r\n\t\tfor ( let i = 0, l = objects.length; i < l; i ++ ) {\r\n\r\n\t\t\tintersectObject( objects[ i ], this, intersects, recursive );\r\n\r\n\t\t}\r\n\r\n\t\tintersects.sort( ascSort );\r\n\r\n\t\treturn intersects;\r\n\r\n\t}\r\n\r\n}\r\n\r\nfunction ascSort( a, b ) {\r\n\r\n\treturn a.distance - b.distance;\r\n\r\n}\r\n\r\nfunction intersectObject( object, raycaster, intersects, recursive ) {\r\n\r\n\tif ( object.layers.test( raycaster.layers ) ) {\r\n\r\n\t\tobject.raycast( raycaster, intersects );\r\n\r\n\t}\r\n\r\n\tif ( recursive === true ) {\r\n\r\n\t\tconst children = object.children;\r\n\r\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\r\n\r\n\t\t\tintersectObject( children[ i ], raycaster, intersects, true );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport { Raycaster };\r\n"]},"metadata":{},"sourceType":"module"}