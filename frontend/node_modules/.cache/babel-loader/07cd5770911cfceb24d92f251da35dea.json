{"ast":null,"code":"import { Mesh } from './Mesh.js';\nimport { Matrix4 } from '../math/Matrix4.js';\nimport { Vector3 } from '../math/Vector3.js';\nimport { Vector4 } from '../math/Vector4.js';\n\nconst _basePosition = /*@__PURE__*/new Vector3();\n\nconst _skinIndex = /*@__PURE__*/new Vector4();\n\nconst _skinWeight = /*@__PURE__*/new Vector4();\n\nconst _vector = /*@__PURE__*/new Vector3();\n\nconst _matrix = /*@__PURE__*/new Matrix4();\n\nclass SkinnedMesh extends Mesh {\n  constructor(geometry, material) {\n    super(geometry, material);\n    this.type = 'SkinnedMesh';\n    this.bindMode = 'attached';\n    this.bindMatrix = new Matrix4();\n    this.bindMatrixInverse = new Matrix4();\n  }\n\n  copy(source) {\n    super.copy(source);\n    this.bindMode = source.bindMode;\n    this.bindMatrix.copy(source.bindMatrix);\n    this.bindMatrixInverse.copy(source.bindMatrixInverse);\n    this.skeleton = source.skeleton;\n    return this;\n  }\n\n  bind(skeleton, bindMatrix) {\n    this.skeleton = skeleton;\n\n    if (bindMatrix === undefined) {\n      this.updateMatrixWorld(true);\n      this.skeleton.calculateInverses();\n      bindMatrix = this.matrixWorld;\n    }\n\n    this.bindMatrix.copy(bindMatrix);\n    this.bindMatrixInverse.copy(bindMatrix).invert();\n  }\n\n  pose() {\n    this.skeleton.pose();\n  }\n\n  normalizeSkinWeights() {\n    const vector = new Vector4();\n    const skinWeight = this.geometry.attributes.skinWeight;\n\n    for (let i = 0, l = skinWeight.count; i < l; i++) {\n      vector.x = skinWeight.getX(i);\n      vector.y = skinWeight.getY(i);\n      vector.z = skinWeight.getZ(i);\n      vector.w = skinWeight.getW(i);\n      const scale = 1.0 / vector.manhattanLength();\n\n      if (scale !== Infinity) {\n        vector.multiplyScalar(scale);\n      } else {\n        vector.set(1, 0, 0, 0); // do something reasonable\n      }\n\n      skinWeight.setXYZW(i, vector.x, vector.y, vector.z, vector.w);\n    }\n  }\n\n  updateMatrixWorld(force) {\n    super.updateMatrixWorld(force);\n\n    if (this.bindMode === 'attached') {\n      this.bindMatrixInverse.copy(this.matrixWorld).invert();\n    } else if (this.bindMode === 'detached') {\n      this.bindMatrixInverse.copy(this.bindMatrix).invert();\n    } else {\n      console.warn('THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode);\n    }\n  }\n\n  boneTransform(index, target) {\n    const skeleton = this.skeleton;\n    const geometry = this.geometry;\n\n    _skinIndex.fromBufferAttribute(geometry.attributes.skinIndex, index);\n\n    _skinWeight.fromBufferAttribute(geometry.attributes.skinWeight, index);\n\n    _basePosition.copy(target).applyMatrix4(this.bindMatrix);\n\n    target.set(0, 0, 0);\n\n    for (let i = 0; i < 4; i++) {\n      const weight = _skinWeight.getComponent(i);\n\n      if (weight !== 0) {\n        const boneIndex = _skinIndex.getComponent(i);\n\n        _matrix.multiplyMatrices(skeleton.bones[boneIndex].matrixWorld, skeleton.boneInverses[boneIndex]);\n\n        target.addScaledVector(_vector.copy(_basePosition).applyMatrix4(_matrix), weight);\n      }\n    }\n\n    return target.applyMatrix4(this.bindMatrixInverse);\n  }\n\n}\n\nSkinnedMesh.prototype.isSkinnedMesh = true;\nexport { SkinnedMesh };","map":{"version":3,"sources":["C:/Users/dell/Desktop/projektlogin/vue-3-authentication-jwt/src/games/three/src/objects/SkinnedMesh.js"],"names":["Mesh","Matrix4","Vector3","Vector4","_basePosition","_skinIndex","_skinWeight","_vector","_matrix","SkinnedMesh","constructor","geometry","material","type","bindMode","bindMatrix","bindMatrixInverse","copy","source","skeleton","bind","undefined","updateMatrixWorld","calculateInverses","matrixWorld","invert","pose","normalizeSkinWeights","vector","skinWeight","attributes","i","l","count","x","getX","y","getY","z","getZ","w","getW","scale","manhattanLength","Infinity","multiplyScalar","set","setXYZW","force","console","warn","boneTransform","index","target","fromBufferAttribute","skinIndex","applyMatrix4","weight","getComponent","boneIndex","multiplyMatrices","bones","boneInverses","addScaledVector","prototype","isSkinnedMesh"],"mappings":"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","sourcesContent":["import { Mesh } from './Mesh.js';\r\nimport { Matrix4 } from '../math/Matrix4.js';\r\nimport { Vector3 } from '../math/Vector3.js';\r\nimport { Vector4 } from '../math/Vector4.js';\r\n\r\nconst _basePosition = /*@__PURE__*/ new Vector3();\r\n\r\nconst _skinIndex = /*@__PURE__*/ new Vector4();\r\nconst _skinWeight = /*@__PURE__*/ new Vector4();\r\n\r\nconst _vector = /*@__PURE__*/ new Vector3();\r\nconst _matrix = /*@__PURE__*/ new Matrix4();\r\n\r\nclass SkinnedMesh extends Mesh {\r\n\r\n\tconstructor( geometry, material ) {\r\n\r\n\t\tsuper( geometry, material );\r\n\r\n\t\tthis.type = 'SkinnedMesh';\r\n\r\n\t\tthis.bindMode = 'attached';\r\n\t\tthis.bindMatrix = new Matrix4();\r\n\t\tthis.bindMatrixInverse = new Matrix4();\r\n\r\n\t}\r\n\r\n\tcopy( source ) {\r\n\r\n\t\tsuper.copy( source );\r\n\r\n\t\tthis.bindMode = source.bindMode;\r\n\t\tthis.bindMatrix.copy( source.bindMatrix );\r\n\t\tthis.bindMatrixInverse.copy( source.bindMatrixInverse );\r\n\r\n\t\tthis.skeleton = source.skeleton;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tbind( skeleton, bindMatrix ) {\r\n\r\n\t\tthis.skeleton = skeleton;\r\n\r\n\t\tif ( bindMatrix === undefined ) {\r\n\r\n\t\t\tthis.updateMatrixWorld( true );\r\n\r\n\t\t\tthis.skeleton.calculateInverses();\r\n\r\n\t\t\tbindMatrix = this.matrixWorld;\r\n\r\n\t\t}\r\n\r\n\t\tthis.bindMatrix.copy( bindMatrix );\r\n\t\tthis.bindMatrixInverse.copy( bindMatrix ).invert();\r\n\r\n\t}\r\n\r\n\tpose() {\r\n\r\n\t\tthis.skeleton.pose();\r\n\r\n\t}\r\n\r\n\tnormalizeSkinWeights() {\r\n\r\n\t\tconst vector = new Vector4();\r\n\r\n\t\tconst skinWeight = this.geometry.attributes.skinWeight;\r\n\r\n\t\tfor ( let i = 0, l = skinWeight.count; i < l; i ++ ) {\r\n\r\n\t\t\tvector.x = skinWeight.getX( i );\r\n\t\t\tvector.y = skinWeight.getY( i );\r\n\t\t\tvector.z = skinWeight.getZ( i );\r\n\t\t\tvector.w = skinWeight.getW( i );\r\n\r\n\t\t\tconst scale = 1.0 / vector.manhattanLength();\r\n\r\n\t\t\tif ( scale !== Infinity ) {\r\n\r\n\t\t\t\tvector.multiplyScalar( scale );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tvector.set( 1, 0, 0, 0 ); // do something reasonable\r\n\r\n\t\t\t}\r\n\r\n\t\t\tskinWeight.setXYZW( i, vector.x, vector.y, vector.z, vector.w );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tupdateMatrixWorld( force ) {\r\n\r\n\t\tsuper.updateMatrixWorld( force );\r\n\r\n\t\tif ( this.bindMode === 'attached' ) {\r\n\r\n\t\t\tthis.bindMatrixInverse.copy( this.matrixWorld ).invert();\r\n\r\n\t\t} else if ( this.bindMode === 'detached' ) {\r\n\r\n\t\t\tthis.bindMatrixInverse.copy( this.bindMatrix ).invert();\r\n\r\n\t\t} else {\r\n\r\n\t\t\tconsole.warn( 'THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tboneTransform( index, target ) {\r\n\r\n\t\tconst skeleton = this.skeleton;\r\n\t\tconst geometry = this.geometry;\r\n\r\n\t\t_skinIndex.fromBufferAttribute( geometry.attributes.skinIndex, index );\r\n\t\t_skinWeight.fromBufferAttribute( geometry.attributes.skinWeight, index );\r\n\r\n\t\t_basePosition.copy( target ).applyMatrix4( this.bindMatrix );\r\n\r\n\t\ttarget.set( 0, 0, 0 );\r\n\r\n\t\tfor ( let i = 0; i < 4; i ++ ) {\r\n\r\n\t\t\tconst weight = _skinWeight.getComponent( i );\r\n\r\n\t\t\tif ( weight !== 0 ) {\r\n\r\n\t\t\t\tconst boneIndex = _skinIndex.getComponent( i );\r\n\r\n\t\t\t\t_matrix.multiplyMatrices( skeleton.bones[ boneIndex ].matrixWorld, skeleton.boneInverses[ boneIndex ] );\r\n\r\n\t\t\t\ttarget.addScaledVector( _vector.copy( _basePosition ).applyMatrix4( _matrix ), weight );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn target.applyMatrix4( this.bindMatrixInverse );\r\n\r\n\t}\r\n\r\n}\r\n\r\nSkinnedMesh.prototype.isSkinnedMesh = true;\r\n\r\nexport { SkinnedMesh };\r\n"]},"metadata":{},"sourceType":"module"}