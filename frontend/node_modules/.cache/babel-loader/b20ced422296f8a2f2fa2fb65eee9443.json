{"ast":null,"code":"import { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport { Vector3 } from '../math/Vector3.js';\n\nclass TorusKnotGeometry extends BufferGeometry {\n  constructor(radius = 1, tube = 0.4, tubularSegments = 64, radialSegments = 8, p = 2, q = 3) {\n    super();\n    this.type = 'TorusKnotGeometry';\n    this.parameters = {\n      radius: radius,\n      tube: tube,\n      tubularSegments: tubularSegments,\n      radialSegments: radialSegments,\n      p: p,\n      q: q\n    };\n    tubularSegments = Math.floor(tubularSegments);\n    radialSegments = Math.floor(radialSegments); // buffers\n\n    const indices = [];\n    const vertices = [];\n    const normals = [];\n    const uvs = []; // helper variables\n\n    const vertex = new Vector3();\n    const normal = new Vector3();\n    const P1 = new Vector3();\n    const P2 = new Vector3();\n    const B = new Vector3();\n    const T = new Vector3();\n    const N = new Vector3(); // generate vertices, normals and uvs\n\n    for (let i = 0; i <= tubularSegments; ++i) {\n      // the radian \"u\" is used to calculate the position on the torus curve of the current tubular segement\n      const u = i / tubularSegments * p * Math.PI * 2; // now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.\n      // these points are used to create a special \"coordinate space\", which is necessary to calculate the correct vertex positions\n\n      calculatePositionOnCurve(u, p, q, radius, P1);\n      calculatePositionOnCurve(u + 0.01, p, q, radius, P2); // calculate orthonormal basis\n\n      T.subVectors(P2, P1);\n      N.addVectors(P2, P1);\n      B.crossVectors(T, N);\n      N.crossVectors(B, T); // normalize B, N. T can be ignored, we don't use it\n\n      B.normalize();\n      N.normalize();\n\n      for (let j = 0; j <= radialSegments; ++j) {\n        // now calculate the vertices. they are nothing more than an extrusion of the torus curve.\n        // because we extrude a shape in the xy-plane, there is no need to calculate a z-value.\n        const v = j / radialSegments * Math.PI * 2;\n        const cx = -tube * Math.cos(v);\n        const cy = tube * Math.sin(v); // now calculate the final vertex position.\n        // first we orient the extrusion with our basis vectos, then we add it to the current position on the curve\n\n        vertex.x = P1.x + (cx * N.x + cy * B.x);\n        vertex.y = P1.y + (cx * N.y + cy * B.y);\n        vertex.z = P1.z + (cx * N.z + cy * B.z);\n        vertices.push(vertex.x, vertex.y, vertex.z); // normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)\n\n        normal.subVectors(vertex, P1).normalize();\n        normals.push(normal.x, normal.y, normal.z); // uv\n\n        uvs.push(i / tubularSegments);\n        uvs.push(j / radialSegments);\n      }\n    } // generate indices\n\n\n    for (let j = 1; j <= tubularSegments; j++) {\n      for (let i = 1; i <= radialSegments; i++) {\n        // indices\n        const a = (radialSegments + 1) * (j - 1) + (i - 1);\n        const b = (radialSegments + 1) * j + (i - 1);\n        const c = (radialSegments + 1) * j + i;\n        const d = (radialSegments + 1) * (j - 1) + i; // faces\n\n        indices.push(a, b, d);\n        indices.push(b, c, d);\n      }\n    } // build geometry\n\n\n    this.setIndex(indices);\n    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2)); // this function calculates the current position on the torus curve\n\n    function calculatePositionOnCurve(u, p, q, radius, position) {\n      const cu = Math.cos(u);\n      const su = Math.sin(u);\n      const quOverP = q / p * u;\n      const cs = Math.cos(quOverP);\n      position.x = radius * (2 + cs) * 0.5 * cu;\n      position.y = radius * (2 + cs) * su * 0.5;\n      position.z = radius * Math.sin(quOverP) * 0.5;\n    }\n  }\n\n  static fromJSON(data) {\n    return new TorusKnotGeometry(data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q);\n  }\n\n}\n\nexport { TorusKnotGeometry, TorusKnotGeometry as TorusKnotBufferGeometry };","map":{"version":3,"sources":["C:/Users/dell/Desktop/projektlogin/vue-3-authentication-jwt/src/games/three/src/geometries/TorusKnotGeometry.js"],"names":["BufferGeometry","Float32BufferAttribute","Vector3","TorusKnotGeometry","constructor","radius","tube","tubularSegments","radialSegments","p","q","type","parameters","Math","floor","indices","vertices","normals","uvs","vertex","normal","P1","P2","B","T","N","i","u","PI","calculatePositionOnCurve","subVectors","addVectors","crossVectors","normalize","j","v","cx","cos","cy","sin","x","y","z","push","a","b","c","d","setIndex","setAttribute","position","cu","su","quOverP","cs","fromJSON","data","TorusKnotBufferGeometry"],"mappings":"AAAA,SAASA,cAAT,QAA+B,2BAA/B;AACA,SAASC,sBAAT,QAAuC,4BAAvC;AACA,SAASC,OAAT,QAAwB,oBAAxB;;AAEA,MAAMC,iBAAN,SAAgCH,cAAhC,CAA+C;AAE9CI,EAAAA,WAAW,CAAEC,MAAM,GAAG,CAAX,EAAcC,IAAI,GAAG,GAArB,EAA0BC,eAAe,GAAG,EAA5C,EAAgDC,cAAc,GAAG,CAAjE,EAAoEC,CAAC,GAAG,CAAxE,EAA2EC,CAAC,GAAG,CAA/E,EAAmF;AAE7F;AACA,SAAKC,IAAL,GAAY,mBAAZ;AAEA,SAAKC,UAAL,GAAkB;AACjBP,MAAAA,MAAM,EAAEA,MADS;AAEjBC,MAAAA,IAAI,EAAEA,IAFW;AAGjBC,MAAAA,eAAe,EAAEA,eAHA;AAIjBC,MAAAA,cAAc,EAAEA,cAJC;AAKjBC,MAAAA,CAAC,EAAEA,CALc;AAMjBC,MAAAA,CAAC,EAAEA;AANc,KAAlB;AASAH,IAAAA,eAAe,GAAGM,IAAI,CAACC,KAAL,CAAYP,eAAZ,CAAlB;AACAC,IAAAA,cAAc,GAAGK,IAAI,CAACC,KAAL,CAAYN,cAAZ,CAAjB,CAf6F,CAiB7F;;AAEA,UAAMO,OAAO,GAAG,EAAhB;AACA,UAAMC,QAAQ,GAAG,EAAjB;AACA,UAAMC,OAAO,GAAG,EAAhB;AACA,UAAMC,GAAG,GAAG,EAAZ,CAtB6F,CAwB7F;;AAEA,UAAMC,MAAM,GAAG,IAAIjB,OAAJ,EAAf;AACA,UAAMkB,MAAM,GAAG,IAAIlB,OAAJ,EAAf;AAEA,UAAMmB,EAAE,GAAG,IAAInB,OAAJ,EAAX;AACA,UAAMoB,EAAE,GAAG,IAAIpB,OAAJ,EAAX;AAEA,UAAMqB,CAAC,GAAG,IAAIrB,OAAJ,EAAV;AACA,UAAMsB,CAAC,GAAG,IAAItB,OAAJ,EAAV;AACA,UAAMuB,CAAC,GAAG,IAAIvB,OAAJ,EAAV,CAlC6F,CAoC7F;;AAEA,SAAM,IAAIwB,CAAC,GAAG,CAAd,EAAiBA,CAAC,IAAInB,eAAtB,EAAuC,EAAGmB,CAA1C,EAA8C;AAE7C;AAEA,YAAMC,CAAC,GAAGD,CAAC,GAAGnB,eAAJ,GAAsBE,CAAtB,GAA0BI,IAAI,CAACe,EAA/B,GAAoC,CAA9C,CAJ6C,CAM7C;AACA;;AAEAC,MAAAA,wBAAwB,CAAEF,CAAF,EAAKlB,CAAL,EAAQC,CAAR,EAAWL,MAAX,EAAmBgB,EAAnB,CAAxB;AACAQ,MAAAA,wBAAwB,CAAEF,CAAC,GAAG,IAAN,EAAYlB,CAAZ,EAAeC,CAAf,EAAkBL,MAAlB,EAA0BiB,EAA1B,CAAxB,CAV6C,CAY7C;;AAEAE,MAAAA,CAAC,CAACM,UAAF,CAAcR,EAAd,EAAkBD,EAAlB;AACAI,MAAAA,CAAC,CAACM,UAAF,CAAcT,EAAd,EAAkBD,EAAlB;AACAE,MAAAA,CAAC,CAACS,YAAF,CAAgBR,CAAhB,EAAmBC,CAAnB;AACAA,MAAAA,CAAC,CAACO,YAAF,CAAgBT,CAAhB,EAAmBC,CAAnB,EAjB6C,CAmB7C;;AAEAD,MAAAA,CAAC,CAACU,SAAF;AACAR,MAAAA,CAAC,CAACQ,SAAF;;AAEA,WAAM,IAAIC,CAAC,GAAG,CAAd,EAAiBA,CAAC,IAAI1B,cAAtB,EAAsC,EAAG0B,CAAzC,EAA6C;AAE5C;AACA;AAEA,cAAMC,CAAC,GAAGD,CAAC,GAAG1B,cAAJ,GAAqBK,IAAI,CAACe,EAA1B,GAA+B,CAAzC;AACA,cAAMQ,EAAE,GAAG,CAAE9B,IAAF,GAASO,IAAI,CAACwB,GAAL,CAAUF,CAAV,CAApB;AACA,cAAMG,EAAE,GAAGhC,IAAI,GAAGO,IAAI,CAAC0B,GAAL,CAAUJ,CAAV,CAAlB,CAP4C,CAS5C;AACA;;AAEAhB,QAAAA,MAAM,CAACqB,CAAP,GAAWnB,EAAE,CAACmB,CAAH,IAASJ,EAAE,GAAGX,CAAC,CAACe,CAAP,GAAWF,EAAE,GAAGf,CAAC,CAACiB,CAA3B,CAAX;AACArB,QAAAA,MAAM,CAACsB,CAAP,GAAWpB,EAAE,CAACoB,CAAH,IAASL,EAAE,GAAGX,CAAC,CAACgB,CAAP,GAAWH,EAAE,GAAGf,CAAC,CAACkB,CAA3B,CAAX;AACAtB,QAAAA,MAAM,CAACuB,CAAP,GAAWrB,EAAE,CAACqB,CAAH,IAASN,EAAE,GAAGX,CAAC,CAACiB,CAAP,GAAWJ,EAAE,GAAGf,CAAC,CAACmB,CAA3B,CAAX;AAEA1B,QAAAA,QAAQ,CAAC2B,IAAT,CAAexB,MAAM,CAACqB,CAAtB,EAAyBrB,MAAM,CAACsB,CAAhC,EAAmCtB,MAAM,CAACuB,CAA1C,EAhB4C,CAkB5C;;AAEAtB,QAAAA,MAAM,CAACU,UAAP,CAAmBX,MAAnB,EAA2BE,EAA3B,EAAgCY,SAAhC;AAEAhB,QAAAA,OAAO,CAAC0B,IAAR,CAAcvB,MAAM,CAACoB,CAArB,EAAwBpB,MAAM,CAACqB,CAA/B,EAAkCrB,MAAM,CAACsB,CAAzC,EAtB4C,CAwB5C;;AAEAxB,QAAAA,GAAG,CAACyB,IAAJ,CAAUjB,CAAC,GAAGnB,eAAd;AACAW,QAAAA,GAAG,CAACyB,IAAJ,CAAUT,CAAC,GAAG1B,cAAd;AAEA;AAED,KA7F4F,CA+F7F;;;AAEA,SAAM,IAAI0B,CAAC,GAAG,CAAd,EAAiBA,CAAC,IAAI3B,eAAtB,EAAuC2B,CAAC,EAAxC,EAA8C;AAE7C,WAAM,IAAIR,CAAC,GAAG,CAAd,EAAiBA,CAAC,IAAIlB,cAAtB,EAAsCkB,CAAC,EAAvC,EAA6C;AAE5C;AAEA,cAAMkB,CAAC,GAAG,CAAEpC,cAAc,GAAG,CAAnB,KAA2B0B,CAAC,GAAG,CAA/B,KAAuCR,CAAC,GAAG,CAA3C,CAAV;AACA,cAAMmB,CAAC,GAAG,CAAErC,cAAc,GAAG,CAAnB,IAAyB0B,CAAzB,IAA+BR,CAAC,GAAG,CAAnC,CAAV;AACA,cAAMoB,CAAC,GAAG,CAAEtC,cAAc,GAAG,CAAnB,IAAyB0B,CAAzB,GAA6BR,CAAvC;AACA,cAAMqB,CAAC,GAAG,CAAEvC,cAAc,GAAG,CAAnB,KAA2B0B,CAAC,GAAG,CAA/B,IAAqCR,CAA/C,CAP4C,CAS5C;;AAEAX,QAAAA,OAAO,CAAC4B,IAAR,CAAcC,CAAd,EAAiBC,CAAjB,EAAoBE,CAApB;AACAhC,QAAAA,OAAO,CAAC4B,IAAR,CAAcE,CAAd,EAAiBC,CAAjB,EAAoBC,CAApB;AAEA;AAED,KAnH4F,CAqH7F;;;AAEA,SAAKC,QAAL,CAAejC,OAAf;AACA,SAAKkC,YAAL,CAAmB,UAAnB,EAA+B,IAAIhD,sBAAJ,CAA4Be,QAA5B,EAAsC,CAAtC,CAA/B;AACA,SAAKiC,YAAL,CAAmB,QAAnB,EAA6B,IAAIhD,sBAAJ,CAA4BgB,OAA5B,EAAqC,CAArC,CAA7B;AACA,SAAKgC,YAAL,CAAmB,IAAnB,EAAyB,IAAIhD,sBAAJ,CAA4BiB,GAA5B,EAAiC,CAAjC,CAAzB,EA1H6F,CA4H7F;;AAEA,aAASW,wBAAT,CAAmCF,CAAnC,EAAsClB,CAAtC,EAAyCC,CAAzC,EAA4CL,MAA5C,EAAoD6C,QAApD,EAA+D;AAE9D,YAAMC,EAAE,GAAGtC,IAAI,CAACwB,GAAL,CAAUV,CAAV,CAAX;AACA,YAAMyB,EAAE,GAAGvC,IAAI,CAAC0B,GAAL,CAAUZ,CAAV,CAAX;AACA,YAAM0B,OAAO,GAAG3C,CAAC,GAAGD,CAAJ,GAAQkB,CAAxB;AACA,YAAM2B,EAAE,GAAGzC,IAAI,CAACwB,GAAL,CAAUgB,OAAV,CAAX;AAEAH,MAAAA,QAAQ,CAACV,CAAT,GAAanC,MAAM,IAAK,IAAIiD,EAAT,CAAN,GAAsB,GAAtB,GAA4BH,EAAzC;AACAD,MAAAA,QAAQ,CAACT,CAAT,GAAapC,MAAM,IAAK,IAAIiD,EAAT,CAAN,GAAsBF,EAAtB,GAA2B,GAAxC;AACAF,MAAAA,QAAQ,CAACR,CAAT,GAAarC,MAAM,GAAGQ,IAAI,CAAC0B,GAAL,CAAUc,OAAV,CAAT,GAA+B,GAA5C;AAEA;AAED;;AAEc,SAARE,QAAQ,CAAEC,IAAF,EAAS;AAEvB,WAAO,IAAIrD,iBAAJ,CAAuBqD,IAAI,CAACnD,MAA5B,EAAoCmD,IAAI,CAAClD,IAAzC,EAA+CkD,IAAI,CAACjD,eAApD,EAAqEiD,IAAI,CAAChD,cAA1E,EAA0FgD,IAAI,CAAC/C,CAA/F,EAAkG+C,IAAI,CAAC9C,CAAvG,CAAP;AAEA;;AAnJ6C;;AAuJ/C,SAASP,iBAAT,EAA4BA,iBAAiB,IAAIsD,uBAAjD","sourcesContent":["import { BufferGeometry } from '../core/BufferGeometry.js';\r\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\r\nimport { Vector3 } from '../math/Vector3.js';\r\n\r\nclass TorusKnotGeometry extends BufferGeometry {\r\n\r\n\tconstructor( radius = 1, tube = 0.4, tubularSegments = 64, radialSegments = 8, p = 2, q = 3 ) {\r\n\r\n\t\tsuper();\r\n\t\tthis.type = 'TorusKnotGeometry';\r\n\r\n\t\tthis.parameters = {\r\n\t\t\tradius: radius,\r\n\t\t\ttube: tube,\r\n\t\t\ttubularSegments: tubularSegments,\r\n\t\t\tradialSegments: radialSegments,\r\n\t\t\tp: p,\r\n\t\t\tq: q\r\n\t\t};\r\n\r\n\t\ttubularSegments = Math.floor( tubularSegments );\r\n\t\tradialSegments = Math.floor( radialSegments );\r\n\r\n\t\t// buffers\r\n\r\n\t\tconst indices = [];\r\n\t\tconst vertices = [];\r\n\t\tconst normals = [];\r\n\t\tconst uvs = [];\r\n\r\n\t\t// helper variables\r\n\r\n\t\tconst vertex = new Vector3();\r\n\t\tconst normal = new Vector3();\r\n\r\n\t\tconst P1 = new Vector3();\r\n\t\tconst P2 = new Vector3();\r\n\r\n\t\tconst B = new Vector3();\r\n\t\tconst T = new Vector3();\r\n\t\tconst N = new Vector3();\r\n\r\n\t\t// generate vertices, normals and uvs\r\n\r\n\t\tfor ( let i = 0; i <= tubularSegments; ++ i ) {\r\n\r\n\t\t\t// the radian \"u\" is used to calculate the position on the torus curve of the current tubular segement\r\n\r\n\t\t\tconst u = i / tubularSegments * p * Math.PI * 2;\r\n\r\n\t\t\t// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.\r\n\t\t\t// these points are used to create a special \"coordinate space\", which is necessary to calculate the correct vertex positions\r\n\r\n\t\t\tcalculatePositionOnCurve( u, p, q, radius, P1 );\r\n\t\t\tcalculatePositionOnCurve( u + 0.01, p, q, radius, P2 );\r\n\r\n\t\t\t// calculate orthonormal basis\r\n\r\n\t\t\tT.subVectors( P2, P1 );\r\n\t\t\tN.addVectors( P2, P1 );\r\n\t\t\tB.crossVectors( T, N );\r\n\t\t\tN.crossVectors( B, T );\r\n\r\n\t\t\t// normalize B, N. T can be ignored, we don't use it\r\n\r\n\t\t\tB.normalize();\r\n\t\t\tN.normalize();\r\n\r\n\t\t\tfor ( let j = 0; j <= radialSegments; ++ j ) {\r\n\r\n\t\t\t\t// now calculate the vertices. they are nothing more than an extrusion of the torus curve.\r\n\t\t\t\t// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.\r\n\r\n\t\t\t\tconst v = j / radialSegments * Math.PI * 2;\r\n\t\t\t\tconst cx = - tube * Math.cos( v );\r\n\t\t\t\tconst cy = tube * Math.sin( v );\r\n\r\n\t\t\t\t// now calculate the final vertex position.\r\n\t\t\t\t// first we orient the extrusion with our basis vectos, then we add it to the current position on the curve\r\n\r\n\t\t\t\tvertex.x = P1.x + ( cx * N.x + cy * B.x );\r\n\t\t\t\tvertex.y = P1.y + ( cx * N.y + cy * B.y );\r\n\t\t\t\tvertex.z = P1.z + ( cx * N.z + cy * B.z );\r\n\r\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\r\n\r\n\t\t\t\t// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)\r\n\r\n\t\t\t\tnormal.subVectors( vertex, P1 ).normalize();\r\n\r\n\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\r\n\r\n\t\t\t\t// uv\r\n\r\n\t\t\t\tuvs.push( i / tubularSegments );\r\n\t\t\t\tuvs.push( j / radialSegments );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// generate indices\r\n\r\n\t\tfor ( let j = 1; j <= tubularSegments; j ++ ) {\r\n\r\n\t\t\tfor ( let i = 1; i <= radialSegments; i ++ ) {\r\n\r\n\t\t\t\t// indices\r\n\r\n\t\t\t\tconst a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );\r\n\t\t\t\tconst b = ( radialSegments + 1 ) * j + ( i - 1 );\r\n\t\t\t\tconst c = ( radialSegments + 1 ) * j + i;\r\n\t\t\t\tconst d = ( radialSegments + 1 ) * ( j - 1 ) + i;\r\n\r\n\t\t\t\t// faces\r\n\r\n\t\t\t\tindices.push( a, b, d );\r\n\t\t\t\tindices.push( b, c, d );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// build geometry\r\n\r\n\t\tthis.setIndex( indices );\r\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\r\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\r\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\r\n\r\n\t\t// this function calculates the current position on the torus curve\r\n\r\n\t\tfunction calculatePositionOnCurve( u, p, q, radius, position ) {\r\n\r\n\t\t\tconst cu = Math.cos( u );\r\n\t\t\tconst su = Math.sin( u );\r\n\t\t\tconst quOverP = q / p * u;\r\n\t\t\tconst cs = Math.cos( quOverP );\r\n\r\n\t\t\tposition.x = radius * ( 2 + cs ) * 0.5 * cu;\r\n\t\t\tposition.y = radius * ( 2 + cs ) * su * 0.5;\r\n\t\t\tposition.z = radius * Math.sin( quOverP ) * 0.5;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tstatic fromJSON( data ) {\r\n\r\n\t\treturn new TorusKnotGeometry( data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q );\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport { TorusKnotGeometry, TorusKnotGeometry as TorusKnotBufferGeometry };\r\n"]},"metadata":{},"sourceType":"module"}