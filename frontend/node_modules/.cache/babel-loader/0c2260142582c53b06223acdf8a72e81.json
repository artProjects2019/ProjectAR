{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport { UVMapping, CubeReflectionMapping, CubeRefractionMapping, EquirectangularReflectionMapping, EquirectangularRefractionMapping, CubeUVReflectionMapping, CubeUVRefractionMapping, RepeatWrapping, ClampToEdgeWrapping, MirroredRepeatWrapping, NearestFilter, NearestMipmapNearestFilter, NearestMipmapLinearFilter, LinearFilter, LinearMipmapNearestFilter, LinearMipmapLinearFilter } from '../constants.js';\nimport { InstancedBufferAttribute } from '../core/InstancedBufferAttribute.js';\nimport { Color } from '../math/Color.js';\nimport { Object3D } from '../core/Object3D.js';\nimport { Group } from '../objects/Group.js';\nimport { InstancedMesh } from '../objects/InstancedMesh.js';\nimport { Sprite } from '../objects/Sprite.js';\nimport { Points } from '../objects/Points.js';\nimport { Line } from '../objects/Line.js';\nimport { LineLoop } from '../objects/LineLoop.js';\nimport { LineSegments } from '../objects/LineSegments.js';\nimport { LOD } from '../objects/LOD.js';\nimport { Mesh } from '../objects/Mesh.js';\nimport { SkinnedMesh } from '../objects/SkinnedMesh.js';\nimport { Bone } from '../objects/Bone.js';\nimport { Skeleton } from '../objects/Skeleton.js';\nimport { Shape } from '../extras/core/Shape.js';\nimport { Fog } from '../scenes/Fog.js';\nimport { FogExp2 } from '../scenes/FogExp2.js';\nimport { HemisphereLight } from '../lights/HemisphereLight.js';\nimport { SpotLight } from '../lights/SpotLight.js';\nimport { PointLight } from '../lights/PointLight.js';\nimport { DirectionalLight } from '../lights/DirectionalLight.js';\nimport { AmbientLight } from '../lights/AmbientLight.js';\nimport { RectAreaLight } from '../lights/RectAreaLight.js';\nimport { LightProbe } from '../lights/LightProbe.js';\nimport { OrthographicCamera } from '../cameras/OrthographicCamera.js';\nimport { PerspectiveCamera } from '../cameras/PerspectiveCamera.js';\nimport { Scene } from '../scenes/Scene.js';\nimport { CubeTexture } from '../textures/CubeTexture.js';\nimport { Texture } from '../textures/Texture.js';\nimport { Source } from '../textures/Source.js';\nimport { DataTexture } from '../textures/DataTexture.js';\nimport { ImageLoader } from './ImageLoader.js';\nimport { LoadingManager } from './LoadingManager.js';\nimport { AnimationClip } from '../animation/AnimationClip.js';\nimport { MaterialLoader } from './MaterialLoader.js';\nimport { LoaderUtils } from './LoaderUtils.js';\nimport { BufferGeometryLoader } from './BufferGeometryLoader.js';\nimport { Loader } from './Loader.js';\nimport { FileLoader } from './FileLoader.js';\nimport * as Geometries from '../geometries/Geometries.js';\nimport { getTypedArray } from '../utils.js';\n\nclass ObjectLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const path = this.path === '' ? LoaderUtils.extractUrlBase(url) : this.path;\n    this.resourcePath = this.resourcePath || path;\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(url, function (text) {\n      let json = null;\n\n      try {\n        json = JSON.parse(text);\n      } catch (error) {\n        if (onError !== undefined) onError(error);\n        console.error('THREE:ObjectLoader: Can\\'t parse ' + url + '.', error.message);\n        return;\n      }\n\n      const metadata = json.metadata;\n\n      if (metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry') {\n        console.error('THREE.ObjectLoader: Can\\'t load ' + url);\n        return;\n      }\n\n      scope.parse(json, onLoad);\n    }, onProgress, onError);\n  }\n\n  async loadAsync(url, onProgress) {\n    const scope = this;\n    const path = this.path === '' ? LoaderUtils.extractUrlBase(url) : this.path;\n    this.resourcePath = this.resourcePath || path;\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n    const text = await loader.loadAsync(url, onProgress);\n    const json = JSON.parse(text);\n    const metadata = json.metadata;\n\n    if (metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry') {\n      throw new Error('THREE.ObjectLoader: Can\\'t load ' + url);\n    }\n\n    return await scope.parseAsync(json);\n  }\n\n  parse(json, onLoad) {\n    const animations = this.parseAnimations(json.animations);\n    const shapes = this.parseShapes(json.shapes);\n    const geometries = this.parseGeometries(json.geometries, shapes);\n    const images = this.parseImages(json.images, function () {\n      if (onLoad !== undefined) onLoad(object);\n    });\n    const textures = this.parseTextures(json.textures, images);\n    const materials = this.parseMaterials(json.materials, textures);\n    const object = this.parseObject(json.object, geometries, materials, textures, animations);\n    const skeletons = this.parseSkeletons(json.skeletons, object);\n    this.bindSkeletons(object, skeletons); //\n\n    if (onLoad !== undefined) {\n      let hasImages = false;\n\n      for (const uuid in images) {\n        if (images[uuid] instanceof HTMLImageElement) {\n          hasImages = true;\n          break;\n        }\n      }\n\n      if (hasImages === false) onLoad(object);\n    }\n\n    return object;\n  }\n\n  async parseAsync(json) {\n    const animations = this.parseAnimations(json.animations);\n    const shapes = this.parseShapes(json.shapes);\n    const geometries = this.parseGeometries(json.geometries, shapes);\n    const images = await this.parseImagesAsync(json.images);\n    const textures = this.parseTextures(json.textures, images);\n    const materials = this.parseMaterials(json.materials, textures);\n    const object = this.parseObject(json.object, geometries, materials, textures, animations);\n    const skeletons = this.parseSkeletons(json.skeletons, object);\n    this.bindSkeletons(object, skeletons);\n    return object;\n  }\n\n  parseShapes(json) {\n    const shapes = {};\n\n    if (json !== undefined) {\n      for (let i = 0, l = json.length; i < l; i++) {\n        const shape = new Shape().fromJSON(json[i]);\n        shapes[shape.uuid] = shape;\n      }\n    }\n\n    return shapes;\n  }\n\n  parseSkeletons(json, object) {\n    const skeletons = {};\n    const bones = {}; // generate bone lookup table\n\n    object.traverse(function (child) {\n      if (child.isBone) bones[child.uuid] = child;\n    }); // create skeletons\n\n    if (json !== undefined) {\n      for (let i = 0, l = json.length; i < l; i++) {\n        const skeleton = new Skeleton().fromJSON(json[i], bones);\n        skeletons[skeleton.uuid] = skeleton;\n      }\n    }\n\n    return skeletons;\n  }\n\n  parseGeometries(json, shapes) {\n    const geometries = {};\n\n    if (json !== undefined) {\n      const bufferGeometryLoader = new BufferGeometryLoader();\n\n      for (let i = 0, l = json.length; i < l; i++) {\n        let geometry;\n        const data = json[i];\n\n        switch (data.type) {\n          case 'BufferGeometry':\n          case 'InstancedBufferGeometry':\n            geometry = bufferGeometryLoader.parse(data);\n            break;\n\n          case 'Geometry':\n            console.error('THREE.ObjectLoader: The legacy Geometry type is no longer supported.');\n            break;\n\n          default:\n            if (data.type in Geometries) {\n              geometry = Geometries[data.type].fromJSON(data, shapes);\n            } else {\n              console.warn(`THREE.ObjectLoader: Unsupported geometry type \"${data.type}\"`);\n            }\n\n        }\n\n        geometry.uuid = data.uuid;\n        if (data.name !== undefined) geometry.name = data.name;\n        if (geometry.isBufferGeometry === true && data.userData !== undefined) geometry.userData = data.userData;\n        geometries[data.uuid] = geometry;\n      }\n    }\n\n    return geometries;\n  }\n\n  parseMaterials(json, textures) {\n    const cache = {}; // MultiMaterial\n\n    const materials = {};\n\n    if (json !== undefined) {\n      const loader = new MaterialLoader();\n      loader.setTextures(textures);\n\n      for (let i = 0, l = json.length; i < l; i++) {\n        const data = json[i];\n\n        if (data.type === 'MultiMaterial') {\n          // Deprecated\n          const array = [];\n\n          for (let j = 0; j < data.materials.length; j++) {\n            const material = data.materials[j];\n\n            if (cache[material.uuid] === undefined) {\n              cache[material.uuid] = loader.parse(material);\n            }\n\n            array.push(cache[material.uuid]);\n          }\n\n          materials[data.uuid] = array;\n        } else {\n          if (cache[data.uuid] === undefined) {\n            cache[data.uuid] = loader.parse(data);\n          }\n\n          materials[data.uuid] = cache[data.uuid];\n        }\n      }\n    }\n\n    return materials;\n  }\n\n  parseAnimations(json) {\n    const animations = {};\n\n    if (json !== undefined) {\n      for (let i = 0; i < json.length; i++) {\n        const data = json[i];\n        const clip = AnimationClip.parse(data);\n        animations[clip.uuid] = clip;\n      }\n    }\n\n    return animations;\n  }\n\n  parseImages(json, onLoad) {\n    const scope = this;\n    const images = {};\n    let loader;\n\n    function loadImage(url) {\n      scope.manager.itemStart(url);\n      return loader.load(url, function () {\n        scope.manager.itemEnd(url);\n      }, undefined, function () {\n        scope.manager.itemError(url);\n        scope.manager.itemEnd(url);\n      });\n    }\n\n    function deserializeImage(image) {\n      if (typeof image === 'string') {\n        const url = image;\n        const path = /^(\\/\\/)|([a-z]+:(\\/\\/)?)/i.test(url) ? url : scope.resourcePath + url;\n        return loadImage(path);\n      } else {\n        if (image.data) {\n          return {\n            data: getTypedArray(image.type, image.data),\n            width: image.width,\n            height: image.height\n          };\n        } else {\n          return null;\n        }\n      }\n    }\n\n    if (json !== undefined && json.length > 0) {\n      const manager = new LoadingManager(onLoad);\n      loader = new ImageLoader(manager);\n      loader.setCrossOrigin(this.crossOrigin);\n\n      for (let i = 0, il = json.length; i < il; i++) {\n        const image = json[i];\n        const url = image.url;\n\n        if (Array.isArray(url)) {\n          // load array of images e.g CubeTexture\n          const imageArray = [];\n\n          for (let j = 0, jl = url.length; j < jl; j++) {\n            const currentUrl = url[j];\n            const deserializedImage = deserializeImage(currentUrl);\n\n            if (deserializedImage !== null) {\n              if (deserializedImage instanceof HTMLImageElement) {\n                imageArray.push(deserializedImage);\n              } else {\n                // special case: handle array of data textures for cube textures\n                imageArray.push(new DataTexture(deserializedImage.data, deserializedImage.width, deserializedImage.height));\n              }\n            }\n          }\n\n          images[image.uuid] = new Source(imageArray);\n        } else {\n          // load single image\n          const deserializedImage = deserializeImage(image.url);\n          images[image.uuid] = new Source(deserializedImage);\n        }\n      }\n    }\n\n    return images;\n  }\n\n  async parseImagesAsync(json) {\n    const scope = this;\n    const images = {};\n    let loader;\n\n    async function deserializeImage(image) {\n      if (typeof image === 'string') {\n        const url = image;\n        const path = /^(\\/\\/)|([a-z]+:(\\/\\/)?)/i.test(url) ? url : scope.resourcePath + url;\n        return await loader.loadAsync(path);\n      } else {\n        if (image.data) {\n          return {\n            data: getTypedArray(image.type, image.data),\n            width: image.width,\n            height: image.height\n          };\n        } else {\n          return null;\n        }\n      }\n    }\n\n    if (json !== undefined && json.length > 0) {\n      loader = new ImageLoader(this.manager);\n      loader.setCrossOrigin(this.crossOrigin);\n\n      for (let i = 0, il = json.length; i < il; i++) {\n        const image = json[i];\n        const url = image.url;\n\n        if (Array.isArray(url)) {\n          // load array of images e.g CubeTexture\n          const imageArray = [];\n\n          for (let j = 0, jl = url.length; j < jl; j++) {\n            const currentUrl = url[j];\n            const deserializedImage = await deserializeImage(currentUrl);\n\n            if (deserializedImage !== null) {\n              if (deserializedImage instanceof HTMLImageElement) {\n                imageArray.push(deserializedImage);\n              } else {\n                // special case: handle array of data textures for cube textures\n                imageArray.push(new DataTexture(deserializedImage.data, deserializedImage.width, deserializedImage.height));\n              }\n            }\n          }\n\n          images[image.uuid] = new Source(imageArray);\n        } else {\n          // load single image\n          const deserializedImage = await deserializeImage(image.url);\n          images[image.uuid] = new Source(deserializedImage);\n        }\n      }\n    }\n\n    return images;\n  }\n\n  parseTextures(json, images) {\n    function parseConstant(value, type) {\n      if (typeof value === 'number') return value;\n      console.warn('THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value);\n      return type[value];\n    }\n\n    const textures = {};\n\n    if (json !== undefined) {\n      for (let i = 0, l = json.length; i < l; i++) {\n        const data = json[i];\n\n        if (data.image === undefined) {\n          console.warn('THREE.ObjectLoader: No \"image\" specified for', data.uuid);\n        }\n\n        if (images[data.image] === undefined) {\n          console.warn('THREE.ObjectLoader: Undefined image', data.image);\n        }\n\n        const source = images[data.image];\n        const image = source.data;\n        let texture;\n\n        if (Array.isArray(image)) {\n          texture = new CubeTexture();\n          if (image.length === 6) texture.needsUpdate = true;\n        } else {\n          if (image && image.data) {\n            texture = new DataTexture();\n          } else {\n            texture = new Texture();\n          }\n\n          if (image) texture.needsUpdate = true; // textures can have undefined image data\n        }\n\n        texture.source = source;\n        texture.uuid = data.uuid;\n        if (data.name !== undefined) texture.name = data.name;\n        if (data.mapping !== undefined) texture.mapping = parseConstant(data.mapping, TEXTURE_MAPPING);\n        if (data.offset !== undefined) texture.offset.fromArray(data.offset);\n        if (data.repeat !== undefined) texture.repeat.fromArray(data.repeat);\n        if (data.center !== undefined) texture.center.fromArray(data.center);\n        if (data.rotation !== undefined) texture.rotation = data.rotation;\n\n        if (data.wrap !== undefined) {\n          texture.wrapS = parseConstant(data.wrap[0], TEXTURE_WRAPPING);\n          texture.wrapT = parseConstant(data.wrap[1], TEXTURE_WRAPPING);\n        }\n\n        if (data.format !== undefined) texture.format = data.format;\n        if (data.type !== undefined) texture.type = data.type;\n        if (data.encoding !== undefined) texture.encoding = data.encoding;\n        if (data.minFilter !== undefined) texture.minFilter = parseConstant(data.minFilter, TEXTURE_FILTER);\n        if (data.magFilter !== undefined) texture.magFilter = parseConstant(data.magFilter, TEXTURE_FILTER);\n        if (data.anisotropy !== undefined) texture.anisotropy = data.anisotropy;\n        if (data.flipY !== undefined) texture.flipY = data.flipY;\n        if (data.premultiplyAlpha !== undefined) texture.premultiplyAlpha = data.premultiplyAlpha;\n        if (data.unpackAlignment !== undefined) texture.unpackAlignment = data.unpackAlignment;\n        if (data.userData !== undefined) texture.userData = data.userData;\n        textures[data.uuid] = texture;\n      }\n    }\n\n    return textures;\n  }\n\n  parseObject(data, geometries, materials, textures, animations) {\n    let object;\n\n    function getGeometry(name) {\n      if (geometries[name] === undefined) {\n        console.warn('THREE.ObjectLoader: Undefined geometry', name);\n      }\n\n      return geometries[name];\n    }\n\n    function getMaterial(name) {\n      if (name === undefined) return undefined;\n\n      if (Array.isArray(name)) {\n        const array = [];\n\n        for (let i = 0, l = name.length; i < l; i++) {\n          const uuid = name[i];\n\n          if (materials[uuid] === undefined) {\n            console.warn('THREE.ObjectLoader: Undefined material', uuid);\n          }\n\n          array.push(materials[uuid]);\n        }\n\n        return array;\n      }\n\n      if (materials[name] === undefined) {\n        console.warn('THREE.ObjectLoader: Undefined material', name);\n      }\n\n      return materials[name];\n    }\n\n    function getTexture(uuid) {\n      if (textures[uuid] === undefined) {\n        console.warn('THREE.ObjectLoader: Undefined texture', uuid);\n      }\n\n      return textures[uuid];\n    }\n\n    let geometry, material;\n\n    switch (data.type) {\n      case 'Scene':\n        object = new Scene();\n\n        if (data.background !== undefined) {\n          if (Number.isInteger(data.background)) {\n            object.background = new Color(data.background);\n          } else {\n            object.background = getTexture(data.background);\n          }\n        }\n\n        if (data.environment !== undefined) {\n          object.environment = getTexture(data.environment);\n        }\n\n        if (data.fog !== undefined) {\n          if (data.fog.type === 'Fog') {\n            object.fog = new Fog(data.fog.color, data.fog.near, data.fog.far);\n          } else if (data.fog.type === 'FogExp2') {\n            object.fog = new FogExp2(data.fog.color, data.fog.density);\n          }\n        }\n\n        break;\n\n      case 'PerspectiveCamera':\n        object = new PerspectiveCamera(data.fov, data.aspect, data.near, data.far);\n        if (data.focus !== undefined) object.focus = data.focus;\n        if (data.zoom !== undefined) object.zoom = data.zoom;\n        if (data.filmGauge !== undefined) object.filmGauge = data.filmGauge;\n        if (data.filmOffset !== undefined) object.filmOffset = data.filmOffset;\n        if (data.view !== undefined) object.view = Object.assign({}, data.view);\n        break;\n\n      case 'OrthographicCamera':\n        object = new OrthographicCamera(data.left, data.right, data.top, data.bottom, data.near, data.far);\n        if (data.zoom !== undefined) object.zoom = data.zoom;\n        if (data.view !== undefined) object.view = Object.assign({}, data.view);\n        break;\n\n      case 'AmbientLight':\n        object = new AmbientLight(data.color, data.intensity);\n        break;\n\n      case 'DirectionalLight':\n        object = new DirectionalLight(data.color, data.intensity);\n        break;\n\n      case 'PointLight':\n        object = new PointLight(data.color, data.intensity, data.distance, data.decay);\n        break;\n\n      case 'RectAreaLight':\n        object = new RectAreaLight(data.color, data.intensity, data.width, data.height);\n        break;\n\n      case 'SpotLight':\n        object = new SpotLight(data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay);\n        break;\n\n      case 'HemisphereLight':\n        object = new HemisphereLight(data.color, data.groundColor, data.intensity);\n        break;\n\n      case 'LightProbe':\n        object = new LightProbe().fromJSON(data);\n        break;\n\n      case 'SkinnedMesh':\n        geometry = getGeometry(data.geometry);\n        material = getMaterial(data.material);\n        object = new SkinnedMesh(geometry, material);\n        if (data.bindMode !== undefined) object.bindMode = data.bindMode;\n        if (data.bindMatrix !== undefined) object.bindMatrix.fromArray(data.bindMatrix);\n        if (data.skeleton !== undefined) object.skeleton = data.skeleton;\n        break;\n\n      case 'Mesh':\n        geometry = getGeometry(data.geometry);\n        material = getMaterial(data.material);\n        object = new Mesh(geometry, material);\n        break;\n\n      case 'InstancedMesh':\n        geometry = getGeometry(data.geometry);\n        material = getMaterial(data.material);\n        const count = data.count;\n        const instanceMatrix = data.instanceMatrix;\n        const instanceColor = data.instanceColor;\n        object = new InstancedMesh(geometry, material, count);\n        object.instanceMatrix = new InstancedBufferAttribute(new Float32Array(instanceMatrix.array), 16);\n        if (instanceColor !== undefined) object.instanceColor = new InstancedBufferAttribute(new Float32Array(instanceColor.array), instanceColor.itemSize);\n        break;\n\n      case 'LOD':\n        object = new LOD();\n        break;\n\n      case 'Line':\n        object = new Line(getGeometry(data.geometry), getMaterial(data.material));\n        break;\n\n      case 'LineLoop':\n        object = new LineLoop(getGeometry(data.geometry), getMaterial(data.material));\n        break;\n\n      case 'LineSegments':\n        object = new LineSegments(getGeometry(data.geometry), getMaterial(data.material));\n        break;\n\n      case 'PointCloud':\n      case 'Points':\n        object = new Points(getGeometry(data.geometry), getMaterial(data.material));\n        break;\n\n      case 'Sprite':\n        object = new Sprite(getMaterial(data.material));\n        break;\n\n      case 'Group':\n        object = new Group();\n        break;\n\n      case 'Bone':\n        object = new Bone();\n        break;\n\n      default:\n        object = new Object3D();\n    }\n\n    object.uuid = data.uuid;\n    if (data.name !== undefined) object.name = data.name;\n\n    if (data.matrix !== undefined) {\n      object.matrix.fromArray(data.matrix);\n      if (data.matrixAutoUpdate !== undefined) object.matrixAutoUpdate = data.matrixAutoUpdate;\n      if (object.matrixAutoUpdate) object.matrix.decompose(object.position, object.quaternion, object.scale);\n    } else {\n      if (data.position !== undefined) object.position.fromArray(data.position);\n      if (data.rotation !== undefined) object.rotation.fromArray(data.rotation);\n      if (data.quaternion !== undefined) object.quaternion.fromArray(data.quaternion);\n      if (data.scale !== undefined) object.scale.fromArray(data.scale);\n    }\n\n    if (data.castShadow !== undefined) object.castShadow = data.castShadow;\n    if (data.receiveShadow !== undefined) object.receiveShadow = data.receiveShadow;\n\n    if (data.shadow) {\n      if (data.shadow.bias !== undefined) object.shadow.bias = data.shadow.bias;\n      if (data.shadow.normalBias !== undefined) object.shadow.normalBias = data.shadow.normalBias;\n      if (data.shadow.radius !== undefined) object.shadow.radius = data.shadow.radius;\n      if (data.shadow.mapSize !== undefined) object.shadow.mapSize.fromArray(data.shadow.mapSize);\n      if (data.shadow.camera !== undefined) object.shadow.camera = this.parseObject(data.shadow.camera);\n    }\n\n    if (data.visible !== undefined) object.visible = data.visible;\n    if (data.frustumCulled !== undefined) object.frustumCulled = data.frustumCulled;\n    if (data.renderOrder !== undefined) object.renderOrder = data.renderOrder;\n    if (data.userData !== undefined) object.userData = data.userData;\n    if (data.layers !== undefined) object.layers.mask = data.layers;\n\n    if (data.children !== undefined) {\n      const children = data.children;\n\n      for (let i = 0; i < children.length; i++) {\n        object.add(this.parseObject(children[i], geometries, materials, textures, animations));\n      }\n    }\n\n    if (data.animations !== undefined) {\n      const objectAnimations = data.animations;\n\n      for (let i = 0; i < objectAnimations.length; i++) {\n        const uuid = objectAnimations[i];\n        object.animations.push(animations[uuid]);\n      }\n    }\n\n    if (data.type === 'LOD') {\n      if (data.autoUpdate !== undefined) object.autoUpdate = data.autoUpdate;\n      const levels = data.levels;\n\n      for (let l = 0; l < levels.length; l++) {\n        const level = levels[l];\n        const child = object.getObjectByProperty('uuid', level.object);\n\n        if (child !== undefined) {\n          object.addLevel(child, level.distance);\n        }\n      }\n    }\n\n    return object;\n  }\n\n  bindSkeletons(object, skeletons) {\n    if (Object.keys(skeletons).length === 0) return;\n    object.traverse(function (child) {\n      if (child.isSkinnedMesh === true && child.skeleton !== undefined) {\n        const skeleton = skeletons[child.skeleton];\n\n        if (skeleton === undefined) {\n          console.warn('THREE.ObjectLoader: No skeleton found with UUID:', child.skeleton);\n        } else {\n          child.bind(skeleton, child.bindMatrix);\n        }\n      }\n    });\n  }\n  /* DEPRECATED */\n\n\n  setTexturePath(value) {\n    console.warn('THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath().');\n    return this.setResourcePath(value);\n  }\n\n}\n\nconst TEXTURE_MAPPING = {\n  UVMapping: UVMapping,\n  CubeReflectionMapping: CubeReflectionMapping,\n  CubeRefractionMapping: CubeRefractionMapping,\n  EquirectangularReflectionMapping: EquirectangularReflectionMapping,\n  EquirectangularRefractionMapping: EquirectangularRefractionMapping,\n  CubeUVReflectionMapping: CubeUVReflectionMapping,\n  CubeUVRefractionMapping: CubeUVRefractionMapping\n};\nconst TEXTURE_WRAPPING = {\n  RepeatWrapping: RepeatWrapping,\n  ClampToEdgeWrapping: ClampToEdgeWrapping,\n  MirroredRepeatWrapping: MirroredRepeatWrapping\n};\nconst TEXTURE_FILTER = {\n  NearestFilter: NearestFilter,\n  NearestMipmapNearestFilter: NearestMipmapNearestFilter,\n  NearestMipmapLinearFilter: NearestMipmapLinearFilter,\n  LinearFilter: LinearFilter,\n  LinearMipmapNearestFilter: LinearMipmapNearestFilter,\n  LinearMipmapLinearFilter: LinearMipmapLinearFilter\n};\nexport { ObjectLoader };","map":{"version":3,"sources":["C:/Users/dell/Desktop/projektlogin/vue-3-authentication-jwt/src/games/three/src/loaders/ObjectLoader.js"],"names":["UVMapping","CubeReflectionMapping","CubeRefractionMapping","EquirectangularReflectionMapping","EquirectangularRefractionMapping","CubeUVReflectionMapping","CubeUVRefractionMapping","RepeatWrapping","ClampToEdgeWrapping","MirroredRepeatWrapping","NearestFilter","NearestMipmapNearestFilter","NearestMipmapLinearFilter","LinearFilter","LinearMipmapNearestFilter","LinearMipmapLinearFilter","InstancedBufferAttribute","Color","Object3D","Group","InstancedMesh","Sprite","Points","Line","LineLoop","LineSegments","LOD","Mesh","SkinnedMesh","Bone","Skeleton","Shape","Fog","FogExp2","HemisphereLight","SpotLight","PointLight","DirectionalLight","AmbientLight","RectAreaLight","LightProbe","OrthographicCamera","PerspectiveCamera","Scene","CubeTexture","Texture","Source","DataTexture","ImageLoader","LoadingManager","AnimationClip","MaterialLoader","LoaderUtils","BufferGeometryLoader","Loader","FileLoader","Geometries","getTypedArray","ObjectLoader","constructor","manager","load","url","onLoad","onProgress","onError","scope","path","extractUrlBase","resourcePath","loader","setPath","setRequestHeader","requestHeader","setWithCredentials","withCredentials","text","json","JSON","parse","error","undefined","console","message","metadata","type","toLowerCase","loadAsync","Error","parseAsync","animations","parseAnimations","shapes","parseShapes","geometries","parseGeometries","images","parseImages","object","textures","parseTextures","materials","parseMaterials","parseObject","skeletons","parseSkeletons","bindSkeletons","hasImages","uuid","HTMLImageElement","parseImagesAsync","i","l","length","shape","fromJSON","bones","traverse","child","isBone","skeleton","bufferGeometryLoader","geometry","data","warn","name","isBufferGeometry","userData","cache","setTextures","array","j","material","push","clip","loadImage","itemStart","itemEnd","itemError","deserializeImage","image","test","width","height","setCrossOrigin","crossOrigin","il","Array","isArray","imageArray","jl","currentUrl","deserializedImage","parseConstant","value","source","texture","needsUpdate","mapping","TEXTURE_MAPPING","offset","fromArray","repeat","center","rotation","wrap","wrapS","TEXTURE_WRAPPING","wrapT","format","encoding","minFilter","TEXTURE_FILTER","magFilter","anisotropy","flipY","premultiplyAlpha","unpackAlignment","getGeometry","getMaterial","getTexture","background","Number","isInteger","environment","fog","color","near","far","density","fov","aspect","focus","zoom","filmGauge","filmOffset","view","Object","assign","left","right","top","bottom","intensity","distance","decay","angle","penumbra","groundColor","bindMode","bindMatrix","count","instanceMatrix","instanceColor","Float32Array","itemSize","matrix","matrixAutoUpdate","decompose","position","quaternion","scale","castShadow","receiveShadow","shadow","bias","normalBias","radius","mapSize","camera","visible","frustumCulled","renderOrder","layers","mask","children","add","objectAnimations","autoUpdate","levels","level","getObjectByProperty","addLevel","keys","isSkinnedMesh","bind","setTexturePath","setResourcePath"],"mappings":"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","sourcesContent":["import {\r\n\tUVMapping,\r\n\tCubeReflectionMapping,\r\n\tCubeRefractionMapping,\r\n\tEquirectangularReflectionMapping,\r\n\tEquirectangularRefractionMapping,\r\n\tCubeUVReflectionMapping,\r\n\tCubeUVRefractionMapping,\r\n\r\n\tRepeatWrapping,\r\n\tClampToEdgeWrapping,\r\n\tMirroredRepeatWrapping,\r\n\r\n\tNearestFilter,\r\n\tNearestMipmapNearestFilter,\r\n\tNearestMipmapLinearFilter,\r\n\tLinearFilter,\r\n\tLinearMipmapNearestFilter,\r\n\tLinearMipmapLinearFilter\r\n} from '../constants.js';\r\nimport { InstancedBufferAttribute } from '../core/InstancedBufferAttribute.js';\r\nimport { Color } from '../math/Color.js';\r\nimport { Object3D } from '../core/Object3D.js';\r\nimport { Group } from '../objects/Group.js';\r\nimport { InstancedMesh } from '../objects/InstancedMesh.js';\r\nimport { Sprite } from '../objects/Sprite.js';\r\nimport { Points } from '../objects/Points.js';\r\nimport { Line } from '../objects/Line.js';\r\nimport { LineLoop } from '../objects/LineLoop.js';\r\nimport { LineSegments } from '../objects/LineSegments.js';\r\nimport { LOD } from '../objects/LOD.js';\r\nimport { Mesh } from '../objects/Mesh.js';\r\nimport { SkinnedMesh } from '../objects/SkinnedMesh.js';\r\nimport { Bone } from '../objects/Bone.js';\r\nimport { Skeleton } from '../objects/Skeleton.js';\r\nimport { Shape } from '../extras/core/Shape.js';\r\nimport { Fog } from '../scenes/Fog.js';\r\nimport { FogExp2 } from '../scenes/FogExp2.js';\r\nimport { HemisphereLight } from '../lights/HemisphereLight.js';\r\nimport { SpotLight } from '../lights/SpotLight.js';\r\nimport { PointLight } from '../lights/PointLight.js';\r\nimport { DirectionalLight } from '../lights/DirectionalLight.js';\r\nimport { AmbientLight } from '../lights/AmbientLight.js';\r\nimport { RectAreaLight } from '../lights/RectAreaLight.js';\r\nimport { LightProbe } from '../lights/LightProbe.js';\r\nimport { OrthographicCamera } from '../cameras/OrthographicCamera.js';\r\nimport { PerspectiveCamera } from '../cameras/PerspectiveCamera.js';\r\nimport { Scene } from '../scenes/Scene.js';\r\nimport { CubeTexture } from '../textures/CubeTexture.js';\r\nimport { Texture } from '../textures/Texture.js';\r\nimport { Source } from '../textures/Source.js';\r\nimport { DataTexture } from '../textures/DataTexture.js';\r\nimport { ImageLoader } from './ImageLoader.js';\r\nimport { LoadingManager } from './LoadingManager.js';\r\nimport { AnimationClip } from '../animation/AnimationClip.js';\r\nimport { MaterialLoader } from './MaterialLoader.js';\r\nimport { LoaderUtils } from './LoaderUtils.js';\r\nimport { BufferGeometryLoader } from './BufferGeometryLoader.js';\r\nimport { Loader } from './Loader.js';\r\nimport { FileLoader } from './FileLoader.js';\r\nimport * as Geometries from '../geometries/Geometries.js';\r\nimport { getTypedArray } from '../utils.js';\r\n\r\nclass ObjectLoader extends Loader {\r\n\r\n\tconstructor( manager ) {\r\n\r\n\t\tsuper( manager );\r\n\r\n\t}\r\n\r\n\tload( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tconst scope = this;\r\n\r\n\t\tconst path = ( this.path === '' ) ? LoaderUtils.extractUrlBase( url ) : this.path;\r\n\t\tthis.resourcePath = this.resourcePath || path;\r\n\r\n\t\tconst loader = new FileLoader( this.manager );\r\n\t\tloader.setPath( this.path );\r\n\t\tloader.setRequestHeader( this.requestHeader );\r\n\t\tloader.setWithCredentials( this.withCredentials );\r\n\t\tloader.load( url, function ( text ) {\r\n\r\n\t\t\tlet json = null;\r\n\r\n\t\t\ttry {\r\n\r\n\t\t\t\tjson = JSON.parse( text );\r\n\r\n\t\t\t} catch ( error ) {\r\n\r\n\t\t\t\tif ( onError !== undefined ) onError( error );\r\n\r\n\t\t\t\tconsole.error( 'THREE:ObjectLoader: Can\\'t parse ' + url + '.', error.message );\r\n\r\n\t\t\t\treturn;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst metadata = json.metadata;\r\n\r\n\t\t\tif ( metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry' ) {\r\n\r\n\t\t\t\tconsole.error( 'THREE.ObjectLoader: Can\\'t load ' + url );\r\n\t\t\t\treturn;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tscope.parse( json, onLoad );\r\n\r\n\t\t}, onProgress, onError );\r\n\r\n\t}\r\n\r\n\tasync loadAsync( url, onProgress ) {\r\n\r\n\t\tconst scope = this;\r\n\r\n\t\tconst path = ( this.path === '' ) ? LoaderUtils.extractUrlBase( url ) : this.path;\r\n\t\tthis.resourcePath = this.resourcePath || path;\r\n\r\n\t\tconst loader = new FileLoader( this.manager );\r\n\t\tloader.setPath( this.path );\r\n\t\tloader.setRequestHeader( this.requestHeader );\r\n\t\tloader.setWithCredentials( this.withCredentials );\r\n\r\n\t\tconst text = await loader.loadAsync( url, onProgress );\r\n\r\n\t\tconst json = JSON.parse( text );\r\n\r\n\t\tconst metadata = json.metadata;\r\n\r\n\t\tif ( metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry' ) {\r\n\r\n\t\t\tthrow new Error( 'THREE.ObjectLoader: Can\\'t load ' + url );\r\n\r\n\t\t}\r\n\r\n\t\treturn await scope.parseAsync( json );\r\n\r\n\t}\r\n\r\n\tparse( json, onLoad ) {\r\n\r\n\t\tconst animations = this.parseAnimations( json.animations );\r\n\t\tconst shapes = this.parseShapes( json.shapes );\r\n\t\tconst geometries = this.parseGeometries( json.geometries, shapes );\r\n\r\n\t\tconst images = this.parseImages( json.images, function () {\r\n\r\n\t\t\tif ( onLoad !== undefined ) onLoad( object );\r\n\r\n\t\t} );\r\n\r\n\t\tconst textures = this.parseTextures( json.textures, images );\r\n\t\tconst materials = this.parseMaterials( json.materials, textures );\r\n\r\n\t\tconst object = this.parseObject( json.object, geometries, materials, textures, animations );\r\n\t\tconst skeletons = this.parseSkeletons( json.skeletons, object );\r\n\r\n\t\tthis.bindSkeletons( object, skeletons );\r\n\r\n\t\t//\r\n\r\n\t\tif ( onLoad !== undefined ) {\r\n\r\n\t\t\tlet hasImages = false;\r\n\r\n\t\t\tfor ( const uuid in images ) {\r\n\r\n\t\t\t\tif ( images[ uuid ] instanceof HTMLImageElement ) {\r\n\r\n\t\t\t\t\thasImages = true;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( hasImages === false ) onLoad( object );\r\n\r\n\t\t}\r\n\r\n\t\treturn object;\r\n\r\n\t}\r\n\r\n\tasync parseAsync( json ) {\r\n\r\n\t\tconst animations = this.parseAnimations( json.animations );\r\n\t\tconst shapes = this.parseShapes( json.shapes );\r\n\t\tconst geometries = this.parseGeometries( json.geometries, shapes );\r\n\r\n\t\tconst images = await this.parseImagesAsync( json.images );\r\n\r\n\t\tconst textures = this.parseTextures( json.textures, images );\r\n\t\tconst materials = this.parseMaterials( json.materials, textures );\r\n\r\n\t\tconst object = this.parseObject( json.object, geometries, materials, textures, animations );\r\n\t\tconst skeletons = this.parseSkeletons( json.skeletons, object );\r\n\r\n\t\tthis.bindSkeletons( object, skeletons );\r\n\r\n\t\treturn object;\r\n\r\n\t}\r\n\r\n\tparseShapes( json ) {\r\n\r\n\t\tconst shapes = {};\r\n\r\n\t\tif ( json !== undefined ) {\r\n\r\n\t\t\tfor ( let i = 0, l = json.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tconst shape = new Shape().fromJSON( json[ i ] );\r\n\r\n\t\t\t\tshapes[ shape.uuid ] = shape;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn shapes;\r\n\r\n\t}\r\n\r\n\tparseSkeletons( json, object ) {\r\n\r\n\t\tconst skeletons = {};\r\n\t\tconst bones = {};\r\n\r\n\t\t// generate bone lookup table\r\n\r\n\t\tobject.traverse( function ( child ) {\r\n\r\n\t\t\tif ( child.isBone ) bones[ child.uuid ] = child;\r\n\r\n\t\t} );\r\n\r\n\t\t// create skeletons\r\n\r\n\t\tif ( json !== undefined ) {\r\n\r\n\t\t\tfor ( let i = 0, l = json.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tconst skeleton = new Skeleton().fromJSON( json[ i ], bones );\r\n\r\n\t\t\t\tskeletons[ skeleton.uuid ] = skeleton;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn skeletons;\r\n\r\n\t}\r\n\r\n\tparseGeometries( json, shapes ) {\r\n\r\n\t\tconst geometries = {};\r\n\r\n\t\tif ( json !== undefined ) {\r\n\r\n\t\t\tconst bufferGeometryLoader = new BufferGeometryLoader();\r\n\r\n\t\t\tfor ( let i = 0, l = json.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tlet geometry;\r\n\t\t\t\tconst data = json[ i ];\r\n\r\n\t\t\t\tswitch ( data.type ) {\r\n\r\n\t\t\t\t\tcase 'BufferGeometry':\r\n\t\t\t\t\tcase 'InstancedBufferGeometry':\r\n\r\n\t\t\t\t\t\tgeometry = bufferGeometryLoader.parse( data );\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'Geometry':\r\n\r\n\t\t\t\t\t\tconsole.error( 'THREE.ObjectLoader: The legacy Geometry type is no longer supported.' );\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tdefault:\r\n\r\n\t\t\t\t\t\tif ( data.type in Geometries ) {\r\n\r\n\t\t\t\t\t\t\tgeometry = Geometries[ data.type ].fromJSON( data, shapes );\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tconsole.warn( `THREE.ObjectLoader: Unsupported geometry type \"${ data.type }\"` );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tgeometry.uuid = data.uuid;\r\n\r\n\t\t\t\tif ( data.name !== undefined ) geometry.name = data.name;\r\n\t\t\t\tif ( geometry.isBufferGeometry === true && data.userData !== undefined ) geometry.userData = data.userData;\r\n\r\n\t\t\t\tgeometries[ data.uuid ] = geometry;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn geometries;\r\n\r\n\t}\r\n\r\n\tparseMaterials( json, textures ) {\r\n\r\n\t\tconst cache = {}; // MultiMaterial\r\n\t\tconst materials = {};\r\n\r\n\t\tif ( json !== undefined ) {\r\n\r\n\t\t\tconst loader = new MaterialLoader();\r\n\t\t\tloader.setTextures( textures );\r\n\r\n\t\t\tfor ( let i = 0, l = json.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tconst data = json[ i ];\r\n\r\n\t\t\t\tif ( data.type === 'MultiMaterial' ) {\r\n\r\n\t\t\t\t\t// Deprecated\r\n\r\n\t\t\t\t\tconst array = [];\r\n\r\n\t\t\t\t\tfor ( let j = 0; j < data.materials.length; j ++ ) {\r\n\r\n\t\t\t\t\t\tconst material = data.materials[ j ];\r\n\r\n\t\t\t\t\t\tif ( cache[ material.uuid ] === undefined ) {\r\n\r\n\t\t\t\t\t\t\tcache[ material.uuid ] = loader.parse( material );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tarray.push( cache[ material.uuid ] );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tmaterials[ data.uuid ] = array;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tif ( cache[ data.uuid ] === undefined ) {\r\n\r\n\t\t\t\t\t\tcache[ data.uuid ] = loader.parse( data );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tmaterials[ data.uuid ] = cache[ data.uuid ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn materials;\r\n\r\n\t}\r\n\r\n\tparseAnimations( json ) {\r\n\r\n\t\tconst animations = {};\r\n\r\n\t\tif ( json !== undefined ) {\r\n\r\n\t\t\tfor ( let i = 0; i < json.length; i ++ ) {\r\n\r\n\t\t\t\tconst data = json[ i ];\r\n\r\n\t\t\t\tconst clip = AnimationClip.parse( data );\r\n\r\n\t\t\t\tanimations[ clip.uuid ] = clip;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn animations;\r\n\r\n\t}\r\n\r\n\tparseImages( json, onLoad ) {\r\n\r\n\t\tconst scope = this;\r\n\t\tconst images = {};\r\n\r\n\t\tlet loader;\r\n\r\n\t\tfunction loadImage( url ) {\r\n\r\n\t\t\tscope.manager.itemStart( url );\r\n\r\n\t\t\treturn loader.load( url, function () {\r\n\r\n\t\t\t\tscope.manager.itemEnd( url );\r\n\r\n\t\t\t}, undefined, function () {\r\n\r\n\t\t\t\tscope.manager.itemError( url );\r\n\t\t\t\tscope.manager.itemEnd( url );\r\n\r\n\t\t\t} );\r\n\r\n\t\t}\r\n\r\n\t\tfunction deserializeImage( image ) {\r\n\r\n\t\t\tif ( typeof image === 'string' ) {\r\n\r\n\t\t\t\tconst url = image;\r\n\r\n\t\t\t\tconst path = /^(\\/\\/)|([a-z]+:(\\/\\/)?)/i.test( url ) ? url : scope.resourcePath + url;\r\n\r\n\t\t\t\treturn loadImage( path );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tif ( image.data ) {\r\n\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\tdata: getTypedArray( image.type, image.data ),\r\n\t\t\t\t\t\twidth: image.width,\r\n\t\t\t\t\t\theight: image.height\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\treturn null;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( json !== undefined && json.length > 0 ) {\r\n\r\n\t\t\tconst manager = new LoadingManager( onLoad );\r\n\r\n\t\t\tloader = new ImageLoader( manager );\r\n\t\t\tloader.setCrossOrigin( this.crossOrigin );\r\n\r\n\t\t\tfor ( let i = 0, il = json.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tconst image = json[ i ];\r\n\t\t\t\tconst url = image.url;\r\n\r\n\t\t\t\tif ( Array.isArray( url ) ) {\r\n\r\n\t\t\t\t\t// load array of images e.g CubeTexture\r\n\r\n\t\t\t\t\tconst imageArray = [];\r\n\r\n\t\t\t\t\tfor ( let j = 0, jl = url.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\t\tconst currentUrl = url[ j ];\r\n\r\n\t\t\t\t\t\tconst deserializedImage = deserializeImage( currentUrl );\r\n\r\n\t\t\t\t\t\tif ( deserializedImage !== null ) {\r\n\r\n\t\t\t\t\t\t\tif ( deserializedImage instanceof HTMLImageElement ) {\r\n\r\n\t\t\t\t\t\t\t\timageArray.push( deserializedImage );\r\n\r\n\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\t// special case: handle array of data textures for cube textures\r\n\r\n\t\t\t\t\t\t\t\timageArray.push( new DataTexture( deserializedImage.data, deserializedImage.width, deserializedImage.height ) );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\timages[ image.uuid ] = new Source( imageArray );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// load single image\r\n\r\n\t\t\t\t\tconst deserializedImage = deserializeImage( image.url );\r\n\t\t\t\t\timages[ image.uuid ] = new Source( deserializedImage );\r\n\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn images;\r\n\r\n\t}\r\n\r\n\tasync parseImagesAsync( json ) {\r\n\r\n\t\tconst scope = this;\r\n\t\tconst images = {};\r\n\r\n\t\tlet loader;\r\n\r\n\t\tasync function deserializeImage( image ) {\r\n\r\n\t\t\tif ( typeof image === 'string' ) {\r\n\r\n\t\t\t\tconst url = image;\r\n\r\n\t\t\t\tconst path = /^(\\/\\/)|([a-z]+:(\\/\\/)?)/i.test( url ) ? url : scope.resourcePath + url;\r\n\r\n\t\t\t\treturn await loader.loadAsync( path );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tif ( image.data ) {\r\n\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\tdata: getTypedArray( image.type, image.data ),\r\n\t\t\t\t\t\twidth: image.width,\r\n\t\t\t\t\t\theight: image.height\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\treturn null;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( json !== undefined && json.length > 0 ) {\r\n\r\n\t\t\tloader = new ImageLoader( this.manager );\r\n\t\t\tloader.setCrossOrigin( this.crossOrigin );\r\n\r\n\t\t\tfor ( let i = 0, il = json.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tconst image = json[ i ];\r\n\t\t\t\tconst url = image.url;\r\n\r\n\t\t\t\tif ( Array.isArray( url ) ) {\r\n\r\n\t\t\t\t\t// load array of images e.g CubeTexture\r\n\r\n\t\t\t\t\tconst imageArray = [];\r\n\r\n\t\t\t\t\tfor ( let j = 0, jl = url.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\t\tconst currentUrl = url[ j ];\r\n\r\n\t\t\t\t\t\tconst deserializedImage = await deserializeImage( currentUrl );\r\n\r\n\t\t\t\t\t\tif ( deserializedImage !== null ) {\r\n\r\n\t\t\t\t\t\t\tif ( deserializedImage instanceof HTMLImageElement ) {\r\n\r\n\t\t\t\t\t\t\t\timageArray.push( deserializedImage );\r\n\r\n\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\t// special case: handle array of data textures for cube textures\r\n\r\n\t\t\t\t\t\t\t\timageArray.push( new DataTexture( deserializedImage.data, deserializedImage.width, deserializedImage.height ) );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\timages[ image.uuid ] = new Source( imageArray );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// load single image\r\n\r\n\t\t\t\t\tconst deserializedImage = await deserializeImage( image.url );\r\n\t\t\t\t\timages[ image.uuid ] = new Source( deserializedImage );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn images;\r\n\r\n\t}\r\n\r\n\tparseTextures( json, images ) {\r\n\r\n\t\tfunction parseConstant( value, type ) {\r\n\r\n\t\t\tif ( typeof value === 'number' ) return value;\r\n\r\n\t\t\tconsole.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );\r\n\r\n\t\t\treturn type[ value ];\r\n\r\n\t\t}\r\n\r\n\t\tconst textures = {};\r\n\r\n\t\tif ( json !== undefined ) {\r\n\r\n\t\t\tfor ( let i = 0, l = json.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tconst data = json[ i ];\r\n\r\n\t\t\t\tif ( data.image === undefined ) {\r\n\r\n\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: No \"image\" specified for', data.uuid );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( images[ data.image ] === undefined ) {\r\n\r\n\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined image', data.image );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconst source = images[ data.image ];\r\n\t\t\t\tconst image = source.data;\r\n\r\n\t\t\t\tlet texture;\r\n\r\n\t\t\t\tif ( Array.isArray( image ) ) {\r\n\r\n\t\t\t\t\ttexture = new CubeTexture();\r\n\r\n\t\t\t\t\tif ( image.length === 6 ) texture.needsUpdate = true;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tif ( image && image.data ) {\r\n\r\n\t\t\t\t\t\ttexture = new DataTexture();\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\ttexture = new Texture();\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( image ) texture.needsUpdate = true; // textures can have undefined image data\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttexture.source = source;\r\n\r\n\t\t\t\ttexture.uuid = data.uuid;\r\n\r\n\t\t\t\tif ( data.name !== undefined ) texture.name = data.name;\r\n\r\n\t\t\t\tif ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping, TEXTURE_MAPPING );\r\n\r\n\t\t\t\tif ( data.offset !== undefined ) texture.offset.fromArray( data.offset );\r\n\t\t\t\tif ( data.repeat !== undefined ) texture.repeat.fromArray( data.repeat );\r\n\t\t\t\tif ( data.center !== undefined ) texture.center.fromArray( data.center );\r\n\t\t\t\tif ( data.rotation !== undefined ) texture.rotation = data.rotation;\r\n\r\n\t\t\t\tif ( data.wrap !== undefined ) {\r\n\r\n\t\t\t\t\ttexture.wrapS = parseConstant( data.wrap[ 0 ], TEXTURE_WRAPPING );\r\n\t\t\t\t\ttexture.wrapT = parseConstant( data.wrap[ 1 ], TEXTURE_WRAPPING );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( data.format !== undefined ) texture.format = data.format;\r\n\t\t\t\tif ( data.type !== undefined ) texture.type = data.type;\r\n\t\t\t\tif ( data.encoding !== undefined ) texture.encoding = data.encoding;\r\n\r\n\t\t\t\tif ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter, TEXTURE_FILTER );\r\n\t\t\t\tif ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter, TEXTURE_FILTER );\r\n\t\t\t\tif ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;\r\n\r\n\t\t\t\tif ( data.flipY !== undefined ) texture.flipY = data.flipY;\r\n\r\n\t\t\t\tif ( data.premultiplyAlpha !== undefined ) texture.premultiplyAlpha = data.premultiplyAlpha;\r\n\t\t\t\tif ( data.unpackAlignment !== undefined ) texture.unpackAlignment = data.unpackAlignment;\r\n\r\n\t\t\t\tif ( data.userData !== undefined ) texture.userData = data.userData;\r\n\r\n\t\t\t\ttextures[ data.uuid ] = texture;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn textures;\r\n\r\n\t}\r\n\r\n\tparseObject( data, geometries, materials, textures, animations ) {\r\n\r\n\t\tlet object;\r\n\r\n\t\tfunction getGeometry( name ) {\r\n\r\n\t\t\tif ( geometries[ name ] === undefined ) {\r\n\r\n\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined geometry', name );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn geometries[ name ];\r\n\r\n\t\t}\r\n\r\n\t\tfunction getMaterial( name ) {\r\n\r\n\t\t\tif ( name === undefined ) return undefined;\r\n\r\n\t\t\tif ( Array.isArray( name ) ) {\r\n\r\n\t\t\t\tconst array = [];\r\n\r\n\t\t\t\tfor ( let i = 0, l = name.length; i < l; i ++ ) {\r\n\r\n\t\t\t\t\tconst uuid = name[ i ];\r\n\r\n\t\t\t\t\tif ( materials[ uuid ] === undefined ) {\r\n\r\n\t\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined material', uuid );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tarray.push( materials[ uuid ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn array;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( materials[ name ] === undefined ) {\r\n\r\n\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined material', name );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn materials[ name ];\r\n\r\n\t\t}\r\n\r\n\t\tfunction getTexture( uuid ) {\r\n\r\n\t\t\tif ( textures[ uuid ] === undefined ) {\r\n\r\n\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined texture', uuid );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn textures[ uuid ];\r\n\r\n\t\t}\r\n\r\n\t\tlet geometry, material;\r\n\r\n\t\tswitch ( data.type ) {\r\n\r\n\t\t\tcase 'Scene':\r\n\r\n\t\t\t\tobject = new Scene();\r\n\r\n\t\t\t\tif ( data.background !== undefined ) {\r\n\r\n\t\t\t\t\tif ( Number.isInteger( data.background ) ) {\r\n\r\n\t\t\t\t\t\tobject.background = new Color( data.background );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tobject.background = getTexture( data.background );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( data.environment !== undefined ) {\r\n\r\n\t\t\t\t\tobject.environment = getTexture( data.environment );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( data.fog !== undefined ) {\r\n\r\n\t\t\t\t\tif ( data.fog.type === 'Fog' ) {\r\n\r\n\t\t\t\t\t\tobject.fog = new Fog( data.fog.color, data.fog.near, data.fog.far );\r\n\r\n\t\t\t\t\t} else if ( data.fog.type === 'FogExp2' ) {\r\n\r\n\t\t\t\t\t\tobject.fog = new FogExp2( data.fog.color, data.fog.density );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'PerspectiveCamera':\r\n\r\n\t\t\t\tobject = new PerspectiveCamera( data.fov, data.aspect, data.near, data.far );\r\n\r\n\t\t\t\tif ( data.focus !== undefined ) object.focus = data.focus;\r\n\t\t\t\tif ( data.zoom !== undefined ) object.zoom = data.zoom;\r\n\t\t\t\tif ( data.filmGauge !== undefined ) object.filmGauge = data.filmGauge;\r\n\t\t\t\tif ( data.filmOffset !== undefined ) object.filmOffset = data.filmOffset;\r\n\t\t\t\tif ( data.view !== undefined ) object.view = Object.assign( {}, data.view );\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'OrthographicCamera':\r\n\r\n\t\t\t\tobject = new OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );\r\n\r\n\t\t\t\tif ( data.zoom !== undefined ) object.zoom = data.zoom;\r\n\t\t\t\tif ( data.view !== undefined ) object.view = Object.assign( {}, data.view );\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'AmbientLight':\r\n\r\n\t\t\t\tobject = new AmbientLight( data.color, data.intensity );\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'DirectionalLight':\r\n\r\n\t\t\t\tobject = new DirectionalLight( data.color, data.intensity );\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'PointLight':\r\n\r\n\t\t\t\tobject = new PointLight( data.color, data.intensity, data.distance, data.decay );\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'RectAreaLight':\r\n\r\n\t\t\t\tobject = new RectAreaLight( data.color, data.intensity, data.width, data.height );\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'SpotLight':\r\n\r\n\t\t\t\tobject = new SpotLight( data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay );\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'HemisphereLight':\r\n\r\n\t\t\t\tobject = new HemisphereLight( data.color, data.groundColor, data.intensity );\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'LightProbe':\r\n\r\n\t\t\t\tobject = new LightProbe().fromJSON( data );\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'SkinnedMesh':\r\n\r\n\t\t\t\tgeometry = getGeometry( data.geometry );\r\n\t\t\t \tmaterial = getMaterial( data.material );\r\n\r\n\t\t\t\tobject = new SkinnedMesh( geometry, material );\r\n\r\n\t\t\t\tif ( data.bindMode !== undefined ) object.bindMode = data.bindMode;\r\n\t\t\t\tif ( data.bindMatrix !== undefined ) object.bindMatrix.fromArray( data.bindMatrix );\r\n\t\t\t\tif ( data.skeleton !== undefined ) object.skeleton = data.skeleton;\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'Mesh':\r\n\r\n\t\t\t\tgeometry = getGeometry( data.geometry );\r\n\t\t\t\tmaterial = getMaterial( data.material );\r\n\r\n\t\t\t\tobject = new Mesh( geometry, material );\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'InstancedMesh':\r\n\r\n\t\t\t\tgeometry = getGeometry( data.geometry );\r\n\t\t\t\tmaterial = getMaterial( data.material );\r\n\t\t\t\tconst count = data.count;\r\n\t\t\t\tconst instanceMatrix = data.instanceMatrix;\r\n\t\t\t\tconst instanceColor = data.instanceColor;\r\n\r\n\t\t\t\tobject = new InstancedMesh( geometry, material, count );\r\n\t\t\t\tobject.instanceMatrix = new InstancedBufferAttribute( new Float32Array( instanceMatrix.array ), 16 );\r\n\t\t\t\tif ( instanceColor !== undefined ) object.instanceColor = new InstancedBufferAttribute( new Float32Array( instanceColor.array ), instanceColor.itemSize );\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'LOD':\r\n\r\n\t\t\t\tobject = new LOD();\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'Line':\r\n\r\n\t\t\t\tobject = new Line( getGeometry( data.geometry ), getMaterial( data.material ) );\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'LineLoop':\r\n\r\n\t\t\t\tobject = new LineLoop( getGeometry( data.geometry ), getMaterial( data.material ) );\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'LineSegments':\r\n\r\n\t\t\t\tobject = new LineSegments( getGeometry( data.geometry ), getMaterial( data.material ) );\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'PointCloud':\r\n\t\t\tcase 'Points':\r\n\r\n\t\t\t\tobject = new Points( getGeometry( data.geometry ), getMaterial( data.material ) );\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'Sprite':\r\n\r\n\t\t\t\tobject = new Sprite( getMaterial( data.material ) );\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'Group':\r\n\r\n\t\t\t\tobject = new Group();\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'Bone':\r\n\r\n\t\t\t\tobject = new Bone();\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tdefault:\r\n\r\n\t\t\t\tobject = new Object3D();\r\n\r\n\t\t}\r\n\r\n\t\tobject.uuid = data.uuid;\r\n\r\n\t\tif ( data.name !== undefined ) object.name = data.name;\r\n\r\n\t\tif ( data.matrix !== undefined ) {\r\n\r\n\t\t\tobject.matrix.fromArray( data.matrix );\r\n\r\n\t\t\tif ( data.matrixAutoUpdate !== undefined ) object.matrixAutoUpdate = data.matrixAutoUpdate;\r\n\t\t\tif ( object.matrixAutoUpdate ) object.matrix.decompose( object.position, object.quaternion, object.scale );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tif ( data.position !== undefined ) object.position.fromArray( data.position );\r\n\t\t\tif ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );\r\n\t\t\tif ( data.quaternion !== undefined ) object.quaternion.fromArray( data.quaternion );\r\n\t\t\tif ( data.scale !== undefined ) object.scale.fromArray( data.scale );\r\n\r\n\t\t}\r\n\r\n\t\tif ( data.castShadow !== undefined ) object.castShadow = data.castShadow;\r\n\t\tif ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;\r\n\r\n\t\tif ( data.shadow ) {\r\n\r\n\t\t\tif ( data.shadow.bias !== undefined ) object.shadow.bias = data.shadow.bias;\r\n\t\t\tif ( data.shadow.normalBias !== undefined ) object.shadow.normalBias = data.shadow.normalBias;\r\n\t\t\tif ( data.shadow.radius !== undefined ) object.shadow.radius = data.shadow.radius;\r\n\t\t\tif ( data.shadow.mapSize !== undefined ) object.shadow.mapSize.fromArray( data.shadow.mapSize );\r\n\t\t\tif ( data.shadow.camera !== undefined ) object.shadow.camera = this.parseObject( data.shadow.camera );\r\n\r\n\t\t}\r\n\r\n\t\tif ( data.visible !== undefined ) object.visible = data.visible;\r\n\t\tif ( data.frustumCulled !== undefined ) object.frustumCulled = data.frustumCulled;\r\n\t\tif ( data.renderOrder !== undefined ) object.renderOrder = data.renderOrder;\r\n\t\tif ( data.userData !== undefined ) object.userData = data.userData;\r\n\t\tif ( data.layers !== undefined ) object.layers.mask = data.layers;\r\n\r\n\t\tif ( data.children !== undefined ) {\r\n\r\n\t\t\tconst children = data.children;\r\n\r\n\t\t\tfor ( let i = 0; i < children.length; i ++ ) {\r\n\r\n\t\t\t\tobject.add( this.parseObject( children[ i ], geometries, materials, textures, animations ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( data.animations !== undefined ) {\r\n\r\n\t\t\tconst objectAnimations = data.animations;\r\n\r\n\t\t\tfor ( let i = 0; i < objectAnimations.length; i ++ ) {\r\n\r\n\t\t\t\tconst uuid = objectAnimations[ i ];\r\n\r\n\t\t\t\tobject.animations.push( animations[ uuid ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( data.type === 'LOD' ) {\r\n\r\n\t\t\tif ( data.autoUpdate !== undefined ) object.autoUpdate = data.autoUpdate;\r\n\r\n\t\t\tconst levels = data.levels;\r\n\r\n\t\t\tfor ( let l = 0; l < levels.length; l ++ ) {\r\n\r\n\t\t\t\tconst level = levels[ l ];\r\n\t\t\t\tconst child = object.getObjectByProperty( 'uuid', level.object );\r\n\r\n\t\t\t\tif ( child !== undefined ) {\r\n\r\n\t\t\t\t\tobject.addLevel( child, level.distance );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn object;\r\n\r\n\t}\r\n\r\n\tbindSkeletons( object, skeletons ) {\r\n\r\n\t\tif ( Object.keys( skeletons ).length === 0 ) return;\r\n\r\n\t\tobject.traverse( function ( child ) {\r\n\r\n\t\t\tif ( child.isSkinnedMesh === true && child.skeleton !== undefined ) {\r\n\r\n\t\t\t\tconst skeleton = skeletons[ child.skeleton ];\r\n\r\n\t\t\t\tif ( skeleton === undefined ) {\r\n\r\n\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: No skeleton found with UUID:', child.skeleton );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tchild.bind( skeleton, child.bindMatrix );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} );\r\n\r\n\t}\r\n\r\n\t/* DEPRECATED */\r\n\r\n\tsetTexturePath( value ) {\r\n\r\n\t\tconsole.warn( 'THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath().' );\r\n\t\treturn this.setResourcePath( value );\r\n\r\n\t}\r\n\r\n}\r\n\r\nconst TEXTURE_MAPPING = {\r\n\tUVMapping: UVMapping,\r\n\tCubeReflectionMapping: CubeReflectionMapping,\r\n\tCubeRefractionMapping: CubeRefractionMapping,\r\n\tEquirectangularReflectionMapping: EquirectangularReflectionMapping,\r\n\tEquirectangularRefractionMapping: EquirectangularRefractionMapping,\r\n\tCubeUVReflectionMapping: CubeUVReflectionMapping,\r\n\tCubeUVRefractionMapping: CubeUVRefractionMapping\r\n};\r\n\r\nconst TEXTURE_WRAPPING = {\r\n\tRepeatWrapping: RepeatWrapping,\r\n\tClampToEdgeWrapping: ClampToEdgeWrapping,\r\n\tMirroredRepeatWrapping: MirroredRepeatWrapping\r\n};\r\n\r\nconst TEXTURE_FILTER = {\r\n\tNearestFilter: NearestFilter,\r\n\tNearestMipmapNearestFilter: NearestMipmapNearestFilter,\r\n\tNearestMipmapLinearFilter: NearestMipmapLinearFilter,\r\n\tLinearFilter: LinearFilter,\r\n\tLinearMipmapNearestFilter: LinearMipmapNearestFilter,\r\n\tLinearMipmapLinearFilter: LinearMipmapLinearFilter\r\n};\r\n\r\nexport { ObjectLoader };\r\n"]},"metadata":{},"sourceType":"module"}