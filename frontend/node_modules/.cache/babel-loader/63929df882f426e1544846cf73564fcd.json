{"ast":null,"code":"function WebGLBindingStates(gl, extensions, attributes, capabilities) {\n  const maxVertexAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);\n  const extension = capabilities.isWebGL2 ? null : extensions.get('OES_vertex_array_object');\n  const vaoAvailable = capabilities.isWebGL2 || extension !== null;\n  const bindingStates = {};\n  const defaultState = createBindingState(null);\n  let currentState = defaultState;\n\n  function setup(object, material, program, geometry, index) {\n    let updateBuffers = false;\n\n    if (vaoAvailable) {\n      const state = getBindingState(geometry, program, material);\n\n      if (currentState !== state) {\n        currentState = state;\n        bindVertexArrayObject(currentState.object);\n      }\n\n      updateBuffers = needsUpdate(geometry, index);\n      if (updateBuffers) saveCache(geometry, index);\n    } else {\n      const wireframe = material.wireframe === true;\n\n      if (currentState.geometry !== geometry.id || currentState.program !== program.id || currentState.wireframe !== wireframe) {\n        currentState.geometry = geometry.id;\n        currentState.program = program.id;\n        currentState.wireframe = wireframe;\n        updateBuffers = true;\n      }\n    }\n\n    if (object.isInstancedMesh === true) {\n      updateBuffers = true;\n    }\n\n    if (index !== null) {\n      attributes.update(index, gl.ELEMENT_ARRAY_BUFFER);\n    }\n\n    if (updateBuffers) {\n      setupVertexAttributes(object, material, program, geometry);\n\n      if (index !== null) {\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, attributes.get(index).buffer);\n      }\n    }\n  }\n\n  function createVertexArrayObject() {\n    if (capabilities.isWebGL2) return gl.createVertexArray();\n    return extension.createVertexArrayOES();\n  }\n\n  function bindVertexArrayObject(vao) {\n    if (capabilities.isWebGL2) return gl.bindVertexArray(vao);\n    return extension.bindVertexArrayOES(vao);\n  }\n\n  function deleteVertexArrayObject(vao) {\n    if (capabilities.isWebGL2) return gl.deleteVertexArray(vao);\n    return extension.deleteVertexArrayOES(vao);\n  }\n\n  function getBindingState(geometry, program, material) {\n    const wireframe = material.wireframe === true;\n    let programMap = bindingStates[geometry.id];\n\n    if (programMap === undefined) {\n      programMap = {};\n      bindingStates[geometry.id] = programMap;\n    }\n\n    let stateMap = programMap[program.id];\n\n    if (stateMap === undefined) {\n      stateMap = {};\n      programMap[program.id] = stateMap;\n    }\n\n    let state = stateMap[wireframe];\n\n    if (state === undefined) {\n      state = createBindingState(createVertexArrayObject());\n      stateMap[wireframe] = state;\n    }\n\n    return state;\n  }\n\n  function createBindingState(vao) {\n    const newAttributes = [];\n    const enabledAttributes = [];\n    const attributeDivisors = [];\n\n    for (let i = 0; i < maxVertexAttributes; i++) {\n      newAttributes[i] = 0;\n      enabledAttributes[i] = 0;\n      attributeDivisors[i] = 0;\n    }\n\n    return {\n      // for backward compatibility on non-VAO support browser\n      geometry: null,\n      program: null,\n      wireframe: false,\n      newAttributes: newAttributes,\n      enabledAttributes: enabledAttributes,\n      attributeDivisors: attributeDivisors,\n      object: vao,\n      attributes: {},\n      index: null\n    };\n  }\n\n  function needsUpdate(geometry, index) {\n    const cachedAttributes = currentState.attributes;\n    const geometryAttributes = geometry.attributes;\n    let attributesNum = 0;\n\n    for (const key in geometryAttributes) {\n      const cachedAttribute = cachedAttributes[key];\n      const geometryAttribute = geometryAttributes[key];\n      if (cachedAttribute === undefined) return true;\n      if (cachedAttribute.attribute !== geometryAttribute) return true;\n      if (cachedAttribute.data !== geometryAttribute.data) return true;\n      attributesNum++;\n    }\n\n    if (currentState.attributesNum !== attributesNum) return true;\n    if (currentState.index !== index) return true;\n    return false;\n  }\n\n  function saveCache(geometry, index) {\n    const cache = {};\n    const attributes = geometry.attributes;\n    let attributesNum = 0;\n\n    for (const key in attributes) {\n      const attribute = attributes[key];\n      const data = {};\n      data.attribute = attribute;\n\n      if (attribute.data) {\n        data.data = attribute.data;\n      }\n\n      cache[key] = data;\n      attributesNum++;\n    }\n\n    currentState.attributes = cache;\n    currentState.attributesNum = attributesNum;\n    currentState.index = index;\n  }\n\n  function initAttributes() {\n    const newAttributes = currentState.newAttributes;\n\n    for (let i = 0, il = newAttributes.length; i < il; i++) {\n      newAttributes[i] = 0;\n    }\n  }\n\n  function enableAttribute(attribute) {\n    enableAttributeAndDivisor(attribute, 0);\n  }\n\n  function enableAttributeAndDivisor(attribute, meshPerAttribute) {\n    const newAttributes = currentState.newAttributes;\n    const enabledAttributes = currentState.enabledAttributes;\n    const attributeDivisors = currentState.attributeDivisors;\n    newAttributes[attribute] = 1;\n\n    if (enabledAttributes[attribute] === 0) {\n      gl.enableVertexAttribArray(attribute);\n      enabledAttributes[attribute] = 1;\n    }\n\n    if (attributeDivisors[attribute] !== meshPerAttribute) {\n      const extension = capabilities.isWebGL2 ? gl : extensions.get('ANGLE_instanced_arrays');\n      extension[capabilities.isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE'](attribute, meshPerAttribute);\n      attributeDivisors[attribute] = meshPerAttribute;\n    }\n  }\n\n  function disableUnusedAttributes() {\n    const newAttributes = currentState.newAttributes;\n    const enabledAttributes = currentState.enabledAttributes;\n\n    for (let i = 0, il = enabledAttributes.length; i < il; i++) {\n      if (enabledAttributes[i] !== newAttributes[i]) {\n        gl.disableVertexAttribArray(i);\n        enabledAttributes[i] = 0;\n      }\n    }\n  }\n\n  function vertexAttribPointer(index, size, type, normalized, stride, offset) {\n    if (capabilities.isWebGL2 === true && (type === gl.INT || type === gl.UNSIGNED_INT)) {\n      gl.vertexAttribIPointer(index, size, type, stride, offset);\n    } else {\n      gl.vertexAttribPointer(index, size, type, normalized, stride, offset);\n    }\n  }\n\n  function setupVertexAttributes(object, material, program, geometry) {\n    if (capabilities.isWebGL2 === false && (object.isInstancedMesh || geometry.isInstancedBufferGeometry)) {\n      if (extensions.get('ANGLE_instanced_arrays') === null) return;\n    }\n\n    initAttributes();\n    const geometryAttributes = geometry.attributes;\n    const programAttributes = program.getAttributes();\n    const materialDefaultAttributeValues = material.defaultAttributeValues;\n\n    for (const name in programAttributes) {\n      const programAttribute = programAttributes[name];\n\n      if (programAttribute.location >= 0) {\n        let geometryAttribute = geometryAttributes[name];\n\n        if (geometryAttribute === undefined) {\n          if (name === 'instanceMatrix' && object.instanceMatrix) geometryAttribute = object.instanceMatrix;\n          if (name === 'instanceColor' && object.instanceColor) geometryAttribute = object.instanceColor;\n        }\n\n        if (geometryAttribute !== undefined) {\n          const normalized = geometryAttribute.normalized;\n          const size = geometryAttribute.itemSize;\n          const attribute = attributes.get(geometryAttribute); // TODO Attribute may not be available on context restore\n\n          if (attribute === undefined) continue;\n          const buffer = attribute.buffer;\n          const type = attribute.type;\n          const bytesPerElement = attribute.bytesPerElement;\n\n          if (geometryAttribute.isInterleavedBufferAttribute) {\n            const data = geometryAttribute.data;\n            const stride = data.stride;\n            const offset = geometryAttribute.offset;\n\n            if (data.isInstancedInterleavedBuffer) {\n              for (let i = 0; i < programAttribute.locationSize; i++) {\n                enableAttributeAndDivisor(programAttribute.location + i, data.meshPerAttribute);\n              }\n\n              if (object.isInstancedMesh !== true && geometry._maxInstanceCount === undefined) {\n                geometry._maxInstanceCount = data.meshPerAttribute * data.count;\n              }\n            } else {\n              for (let i = 0; i < programAttribute.locationSize; i++) {\n                enableAttribute(programAttribute.location + i);\n              }\n            }\n\n            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n\n            for (let i = 0; i < programAttribute.locationSize; i++) {\n              vertexAttribPointer(programAttribute.location + i, size / programAttribute.locationSize, type, normalized, stride * bytesPerElement, (offset + size / programAttribute.locationSize * i) * bytesPerElement);\n            }\n          } else {\n            if (geometryAttribute.isInstancedBufferAttribute) {\n              for (let i = 0; i < programAttribute.locationSize; i++) {\n                enableAttributeAndDivisor(programAttribute.location + i, geometryAttribute.meshPerAttribute);\n              }\n\n              if (object.isInstancedMesh !== true && geometry._maxInstanceCount === undefined) {\n                geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;\n              }\n            } else {\n              for (let i = 0; i < programAttribute.locationSize; i++) {\n                enableAttribute(programAttribute.location + i);\n              }\n            }\n\n            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n\n            for (let i = 0; i < programAttribute.locationSize; i++) {\n              vertexAttribPointer(programAttribute.location + i, size / programAttribute.locationSize, type, normalized, size * bytesPerElement, size / programAttribute.locationSize * i * bytesPerElement);\n            }\n          }\n        } else if (materialDefaultAttributeValues !== undefined) {\n          const value = materialDefaultAttributeValues[name];\n\n          if (value !== undefined) {\n            switch (value.length) {\n              case 2:\n                gl.vertexAttrib2fv(programAttribute.location, value);\n                break;\n\n              case 3:\n                gl.vertexAttrib3fv(programAttribute.location, value);\n                break;\n\n              case 4:\n                gl.vertexAttrib4fv(programAttribute.location, value);\n                break;\n\n              default:\n                gl.vertexAttrib1fv(programAttribute.location, value);\n            }\n          }\n        }\n      }\n    }\n\n    disableUnusedAttributes();\n  }\n\n  function dispose() {\n    reset();\n\n    for (const geometryId in bindingStates) {\n      const programMap = bindingStates[geometryId];\n\n      for (const programId in programMap) {\n        const stateMap = programMap[programId];\n\n        for (const wireframe in stateMap) {\n          deleteVertexArrayObject(stateMap[wireframe].object);\n          delete stateMap[wireframe];\n        }\n\n        delete programMap[programId];\n      }\n\n      delete bindingStates[geometryId];\n    }\n  }\n\n  function releaseStatesOfGeometry(geometry) {\n    if (bindingStates[geometry.id] === undefined) return;\n    const programMap = bindingStates[geometry.id];\n\n    for (const programId in programMap) {\n      const stateMap = programMap[programId];\n\n      for (const wireframe in stateMap) {\n        deleteVertexArrayObject(stateMap[wireframe].object);\n        delete stateMap[wireframe];\n      }\n\n      delete programMap[programId];\n    }\n\n    delete bindingStates[geometry.id];\n  }\n\n  function releaseStatesOfProgram(program) {\n    for (const geometryId in bindingStates) {\n      const programMap = bindingStates[geometryId];\n      if (programMap[program.id] === undefined) continue;\n      const stateMap = programMap[program.id];\n\n      for (const wireframe in stateMap) {\n        deleteVertexArrayObject(stateMap[wireframe].object);\n        delete stateMap[wireframe];\n      }\n\n      delete programMap[program.id];\n    }\n  }\n\n  function reset() {\n    resetDefaultState();\n    if (currentState === defaultState) return;\n    currentState = defaultState;\n    bindVertexArrayObject(currentState.object);\n  } // for backward-compatilibity\n\n\n  function resetDefaultState() {\n    defaultState.geometry = null;\n    defaultState.program = null;\n    defaultState.wireframe = false;\n  }\n\n  return {\n    setup: setup,\n    reset: reset,\n    resetDefaultState: resetDefaultState,\n    dispose: dispose,\n    releaseStatesOfGeometry: releaseStatesOfGeometry,\n    releaseStatesOfProgram: releaseStatesOfProgram,\n    initAttributes: initAttributes,\n    enableAttribute: enableAttribute,\n    disableUnusedAttributes: disableUnusedAttributes\n  };\n}\n\nexport { WebGLBindingStates };","map":{"version":3,"sources":["C:/Users/dell/Desktop/projektlogin/vue-3-authentication-jwt/src/games/three/src/renderers/webgl/WebGLBindingStates.js"],"names":["WebGLBindingStates","gl","extensions","attributes","capabilities","maxVertexAttributes","getParameter","MAX_VERTEX_ATTRIBS","extension","isWebGL2","get","vaoAvailable","bindingStates","defaultState","createBindingState","currentState","setup","object","material","program","geometry","index","updateBuffers","state","getBindingState","bindVertexArrayObject","needsUpdate","saveCache","wireframe","id","isInstancedMesh","update","ELEMENT_ARRAY_BUFFER","setupVertexAttributes","bindBuffer","buffer","createVertexArrayObject","createVertexArray","createVertexArrayOES","vao","bindVertexArray","bindVertexArrayOES","deleteVertexArrayObject","deleteVertexArray","deleteVertexArrayOES","programMap","undefined","stateMap","newAttributes","enabledAttributes","attributeDivisors","i","cachedAttributes","geometryAttributes","attributesNum","key","cachedAttribute","geometryAttribute","attribute","data","cache","initAttributes","il","length","enableAttribute","enableAttributeAndDivisor","meshPerAttribute","enableVertexAttribArray","disableUnusedAttributes","disableVertexAttribArray","vertexAttribPointer","size","type","normalized","stride","offset","INT","UNSIGNED_INT","vertexAttribIPointer","isInstancedBufferGeometry","programAttributes","getAttributes","materialDefaultAttributeValues","defaultAttributeValues","name","programAttribute","location","instanceMatrix","instanceColor","itemSize","bytesPerElement","isInterleavedBufferAttribute","isInstancedInterleavedBuffer","locationSize","_maxInstanceCount","count","ARRAY_BUFFER","isInstancedBufferAttribute","value","vertexAttrib2fv","vertexAttrib3fv","vertexAttrib4fv","vertexAttrib1fv","dispose","reset","geometryId","programId","releaseStatesOfGeometry","releaseStatesOfProgram","resetDefaultState"],"mappings":"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","sourcesContent":["function WebGLBindingStates( gl, extensions, attributes, capabilities ) {\r\n\r\n\tconst maxVertexAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );\r\n\r\n\tconst extension = capabilities.isWebGL2 ? null : extensions.get( 'OES_vertex_array_object' );\r\n\tconst vaoAvailable = capabilities.isWebGL2 || extension !== null;\r\n\r\n\tconst bindingStates = {};\r\n\r\n\tconst defaultState = createBindingState( null );\r\n\tlet currentState = defaultState;\r\n\r\n\tfunction setup( object, material, program, geometry, index ) {\r\n\r\n\t\tlet updateBuffers = false;\r\n\r\n\t\tif ( vaoAvailable ) {\r\n\r\n\t\t\tconst state = getBindingState( geometry, program, material );\r\n\r\n\t\t\tif ( currentState !== state ) {\r\n\r\n\t\t\t\tcurrentState = state;\r\n\t\t\t\tbindVertexArrayObject( currentState.object );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tupdateBuffers = needsUpdate( geometry, index );\r\n\r\n\t\t\tif ( updateBuffers ) saveCache( geometry, index );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tconst wireframe = ( material.wireframe === true );\r\n\r\n\t\t\tif ( currentState.geometry !== geometry.id ||\r\n\t\t\t\tcurrentState.program !== program.id ||\r\n\t\t\t\tcurrentState.wireframe !== wireframe ) {\r\n\r\n\t\t\t\tcurrentState.geometry = geometry.id;\r\n\t\t\t\tcurrentState.program = program.id;\r\n\t\t\t\tcurrentState.wireframe = wireframe;\r\n\r\n\t\t\t\tupdateBuffers = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( object.isInstancedMesh === true ) {\r\n\r\n\t\t\tupdateBuffers = true;\r\n\r\n\t\t}\r\n\r\n\t\tif ( index !== null ) {\r\n\r\n\t\t\tattributes.update( index, gl.ELEMENT_ARRAY_BUFFER );\r\n\r\n\t\t}\r\n\r\n\t\tif ( updateBuffers ) {\r\n\r\n\t\t\tsetupVertexAttributes( object, material, program, geometry );\r\n\r\n\t\t\tif ( index !== null ) {\r\n\r\n\t\t\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, attributes.get( index ).buffer );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction createVertexArrayObject() {\r\n\r\n\t\tif ( capabilities.isWebGL2 ) return gl.createVertexArray();\r\n\r\n\t\treturn extension.createVertexArrayOES();\r\n\r\n\t}\r\n\r\n\tfunction bindVertexArrayObject( vao ) {\r\n\r\n\t\tif ( capabilities.isWebGL2 ) return gl.bindVertexArray( vao );\r\n\r\n\t\treturn extension.bindVertexArrayOES( vao );\r\n\r\n\t}\r\n\r\n\tfunction deleteVertexArrayObject( vao ) {\r\n\r\n\t\tif ( capabilities.isWebGL2 ) return gl.deleteVertexArray( vao );\r\n\r\n\t\treturn extension.deleteVertexArrayOES( vao );\r\n\r\n\t}\r\n\r\n\tfunction getBindingState( geometry, program, material ) {\r\n\r\n\t\tconst wireframe = ( material.wireframe === true );\r\n\r\n\t\tlet programMap = bindingStates[ geometry.id ];\r\n\r\n\t\tif ( programMap === undefined ) {\r\n\r\n\t\t\tprogramMap = {};\r\n\t\t\tbindingStates[ geometry.id ] = programMap;\r\n\r\n\t\t}\r\n\r\n\t\tlet stateMap = programMap[ program.id ];\r\n\r\n\t\tif ( stateMap === undefined ) {\r\n\r\n\t\t\tstateMap = {};\r\n\t\t\tprogramMap[ program.id ] = stateMap;\r\n\r\n\t\t}\r\n\r\n\t\tlet state = stateMap[ wireframe ];\r\n\r\n\t\tif ( state === undefined ) {\r\n\r\n\t\t\tstate = createBindingState( createVertexArrayObject() );\r\n\t\t\tstateMap[ wireframe ] = state;\r\n\r\n\t\t}\r\n\r\n\t\treturn state;\r\n\r\n\t}\r\n\r\n\tfunction createBindingState( vao ) {\r\n\r\n\t\tconst newAttributes = [];\r\n\t\tconst enabledAttributes = [];\r\n\t\tconst attributeDivisors = [];\r\n\r\n\t\tfor ( let i = 0; i < maxVertexAttributes; i ++ ) {\r\n\r\n\t\t\tnewAttributes[ i ] = 0;\r\n\t\t\tenabledAttributes[ i ] = 0;\r\n\t\t\tattributeDivisors[ i ] = 0;\r\n\r\n\t\t}\r\n\r\n\t\treturn {\r\n\r\n\t\t\t// for backward compatibility on non-VAO support browser\r\n\t\t\tgeometry: null,\r\n\t\t\tprogram: null,\r\n\t\t\twireframe: false,\r\n\r\n\t\t\tnewAttributes: newAttributes,\r\n\t\t\tenabledAttributes: enabledAttributes,\r\n\t\t\tattributeDivisors: attributeDivisors,\r\n\t\t\tobject: vao,\r\n\t\t\tattributes: {},\r\n\t\t\tindex: null\r\n\r\n\t\t};\r\n\r\n\t}\r\n\r\n\tfunction needsUpdate( geometry, index ) {\r\n\r\n\t\tconst cachedAttributes = currentState.attributes;\r\n\t\tconst geometryAttributes = geometry.attributes;\r\n\r\n\t\tlet attributesNum = 0;\r\n\r\n\t\tfor ( const key in geometryAttributes ) {\r\n\r\n\t\t\tconst cachedAttribute = cachedAttributes[ key ];\r\n\t\t\tconst geometryAttribute = geometryAttributes[ key ];\r\n\r\n\t\t\tif ( cachedAttribute === undefined ) return true;\r\n\r\n\t\t\tif ( cachedAttribute.attribute !== geometryAttribute ) return true;\r\n\r\n\t\t\tif ( cachedAttribute.data !== geometryAttribute.data ) return true;\r\n\r\n\t\t\tattributesNum ++;\r\n\r\n\t\t}\r\n\r\n\t\tif ( currentState.attributesNum !== attributesNum ) return true;\r\n\r\n\t\tif ( currentState.index !== index ) return true;\r\n\r\n\t\treturn false;\r\n\r\n\t}\r\n\r\n\tfunction saveCache( geometry, index ) {\r\n\r\n\t\tconst cache = {};\r\n\t\tconst attributes = geometry.attributes;\r\n\t\tlet attributesNum = 0;\r\n\r\n\t\tfor ( const key in attributes ) {\r\n\r\n\t\t\tconst attribute = attributes[ key ];\r\n\r\n\t\t\tconst data = {};\r\n\t\t\tdata.attribute = attribute;\r\n\r\n\t\t\tif ( attribute.data ) {\r\n\r\n\t\t\t\tdata.data = attribute.data;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tcache[ key ] = data;\r\n\r\n\t\t\tattributesNum ++;\r\n\r\n\t\t}\r\n\r\n\t\tcurrentState.attributes = cache;\r\n\t\tcurrentState.attributesNum = attributesNum;\r\n\r\n\t\tcurrentState.index = index;\r\n\r\n\t}\r\n\r\n\tfunction initAttributes() {\r\n\r\n\t\tconst newAttributes = currentState.newAttributes;\r\n\r\n\t\tfor ( let i = 0, il = newAttributes.length; i < il; i ++ ) {\r\n\r\n\t\t\tnewAttributes[ i ] = 0;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction enableAttribute( attribute ) {\r\n\r\n\t\tenableAttributeAndDivisor( attribute, 0 );\r\n\r\n\t}\r\n\r\n\tfunction enableAttributeAndDivisor( attribute, meshPerAttribute ) {\r\n\r\n\t\tconst newAttributes = currentState.newAttributes;\r\n\t\tconst enabledAttributes = currentState.enabledAttributes;\r\n\t\tconst attributeDivisors = currentState.attributeDivisors;\r\n\r\n\t\tnewAttributes[ attribute ] = 1;\r\n\r\n\t\tif ( enabledAttributes[ attribute ] === 0 ) {\r\n\r\n\t\t\tgl.enableVertexAttribArray( attribute );\r\n\t\t\tenabledAttributes[ attribute ] = 1;\r\n\r\n\t\t}\r\n\r\n\t\tif ( attributeDivisors[ attribute ] !== meshPerAttribute ) {\r\n\r\n\t\t\tconst extension = capabilities.isWebGL2 ? gl : extensions.get( 'ANGLE_instanced_arrays' );\r\n\r\n\t\t\textension[ capabilities.isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE' ]( attribute, meshPerAttribute );\r\n\t\t\tattributeDivisors[ attribute ] = meshPerAttribute;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction disableUnusedAttributes() {\r\n\r\n\t\tconst newAttributes = currentState.newAttributes;\r\n\t\tconst enabledAttributes = currentState.enabledAttributes;\r\n\r\n\t\tfor ( let i = 0, il = enabledAttributes.length; i < il; i ++ ) {\r\n\r\n\t\t\tif ( enabledAttributes[ i ] !== newAttributes[ i ] ) {\r\n\r\n\t\t\t\tgl.disableVertexAttribArray( i );\r\n\t\t\t\tenabledAttributes[ i ] = 0;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction vertexAttribPointer( index, size, type, normalized, stride, offset ) {\r\n\r\n\t\tif ( capabilities.isWebGL2 === true && ( type === gl.INT || type === gl.UNSIGNED_INT ) ) {\r\n\r\n\t\t\tgl.vertexAttribIPointer( index, size, type, stride, offset );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tgl.vertexAttribPointer( index, size, type, normalized, stride, offset );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction setupVertexAttributes( object, material, program, geometry ) {\r\n\r\n\t\tif ( capabilities.isWebGL2 === false && ( object.isInstancedMesh || geometry.isInstancedBufferGeometry ) ) {\r\n\r\n\t\t\tif ( extensions.get( 'ANGLE_instanced_arrays' ) === null ) return;\r\n\r\n\t\t}\r\n\r\n\t\tinitAttributes();\r\n\r\n\t\tconst geometryAttributes = geometry.attributes;\r\n\r\n\t\tconst programAttributes = program.getAttributes();\r\n\r\n\t\tconst materialDefaultAttributeValues = material.defaultAttributeValues;\r\n\r\n\t\tfor ( const name in programAttributes ) {\r\n\r\n\t\t\tconst programAttribute = programAttributes[ name ];\r\n\r\n\t\t\tif ( programAttribute.location >= 0 ) {\r\n\r\n\t\t\t\tlet geometryAttribute = geometryAttributes[ name ];\r\n\r\n\t\t\t\tif ( geometryAttribute === undefined ) {\r\n\r\n\t\t\t\t\tif ( name === 'instanceMatrix' && object.instanceMatrix ) geometryAttribute = object.instanceMatrix;\r\n\t\t\t\t\tif ( name === 'instanceColor' && object.instanceColor ) geometryAttribute = object.instanceColor;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( geometryAttribute !== undefined ) {\r\n\r\n\t\t\t\t\tconst normalized = geometryAttribute.normalized;\r\n\t\t\t\t\tconst size = geometryAttribute.itemSize;\r\n\r\n\t\t\t\t\tconst attribute = attributes.get( geometryAttribute );\r\n\r\n\t\t\t\t\t// TODO Attribute may not be available on context restore\r\n\r\n\t\t\t\t\tif ( attribute === undefined ) continue;\r\n\r\n\t\t\t\t\tconst buffer = attribute.buffer;\r\n\t\t\t\t\tconst type = attribute.type;\r\n\t\t\t\t\tconst bytesPerElement = attribute.bytesPerElement;\r\n\r\n\t\t\t\t\tif ( geometryAttribute.isInterleavedBufferAttribute ) {\r\n\r\n\t\t\t\t\t\tconst data = geometryAttribute.data;\r\n\t\t\t\t\t\tconst stride = data.stride;\r\n\t\t\t\t\t\tconst offset = geometryAttribute.offset;\r\n\r\n\t\t\t\t\t\tif ( data.isInstancedInterleavedBuffer ) {\r\n\r\n\t\t\t\t\t\t\tfor ( let i = 0; i < programAttribute.locationSize; i ++ ) {\r\n\r\n\t\t\t\t\t\t\t\tenableAttributeAndDivisor( programAttribute.location + i, data.meshPerAttribute );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif ( object.isInstancedMesh !== true && geometry._maxInstanceCount === undefined ) {\r\n\r\n\t\t\t\t\t\t\t\tgeometry._maxInstanceCount = data.meshPerAttribute * data.count;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tfor ( let i = 0; i < programAttribute.locationSize; i ++ ) {\r\n\r\n\t\t\t\t\t\t\t\tenableAttribute( programAttribute.location + i );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tgl.bindBuffer( gl.ARRAY_BUFFER, buffer );\r\n\r\n\t\t\t\t\t\tfor ( let i = 0; i < programAttribute.locationSize; i ++ ) {\r\n\r\n\t\t\t\t\t\t\tvertexAttribPointer(\r\n\t\t\t\t\t\t\t\tprogramAttribute.location + i,\r\n\t\t\t\t\t\t\t\tsize / programAttribute.locationSize,\r\n\t\t\t\t\t\t\t\ttype,\r\n\t\t\t\t\t\t\t\tnormalized,\r\n\t\t\t\t\t\t\t\tstride * bytesPerElement,\r\n\t\t\t\t\t\t\t\t( offset + ( size / programAttribute.locationSize ) * i ) * bytesPerElement\r\n\t\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tif ( geometryAttribute.isInstancedBufferAttribute ) {\r\n\r\n\t\t\t\t\t\t\tfor ( let i = 0; i < programAttribute.locationSize; i ++ ) {\r\n\r\n\t\t\t\t\t\t\t\tenableAttributeAndDivisor( programAttribute.location + i, geometryAttribute.meshPerAttribute );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif ( object.isInstancedMesh !== true && geometry._maxInstanceCount === undefined ) {\r\n\r\n\t\t\t\t\t\t\t\tgeometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tfor ( let i = 0; i < programAttribute.locationSize; i ++ ) {\r\n\r\n\t\t\t\t\t\t\t\tenableAttribute( programAttribute.location + i );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tgl.bindBuffer( gl.ARRAY_BUFFER, buffer );\r\n\r\n\t\t\t\t\t\tfor ( let i = 0; i < programAttribute.locationSize; i ++ ) {\r\n\r\n\t\t\t\t\t\t\tvertexAttribPointer(\r\n\t\t\t\t\t\t\t\tprogramAttribute.location + i,\r\n\t\t\t\t\t\t\t\tsize / programAttribute.locationSize,\r\n\t\t\t\t\t\t\t\ttype,\r\n\t\t\t\t\t\t\t\tnormalized,\r\n\t\t\t\t\t\t\t\tsize * bytesPerElement,\r\n\t\t\t\t\t\t\t\t( size / programAttribute.locationSize ) * i * bytesPerElement\r\n\t\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else if ( materialDefaultAttributeValues !== undefined ) {\r\n\r\n\t\t\t\t\tconst value = materialDefaultAttributeValues[ name ];\r\n\r\n\t\t\t\t\tif ( value !== undefined ) {\r\n\r\n\t\t\t\t\t\tswitch ( value.length ) {\r\n\r\n\t\t\t\t\t\t\tcase 2:\r\n\t\t\t\t\t\t\t\tgl.vertexAttrib2fv( programAttribute.location, value );\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\tcase 3:\r\n\t\t\t\t\t\t\t\tgl.vertexAttrib3fv( programAttribute.location, value );\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\tcase 4:\r\n\t\t\t\t\t\t\t\tgl.vertexAttrib4fv( programAttribute.location, value );\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\t\tgl.vertexAttrib1fv( programAttribute.location, value );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tdisableUnusedAttributes();\r\n\r\n\t}\r\n\r\n\tfunction dispose() {\r\n\r\n\t\treset();\r\n\r\n\t\tfor ( const geometryId in bindingStates ) {\r\n\r\n\t\t\tconst programMap = bindingStates[ geometryId ];\r\n\r\n\t\t\tfor ( const programId in programMap ) {\r\n\r\n\t\t\t\tconst stateMap = programMap[ programId ];\r\n\r\n\t\t\t\tfor ( const wireframe in stateMap ) {\r\n\r\n\t\t\t\t\tdeleteVertexArrayObject( stateMap[ wireframe ].object );\r\n\r\n\t\t\t\t\tdelete stateMap[ wireframe ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tdelete programMap[ programId ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tdelete bindingStates[ geometryId ];\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction releaseStatesOfGeometry( geometry ) {\r\n\r\n\t\tif ( bindingStates[ geometry.id ] === undefined ) return;\r\n\r\n\t\tconst programMap = bindingStates[ geometry.id ];\r\n\r\n\t\tfor ( const programId in programMap ) {\r\n\r\n\t\t\tconst stateMap = programMap[ programId ];\r\n\r\n\t\t\tfor ( const wireframe in stateMap ) {\r\n\r\n\t\t\t\tdeleteVertexArrayObject( stateMap[ wireframe ].object );\r\n\r\n\t\t\t\tdelete stateMap[ wireframe ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tdelete programMap[ programId ];\r\n\r\n\t\t}\r\n\r\n\t\tdelete bindingStates[ geometry.id ];\r\n\r\n\t}\r\n\r\n\tfunction releaseStatesOfProgram( program ) {\r\n\r\n\t\tfor ( const geometryId in bindingStates ) {\r\n\r\n\t\t\tconst programMap = bindingStates[ geometryId ];\r\n\r\n\t\t\tif ( programMap[ program.id ] === undefined ) continue;\r\n\r\n\t\t\tconst stateMap = programMap[ program.id ];\r\n\r\n\t\t\tfor ( const wireframe in stateMap ) {\r\n\r\n\t\t\t\tdeleteVertexArrayObject( stateMap[ wireframe ].object );\r\n\r\n\t\t\t\tdelete stateMap[ wireframe ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tdelete programMap[ program.id ];\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction reset() {\r\n\r\n\t\tresetDefaultState();\r\n\r\n\t\tif ( currentState === defaultState ) return;\r\n\r\n\t\tcurrentState = defaultState;\r\n\t\tbindVertexArrayObject( currentState.object );\r\n\r\n\t}\r\n\r\n\t// for backward-compatilibity\r\n\r\n\tfunction resetDefaultState() {\r\n\r\n\t\tdefaultState.geometry = null;\r\n\t\tdefaultState.program = null;\r\n\t\tdefaultState.wireframe = false;\r\n\r\n\t}\r\n\r\n\treturn {\r\n\r\n\t\tsetup: setup,\r\n\t\treset: reset,\r\n\t\tresetDefaultState: resetDefaultState,\r\n\t\tdispose: dispose,\r\n\t\treleaseStatesOfGeometry: releaseStatesOfGeometry,\r\n\t\treleaseStatesOfProgram: releaseStatesOfProgram,\r\n\r\n\t\tinitAttributes: initAttributes,\r\n\t\tenableAttribute: enableAttribute,\r\n\t\tdisableUnusedAttributes: disableUnusedAttributes\r\n\r\n\t};\r\n\r\n}\r\n\r\n\r\nexport { WebGLBindingStates };\r\n"]},"metadata":{},"sourceType":"module"}