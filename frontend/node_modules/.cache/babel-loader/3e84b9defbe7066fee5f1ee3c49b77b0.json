{"ast":null,"code":"import * as MathUtils from '../../math/MathUtils.js';\nimport { Vector2 } from '../../math/Vector2.js';\nimport { Vector3 } from '../../math/Vector3.js';\nimport { Matrix4 } from '../../math/Matrix4.js';\n/**\r\n * Extensible curve object.\r\n *\r\n * Some common of curve methods:\r\n * .getPoint( t, optionalTarget ), .getTangent( t, optionalTarget )\r\n * .getPointAt( u, optionalTarget ), .getTangentAt( u, optionalTarget )\r\n * .getPoints(), .getSpacedPoints()\r\n * .getLength()\r\n * .updateArcLengths()\r\n *\r\n * This following curves inherit from THREE.Curve:\r\n *\r\n * -- 2D curves --\r\n * THREE.ArcCurve\r\n * THREE.CubicBezierCurve\r\n * THREE.EllipseCurve\r\n * THREE.LineCurve\r\n * THREE.QuadraticBezierCurve\r\n * THREE.SplineCurve\r\n *\r\n * -- 3D curves --\r\n * THREE.CatmullRomCurve3\r\n * THREE.CubicBezierCurve3\r\n * THREE.LineCurve3\r\n * THREE.QuadraticBezierCurve3\r\n *\r\n * A series of curves can be represented as a THREE.CurvePath.\r\n *\r\n **/\n\nclass Curve {\n  constructor() {\n    this.type = 'Curve';\n    this.arcLengthDivisions = 200;\n  } // Virtual base class method to overwrite and implement in subclasses\n  //\t- t [0 .. 1]\n\n\n  getPoint() {\n    console.warn('THREE.Curve: .getPoint() not implemented.');\n    return null;\n  } // Get point at relative position in curve according to arc length\n  // - u [0 .. 1]\n\n\n  getPointAt(u, optionalTarget) {\n    const t = this.getUtoTmapping(u);\n    return this.getPoint(t, optionalTarget);\n  } // Get sequence of points using getPoint( t )\n\n\n  getPoints(divisions = 5) {\n    const points = [];\n\n    for (let d = 0; d <= divisions; d++) {\n      points.push(this.getPoint(d / divisions));\n    }\n\n    return points;\n  } // Get sequence of points using getPointAt( u )\n\n\n  getSpacedPoints(divisions = 5) {\n    const points = [];\n\n    for (let d = 0; d <= divisions; d++) {\n      points.push(this.getPointAt(d / divisions));\n    }\n\n    return points;\n  } // Get total curve arc length\n\n\n  getLength() {\n    const lengths = this.getLengths();\n    return lengths[lengths.length - 1];\n  } // Get list of cumulative segment lengths\n\n\n  getLengths(divisions = this.arcLengthDivisions) {\n    if (this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) {\n      return this.cacheArcLengths;\n    }\n\n    this.needsUpdate = false;\n    const cache = [];\n    let current,\n        last = this.getPoint(0);\n    let sum = 0;\n    cache.push(0);\n\n    for (let p = 1; p <= divisions; p++) {\n      current = this.getPoint(p / divisions);\n      sum += current.distanceTo(last);\n      cache.push(sum);\n      last = current;\n    }\n\n    this.cacheArcLengths = cache;\n    return cache; // { sums: cache, sum: sum }; Sum is in the last element.\n  }\n\n  updateArcLengths() {\n    this.needsUpdate = true;\n    this.getLengths();\n  } // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant\n\n\n  getUtoTmapping(u, distance) {\n    const arcLengths = this.getLengths();\n    let i = 0;\n    const il = arcLengths.length;\n    let targetArcLength; // The targeted u distance value to get\n\n    if (distance) {\n      targetArcLength = distance;\n    } else {\n      targetArcLength = u * arcLengths[il - 1];\n    } // binary search for the index with largest value smaller than target u distance\n\n\n    let low = 0,\n        high = il - 1,\n        comparison;\n\n    while (low <= high) {\n      i = Math.floor(low + (high - low) / 2); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats\n\n      comparison = arcLengths[i] - targetArcLength;\n\n      if (comparison < 0) {\n        low = i + 1;\n      } else if (comparison > 0) {\n        high = i - 1;\n      } else {\n        high = i;\n        break; // DONE\n      }\n    }\n\n    i = high;\n\n    if (arcLengths[i] === targetArcLength) {\n      return i / (il - 1);\n    } // we could get finer grain at lengths, or use simple interpolation between two points\n\n\n    const lengthBefore = arcLengths[i];\n    const lengthAfter = arcLengths[i + 1];\n    const segmentLength = lengthAfter - lengthBefore; // determine where we are between the 'before' and 'after' points\n\n    const segmentFraction = (targetArcLength - lengthBefore) / segmentLength; // add that fractional amount to t\n\n    const t = (i + segmentFraction) / (il - 1);\n    return t;\n  } // Returns a unit vector tangent at t\n  // In case any sub curve does not implement its tangent derivation,\n  // 2 points a small delta apart will be used to find its gradient\n  // which seems to give a reasonable approximation\n\n\n  getTangent(t, optionalTarget) {\n    const delta = 0.0001;\n    let t1 = t - delta;\n    let t2 = t + delta; // Capping in case of danger\n\n    if (t1 < 0) t1 = 0;\n    if (t2 > 1) t2 = 1;\n    const pt1 = this.getPoint(t1);\n    const pt2 = this.getPoint(t2);\n    const tangent = optionalTarget || (pt1.isVector2 ? new Vector2() : new Vector3());\n    tangent.copy(pt2).sub(pt1).normalize();\n    return tangent;\n  }\n\n  getTangentAt(u, optionalTarget) {\n    const t = this.getUtoTmapping(u);\n    return this.getTangent(t, optionalTarget);\n  }\n\n  computeFrenetFrames(segments, closed) {\n    // see http://www.cs.indiana.edu/pub/techreports/TR425.pdf\n    const normal = new Vector3();\n    const tangents = [];\n    const normals = [];\n    const binormals = [];\n    const vec = new Vector3();\n    const mat = new Matrix4(); // compute the tangent vectors for each segment on the curve\n\n    for (let i = 0; i <= segments; i++) {\n      const u = i / segments;\n      tangents[i] = this.getTangentAt(u, new Vector3());\n    } // select an initial normal vector perpendicular to the first tangent vector,\n    // and in the direction of the minimum tangent xyz component\n\n\n    normals[0] = new Vector3();\n    binormals[0] = new Vector3();\n    let min = Number.MAX_VALUE;\n    const tx = Math.abs(tangents[0].x);\n    const ty = Math.abs(tangents[0].y);\n    const tz = Math.abs(tangents[0].z);\n\n    if (tx <= min) {\n      min = tx;\n      normal.set(1, 0, 0);\n    }\n\n    if (ty <= min) {\n      min = ty;\n      normal.set(0, 1, 0);\n    }\n\n    if (tz <= min) {\n      normal.set(0, 0, 1);\n    }\n\n    vec.crossVectors(tangents[0], normal).normalize();\n    normals[0].crossVectors(tangents[0], vec);\n    binormals[0].crossVectors(tangents[0], normals[0]); // compute the slowly-varying normal and binormal vectors for each segment on the curve\n\n    for (let i = 1; i <= segments; i++) {\n      normals[i] = normals[i - 1].clone();\n      binormals[i] = binormals[i - 1].clone();\n      vec.crossVectors(tangents[i - 1], tangents[i]);\n\n      if (vec.length() > Number.EPSILON) {\n        vec.normalize();\n        const theta = Math.acos(MathUtils.clamp(tangents[i - 1].dot(tangents[i]), -1, 1)); // clamp for floating pt errors\n\n        normals[i].applyMatrix4(mat.makeRotationAxis(vec, theta));\n      }\n\n      binormals[i].crossVectors(tangents[i], normals[i]);\n    } // if the curve is closed, postprocess the vectors so the first and last normal vectors are the same\n\n\n    if (closed === true) {\n      let theta = Math.acos(MathUtils.clamp(normals[0].dot(normals[segments]), -1, 1));\n      theta /= segments;\n\n      if (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) {\n        theta = -theta;\n      }\n\n      for (let i = 1; i <= segments; i++) {\n        // twist a little...\n        normals[i].applyMatrix4(mat.makeRotationAxis(tangents[i], theta * i));\n        binormals[i].crossVectors(tangents[i], normals[i]);\n      }\n    }\n\n    return {\n      tangents: tangents,\n      normals: normals,\n      binormals: binormals\n    };\n  }\n\n  clone() {\n    return new this.constructor().copy(this);\n  }\n\n  copy(source) {\n    this.arcLengthDivisions = source.arcLengthDivisions;\n    return this;\n  }\n\n  toJSON() {\n    const data = {\n      metadata: {\n        version: 4.5,\n        type: 'Curve',\n        generator: 'Curve.toJSON'\n      }\n    };\n    data.arcLengthDivisions = this.arcLengthDivisions;\n    data.type = this.type;\n    return data;\n  }\n\n  fromJSON(json) {\n    this.arcLengthDivisions = json.arcLengthDivisions;\n    return this;\n  }\n\n}\n\nexport { Curve };","map":{"version":3,"sources":["C:/Users/dell/Desktop/projektlogin/vue-3-authentication-jwt/src/games/three/src/extras/core/Curve.js"],"names":["MathUtils","Vector2","Vector3","Matrix4","Curve","constructor","type","arcLengthDivisions","getPoint","console","warn","getPointAt","u","optionalTarget","t","getUtoTmapping","getPoints","divisions","points","d","push","getSpacedPoints","getLength","lengths","getLengths","length","cacheArcLengths","needsUpdate","cache","current","last","sum","p","distanceTo","updateArcLengths","distance","arcLengths","i","il","targetArcLength","low","high","comparison","Math","floor","lengthBefore","lengthAfter","segmentLength","segmentFraction","getTangent","delta","t1","t2","pt1","pt2","tangent","isVector2","copy","sub","normalize","getTangentAt","computeFrenetFrames","segments","closed","normal","tangents","normals","binormals","vec","mat","min","Number","MAX_VALUE","tx","abs","x","ty","y","tz","z","set","crossVectors","clone","EPSILON","theta","acos","clamp","dot","applyMatrix4","makeRotationAxis","source","toJSON","data","metadata","version","generator","fromJSON","json"],"mappings":"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","sourcesContent":["import * as MathUtils from '../../math/MathUtils.js';\r\nimport { Vector2 } from '../../math/Vector2.js';\r\nimport { Vector3 } from '../../math/Vector3.js';\r\nimport { Matrix4 } from '../../math/Matrix4.js';\r\n\r\n/**\r\n * Extensible curve object.\r\n *\r\n * Some common of curve methods:\r\n * .getPoint( t, optionalTarget ), .getTangent( t, optionalTarget )\r\n * .getPointAt( u, optionalTarget ), .getTangentAt( u, optionalTarget )\r\n * .getPoints(), .getSpacedPoints()\r\n * .getLength()\r\n * .updateArcLengths()\r\n *\r\n * This following curves inherit from THREE.Curve:\r\n *\r\n * -- 2D curves --\r\n * THREE.ArcCurve\r\n * THREE.CubicBezierCurve\r\n * THREE.EllipseCurve\r\n * THREE.LineCurve\r\n * THREE.QuadraticBezierCurve\r\n * THREE.SplineCurve\r\n *\r\n * -- 3D curves --\r\n * THREE.CatmullRomCurve3\r\n * THREE.CubicBezierCurve3\r\n * THREE.LineCurve3\r\n * THREE.QuadraticBezierCurve3\r\n *\r\n * A series of curves can be represented as a THREE.CurvePath.\r\n *\r\n **/\r\n\r\nclass Curve {\r\n\r\n\tconstructor() {\r\n\r\n\t\tthis.type = 'Curve';\r\n\r\n\t\tthis.arcLengthDivisions = 200;\r\n\r\n\t}\r\n\r\n\t// Virtual base class method to overwrite and implement in subclasses\r\n\t//\t- t [0 .. 1]\r\n\r\n\tgetPoint( /* t, optionalTarget */ ) {\r\n\r\n\t\tconsole.warn( 'THREE.Curve: .getPoint() not implemented.' );\r\n\t\treturn null;\r\n\r\n\t}\r\n\r\n\t// Get point at relative position in curve according to arc length\r\n\t// - u [0 .. 1]\r\n\r\n\tgetPointAt( u, optionalTarget ) {\r\n\r\n\t\tconst t = this.getUtoTmapping( u );\r\n\t\treturn this.getPoint( t, optionalTarget );\r\n\r\n\t}\r\n\r\n\t// Get sequence of points using getPoint( t )\r\n\r\n\tgetPoints( divisions = 5 ) {\r\n\r\n\t\tconst points = [];\r\n\r\n\t\tfor ( let d = 0; d <= divisions; d ++ ) {\r\n\r\n\t\t\tpoints.push( this.getPoint( d / divisions ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn points;\r\n\r\n\t}\r\n\r\n\t// Get sequence of points using getPointAt( u )\r\n\r\n\tgetSpacedPoints( divisions = 5 ) {\r\n\r\n\t\tconst points = [];\r\n\r\n\t\tfor ( let d = 0; d <= divisions; d ++ ) {\r\n\r\n\t\t\tpoints.push( this.getPointAt( d / divisions ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn points;\r\n\r\n\t}\r\n\r\n\t// Get total curve arc length\r\n\r\n\tgetLength() {\r\n\r\n\t\tconst lengths = this.getLengths();\r\n\t\treturn lengths[ lengths.length - 1 ];\r\n\r\n\t}\r\n\r\n\t// Get list of cumulative segment lengths\r\n\r\n\tgetLengths( divisions = this.arcLengthDivisions ) {\r\n\r\n\t\tif ( this.cacheArcLengths &&\r\n\t\t\t( this.cacheArcLengths.length === divisions + 1 ) &&\r\n\t\t\t! this.needsUpdate ) {\r\n\r\n\t\t\treturn this.cacheArcLengths;\r\n\r\n\t\t}\r\n\r\n\t\tthis.needsUpdate = false;\r\n\r\n\t\tconst cache = [];\r\n\t\tlet current, last = this.getPoint( 0 );\r\n\t\tlet sum = 0;\r\n\r\n\t\tcache.push( 0 );\r\n\r\n\t\tfor ( let p = 1; p <= divisions; p ++ ) {\r\n\r\n\t\t\tcurrent = this.getPoint( p / divisions );\r\n\t\t\tsum += current.distanceTo( last );\r\n\t\t\tcache.push( sum );\r\n\t\t\tlast = current;\r\n\r\n\t\t}\r\n\r\n\t\tthis.cacheArcLengths = cache;\r\n\r\n\t\treturn cache; // { sums: cache, sum: sum }; Sum is in the last element.\r\n\r\n\t}\r\n\r\n\tupdateArcLengths() {\r\n\r\n\t\tthis.needsUpdate = true;\r\n\t\tthis.getLengths();\r\n\r\n\t}\r\n\r\n\t// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant\r\n\r\n\tgetUtoTmapping( u, distance ) {\r\n\r\n\t\tconst arcLengths = this.getLengths();\r\n\r\n\t\tlet i = 0;\r\n\t\tconst il = arcLengths.length;\r\n\r\n\t\tlet targetArcLength; // The targeted u distance value to get\r\n\r\n\t\tif ( distance ) {\r\n\r\n\t\t\ttargetArcLength = distance;\r\n\r\n\t\t} else {\r\n\r\n\t\t\ttargetArcLength = u * arcLengths[ il - 1 ];\r\n\r\n\t\t}\r\n\r\n\t\t// binary search for the index with largest value smaller than target u distance\r\n\r\n\t\tlet low = 0, high = il - 1, comparison;\r\n\r\n\t\twhile ( low <= high ) {\r\n\r\n\t\t\ti = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats\r\n\r\n\t\t\tcomparison = arcLengths[ i ] - targetArcLength;\r\n\r\n\t\t\tif ( comparison < 0 ) {\r\n\r\n\t\t\t\tlow = i + 1;\r\n\r\n\t\t\t} else if ( comparison > 0 ) {\r\n\r\n\t\t\t\thigh = i - 1;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\thigh = i;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t\t// DONE\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\ti = high;\r\n\r\n\t\tif ( arcLengths[ i ] === targetArcLength ) {\r\n\r\n\t\t\treturn i / ( il - 1 );\r\n\r\n\t\t}\r\n\r\n\t\t// we could get finer grain at lengths, or use simple interpolation between two points\r\n\r\n\t\tconst lengthBefore = arcLengths[ i ];\r\n\t\tconst lengthAfter = arcLengths[ i + 1 ];\r\n\r\n\t\tconst segmentLength = lengthAfter - lengthBefore;\r\n\r\n\t\t// determine where we are between the 'before' and 'after' points\r\n\r\n\t\tconst segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;\r\n\r\n\t\t// add that fractional amount to t\r\n\r\n\t\tconst t = ( i + segmentFraction ) / ( il - 1 );\r\n\r\n\t\treturn t;\r\n\r\n\t}\r\n\r\n\t// Returns a unit vector tangent at t\r\n\t// In case any sub curve does not implement its tangent derivation,\r\n\t// 2 points a small delta apart will be used to find its gradient\r\n\t// which seems to give a reasonable approximation\r\n\r\n\tgetTangent( t, optionalTarget ) {\r\n\r\n\t\tconst delta = 0.0001;\r\n\t\tlet t1 = t - delta;\r\n\t\tlet t2 = t + delta;\r\n\r\n\t\t// Capping in case of danger\r\n\r\n\t\tif ( t1 < 0 ) t1 = 0;\r\n\t\tif ( t2 > 1 ) t2 = 1;\r\n\r\n\t\tconst pt1 = this.getPoint( t1 );\r\n\t\tconst pt2 = this.getPoint( t2 );\r\n\r\n\t\tconst tangent = optionalTarget || ( ( pt1.isVector2 ) ? new Vector2() : new Vector3() );\r\n\r\n\t\ttangent.copy( pt2 ).sub( pt1 ).normalize();\r\n\r\n\t\treturn tangent;\r\n\r\n\t}\r\n\r\n\tgetTangentAt( u, optionalTarget ) {\r\n\r\n\t\tconst t = this.getUtoTmapping( u );\r\n\t\treturn this.getTangent( t, optionalTarget );\r\n\r\n\t}\r\n\r\n\tcomputeFrenetFrames( segments, closed ) {\r\n\r\n\t\t// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf\r\n\r\n\t\tconst normal = new Vector3();\r\n\r\n\t\tconst tangents = [];\r\n\t\tconst normals = [];\r\n\t\tconst binormals = [];\r\n\r\n\t\tconst vec = new Vector3();\r\n\t\tconst mat = new Matrix4();\r\n\r\n\t\t// compute the tangent vectors for each segment on the curve\r\n\r\n\t\tfor ( let i = 0; i <= segments; i ++ ) {\r\n\r\n\t\t\tconst u = i / segments;\r\n\r\n\t\t\ttangents[ i ] = this.getTangentAt( u, new Vector3() );\r\n\r\n\t\t}\r\n\r\n\t\t// select an initial normal vector perpendicular to the first tangent vector,\r\n\t\t// and in the direction of the minimum tangent xyz component\r\n\r\n\t\tnormals[ 0 ] = new Vector3();\r\n\t\tbinormals[ 0 ] = new Vector3();\r\n\t\tlet min = Number.MAX_VALUE;\r\n\t\tconst tx = Math.abs( tangents[ 0 ].x );\r\n\t\tconst ty = Math.abs( tangents[ 0 ].y );\r\n\t\tconst tz = Math.abs( tangents[ 0 ].z );\r\n\r\n\t\tif ( tx <= min ) {\r\n\r\n\t\t\tmin = tx;\r\n\t\t\tnormal.set( 1, 0, 0 );\r\n\r\n\t\t}\r\n\r\n\t\tif ( ty <= min ) {\r\n\r\n\t\t\tmin = ty;\r\n\t\t\tnormal.set( 0, 1, 0 );\r\n\r\n\t\t}\r\n\r\n\t\tif ( tz <= min ) {\r\n\r\n\t\t\tnormal.set( 0, 0, 1 );\r\n\r\n\t\t}\r\n\r\n\t\tvec.crossVectors( tangents[ 0 ], normal ).normalize();\r\n\r\n\t\tnormals[ 0 ].crossVectors( tangents[ 0 ], vec );\r\n\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );\r\n\r\n\r\n\t\t// compute the slowly-varying normal and binormal vectors for each segment on the curve\r\n\r\n\t\tfor ( let i = 1; i <= segments; i ++ ) {\r\n\r\n\t\t\tnormals[ i ] = normals[ i - 1 ].clone();\r\n\r\n\t\t\tbinormals[ i ] = binormals[ i - 1 ].clone();\r\n\r\n\t\t\tvec.crossVectors( tangents[ i - 1 ], tangents[ i ] );\r\n\r\n\t\t\tif ( vec.length() > Number.EPSILON ) {\r\n\r\n\t\t\t\tvec.normalize();\r\n\r\n\t\t\t\tconst theta = Math.acos( MathUtils.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors\r\n\r\n\t\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\r\n\r\n\t\t}\r\n\r\n\t\t// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same\r\n\r\n\t\tif ( closed === true ) {\r\n\r\n\t\t\tlet theta = Math.acos( MathUtils.clamp( normals[ 0 ].dot( normals[ segments ] ), - 1, 1 ) );\r\n\t\t\ttheta /= segments;\r\n\r\n\t\t\tif ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ segments ] ) ) > 0 ) {\r\n\r\n\t\t\t\ttheta = - theta;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( let i = 1; i <= segments; i ++ ) {\r\n\r\n\t\t\t\t// twist a little...\r\n\t\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );\r\n\t\t\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn {\r\n\t\t\ttangents: tangents,\r\n\t\t\tnormals: normals,\r\n\t\t\tbinormals: binormals\r\n\t\t};\r\n\r\n\t}\r\n\r\n\tclone() {\r\n\r\n\t\treturn new this.constructor().copy( this );\r\n\r\n\t}\r\n\r\n\tcopy( source ) {\r\n\r\n\t\tthis.arcLengthDivisions = source.arcLengthDivisions;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\ttoJSON() {\r\n\r\n\t\tconst data = {\r\n\t\t\tmetadata: {\r\n\t\t\t\tversion: 4.5,\r\n\t\t\t\ttype: 'Curve',\r\n\t\t\t\tgenerator: 'Curve.toJSON'\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tdata.arcLengthDivisions = this.arcLengthDivisions;\r\n\t\tdata.type = this.type;\r\n\r\n\t\treturn data;\r\n\r\n\t}\r\n\r\n\tfromJSON( json ) {\r\n\r\n\t\tthis.arcLengthDivisions = json.arcLengthDivisions;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\nexport { Curve };\r\n"]},"metadata":{},"sourceType":"module"}