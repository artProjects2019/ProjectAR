{"ast":null,"code":"import { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport { Vector3 } from '../math/Vector3.js';\n\nclass SphereGeometry extends BufferGeometry {\n  constructor(radius = 1, widthSegments = 32, heightSegments = 16, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI) {\n    super();\n    this.type = 'SphereGeometry';\n    this.parameters = {\n      radius: radius,\n      widthSegments: widthSegments,\n      heightSegments: heightSegments,\n      phiStart: phiStart,\n      phiLength: phiLength,\n      thetaStart: thetaStart,\n      thetaLength: thetaLength\n    };\n    widthSegments = Math.max(3, Math.floor(widthSegments));\n    heightSegments = Math.max(2, Math.floor(heightSegments));\n    const thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);\n    let index = 0;\n    const grid = [];\n    const vertex = new Vector3();\n    const normal = new Vector3(); // buffers\n\n    const indices = [];\n    const vertices = [];\n    const normals = [];\n    const uvs = []; // generate vertices, normals and uvs\n\n    for (let iy = 0; iy <= heightSegments; iy++) {\n      const verticesRow = [];\n      const v = iy / heightSegments; // special case for the poles\n\n      let uOffset = 0;\n\n      if (iy == 0 && thetaStart == 0) {\n        uOffset = 0.5 / widthSegments;\n      } else if (iy == heightSegments && thetaEnd == Math.PI) {\n        uOffset = -0.5 / widthSegments;\n      }\n\n      for (let ix = 0; ix <= widthSegments; ix++) {\n        const u = ix / widthSegments; // vertex\n\n        vertex.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);\n        vertex.y = radius * Math.cos(thetaStart + v * thetaLength);\n        vertex.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);\n        vertices.push(vertex.x, vertex.y, vertex.z); // normal\n\n        normal.copy(vertex).normalize();\n        normals.push(normal.x, normal.y, normal.z); // uv\n\n        uvs.push(u + uOffset, 1 - v);\n        verticesRow.push(index++);\n      }\n\n      grid.push(verticesRow);\n    } // indices\n\n\n    for (let iy = 0; iy < heightSegments; iy++) {\n      for (let ix = 0; ix < widthSegments; ix++) {\n        const a = grid[iy][ix + 1];\n        const b = grid[iy][ix];\n        const c = grid[iy + 1][ix];\n        const d = grid[iy + 1][ix + 1];\n        if (iy !== 0 || thetaStart > 0) indices.push(a, b, d);\n        if (iy !== heightSegments - 1 || thetaEnd < Math.PI) indices.push(b, c, d);\n      }\n    } // build geometry\n\n\n    this.setIndex(indices);\n    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\n  }\n\n  static fromJSON(data) {\n    return new SphereGeometry(data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);\n  }\n\n}\n\nexport { SphereGeometry, SphereGeometry as SphereBufferGeometry };","map":{"version":3,"sources":["C:/Users/dell/Desktop/projektlogin/vue-3-authentication-jwt/src/games/three/src/geometries/SphereGeometry.js"],"names":["BufferGeometry","Float32BufferAttribute","Vector3","SphereGeometry","constructor","radius","widthSegments","heightSegments","phiStart","phiLength","Math","PI","thetaStart","thetaLength","type","parameters","max","floor","thetaEnd","min","index","grid","vertex","normal","indices","vertices","normals","uvs","iy","verticesRow","v","uOffset","ix","u","x","cos","sin","y","z","push","copy","normalize","a","b","c","d","setIndex","setAttribute","fromJSON","data","SphereBufferGeometry"],"mappings":"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","sourcesContent":["import { BufferGeometry } from '../core/BufferGeometry.js';\r\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\r\nimport { Vector3 } from '../math/Vector3.js';\r\n\r\nclass SphereGeometry extends BufferGeometry {\r\n\r\n\tconstructor( radius = 1, widthSegments = 32, heightSegments = 16, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI ) {\r\n\r\n\t\tsuper();\r\n\t\tthis.type = 'SphereGeometry';\r\n\r\n\t\tthis.parameters = {\r\n\t\t\tradius: radius,\r\n\t\t\twidthSegments: widthSegments,\r\n\t\t\theightSegments: heightSegments,\r\n\t\t\tphiStart: phiStart,\r\n\t\t\tphiLength: phiLength,\r\n\t\t\tthetaStart: thetaStart,\r\n\t\t\tthetaLength: thetaLength\r\n\t\t};\r\n\r\n\t\twidthSegments = Math.max( 3, Math.floor( widthSegments ) );\r\n\t\theightSegments = Math.max( 2, Math.floor( heightSegments ) );\r\n\r\n\t\tconst thetaEnd = Math.min( thetaStart + thetaLength, Math.PI );\r\n\r\n\t\tlet index = 0;\r\n\t\tconst grid = [];\r\n\r\n\t\tconst vertex = new Vector3();\r\n\t\tconst normal = new Vector3();\r\n\r\n\t\t// buffers\r\n\r\n\t\tconst indices = [];\r\n\t\tconst vertices = [];\r\n\t\tconst normals = [];\r\n\t\tconst uvs = [];\r\n\r\n\t\t// generate vertices, normals and uvs\r\n\r\n\t\tfor ( let iy = 0; iy <= heightSegments; iy ++ ) {\r\n\r\n\t\t\tconst verticesRow = [];\r\n\r\n\t\t\tconst v = iy / heightSegments;\r\n\r\n\t\t\t// special case for the poles\r\n\r\n\t\t\tlet uOffset = 0;\r\n\r\n\t\t\tif ( iy == 0 && thetaStart == 0 ) {\r\n\r\n\t\t\t\tuOffset = 0.5 / widthSegments;\r\n\r\n\t\t\t} else if ( iy == heightSegments && thetaEnd == Math.PI ) {\r\n\r\n\t\t\t\tuOffset = - 0.5 / widthSegments;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( let ix = 0; ix <= widthSegments; ix ++ ) {\r\n\r\n\t\t\t\tconst u = ix / widthSegments;\r\n\r\n\t\t\t\t// vertex\r\n\r\n\t\t\t\tvertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\r\n\t\t\t\tvertex.y = radius * Math.cos( thetaStart + v * thetaLength );\r\n\t\t\t\tvertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\r\n\r\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\r\n\r\n\t\t\t\t// normal\r\n\r\n\t\t\t\tnormal.copy( vertex ).normalize();\r\n\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\r\n\r\n\t\t\t\t// uv\r\n\r\n\t\t\t\tuvs.push( u + uOffset, 1 - v );\r\n\r\n\t\t\t\tverticesRow.push( index ++ );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgrid.push( verticesRow );\r\n\r\n\t\t}\r\n\r\n\t\t// indices\r\n\r\n\t\tfor ( let iy = 0; iy < heightSegments; iy ++ ) {\r\n\r\n\t\t\tfor ( let ix = 0; ix < widthSegments; ix ++ ) {\r\n\r\n\t\t\t\tconst a = grid[ iy ][ ix + 1 ];\r\n\t\t\t\tconst b = grid[ iy ][ ix ];\r\n\t\t\t\tconst c = grid[ iy + 1 ][ ix ];\r\n\t\t\t\tconst d = grid[ iy + 1 ][ ix + 1 ];\r\n\r\n\t\t\t\tif ( iy !== 0 || thetaStart > 0 ) indices.push( a, b, d );\r\n\t\t\t\tif ( iy !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( b, c, d );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// build geometry\r\n\r\n\t\tthis.setIndex( indices );\r\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\r\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\r\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\r\n\r\n\t}\r\n\r\n\tstatic fromJSON( data ) {\r\n\r\n\t\treturn new SphereGeometry( data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength );\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport { SphereGeometry, SphereGeometry as SphereBufferGeometry };\r\n"]},"metadata":{},"sourceType":"module"}