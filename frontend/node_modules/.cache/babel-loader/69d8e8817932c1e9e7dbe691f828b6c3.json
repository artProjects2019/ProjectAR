{"ast":null,"code":"import { LinearFilter, LinearMipmapLinearFilter, ClampToEdgeWrapping } from '../constants.js';\nimport { FileLoader } from './FileLoader.js';\nimport { DataTexture } from '../textures/DataTexture.js';\nimport { Loader } from './Loader.js';\n/**\r\n * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)\r\n *\r\n * Sub classes have to implement the parse() method which will be used in load().\r\n */\n\nclass DataTextureLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const texture = new DataTexture();\n    const loader = new FileLoader(this.manager);\n    loader.setResponseType('arraybuffer');\n    loader.setRequestHeader(this.requestHeader);\n    loader.setPath(this.path);\n    loader.setWithCredentials(scope.withCredentials);\n    loader.load(url, function (buffer) {\n      const texData = scope.parse(buffer);\n      if (!texData) return;\n\n      if (texData.image !== undefined) {\n        texture.image = texData.image;\n      } else if (texData.data !== undefined) {\n        texture.image.width = texData.width;\n        texture.image.height = texData.height;\n        texture.image.data = texData.data;\n      }\n\n      texture.wrapS = texData.wrapS !== undefined ? texData.wrapS : ClampToEdgeWrapping;\n      texture.wrapT = texData.wrapT !== undefined ? texData.wrapT : ClampToEdgeWrapping;\n      texture.magFilter = texData.magFilter !== undefined ? texData.magFilter : LinearFilter;\n      texture.minFilter = texData.minFilter !== undefined ? texData.minFilter : LinearFilter;\n      texture.anisotropy = texData.anisotropy !== undefined ? texData.anisotropy : 1;\n\n      if (texData.encoding !== undefined) {\n        texture.encoding = texData.encoding;\n      }\n\n      if (texData.flipY !== undefined) {\n        texture.flipY = texData.flipY;\n      }\n\n      if (texData.format !== undefined) {\n        texture.format = texData.format;\n      }\n\n      if (texData.type !== undefined) {\n        texture.type = texData.type;\n      }\n\n      if (texData.mipmaps !== undefined) {\n        texture.mipmaps = texData.mipmaps;\n        texture.minFilter = LinearMipmapLinearFilter; // presumably...\n      }\n\n      if (texData.mipmapCount === 1) {\n        texture.minFilter = LinearFilter;\n      }\n\n      if (texData.generateMipmaps !== undefined) {\n        texture.generateMipmaps = texData.generateMipmaps;\n      }\n\n      texture.needsUpdate = true;\n      if (onLoad) onLoad(texture, texData);\n    }, onProgress, onError);\n    return texture;\n  }\n\n}\n\nexport { DataTextureLoader };","map":{"version":3,"sources":["C:/Users/dell/Desktop/projektlogin/vue-3-authentication-jwt/src/games/three/src/loaders/DataTextureLoader.js"],"names":["LinearFilter","LinearMipmapLinearFilter","ClampToEdgeWrapping","FileLoader","DataTexture","Loader","DataTextureLoader","constructor","manager","load","url","onLoad","onProgress","onError","scope","texture","loader","setResponseType","setRequestHeader","requestHeader","setPath","path","setWithCredentials","withCredentials","buffer","texData","parse","image","undefined","data","width","height","wrapS","wrapT","magFilter","minFilter","anisotropy","encoding","flipY","format","type","mipmaps","mipmapCount","generateMipmaps","needsUpdate"],"mappings":"AAAA,SAASA,YAAT,EAAuBC,wBAAvB,EAAiDC,mBAAjD,QAA4E,iBAA5E;AACA,SAASC,UAAT,QAA2B,iBAA3B;AACA,SAASC,WAAT,QAA4B,4BAA5B;AACA,SAASC,MAAT,QAAuB,aAAvB;AAEA;AACA;AACA;AACA;AACA;;AAEA,MAAMC,iBAAN,SAAgCD,MAAhC,CAAuC;AAEtCE,EAAAA,WAAW,CAAEC,OAAF,EAAY;AAEtB,UAAOA,OAAP;AAEA;;AAEDC,EAAAA,IAAI,CAAEC,GAAF,EAAOC,MAAP,EAAeC,UAAf,EAA2BC,OAA3B,EAAqC;AAExC,UAAMC,KAAK,GAAG,IAAd;AAEA,UAAMC,OAAO,GAAG,IAAIX,WAAJ,EAAhB;AAEA,UAAMY,MAAM,GAAG,IAAIb,UAAJ,CAAgB,KAAKK,OAArB,CAAf;AACAQ,IAAAA,MAAM,CAACC,eAAP,CAAwB,aAAxB;AACAD,IAAAA,MAAM,CAACE,gBAAP,CAAyB,KAAKC,aAA9B;AACAH,IAAAA,MAAM,CAACI,OAAP,CAAgB,KAAKC,IAArB;AACAL,IAAAA,MAAM,CAACM,kBAAP,CAA2BR,KAAK,CAACS,eAAjC;AACAP,IAAAA,MAAM,CAACP,IAAP,CAAaC,GAAb,EAAkB,UAAWc,MAAX,EAAoB;AAErC,YAAMC,OAAO,GAAGX,KAAK,CAACY,KAAN,CAAaF,MAAb,CAAhB;AAEA,UAAK,CAAEC,OAAP,EAAiB;;AAEjB,UAAKA,OAAO,CAACE,KAAR,KAAkBC,SAAvB,EAAmC;AAElCb,QAAAA,OAAO,CAACY,KAAR,GAAgBF,OAAO,CAACE,KAAxB;AAEA,OAJD,MAIO,IAAKF,OAAO,CAACI,IAAR,KAAiBD,SAAtB,EAAkC;AAExCb,QAAAA,OAAO,CAACY,KAAR,CAAcG,KAAd,GAAsBL,OAAO,CAACK,KAA9B;AACAf,QAAAA,OAAO,CAACY,KAAR,CAAcI,MAAd,GAAuBN,OAAO,CAACM,MAA/B;AACAhB,QAAAA,OAAO,CAACY,KAAR,CAAcE,IAAd,GAAqBJ,OAAO,CAACI,IAA7B;AAEA;;AAEDd,MAAAA,OAAO,CAACiB,KAAR,GAAgBP,OAAO,CAACO,KAAR,KAAkBJ,SAAlB,GAA8BH,OAAO,CAACO,KAAtC,GAA8C9B,mBAA9D;AACAa,MAAAA,OAAO,CAACkB,KAAR,GAAgBR,OAAO,CAACQ,KAAR,KAAkBL,SAAlB,GAA8BH,OAAO,CAACQ,KAAtC,GAA8C/B,mBAA9D;AAEAa,MAAAA,OAAO,CAACmB,SAAR,GAAoBT,OAAO,CAACS,SAAR,KAAsBN,SAAtB,GAAkCH,OAAO,CAACS,SAA1C,GAAsDlC,YAA1E;AACAe,MAAAA,OAAO,CAACoB,SAAR,GAAoBV,OAAO,CAACU,SAAR,KAAsBP,SAAtB,GAAkCH,OAAO,CAACU,SAA1C,GAAsDnC,YAA1E;AAEAe,MAAAA,OAAO,CAACqB,UAAR,GAAqBX,OAAO,CAACW,UAAR,KAAuBR,SAAvB,GAAmCH,OAAO,CAACW,UAA3C,GAAwD,CAA7E;;AAEA,UAAKX,OAAO,CAACY,QAAR,KAAqBT,SAA1B,EAAsC;AAErCb,QAAAA,OAAO,CAACsB,QAAR,GAAmBZ,OAAO,CAACY,QAA3B;AAEA;;AAED,UAAKZ,OAAO,CAACa,KAAR,KAAkBV,SAAvB,EAAmC;AAElCb,QAAAA,OAAO,CAACuB,KAAR,GAAgBb,OAAO,CAACa,KAAxB;AAEA;;AAED,UAAKb,OAAO,CAACc,MAAR,KAAmBX,SAAxB,EAAoC;AAEnCb,QAAAA,OAAO,CAACwB,MAAR,GAAiBd,OAAO,CAACc,MAAzB;AAEA;;AAED,UAAKd,OAAO,CAACe,IAAR,KAAiBZ,SAAtB,EAAkC;AAEjCb,QAAAA,OAAO,CAACyB,IAAR,GAAef,OAAO,CAACe,IAAvB;AAEA;;AAED,UAAKf,OAAO,CAACgB,OAAR,KAAoBb,SAAzB,EAAqC;AAEpCb,QAAAA,OAAO,CAAC0B,OAAR,GAAkBhB,OAAO,CAACgB,OAA1B;AACA1B,QAAAA,OAAO,CAACoB,SAAR,GAAoBlC,wBAApB,CAHoC,CAGU;AAE9C;;AAED,UAAKwB,OAAO,CAACiB,WAAR,KAAwB,CAA7B,EAAiC;AAEhC3B,QAAAA,OAAO,CAACoB,SAAR,GAAoBnC,YAApB;AAEA;;AAED,UAAKyB,OAAO,CAACkB,eAAR,KAA4Bf,SAAjC,EAA6C;AAE5Cb,QAAAA,OAAO,CAAC4B,eAAR,GAA0BlB,OAAO,CAACkB,eAAlC;AAEA;;AAED5B,MAAAA,OAAO,CAAC6B,WAAR,GAAsB,IAAtB;AAEA,UAAKjC,MAAL,EAAcA,MAAM,CAAEI,OAAF,EAAWU,OAAX,CAAN;AAEd,KAzED,EAyEGb,UAzEH,EAyEeC,OAzEf;AA4EA,WAAOE,OAAP;AAEA;;AAjGqC;;AAsGvC,SAAST,iBAAT","sourcesContent":["import { LinearFilter, LinearMipmapLinearFilter, ClampToEdgeWrapping } from '../constants.js';\r\nimport { FileLoader } from './FileLoader.js';\r\nimport { DataTexture } from '../textures/DataTexture.js';\r\nimport { Loader } from './Loader.js';\r\n\r\n/**\r\n * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)\r\n *\r\n * Sub classes have to implement the parse() method which will be used in load().\r\n */\r\n\r\nclass DataTextureLoader extends Loader {\r\n\r\n\tconstructor( manager ) {\r\n\r\n\t\tsuper( manager );\r\n\r\n\t}\r\n\r\n\tload( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tconst scope = this;\r\n\r\n\t\tconst texture = new DataTexture();\r\n\r\n\t\tconst loader = new FileLoader( this.manager );\r\n\t\tloader.setResponseType( 'arraybuffer' );\r\n\t\tloader.setRequestHeader( this.requestHeader );\r\n\t\tloader.setPath( this.path );\r\n\t\tloader.setWithCredentials( scope.withCredentials );\r\n\t\tloader.load( url, function ( buffer ) {\r\n\r\n\t\t\tconst texData = scope.parse( buffer );\r\n\r\n\t\t\tif ( ! texData ) return;\r\n\r\n\t\t\tif ( texData.image !== undefined ) {\r\n\r\n\t\t\t\ttexture.image = texData.image;\r\n\r\n\t\t\t} else if ( texData.data !== undefined ) {\r\n\r\n\t\t\t\ttexture.image.width = texData.width;\r\n\t\t\t\ttexture.image.height = texData.height;\r\n\t\t\t\ttexture.image.data = texData.data;\r\n\r\n\t\t\t}\r\n\r\n\t\t\ttexture.wrapS = texData.wrapS !== undefined ? texData.wrapS : ClampToEdgeWrapping;\r\n\t\t\ttexture.wrapT = texData.wrapT !== undefined ? texData.wrapT : ClampToEdgeWrapping;\r\n\r\n\t\t\ttexture.magFilter = texData.magFilter !== undefined ? texData.magFilter : LinearFilter;\r\n\t\t\ttexture.minFilter = texData.minFilter !== undefined ? texData.minFilter : LinearFilter;\r\n\r\n\t\t\ttexture.anisotropy = texData.anisotropy !== undefined ? texData.anisotropy : 1;\r\n\r\n\t\t\tif ( texData.encoding !== undefined ) {\r\n\r\n\t\t\t\ttexture.encoding = texData.encoding;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( texData.flipY !== undefined ) {\r\n\r\n\t\t\t\ttexture.flipY = texData.flipY;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( texData.format !== undefined ) {\r\n\r\n\t\t\t\ttexture.format = texData.format;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( texData.type !== undefined ) {\r\n\r\n\t\t\t\ttexture.type = texData.type;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( texData.mipmaps !== undefined ) {\r\n\r\n\t\t\t\ttexture.mipmaps = texData.mipmaps;\r\n\t\t\t\ttexture.minFilter = LinearMipmapLinearFilter; // presumably...\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( texData.mipmapCount === 1 ) {\r\n\r\n\t\t\t\ttexture.minFilter = LinearFilter;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( texData.generateMipmaps !== undefined ) {\r\n\r\n\t\t\t\ttexture.generateMipmaps = texData.generateMipmaps;\r\n\r\n\t\t\t}\r\n\r\n\t\t\ttexture.needsUpdate = true;\r\n\r\n\t\t\tif ( onLoad ) onLoad( texture, texData );\r\n\r\n\t\t}, onProgress, onError );\r\n\r\n\r\n\t\treturn texture;\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\nexport { DataTextureLoader };\r\n"]},"metadata":{},"sourceType":"module"}