{"ast":null,"code":"import { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport { Vector3 } from '../math/Vector3.js';\nimport { Vector2 } from '../math/Vector2.js';\n\nclass CylinderGeometry extends BufferGeometry {\n  constructor(radiusTop = 1, radiusBottom = 1, height = 1, radialSegments = 8, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2) {\n    super();\n    this.type = 'CylinderGeometry';\n    this.parameters = {\n      radiusTop: radiusTop,\n      radiusBottom: radiusBottom,\n      height: height,\n      radialSegments: radialSegments,\n      heightSegments: heightSegments,\n      openEnded: openEnded,\n      thetaStart: thetaStart,\n      thetaLength: thetaLength\n    };\n    const scope = this;\n    radialSegments = Math.floor(radialSegments);\n    heightSegments = Math.floor(heightSegments); // buffers\n\n    const indices = [];\n    const vertices = [];\n    const normals = [];\n    const uvs = []; // helper variables\n\n    let index = 0;\n    const indexArray = [];\n    const halfHeight = height / 2;\n    let groupStart = 0; // generate geometry\n\n    generateTorso();\n\n    if (openEnded === false) {\n      if (radiusTop > 0) generateCap(true);\n      if (radiusBottom > 0) generateCap(false);\n    } // build geometry\n\n\n    this.setIndex(indices);\n    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\n\n    function generateTorso() {\n      const normal = new Vector3();\n      const vertex = new Vector3();\n      let groupCount = 0; // this will be used to calculate the normal\n\n      const slope = (radiusBottom - radiusTop) / height; // generate vertices, normals and uvs\n\n      for (let y = 0; y <= heightSegments; y++) {\n        const indexRow = [];\n        const v = y / heightSegments; // calculate the radius of the current row\n\n        const radius = v * (radiusBottom - radiusTop) + radiusTop;\n\n        for (let x = 0; x <= radialSegments; x++) {\n          const u = x / radialSegments;\n          const theta = u * thetaLength + thetaStart;\n          const sinTheta = Math.sin(theta);\n          const cosTheta = Math.cos(theta); // vertex\n\n          vertex.x = radius * sinTheta;\n          vertex.y = -v * height + halfHeight;\n          vertex.z = radius * cosTheta;\n          vertices.push(vertex.x, vertex.y, vertex.z); // normal\n\n          normal.set(sinTheta, slope, cosTheta).normalize();\n          normals.push(normal.x, normal.y, normal.z); // uv\n\n          uvs.push(u, 1 - v); // save index of vertex in respective row\n\n          indexRow.push(index++);\n        } // now save vertices of the row in our index array\n\n\n        indexArray.push(indexRow);\n      } // generate indices\n\n\n      for (let x = 0; x < radialSegments; x++) {\n        for (let y = 0; y < heightSegments; y++) {\n          // we use the index array to access the correct indices\n          const a = indexArray[y][x];\n          const b = indexArray[y + 1][x];\n          const c = indexArray[y + 1][x + 1];\n          const d = indexArray[y][x + 1]; // faces\n\n          indices.push(a, b, d);\n          indices.push(b, c, d); // update group counter\n\n          groupCount += 6;\n        }\n      } // add a group to the geometry. this will ensure multi material support\n\n\n      scope.addGroup(groupStart, groupCount, 0); // calculate new start value for groups\n\n      groupStart += groupCount;\n    }\n\n    function generateCap(top) {\n      // save the index of the first center vertex\n      const centerIndexStart = index;\n      const uv = new Vector2();\n      const vertex = new Vector3();\n      let groupCount = 0;\n      const radius = top === true ? radiusTop : radiusBottom;\n      const sign = top === true ? 1 : -1; // first we generate the center vertex data of the cap.\n      // because the geometry needs one set of uvs per face,\n      // we must generate a center vertex per face/segment\n\n      for (let x = 1; x <= radialSegments; x++) {\n        // vertex\n        vertices.push(0, halfHeight * sign, 0); // normal\n\n        normals.push(0, sign, 0); // uv\n\n        uvs.push(0.5, 0.5); // increase index\n\n        index++;\n      } // save the index of the last center vertex\n\n\n      const centerIndexEnd = index; // now we generate the surrounding vertices, normals and uvs\n\n      for (let x = 0; x <= radialSegments; x++) {\n        const u = x / radialSegments;\n        const theta = u * thetaLength + thetaStart;\n        const cosTheta = Math.cos(theta);\n        const sinTheta = Math.sin(theta); // vertex\n\n        vertex.x = radius * sinTheta;\n        vertex.y = halfHeight * sign;\n        vertex.z = radius * cosTheta;\n        vertices.push(vertex.x, vertex.y, vertex.z); // normal\n\n        normals.push(0, sign, 0); // uv\n\n        uv.x = cosTheta * 0.5 + 0.5;\n        uv.y = sinTheta * 0.5 * sign + 0.5;\n        uvs.push(uv.x, uv.y); // increase index\n\n        index++;\n      } // generate indices\n\n\n      for (let x = 0; x < radialSegments; x++) {\n        const c = centerIndexStart + x;\n        const i = centerIndexEnd + x;\n\n        if (top === true) {\n          // face top\n          indices.push(i, i + 1, c);\n        } else {\n          // face bottom\n          indices.push(i + 1, i, c);\n        }\n\n        groupCount += 3;\n      } // add a group to the geometry. this will ensure multi material support\n\n\n      scope.addGroup(groupStart, groupCount, top === true ? 1 : 2); // calculate new start value for groups\n\n      groupStart += groupCount;\n    }\n  }\n\n  static fromJSON(data) {\n    return new CylinderGeometry(data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);\n  }\n\n}\n\nexport { CylinderGeometry, CylinderGeometry as CylinderBufferGeometry };","map":{"version":3,"sources":["C:/Users/dell/Desktop/projektlogin/vue-3-authentication-jwt/src/games/three/src/geometries/CylinderGeometry.js"],"names":["BufferGeometry","Float32BufferAttribute","Vector3","Vector2","CylinderGeometry","constructor","radiusTop","radiusBottom","height","radialSegments","heightSegments","openEnded","thetaStart","thetaLength","Math","PI","type","parameters","scope","floor","indices","vertices","normals","uvs","index","indexArray","halfHeight","groupStart","generateTorso","generateCap","setIndex","setAttribute","normal","vertex","groupCount","slope","y","indexRow","v","radius","x","u","theta","sinTheta","sin","cosTheta","cos","z","push","set","normalize","a","b","c","d","addGroup","top","centerIndexStart","uv","sign","centerIndexEnd","i","fromJSON","data","CylinderBufferGeometry"],"mappings":"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","sourcesContent":["import { BufferGeometry } from '../core/BufferGeometry.js';\r\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\r\nimport { Vector3 } from '../math/Vector3.js';\r\nimport { Vector2 } from '../math/Vector2.js';\r\n\r\nclass CylinderGeometry extends BufferGeometry {\r\n\r\n\tconstructor( radiusTop = 1, radiusBottom = 1, height = 1, radialSegments = 8, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2 ) {\r\n\r\n\t\tsuper();\r\n\t\tthis.type = 'CylinderGeometry';\r\n\r\n\t\tthis.parameters = {\r\n\t\t\tradiusTop: radiusTop,\r\n\t\t\tradiusBottom: radiusBottom,\r\n\t\t\theight: height,\r\n\t\t\tradialSegments: radialSegments,\r\n\t\t\theightSegments: heightSegments,\r\n\t\t\topenEnded: openEnded,\r\n\t\t\tthetaStart: thetaStart,\r\n\t\t\tthetaLength: thetaLength\r\n\t\t};\r\n\r\n\t\tconst scope = this;\r\n\r\n\t\tradialSegments = Math.floor( radialSegments );\r\n\t\theightSegments = Math.floor( heightSegments );\r\n\r\n\t\t// buffers\r\n\r\n\t\tconst indices = [];\r\n\t\tconst vertices = [];\r\n\t\tconst normals = [];\r\n\t\tconst uvs = [];\r\n\r\n\t\t// helper variables\r\n\r\n\t\tlet index = 0;\r\n\t\tconst indexArray = [];\r\n\t\tconst halfHeight = height / 2;\r\n\t\tlet groupStart = 0;\r\n\r\n\t\t// generate geometry\r\n\r\n\t\tgenerateTorso();\r\n\r\n\t\tif ( openEnded === false ) {\r\n\r\n\t\t\tif ( radiusTop > 0 ) generateCap( true );\r\n\t\t\tif ( radiusBottom > 0 ) generateCap( false );\r\n\r\n\t\t}\r\n\r\n\t\t// build geometry\r\n\r\n\t\tthis.setIndex( indices );\r\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\r\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\r\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\r\n\r\n\t\tfunction generateTorso() {\r\n\r\n\t\t\tconst normal = new Vector3();\r\n\t\t\tconst vertex = new Vector3();\r\n\r\n\t\t\tlet groupCount = 0;\r\n\r\n\t\t\t// this will be used to calculate the normal\r\n\t\t\tconst slope = ( radiusBottom - radiusTop ) / height;\r\n\r\n\t\t\t// generate vertices, normals and uvs\r\n\r\n\t\t\tfor ( let y = 0; y <= heightSegments; y ++ ) {\r\n\r\n\t\t\t\tconst indexRow = [];\r\n\r\n\t\t\t\tconst v = y / heightSegments;\r\n\r\n\t\t\t\t// calculate the radius of the current row\r\n\r\n\t\t\t\tconst radius = v * ( radiusBottom - radiusTop ) + radiusTop;\r\n\r\n\t\t\t\tfor ( let x = 0; x <= radialSegments; x ++ ) {\r\n\r\n\t\t\t\t\tconst u = x / radialSegments;\r\n\r\n\t\t\t\t\tconst theta = u * thetaLength + thetaStart;\r\n\r\n\t\t\t\t\tconst sinTheta = Math.sin( theta );\r\n\t\t\t\t\tconst cosTheta = Math.cos( theta );\r\n\r\n\t\t\t\t\t// vertex\r\n\r\n\t\t\t\t\tvertex.x = radius * sinTheta;\r\n\t\t\t\t\tvertex.y = - v * height + halfHeight;\r\n\t\t\t\t\tvertex.z = radius * cosTheta;\r\n\t\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\r\n\r\n\t\t\t\t\t// normal\r\n\r\n\t\t\t\t\tnormal.set( sinTheta, slope, cosTheta ).normalize();\r\n\t\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\r\n\r\n\t\t\t\t\t// uv\r\n\r\n\t\t\t\t\tuvs.push( u, 1 - v );\r\n\r\n\t\t\t\t\t// save index of vertex in respective row\r\n\r\n\t\t\t\t\tindexRow.push( index ++ );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// now save vertices of the row in our index array\r\n\r\n\t\t\t\tindexArray.push( indexRow );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// generate indices\r\n\r\n\t\t\tfor ( let x = 0; x < radialSegments; x ++ ) {\r\n\r\n\t\t\t\tfor ( let y = 0; y < heightSegments; y ++ ) {\r\n\r\n\t\t\t\t\t// we use the index array to access the correct indices\r\n\r\n\t\t\t\t\tconst a = indexArray[ y ][ x ];\r\n\t\t\t\t\tconst b = indexArray[ y + 1 ][ x ];\r\n\t\t\t\t\tconst c = indexArray[ y + 1 ][ x + 1 ];\r\n\t\t\t\t\tconst d = indexArray[ y ][ x + 1 ];\r\n\r\n\t\t\t\t\t// faces\r\n\r\n\t\t\t\t\tindices.push( a, b, d );\r\n\t\t\t\t\tindices.push( b, c, d );\r\n\r\n\t\t\t\t\t// update group counter\r\n\r\n\t\t\t\t\tgroupCount += 6;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// add a group to the geometry. this will ensure multi material support\r\n\r\n\t\t\tscope.addGroup( groupStart, groupCount, 0 );\r\n\r\n\t\t\t// calculate new start value for groups\r\n\r\n\t\t\tgroupStart += groupCount;\r\n\r\n\t\t}\r\n\r\n\t\tfunction generateCap( top ) {\r\n\r\n\t\t\t// save the index of the first center vertex\r\n\t\t\tconst centerIndexStart = index;\r\n\r\n\t\t\tconst uv = new Vector2();\r\n\t\t\tconst vertex = new Vector3();\r\n\r\n\t\t\tlet groupCount = 0;\r\n\r\n\t\t\tconst radius = ( top === true ) ? radiusTop : radiusBottom;\r\n\t\t\tconst sign = ( top === true ) ? 1 : - 1;\r\n\r\n\t\t\t// first we generate the center vertex data of the cap.\r\n\t\t\t// because the geometry needs one set of uvs per face,\r\n\t\t\t// we must generate a center vertex per face/segment\r\n\r\n\t\t\tfor ( let x = 1; x <= radialSegments; x ++ ) {\r\n\r\n\t\t\t\t// vertex\r\n\r\n\t\t\t\tvertices.push( 0, halfHeight * sign, 0 );\r\n\r\n\t\t\t\t// normal\r\n\r\n\t\t\t\tnormals.push( 0, sign, 0 );\r\n\r\n\t\t\t\t// uv\r\n\r\n\t\t\t\tuvs.push( 0.5, 0.5 );\r\n\r\n\t\t\t\t// increase index\r\n\r\n\t\t\t\tindex ++;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// save the index of the last center vertex\r\n\t\t\tconst centerIndexEnd = index;\r\n\r\n\t\t\t// now we generate the surrounding vertices, normals and uvs\r\n\r\n\t\t\tfor ( let x = 0; x <= radialSegments; x ++ ) {\r\n\r\n\t\t\t\tconst u = x / radialSegments;\r\n\t\t\t\tconst theta = u * thetaLength + thetaStart;\r\n\r\n\t\t\t\tconst cosTheta = Math.cos( theta );\r\n\t\t\t\tconst sinTheta = Math.sin( theta );\r\n\r\n\t\t\t\t// vertex\r\n\r\n\t\t\t\tvertex.x = radius * sinTheta;\r\n\t\t\t\tvertex.y = halfHeight * sign;\r\n\t\t\t\tvertex.z = radius * cosTheta;\r\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\r\n\r\n\t\t\t\t// normal\r\n\r\n\t\t\t\tnormals.push( 0, sign, 0 );\r\n\r\n\t\t\t\t// uv\r\n\r\n\t\t\t\tuv.x = ( cosTheta * 0.5 ) + 0.5;\r\n\t\t\t\tuv.y = ( sinTheta * 0.5 * sign ) + 0.5;\r\n\t\t\t\tuvs.push( uv.x, uv.y );\r\n\r\n\t\t\t\t// increase index\r\n\r\n\t\t\t\tindex ++;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// generate indices\r\n\r\n\t\t\tfor ( let x = 0; x < radialSegments; x ++ ) {\r\n\r\n\t\t\t\tconst c = centerIndexStart + x;\r\n\t\t\t\tconst i = centerIndexEnd + x;\r\n\r\n\t\t\t\tif ( top === true ) {\r\n\r\n\t\t\t\t\t// face top\r\n\r\n\t\t\t\t\tindices.push( i, i + 1, c );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// face bottom\r\n\r\n\t\t\t\t\tindices.push( i + 1, i, c );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tgroupCount += 3;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// add a group to the geometry. this will ensure multi material support\r\n\r\n\t\t\tscope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );\r\n\r\n\t\t\t// calculate new start value for groups\r\n\r\n\t\t\tgroupStart += groupCount;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tstatic fromJSON( data ) {\r\n\r\n\t\treturn new CylinderGeometry( data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength );\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\nexport { CylinderGeometry, CylinderGeometry as CylinderBufferGeometry };\r\n"]},"metadata":{},"sourceType":"module"}