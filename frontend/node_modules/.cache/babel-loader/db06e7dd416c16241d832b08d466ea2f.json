{"ast":null,"code":"export default\n/* glsl */\n`\n#ifdef USE_TRANSMISSION\n\n\t// Transmission code is based on glTF-Sampler-Viewer\n\t// https://github.com/KhronosGroup/glTF-Sample-Viewer\n\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\n\t#ifdef USE_TRANSMISSIONMAP\n\n\t\tuniform sampler2D transmissionMap;\n\n\t#endif\n\n\t#ifdef USE_THICKNESSMAP\n\n\t\tuniform sampler2D thicknessMap;\n\n\t#endif\n\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\n\tvarying vec3 vWorldPosition;\n\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\n\t\t// Direction of refracted light.\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\n\t\t// Compute rotation-independant scaling of the model matrix.\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\n\t\t// The thickness is specified in local space.\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\n\t}\n\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\n\t\t// Scale roughness with IOR so that an IOR of 1.0 results in no microfacet refraction and\n\t\t// an IOR of 1.5 results in the default amount of microfacet refraction.\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\n\t}\n\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\n\t\tfloat framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\n\t\t#ifdef texture2DLodEXT\n\n\t\t\treturn texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\n\t\t#else\n\n\t\t\treturn texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\n\t\t#endif\n\n\t}\n\n\tvec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\n\t\tif ( attenuationDistance == 0.0 ) {\n\n\t\t\t// Attenuation distance is +∞ (which we indicate by zero), i.e. the transmitted color is not attenuated at all.\n\t\t\treturn radiance;\n\n\t\t} else {\n\n\t\t\t// Compute light attenuation using Beer's law.\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance ); // Beer's law\n\t\t\treturn transmittance * radiance;\n\n\t\t}\n\n\t}\n\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\n\t\t// Project refracted vector on the framebuffer, while mapping to normalized device coordinates.\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\n\t\t// Sample framebuffer to get pixel the refracted ray hits.\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\n\t\tvec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n\n\t\t// Get the specular component.\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n\n\t}\n#endif\n`;","map":{"version":3,"sources":["C:/Users/dell/Desktop/projektlogin/vue-3-authentication-jwt/src/games/three/src/renderers/shaders/ShaderChunk/transmission_pars_fragment.glsl.js"],"names":[],"mappings":"AAAA;AAAe;AAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAnHA","sourcesContent":["export default /* glsl */`\r\n#ifdef USE_TRANSMISSION\r\n\r\n\t// Transmission code is based on glTF-Sampler-Viewer\r\n\t// https://github.com/KhronosGroup/glTF-Sample-Viewer\r\n\r\n\tuniform float transmission;\r\n\tuniform float thickness;\r\n\tuniform float attenuationDistance;\r\n\tuniform vec3 attenuationColor;\r\n\r\n\t#ifdef USE_TRANSMISSIONMAP\r\n\r\n\t\tuniform sampler2D transmissionMap;\r\n\r\n\t#endif\r\n\r\n\t#ifdef USE_THICKNESSMAP\r\n\r\n\t\tuniform sampler2D thicknessMap;\r\n\r\n\t#endif\r\n\r\n\tuniform vec2 transmissionSamplerSize;\r\n\tuniform sampler2D transmissionSamplerMap;\r\n\r\n\tuniform mat4 modelMatrix;\r\n\tuniform mat4 projectionMatrix;\r\n\r\n\tvarying vec3 vWorldPosition;\r\n\r\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\r\n\r\n\t\t// Direction of refracted light.\r\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\r\n\r\n\t\t// Compute rotation-independant scaling of the model matrix.\r\n\t\tvec3 modelScale;\r\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\r\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\r\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\r\n\r\n\t\t// The thickness is specified in local space.\r\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\r\n\r\n\t}\r\n\r\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\r\n\r\n\t\t// Scale roughness with IOR so that an IOR of 1.0 results in no microfacet refraction and\r\n\t\t// an IOR of 1.5 results in the default amount of microfacet refraction.\r\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\r\n\r\n\t}\r\n\r\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\r\n\r\n\t\tfloat framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\r\n\r\n\t\t#ifdef texture2DLodEXT\r\n\r\n\t\t\treturn texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\r\n\r\n\t\t#else\r\n\r\n\t\t\treturn texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\r\n\r\n\t\t#endif\r\n\r\n\t}\r\n\r\n\tvec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\r\n\r\n\t\tif ( attenuationDistance == 0.0 ) {\r\n\r\n\t\t\t// Attenuation distance is +∞ (which we indicate by zero), i.e. the transmitted color is not attenuated at all.\r\n\t\t\treturn radiance;\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// Compute light attenuation using Beer's law.\r\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\r\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance ); // Beer's law\r\n\t\t\treturn transmittance * radiance;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\r\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\r\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\r\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\r\n\r\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\r\n\t\tvec3 refractedRayExit = position + transmissionRay;\r\n\r\n\t\t// Project refracted vector on the framebuffer, while mapping to normalized device coordinates.\r\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\r\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\r\n\t\trefractionCoords += 1.0;\r\n\t\trefractionCoords /= 2.0;\r\n\r\n\t\t// Sample framebuffer to get pixel the refracted ray hits.\r\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\r\n\r\n\t\tvec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\r\n\r\n\t\t// Get the specular component.\r\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\r\n\r\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\r\n\r\n\t}\r\n#endif\r\n`;\r\n"]},"metadata":{},"sourceType":"module"}