{"ast":null,"code":"import \"core-js/modules/es.array.at.js\";\nimport \"core-js/modules/es.string.at-alternative.js\";\nimport { Vector3 } from './Vector3.js';\n\nconst _vector = /*@__PURE__*/new Vector3();\n\nconst _segCenter = /*@__PURE__*/new Vector3();\n\nconst _segDir = /*@__PURE__*/new Vector3();\n\nconst _diff = /*@__PURE__*/new Vector3();\n\nconst _edge1 = /*@__PURE__*/new Vector3();\n\nconst _edge2 = /*@__PURE__*/new Vector3();\n\nconst _normal = /*@__PURE__*/new Vector3();\n\nclass Ray {\n  constructor(origin = new Vector3(), direction = new Vector3(0, 0, -1)) {\n    this.origin = origin;\n    this.direction = direction;\n  }\n\n  set(origin, direction) {\n    this.origin.copy(origin);\n    this.direction.copy(direction);\n    return this;\n  }\n\n  copy(ray) {\n    this.origin.copy(ray.origin);\n    this.direction.copy(ray.direction);\n    return this;\n  }\n\n  at(t, target) {\n    return target.copy(this.direction).multiplyScalar(t).add(this.origin);\n  }\n\n  lookAt(v) {\n    this.direction.copy(v).sub(this.origin).normalize();\n    return this;\n  }\n\n  recast(t) {\n    this.origin.copy(this.at(t, _vector));\n    return this;\n  }\n\n  closestPointToPoint(point, target) {\n    target.subVectors(point, this.origin);\n    const directionDistance = target.dot(this.direction);\n\n    if (directionDistance < 0) {\n      return target.copy(this.origin);\n    }\n\n    return target.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);\n  }\n\n  distanceToPoint(point) {\n    return Math.sqrt(this.distanceSqToPoint(point));\n  }\n\n  distanceSqToPoint(point) {\n    const directionDistance = _vector.subVectors(point, this.origin).dot(this.direction); // point behind the ray\n\n\n    if (directionDistance < 0) {\n      return this.origin.distanceToSquared(point);\n    }\n\n    _vector.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);\n\n    return _vector.distanceToSquared(point);\n  }\n\n  distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {\n    // from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteDistRaySegment.h\n    // It returns the min distance between the ray and the segment\n    // defined by v0 and v1\n    // It can also set two optional targets :\n    // - The closest point on the ray\n    // - The closest point on the segment\n    _segCenter.copy(v0).add(v1).multiplyScalar(0.5);\n\n    _segDir.copy(v1).sub(v0).normalize();\n\n    _diff.copy(this.origin).sub(_segCenter);\n\n    const segExtent = v0.distanceTo(v1) * 0.5;\n    const a01 = -this.direction.dot(_segDir);\n\n    const b0 = _diff.dot(this.direction);\n\n    const b1 = -_diff.dot(_segDir);\n\n    const c = _diff.lengthSq();\n\n    const det = Math.abs(1 - a01 * a01);\n    let s0, s1, sqrDist, extDet;\n\n    if (det > 0) {\n      // The ray and segment are not parallel.\n      s0 = a01 * b1 - b0;\n      s1 = a01 * b0 - b1;\n      extDet = segExtent * det;\n\n      if (s0 >= 0) {\n        if (s1 >= -extDet) {\n          if (s1 <= extDet) {\n            // region 0\n            // Minimum at interior points of ray and segment.\n            const invDet = 1 / det;\n            s0 *= invDet;\n            s1 *= invDet;\n            sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;\n          } else {\n            // region 1\n            s1 = segExtent;\n            s0 = Math.max(0, -(a01 * s1 + b0));\n            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;\n          }\n        } else {\n          // region 5\n          s1 = -segExtent;\n          s0 = Math.max(0, -(a01 * s1 + b0));\n          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;\n        }\n      } else {\n        if (s1 <= -extDet) {\n          // region 4\n          s0 = Math.max(0, -(-a01 * segExtent + b0));\n          s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);\n          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;\n        } else if (s1 <= extDet) {\n          // region 3\n          s0 = 0;\n          s1 = Math.min(Math.max(-segExtent, -b1), segExtent);\n          sqrDist = s1 * (s1 + 2 * b1) + c;\n        } else {\n          // region 2\n          s0 = Math.max(0, -(a01 * segExtent + b0));\n          s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);\n          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;\n        }\n      }\n    } else {\n      // Ray and segment are parallel.\n      s1 = a01 > 0 ? -segExtent : segExtent;\n      s0 = Math.max(0, -(a01 * s1 + b0));\n      sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;\n    }\n\n    if (optionalPointOnRay) {\n      optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);\n    }\n\n    if (optionalPointOnSegment) {\n      optionalPointOnSegment.copy(_segDir).multiplyScalar(s1).add(_segCenter);\n    }\n\n    return sqrDist;\n  }\n\n  intersectSphere(sphere, target) {\n    _vector.subVectors(sphere.center, this.origin);\n\n    const tca = _vector.dot(this.direction);\n\n    const d2 = _vector.dot(_vector) - tca * tca;\n    const radius2 = sphere.radius * sphere.radius;\n    if (d2 > radius2) return null;\n    const thc = Math.sqrt(radius2 - d2); // t0 = first intersect point - entrance on front of sphere\n\n    const t0 = tca - thc; // t1 = second intersect point - exit point on back of sphere\n\n    const t1 = tca + thc; // test to see if both t0 and t1 are behind the ray - if so, return null\n\n    if (t0 < 0 && t1 < 0) return null; // test to see if t0 is behind the ray:\n    // if it is, the ray is inside the sphere, so return the second exit point scaled by t1,\n    // in order to always return an intersect point that is in front of the ray.\n\n    if (t0 < 0) return this.at(t1, target); // else t0 is in front of the ray, so return the first collision point scaled by t0\n\n    return this.at(t0, target);\n  }\n\n  intersectsSphere(sphere) {\n    return this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;\n  }\n\n  distanceToPlane(plane) {\n    const denominator = plane.normal.dot(this.direction);\n\n    if (denominator === 0) {\n      // line is coplanar, return origin\n      if (plane.distanceToPoint(this.origin) === 0) {\n        return 0;\n      } // Null is preferable to undefined since undefined means.... it is undefined\n\n\n      return null;\n    }\n\n    const t = -(this.origin.dot(plane.normal) + plane.constant) / denominator; // Return if the ray never intersects the plane\n\n    return t >= 0 ? t : null;\n  }\n\n  intersectPlane(plane, target) {\n    const t = this.distanceToPlane(plane);\n\n    if (t === null) {\n      return null;\n    }\n\n    return this.at(t, target);\n  }\n\n  intersectsPlane(plane) {\n    // check if the ray lies on the plane first\n    const distToPoint = plane.distanceToPoint(this.origin);\n\n    if (distToPoint === 0) {\n      return true;\n    }\n\n    const denominator = plane.normal.dot(this.direction);\n\n    if (denominator * distToPoint < 0) {\n      return true;\n    } // ray origin is behind the plane (and is pointing behind it)\n\n\n    return false;\n  }\n\n  intersectBox(box, target) {\n    let tmin, tmax, tymin, tymax, tzmin, tzmax;\n    const invdirx = 1 / this.direction.x,\n          invdiry = 1 / this.direction.y,\n          invdirz = 1 / this.direction.z;\n    const origin = this.origin;\n\n    if (invdirx >= 0) {\n      tmin = (box.min.x - origin.x) * invdirx;\n      tmax = (box.max.x - origin.x) * invdirx;\n    } else {\n      tmin = (box.max.x - origin.x) * invdirx;\n      tmax = (box.min.x - origin.x) * invdirx;\n    }\n\n    if (invdiry >= 0) {\n      tymin = (box.min.y - origin.y) * invdiry;\n      tymax = (box.max.y - origin.y) * invdiry;\n    } else {\n      tymin = (box.max.y - origin.y) * invdiry;\n      tymax = (box.min.y - origin.y) * invdiry;\n    }\n\n    if (tmin > tymax || tymin > tmax) return null; // These lines also handle the case where tmin or tmax is NaN\n    // (result of 0 * Infinity). x !== x returns true if x is NaN\n\n    if (tymin > tmin || tmin !== tmin) tmin = tymin;\n    if (tymax < tmax || tmax !== tmax) tmax = tymax;\n\n    if (invdirz >= 0) {\n      tzmin = (box.min.z - origin.z) * invdirz;\n      tzmax = (box.max.z - origin.z) * invdirz;\n    } else {\n      tzmin = (box.max.z - origin.z) * invdirz;\n      tzmax = (box.min.z - origin.z) * invdirz;\n    }\n\n    if (tmin > tzmax || tzmin > tmax) return null;\n    if (tzmin > tmin || tmin !== tmin) tmin = tzmin;\n    if (tzmax < tmax || tmax !== tmax) tmax = tzmax; //return point closest to the ray (positive side)\n\n    if (tmax < 0) return null;\n    return this.at(tmin >= 0 ? tmin : tmax, target);\n  }\n\n  intersectsBox(box) {\n    return this.intersectBox(box, _vector) !== null;\n  }\n\n  intersectTriangle(a, b, c, backfaceCulling, target) {\n    // Compute the offset origin, edges, and normal.\n    // from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h\n    _edge1.subVectors(b, a);\n\n    _edge2.subVectors(c, a);\n\n    _normal.crossVectors(_edge1, _edge2); // Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,\n    // E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by\n    //   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))\n    //   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))\n    //   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)\n\n\n    let DdN = this.direction.dot(_normal);\n    let sign;\n\n    if (DdN > 0) {\n      if (backfaceCulling) return null;\n      sign = 1;\n    } else if (DdN < 0) {\n      sign = -1;\n      DdN = -DdN;\n    } else {\n      return null;\n    }\n\n    _diff.subVectors(this.origin, a);\n\n    const DdQxE2 = sign * this.direction.dot(_edge2.crossVectors(_diff, _edge2)); // b1 < 0, no intersection\n\n    if (DdQxE2 < 0) {\n      return null;\n    }\n\n    const DdE1xQ = sign * this.direction.dot(_edge1.cross(_diff)); // b2 < 0, no intersection\n\n    if (DdE1xQ < 0) {\n      return null;\n    } // b1+b2 > 1, no intersection\n\n\n    if (DdQxE2 + DdE1xQ > DdN) {\n      return null;\n    } // Line intersects triangle, check if ray does.\n\n\n    const QdN = -sign * _diff.dot(_normal); // t < 0, no intersection\n\n\n    if (QdN < 0) {\n      return null;\n    } // Ray intersects triangle.\n\n\n    return this.at(QdN / DdN, target);\n  }\n\n  applyMatrix4(matrix4) {\n    this.origin.applyMatrix4(matrix4);\n    this.direction.transformDirection(matrix4);\n    return this;\n  }\n\n  equals(ray) {\n    return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);\n  }\n\n  clone() {\n    return new this.constructor().copy(this);\n  }\n\n}\n\nexport { Ray };","map":{"version":3,"sources":["C:/Users/dell/Desktop/projektlogin/vue-3-authentication-jwt/src/games/three/src/math/Ray.js"],"names":["Vector3","_vector","_segCenter","_segDir","_diff","_edge1","_edge2","_normal","Ray","constructor","origin","direction","set","copy","ray","at","t","target","multiplyScalar","add","lookAt","v","sub","normalize","recast","closestPointToPoint","point","subVectors","directionDistance","dot","distanceToPoint","Math","sqrt","distanceSqToPoint","distanceToSquared","distanceSqToSegment","v0","v1","optionalPointOnRay","optionalPointOnSegment","segExtent","distanceTo","a01","b0","b1","c","lengthSq","det","abs","s0","s1","sqrDist","extDet","invDet","max","min","intersectSphere","sphere","center","tca","d2","radius2","radius","thc","t0","t1","intersectsSphere","distanceToPlane","plane","denominator","normal","constant","intersectPlane","intersectsPlane","distToPoint","intersectBox","box","tmin","tmax","tymin","tymax","tzmin","tzmax","invdirx","x","invdiry","y","invdirz","z","intersectsBox","intersectTriangle","a","b","backfaceCulling","crossVectors","DdN","sign","DdQxE2","DdE1xQ","cross","QdN","applyMatrix4","matrix4","transformDirection","equals","clone"],"mappings":"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","sourcesContent":["import { Vector3 } from './Vector3.js';\r\n\r\nconst _vector = /*@__PURE__*/ new Vector3();\r\nconst _segCenter = /*@__PURE__*/ new Vector3();\r\nconst _segDir = /*@__PURE__*/ new Vector3();\r\nconst _diff = /*@__PURE__*/ new Vector3();\r\n\r\nconst _edge1 = /*@__PURE__*/ new Vector3();\r\nconst _edge2 = /*@__PURE__*/ new Vector3();\r\nconst _normal = /*@__PURE__*/ new Vector3();\r\n\r\nclass Ray {\r\n\r\n\tconstructor( origin = new Vector3(), direction = new Vector3( 0, 0, - 1 ) ) {\r\n\r\n\t\tthis.origin = origin;\r\n\t\tthis.direction = direction;\r\n\r\n\t}\r\n\r\n\tset( origin, direction ) {\r\n\r\n\t\tthis.origin.copy( origin );\r\n\t\tthis.direction.copy( direction );\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tcopy( ray ) {\r\n\r\n\t\tthis.origin.copy( ray.origin );\r\n\t\tthis.direction.copy( ray.direction );\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tat( t, target ) {\r\n\r\n\t\treturn target.copy( this.direction ).multiplyScalar( t ).add( this.origin );\r\n\r\n\t}\r\n\r\n\tlookAt( v ) {\r\n\r\n\t\tthis.direction.copy( v ).sub( this.origin ).normalize();\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\trecast( t ) {\r\n\r\n\t\tthis.origin.copy( this.at( t, _vector ) );\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tclosestPointToPoint( point, target ) {\r\n\r\n\t\ttarget.subVectors( point, this.origin );\r\n\r\n\t\tconst directionDistance = target.dot( this.direction );\r\n\r\n\t\tif ( directionDistance < 0 ) {\r\n\r\n\t\t\treturn target.copy( this.origin );\r\n\r\n\t\t}\r\n\r\n\t\treturn target.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\r\n\r\n\t}\r\n\r\n\tdistanceToPoint( point ) {\r\n\r\n\t\treturn Math.sqrt( this.distanceSqToPoint( point ) );\r\n\r\n\t}\r\n\r\n\tdistanceSqToPoint( point ) {\r\n\r\n\t\tconst directionDistance = _vector.subVectors( point, this.origin ).dot( this.direction );\r\n\r\n\t\t// point behind the ray\r\n\r\n\t\tif ( directionDistance < 0 ) {\r\n\r\n\t\t\treturn this.origin.distanceToSquared( point );\r\n\r\n\t\t}\r\n\r\n\t\t_vector.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\r\n\r\n\t\treturn _vector.distanceToSquared( point );\r\n\r\n\t}\r\n\r\n\tdistanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {\r\n\r\n\t\t// from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteDistRaySegment.h\r\n\t\t// It returns the min distance between the ray and the segment\r\n\t\t// defined by v0 and v1\r\n\t\t// It can also set two optional targets :\r\n\t\t// - The closest point on the ray\r\n\t\t// - The closest point on the segment\r\n\r\n\t\t_segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );\r\n\t\t_segDir.copy( v1 ).sub( v0 ).normalize();\r\n\t\t_diff.copy( this.origin ).sub( _segCenter );\r\n\r\n\t\tconst segExtent = v0.distanceTo( v1 ) * 0.5;\r\n\t\tconst a01 = - this.direction.dot( _segDir );\r\n\t\tconst b0 = _diff.dot( this.direction );\r\n\t\tconst b1 = - _diff.dot( _segDir );\r\n\t\tconst c = _diff.lengthSq();\r\n\t\tconst det = Math.abs( 1 - a01 * a01 );\r\n\t\tlet s0, s1, sqrDist, extDet;\r\n\r\n\t\tif ( det > 0 ) {\r\n\r\n\t\t\t// The ray and segment are not parallel.\r\n\r\n\t\t\ts0 = a01 * b1 - b0;\r\n\t\t\ts1 = a01 * b0 - b1;\r\n\t\t\textDet = segExtent * det;\r\n\r\n\t\t\tif ( s0 >= 0 ) {\r\n\r\n\t\t\t\tif ( s1 >= - extDet ) {\r\n\r\n\t\t\t\t\tif ( s1 <= extDet ) {\r\n\r\n\t\t\t\t\t\t// region 0\r\n\t\t\t\t\t\t// Minimum at interior points of ray and segment.\r\n\r\n\t\t\t\t\t\tconst invDet = 1 / det;\r\n\t\t\t\t\t\ts0 *= invDet;\r\n\t\t\t\t\t\ts1 *= invDet;\r\n\t\t\t\t\t\tsqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t// region 1\r\n\r\n\t\t\t\t\t\ts1 = segExtent;\r\n\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\r\n\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// region 5\r\n\r\n\t\t\t\t\ts1 = - segExtent;\r\n\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\r\n\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tif ( s1 <= - extDet ) {\r\n\r\n\t\t\t\t\t// region 4\r\n\r\n\t\t\t\t\ts0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );\r\n\t\t\t\t\ts1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\r\n\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\r\n\r\n\t\t\t\t} else if ( s1 <= extDet ) {\r\n\r\n\t\t\t\t\t// region 3\r\n\r\n\t\t\t\t\ts0 = 0;\r\n\t\t\t\t\ts1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );\r\n\t\t\t\t\tsqrDist = s1 * ( s1 + 2 * b1 ) + c;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// region 2\r\n\r\n\t\t\t\t\ts0 = Math.max( 0, - ( a01 * segExtent + b0 ) );\r\n\t\t\t\t\ts1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\r\n\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// Ray and segment are parallel.\r\n\r\n\t\t\ts1 = ( a01 > 0 ) ? - segExtent : segExtent;\r\n\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\r\n\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\r\n\r\n\t\t}\r\n\r\n\t\tif ( optionalPointOnRay ) {\r\n\r\n\t\t\toptionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );\r\n\r\n\t\t}\r\n\r\n\t\tif ( optionalPointOnSegment ) {\r\n\r\n\t\t\toptionalPointOnSegment.copy( _segDir ).multiplyScalar( s1 ).add( _segCenter );\r\n\r\n\t\t}\r\n\r\n\t\treturn sqrDist;\r\n\r\n\t}\r\n\r\n\tintersectSphere( sphere, target ) {\r\n\r\n\t\t_vector.subVectors( sphere.center, this.origin );\r\n\t\tconst tca = _vector.dot( this.direction );\r\n\t\tconst d2 = _vector.dot( _vector ) - tca * tca;\r\n\t\tconst radius2 = sphere.radius * sphere.radius;\r\n\r\n\t\tif ( d2 > radius2 ) return null;\r\n\r\n\t\tconst thc = Math.sqrt( radius2 - d2 );\r\n\r\n\t\t// t0 = first intersect point - entrance on front of sphere\r\n\t\tconst t0 = tca - thc;\r\n\r\n\t\t// t1 = second intersect point - exit point on back of sphere\r\n\t\tconst t1 = tca + thc;\r\n\r\n\t\t// test to see if both t0 and t1 are behind the ray - if so, return null\r\n\t\tif ( t0 < 0 && t1 < 0 ) return null;\r\n\r\n\t\t// test to see if t0 is behind the ray:\r\n\t\t// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,\r\n\t\t// in order to always return an intersect point that is in front of the ray.\r\n\t\tif ( t0 < 0 ) return this.at( t1, target );\r\n\r\n\t\t// else t0 is in front of the ray, so return the first collision point scaled by t0\r\n\t\treturn this.at( t0, target );\r\n\r\n\t}\r\n\r\n\tintersectsSphere( sphere ) {\r\n\r\n\t\treturn this.distanceSqToPoint( sphere.center ) <= ( sphere.radius * sphere.radius );\r\n\r\n\t}\r\n\r\n\tdistanceToPlane( plane ) {\r\n\r\n\t\tconst denominator = plane.normal.dot( this.direction );\r\n\r\n\t\tif ( denominator === 0 ) {\r\n\r\n\t\t\t// line is coplanar, return origin\r\n\t\t\tif ( plane.distanceToPoint( this.origin ) === 0 ) {\r\n\r\n\t\t\t\treturn 0;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Null is preferable to undefined since undefined means.... it is undefined\r\n\r\n\t\t\treturn null;\r\n\r\n\t\t}\r\n\r\n\t\tconst t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;\r\n\r\n\t\t// Return if the ray never intersects the plane\r\n\r\n\t\treturn t >= 0 ? t : null;\r\n\r\n\t}\r\n\r\n\tintersectPlane( plane, target ) {\r\n\r\n\t\tconst t = this.distanceToPlane( plane );\r\n\r\n\t\tif ( t === null ) {\r\n\r\n\t\t\treturn null;\r\n\r\n\t\t}\r\n\r\n\t\treturn this.at( t, target );\r\n\r\n\t}\r\n\r\n\tintersectsPlane( plane ) {\r\n\r\n\t\t// check if the ray lies on the plane first\r\n\r\n\t\tconst distToPoint = plane.distanceToPoint( this.origin );\r\n\r\n\t\tif ( distToPoint === 0 ) {\r\n\r\n\t\t\treturn true;\r\n\r\n\t\t}\r\n\r\n\t\tconst denominator = plane.normal.dot( this.direction );\r\n\r\n\t\tif ( denominator * distToPoint < 0 ) {\r\n\r\n\t\t\treturn true;\r\n\r\n\t\t}\r\n\r\n\t\t// ray origin is behind the plane (and is pointing behind it)\r\n\r\n\t\treturn false;\r\n\r\n\t}\r\n\r\n\tintersectBox( box, target ) {\r\n\r\n\t\tlet tmin, tmax, tymin, tymax, tzmin, tzmax;\r\n\r\n\t\tconst invdirx = 1 / this.direction.x,\r\n\t\t\tinvdiry = 1 / this.direction.y,\r\n\t\t\tinvdirz = 1 / this.direction.z;\r\n\r\n\t\tconst origin = this.origin;\r\n\r\n\t\tif ( invdirx >= 0 ) {\r\n\r\n\t\t\ttmin = ( box.min.x - origin.x ) * invdirx;\r\n\t\t\ttmax = ( box.max.x - origin.x ) * invdirx;\r\n\r\n\t\t} else {\r\n\r\n\t\t\ttmin = ( box.max.x - origin.x ) * invdirx;\r\n\t\t\ttmax = ( box.min.x - origin.x ) * invdirx;\r\n\r\n\t\t}\r\n\r\n\t\tif ( invdiry >= 0 ) {\r\n\r\n\t\t\ttymin = ( box.min.y - origin.y ) * invdiry;\r\n\t\t\ttymax = ( box.max.y - origin.y ) * invdiry;\r\n\r\n\t\t} else {\r\n\r\n\t\t\ttymin = ( box.max.y - origin.y ) * invdiry;\r\n\t\t\ttymax = ( box.min.y - origin.y ) * invdiry;\r\n\r\n\t\t}\r\n\r\n\t\tif ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;\r\n\r\n\t\t// These lines also handle the case where tmin or tmax is NaN\r\n\t\t// (result of 0 * Infinity). x !== x returns true if x is NaN\r\n\r\n\t\tif ( tymin > tmin || tmin !== tmin ) tmin = tymin;\r\n\r\n\t\tif ( tymax < tmax || tmax !== tmax ) tmax = tymax;\r\n\r\n\t\tif ( invdirz >= 0 ) {\r\n\r\n\t\t\ttzmin = ( box.min.z - origin.z ) * invdirz;\r\n\t\t\ttzmax = ( box.max.z - origin.z ) * invdirz;\r\n\r\n\t\t} else {\r\n\r\n\t\t\ttzmin = ( box.max.z - origin.z ) * invdirz;\r\n\t\t\ttzmax = ( box.min.z - origin.z ) * invdirz;\r\n\r\n\t\t}\r\n\r\n\t\tif ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;\r\n\r\n\t\tif ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;\r\n\r\n\t\tif ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;\r\n\r\n\t\t//return point closest to the ray (positive side)\r\n\r\n\t\tif ( tmax < 0 ) return null;\r\n\r\n\t\treturn this.at( tmin >= 0 ? tmin : tmax, target );\r\n\r\n\t}\r\n\r\n\tintersectsBox( box ) {\r\n\r\n\t\treturn this.intersectBox( box, _vector ) !== null;\r\n\r\n\t}\r\n\r\n\tintersectTriangle( a, b, c, backfaceCulling, target ) {\r\n\r\n\t\t// Compute the offset origin, edges, and normal.\r\n\r\n\t\t// from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h\r\n\r\n\t\t_edge1.subVectors( b, a );\r\n\t\t_edge2.subVectors( c, a );\r\n\t\t_normal.crossVectors( _edge1, _edge2 );\r\n\r\n\t\t// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,\r\n\t\t// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by\r\n\t\t//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))\r\n\t\t//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))\r\n\t\t//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)\r\n\t\tlet DdN = this.direction.dot( _normal );\r\n\t\tlet sign;\r\n\r\n\t\tif ( DdN > 0 ) {\r\n\r\n\t\t\tif ( backfaceCulling ) return null;\r\n\t\t\tsign = 1;\r\n\r\n\t\t} else if ( DdN < 0 ) {\r\n\r\n\t\t\tsign = - 1;\r\n\t\t\tDdN = - DdN;\r\n\r\n\t\t} else {\r\n\r\n\t\t\treturn null;\r\n\r\n\t\t}\r\n\r\n\t\t_diff.subVectors( this.origin, a );\r\n\t\tconst DdQxE2 = sign * this.direction.dot( _edge2.crossVectors( _diff, _edge2 ) );\r\n\r\n\t\t// b1 < 0, no intersection\r\n\t\tif ( DdQxE2 < 0 ) {\r\n\r\n\t\t\treturn null;\r\n\r\n\t\t}\r\n\r\n\t\tconst DdE1xQ = sign * this.direction.dot( _edge1.cross( _diff ) );\r\n\r\n\t\t// b2 < 0, no intersection\r\n\t\tif ( DdE1xQ < 0 ) {\r\n\r\n\t\t\treturn null;\r\n\r\n\t\t}\r\n\r\n\t\t// b1+b2 > 1, no intersection\r\n\t\tif ( DdQxE2 + DdE1xQ > DdN ) {\r\n\r\n\t\t\treturn null;\r\n\r\n\t\t}\r\n\r\n\t\t// Line intersects triangle, check if ray does.\r\n\t\tconst QdN = - sign * _diff.dot( _normal );\r\n\r\n\t\t// t < 0, no intersection\r\n\t\tif ( QdN < 0 ) {\r\n\r\n\t\t\treturn null;\r\n\r\n\t\t}\r\n\r\n\t\t// Ray intersects triangle.\r\n\t\treturn this.at( QdN / DdN, target );\r\n\r\n\t}\r\n\r\n\tapplyMatrix4( matrix4 ) {\r\n\r\n\t\tthis.origin.applyMatrix4( matrix4 );\r\n\t\tthis.direction.transformDirection( matrix4 );\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tequals( ray ) {\r\n\r\n\t\treturn ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );\r\n\r\n\t}\r\n\r\n\tclone() {\r\n\r\n\t\treturn new this.constructor().copy( this );\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport { Ray };\r\n"]},"metadata":{},"sourceType":"module"}