{"ast":null,"code":"import \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport { Quaternion } from '../math/Quaternion.js';\n\nclass PropertyMixer {\n  constructor(binding, typeName, valueSize) {\n    this.binding = binding;\n    this.valueSize = valueSize;\n    let mixFunction, mixFunctionAdditive, setIdentity; // buffer layout: [ incoming | accu0 | accu1 | orig | addAccu | (optional work) ]\n    //\n    // interpolators can use .buffer as their .result\n    // the data then goes to 'incoming'\n    //\n    // 'accu0' and 'accu1' are used frame-interleaved for\n    // the cumulative result and are compared to detect\n    // changes\n    //\n    // 'orig' stores the original state of the property\n    //\n    // 'add' is used for additive cumulative results\n    //\n    // 'work' is optional and is only present for quaternion types. It is used\n    // to store intermediate quaternion multiplication results\n\n    switch (typeName) {\n      case 'quaternion':\n        mixFunction = this._slerp;\n        mixFunctionAdditive = this._slerpAdditive;\n        setIdentity = this._setAdditiveIdentityQuaternion;\n        this.buffer = new Float64Array(valueSize * 6);\n        this._workIndex = 5;\n        break;\n\n      case 'string':\n      case 'bool':\n        mixFunction = this._select; // Use the regular mix function and for additive on these types,\n        // additive is not relevant for non-numeric types\n\n        mixFunctionAdditive = this._select;\n        setIdentity = this._setAdditiveIdentityOther;\n        this.buffer = new Array(valueSize * 5);\n        break;\n\n      default:\n        mixFunction = this._lerp;\n        mixFunctionAdditive = this._lerpAdditive;\n        setIdentity = this._setAdditiveIdentityNumeric;\n        this.buffer = new Float64Array(valueSize * 5);\n    }\n\n    this._mixBufferRegion = mixFunction;\n    this._mixBufferRegionAdditive = mixFunctionAdditive;\n    this._setIdentity = setIdentity;\n    this._origIndex = 3;\n    this._addIndex = 4;\n    this.cumulativeWeight = 0;\n    this.cumulativeWeightAdditive = 0;\n    this.useCount = 0;\n    this.referenceCount = 0;\n  } // accumulate data in the 'incoming' region into 'accu<i>'\n\n\n  accumulate(accuIndex, weight) {\n    // note: happily accumulating nothing when weight = 0, the caller knows\n    // the weight and shouldn't have made the call in the first place\n    const buffer = this.buffer,\n          stride = this.valueSize,\n          offset = accuIndex * stride + stride;\n    let currentWeight = this.cumulativeWeight;\n\n    if (currentWeight === 0) {\n      // accuN := incoming * weight\n      for (let i = 0; i !== stride; ++i) {\n        buffer[offset + i] = buffer[i];\n      }\n\n      currentWeight = weight;\n    } else {\n      // accuN := accuN + incoming * weight\n      currentWeight += weight;\n      const mix = weight / currentWeight;\n\n      this._mixBufferRegion(buffer, offset, 0, mix, stride);\n    }\n\n    this.cumulativeWeight = currentWeight;\n  } // accumulate data in the 'incoming' region into 'add'\n\n\n  accumulateAdditive(weight) {\n    const buffer = this.buffer,\n          stride = this.valueSize,\n          offset = stride * this._addIndex;\n\n    if (this.cumulativeWeightAdditive === 0) {\n      // add = identity\n      this._setIdentity();\n    } // add := add + incoming * weight\n\n\n    this._mixBufferRegionAdditive(buffer, offset, 0, weight, stride);\n\n    this.cumulativeWeightAdditive += weight;\n  } // apply the state of 'accu<i>' to the binding when accus differ\n\n\n  apply(accuIndex) {\n    const stride = this.valueSize,\n          buffer = this.buffer,\n          offset = accuIndex * stride + stride,\n          weight = this.cumulativeWeight,\n          weightAdditive = this.cumulativeWeightAdditive,\n          binding = this.binding;\n    this.cumulativeWeight = 0;\n    this.cumulativeWeightAdditive = 0;\n\n    if (weight < 1) {\n      // accuN := accuN + original * ( 1 - cumulativeWeight )\n      const originalValueOffset = stride * this._origIndex;\n\n      this._mixBufferRegion(buffer, offset, originalValueOffset, 1 - weight, stride);\n    }\n\n    if (weightAdditive > 0) {\n      // accuN := accuN + additive accuN\n      this._mixBufferRegionAdditive(buffer, offset, this._addIndex * stride, 1, stride);\n    }\n\n    for (let i = stride, e = stride + stride; i !== e; ++i) {\n      if (buffer[i] !== buffer[i + stride]) {\n        // value has changed -> update scene graph\n        binding.setValue(buffer, offset);\n        break;\n      }\n    }\n  } // remember the state of the bound property and copy it to both accus\n\n\n  saveOriginalState() {\n    const binding = this.binding;\n    const buffer = this.buffer,\n          stride = this.valueSize,\n          originalValueOffset = stride * this._origIndex;\n    binding.getValue(buffer, originalValueOffset); // accu[0..1] := orig -- initially detect changes against the original\n\n    for (let i = stride, e = originalValueOffset; i !== e; ++i) {\n      buffer[i] = buffer[originalValueOffset + i % stride];\n    } // Add to identity for additive\n\n\n    this._setIdentity();\n\n    this.cumulativeWeight = 0;\n    this.cumulativeWeightAdditive = 0;\n  } // apply the state previously taken via 'saveOriginalState' to the binding\n\n\n  restoreOriginalState() {\n    const originalValueOffset = this.valueSize * 3;\n    this.binding.setValue(this.buffer, originalValueOffset);\n  }\n\n  _setAdditiveIdentityNumeric() {\n    const startIndex = this._addIndex * this.valueSize;\n    const endIndex = startIndex + this.valueSize;\n\n    for (let i = startIndex; i < endIndex; i++) {\n      this.buffer[i] = 0;\n    }\n  }\n\n  _setAdditiveIdentityQuaternion() {\n    this._setAdditiveIdentityNumeric();\n\n    this.buffer[this._addIndex * this.valueSize + 3] = 1;\n  }\n\n  _setAdditiveIdentityOther() {\n    const startIndex = this._origIndex * this.valueSize;\n    const targetIndex = this._addIndex * this.valueSize;\n\n    for (let i = 0; i < this.valueSize; i++) {\n      this.buffer[targetIndex + i] = this.buffer[startIndex + i];\n    }\n  } // mix functions\n\n\n  _select(buffer, dstOffset, srcOffset, t, stride) {\n    if (t >= 0.5) {\n      for (let i = 0; i !== stride; ++i) {\n        buffer[dstOffset + i] = buffer[srcOffset + i];\n      }\n    }\n  }\n\n  _slerp(buffer, dstOffset, srcOffset, t) {\n    Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t);\n  }\n\n  _slerpAdditive(buffer, dstOffset, srcOffset, t, stride) {\n    const workOffset = this._workIndex * stride; // Store result in intermediate buffer offset\n\n    Quaternion.multiplyQuaternionsFlat(buffer, workOffset, buffer, dstOffset, buffer, srcOffset); // Slerp to the intermediate result\n\n    Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t);\n  }\n\n  _lerp(buffer, dstOffset, srcOffset, t, stride) {\n    const s = 1 - t;\n\n    for (let i = 0; i !== stride; ++i) {\n      const j = dstOffset + i;\n      buffer[j] = buffer[j] * s + buffer[srcOffset + i] * t;\n    }\n  }\n\n  _lerpAdditive(buffer, dstOffset, srcOffset, t, stride) {\n    for (let i = 0; i !== stride; ++i) {\n      const j = dstOffset + i;\n      buffer[j] = buffer[j] + buffer[srcOffset + i] * t;\n    }\n  }\n\n}\n\nexport { PropertyMixer };","map":{"version":3,"sources":["C:/Users/dell/Desktop/projektlogin/vue-3-authentication-jwt/src/games/three/src/animation/PropertyMixer.js"],"names":["Quaternion","PropertyMixer","constructor","binding","typeName","valueSize","mixFunction","mixFunctionAdditive","setIdentity","_slerp","_slerpAdditive","_setAdditiveIdentityQuaternion","buffer","Float64Array","_workIndex","_select","_setAdditiveIdentityOther","Array","_lerp","_lerpAdditive","_setAdditiveIdentityNumeric","_mixBufferRegion","_mixBufferRegionAdditive","_setIdentity","_origIndex","_addIndex","cumulativeWeight","cumulativeWeightAdditive","useCount","referenceCount","accumulate","accuIndex","weight","stride","offset","currentWeight","i","mix","accumulateAdditive","apply","weightAdditive","originalValueOffset","e","setValue","saveOriginalState","getValue","restoreOriginalState","startIndex","endIndex","targetIndex","dstOffset","srcOffset","t","slerpFlat","workOffset","multiplyQuaternionsFlat","s","j"],"mappings":"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","sourcesContent":["import { Quaternion } from '../math/Quaternion.js';\r\n\r\nclass PropertyMixer {\r\n\r\n\tconstructor( binding, typeName, valueSize ) {\r\n\r\n\t\tthis.binding = binding;\r\n\t\tthis.valueSize = valueSize;\r\n\r\n\t\tlet mixFunction,\r\n\t\t\tmixFunctionAdditive,\r\n\t\t\tsetIdentity;\r\n\r\n\t\t// buffer layout: [ incoming | accu0 | accu1 | orig | addAccu | (optional work) ]\r\n\t\t//\r\n\t\t// interpolators can use .buffer as their .result\r\n\t\t// the data then goes to 'incoming'\r\n\t\t//\r\n\t\t// 'accu0' and 'accu1' are used frame-interleaved for\r\n\t\t// the cumulative result and are compared to detect\r\n\t\t// changes\r\n\t\t//\r\n\t\t// 'orig' stores the original state of the property\r\n\t\t//\r\n\t\t// 'add' is used for additive cumulative results\r\n\t\t//\r\n\t\t// 'work' is optional and is only present for quaternion types. It is used\r\n\t\t// to store intermediate quaternion multiplication results\r\n\r\n\t\tswitch ( typeName ) {\r\n\r\n\t\t\tcase 'quaternion':\r\n\t\t\t\tmixFunction = this._slerp;\r\n\t\t\t\tmixFunctionAdditive = this._slerpAdditive;\r\n\t\t\t\tsetIdentity = this._setAdditiveIdentityQuaternion;\r\n\r\n\t\t\t\tthis.buffer = new Float64Array( valueSize * 6 );\r\n\t\t\t\tthis._workIndex = 5;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'string':\r\n\t\t\tcase 'bool':\r\n\t\t\t\tmixFunction = this._select;\r\n\r\n\t\t\t\t// Use the regular mix function and for additive on these types,\r\n\t\t\t\t// additive is not relevant for non-numeric types\r\n\t\t\t\tmixFunctionAdditive = this._select;\r\n\r\n\t\t\t\tsetIdentity = this._setAdditiveIdentityOther;\r\n\r\n\t\t\t\tthis.buffer = new Array( valueSize * 5 );\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tdefault:\r\n\t\t\t\tmixFunction = this._lerp;\r\n\t\t\t\tmixFunctionAdditive = this._lerpAdditive;\r\n\t\t\t\tsetIdentity = this._setAdditiveIdentityNumeric;\r\n\r\n\t\t\t\tthis.buffer = new Float64Array( valueSize * 5 );\r\n\r\n\t\t}\r\n\r\n\t\tthis._mixBufferRegion = mixFunction;\r\n\t\tthis._mixBufferRegionAdditive = mixFunctionAdditive;\r\n\t\tthis._setIdentity = setIdentity;\r\n\t\tthis._origIndex = 3;\r\n\t\tthis._addIndex = 4;\r\n\r\n\t\tthis.cumulativeWeight = 0;\r\n\t\tthis.cumulativeWeightAdditive = 0;\r\n\r\n\t\tthis.useCount = 0;\r\n\t\tthis.referenceCount = 0;\r\n\r\n\t}\r\n\r\n\t// accumulate data in the 'incoming' region into 'accu<i>'\r\n\taccumulate( accuIndex, weight ) {\r\n\r\n\t\t// note: happily accumulating nothing when weight = 0, the caller knows\r\n\t\t// the weight and shouldn't have made the call in the first place\r\n\r\n\t\tconst buffer = this.buffer,\r\n\t\t\tstride = this.valueSize,\r\n\t\t\toffset = accuIndex * stride + stride;\r\n\r\n\t\tlet currentWeight = this.cumulativeWeight;\r\n\r\n\t\tif ( currentWeight === 0 ) {\r\n\r\n\t\t\t// accuN := incoming * weight\r\n\r\n\t\t\tfor ( let i = 0; i !== stride; ++ i ) {\r\n\r\n\t\t\t\tbuffer[ offset + i ] = buffer[ i ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tcurrentWeight = weight;\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// accuN := accuN + incoming * weight\r\n\r\n\t\t\tcurrentWeight += weight;\r\n\t\t\tconst mix = weight / currentWeight;\r\n\t\t\tthis._mixBufferRegion( buffer, offset, 0, mix, stride );\r\n\r\n\t\t}\r\n\r\n\t\tthis.cumulativeWeight = currentWeight;\r\n\r\n\t}\r\n\r\n\t// accumulate data in the 'incoming' region into 'add'\r\n\taccumulateAdditive( weight ) {\r\n\r\n\t\tconst buffer = this.buffer,\r\n\t\t\tstride = this.valueSize,\r\n\t\t\toffset = stride * this._addIndex;\r\n\r\n\t\tif ( this.cumulativeWeightAdditive === 0 ) {\r\n\r\n\t\t\t// add = identity\r\n\r\n\t\t\tthis._setIdentity();\r\n\r\n\t\t}\r\n\r\n\t\t// add := add + incoming * weight\r\n\r\n\t\tthis._mixBufferRegionAdditive( buffer, offset, 0, weight, stride );\r\n\t\tthis.cumulativeWeightAdditive += weight;\r\n\r\n\t}\r\n\r\n\t// apply the state of 'accu<i>' to the binding when accus differ\r\n\tapply( accuIndex ) {\r\n\r\n\t\tconst stride = this.valueSize,\r\n\t\t\tbuffer = this.buffer,\r\n\t\t\toffset = accuIndex * stride + stride,\r\n\r\n\t\t\tweight = this.cumulativeWeight,\r\n\t\t\tweightAdditive = this.cumulativeWeightAdditive,\r\n\r\n\t\t\tbinding = this.binding;\r\n\r\n\t\tthis.cumulativeWeight = 0;\r\n\t\tthis.cumulativeWeightAdditive = 0;\r\n\r\n\t\tif ( weight < 1 ) {\r\n\r\n\t\t\t// accuN := accuN + original * ( 1 - cumulativeWeight )\r\n\r\n\t\t\tconst originalValueOffset = stride * this._origIndex;\r\n\r\n\t\t\tthis._mixBufferRegion(\r\n\t\t\t\tbuffer, offset, originalValueOffset, 1 - weight, stride );\r\n\r\n\t\t}\r\n\r\n\t\tif ( weightAdditive > 0 ) {\r\n\r\n\t\t\t// accuN := accuN + additive accuN\r\n\r\n\t\t\tthis._mixBufferRegionAdditive( buffer, offset, this._addIndex * stride, 1, stride );\r\n\r\n\t\t}\r\n\r\n\t\tfor ( let i = stride, e = stride + stride; i !== e; ++ i ) {\r\n\r\n\t\t\tif ( buffer[ i ] !== buffer[ i + stride ] ) {\r\n\r\n\t\t\t\t// value has changed -> update scene graph\r\n\r\n\t\t\t\tbinding.setValue( buffer, offset );\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// remember the state of the bound property and copy it to both accus\r\n\tsaveOriginalState() {\r\n\r\n\t\tconst binding = this.binding;\r\n\r\n\t\tconst buffer = this.buffer,\r\n\t\t\tstride = this.valueSize,\r\n\r\n\t\t\toriginalValueOffset = stride * this._origIndex;\r\n\r\n\t\tbinding.getValue( buffer, originalValueOffset );\r\n\r\n\t\t// accu[0..1] := orig -- initially detect changes against the original\r\n\t\tfor ( let i = stride, e = originalValueOffset; i !== e; ++ i ) {\r\n\r\n\t\t\tbuffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];\r\n\r\n\t\t}\r\n\r\n\t\t// Add to identity for additive\r\n\t\tthis._setIdentity();\r\n\r\n\t\tthis.cumulativeWeight = 0;\r\n\t\tthis.cumulativeWeightAdditive = 0;\r\n\r\n\t}\r\n\r\n\t// apply the state previously taken via 'saveOriginalState' to the binding\r\n\trestoreOriginalState() {\r\n\r\n\t\tconst originalValueOffset = this.valueSize * 3;\r\n\t\tthis.binding.setValue( this.buffer, originalValueOffset );\r\n\r\n\t}\r\n\r\n\t_setAdditiveIdentityNumeric() {\r\n\r\n\t\tconst startIndex = this._addIndex * this.valueSize;\r\n\t\tconst endIndex = startIndex + this.valueSize;\r\n\r\n\t\tfor ( let i = startIndex; i < endIndex; i ++ ) {\r\n\r\n\t\t\tthis.buffer[ i ] = 0;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t_setAdditiveIdentityQuaternion() {\r\n\r\n\t\tthis._setAdditiveIdentityNumeric();\r\n\t\tthis.buffer[ this._addIndex * this.valueSize + 3 ] = 1;\r\n\r\n\t}\r\n\r\n\t_setAdditiveIdentityOther() {\r\n\r\n\t\tconst startIndex = this._origIndex * this.valueSize;\r\n\t\tconst targetIndex = this._addIndex * this.valueSize;\r\n\r\n\t\tfor ( let i = 0; i < this.valueSize; i ++ ) {\r\n\r\n\t\t\tthis.buffer[ targetIndex + i ] = this.buffer[ startIndex + i ];\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\r\n\t// mix functions\r\n\r\n\t_select( buffer, dstOffset, srcOffset, t, stride ) {\r\n\r\n\t\tif ( t >= 0.5 ) {\r\n\r\n\t\t\tfor ( let i = 0; i !== stride; ++ i ) {\r\n\r\n\t\t\t\tbuffer[ dstOffset + i ] = buffer[ srcOffset + i ];\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t_slerp( buffer, dstOffset, srcOffset, t ) {\r\n\r\n\t\tQuaternion.slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t );\r\n\r\n\t}\r\n\r\n\t_slerpAdditive( buffer, dstOffset, srcOffset, t, stride ) {\r\n\r\n\t\tconst workOffset = this._workIndex * stride;\r\n\r\n\t\t// Store result in intermediate buffer offset\r\n\t\tQuaternion.multiplyQuaternionsFlat( buffer, workOffset, buffer, dstOffset, buffer, srcOffset );\r\n\r\n\t\t// Slerp to the intermediate result\r\n\t\tQuaternion.slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t );\r\n\r\n\t}\r\n\r\n\t_lerp( buffer, dstOffset, srcOffset, t, stride ) {\r\n\r\n\t\tconst s = 1 - t;\r\n\r\n\t\tfor ( let i = 0; i !== stride; ++ i ) {\r\n\r\n\t\t\tconst j = dstOffset + i;\r\n\r\n\t\t\tbuffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t_lerpAdditive( buffer, dstOffset, srcOffset, t, stride ) {\r\n\r\n\t\tfor ( let i = 0; i !== stride; ++ i ) {\r\n\r\n\t\t\tconst j = dstOffset + i;\r\n\r\n\t\t\tbuffer[ j ] = buffer[ j ] + buffer[ srcOffset + i ] * t;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\nexport { PropertyMixer };\r\n"]},"metadata":{},"sourceType":"module"}