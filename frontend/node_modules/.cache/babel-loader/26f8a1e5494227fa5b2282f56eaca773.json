{"ast":null,"code":"import { Box3 } from './Box3.js';\nimport { Vector3 } from './Vector3.js';\n\nconst _box = /*@__PURE__*/new Box3();\n\nconst _v1 = /*@__PURE__*/new Vector3();\n\nconst _toFarthestPoint = /*@__PURE__*/new Vector3();\n\nconst _toPoint = /*@__PURE__*/new Vector3();\n\nclass Sphere {\n  constructor(center = new Vector3(), radius = -1) {\n    this.center = center;\n    this.radius = radius;\n  }\n\n  set(center, radius) {\n    this.center.copy(center);\n    this.radius = radius;\n    return this;\n  }\n\n  setFromPoints(points, optionalCenter) {\n    const center = this.center;\n\n    if (optionalCenter !== undefined) {\n      center.copy(optionalCenter);\n    } else {\n      _box.setFromPoints(points).getCenter(center);\n    }\n\n    let maxRadiusSq = 0;\n\n    for (let i = 0, il = points.length; i < il; i++) {\n      maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));\n    }\n\n    this.radius = Math.sqrt(maxRadiusSq);\n    return this;\n  }\n\n  copy(sphere) {\n    this.center.copy(sphere.center);\n    this.radius = sphere.radius;\n    return this;\n  }\n\n  isEmpty() {\n    return this.radius < 0;\n  }\n\n  makeEmpty() {\n    this.center.set(0, 0, 0);\n    this.radius = -1;\n    return this;\n  }\n\n  containsPoint(point) {\n    return point.distanceToSquared(this.center) <= this.radius * this.radius;\n  }\n\n  distanceToPoint(point) {\n    return point.distanceTo(this.center) - this.radius;\n  }\n\n  intersectsSphere(sphere) {\n    const radiusSum = this.radius + sphere.radius;\n    return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;\n  }\n\n  intersectsBox(box) {\n    return box.intersectsSphere(this);\n  }\n\n  intersectsPlane(plane) {\n    return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;\n  }\n\n  clampPoint(point, target) {\n    const deltaLengthSq = this.center.distanceToSquared(point);\n    target.copy(point);\n\n    if (deltaLengthSq > this.radius * this.radius) {\n      target.sub(this.center).normalize();\n      target.multiplyScalar(this.radius).add(this.center);\n    }\n\n    return target;\n  }\n\n  getBoundingBox(target) {\n    if (this.isEmpty()) {\n      // Empty sphere produces empty bounding box\n      target.makeEmpty();\n      return target;\n    }\n\n    target.set(this.center, this.center);\n    target.expandByScalar(this.radius);\n    return target;\n  }\n\n  applyMatrix4(matrix) {\n    this.center.applyMatrix4(matrix);\n    this.radius = this.radius * matrix.getMaxScaleOnAxis();\n    return this;\n  }\n\n  translate(offset) {\n    this.center.add(offset);\n    return this;\n  }\n\n  expandByPoint(point) {\n    // from https://github.com/juj/MathGeoLib/blob/2940b99b99cfe575dd45103ef20f4019dee15b54/src/Geometry/Sphere.cpp#L649-L671\n    _toPoint.subVectors(point, this.center);\n\n    const lengthSq = _toPoint.lengthSq();\n\n    if (lengthSq > this.radius * this.radius) {\n      const length = Math.sqrt(lengthSq);\n      const missingRadiusHalf = (length - this.radius) * 0.5; // Nudge this sphere towards the target point. Add half the missing distance to radius,\n      // and the other half to position. This gives a tighter enclosure, instead of if\n      // the whole missing distance were just added to radius.\n\n      this.center.add(_toPoint.multiplyScalar(missingRadiusHalf / length));\n      this.radius += missingRadiusHalf;\n    }\n\n    return this;\n  }\n\n  union(sphere) {\n    // from https://github.com/juj/MathGeoLib/blob/2940b99b99cfe575dd45103ef20f4019dee15b54/src/Geometry/Sphere.cpp#L759-L769\n    // To enclose another sphere into this sphere, we only need to enclose two points:\n    // 1) Enclose the farthest point on the other sphere into this sphere.\n    // 2) Enclose the opposite point of the farthest point into this sphere.\n    if (this.center.equals(sphere.center) === true) {\n      _toFarthestPoint.set(0, 0, 1).multiplyScalar(sphere.radius);\n    } else {\n      _toFarthestPoint.subVectors(sphere.center, this.center).normalize().multiplyScalar(sphere.radius);\n    }\n\n    this.expandByPoint(_v1.copy(sphere.center).add(_toFarthestPoint));\n    this.expandByPoint(_v1.copy(sphere.center).sub(_toFarthestPoint));\n    return this;\n  }\n\n  equals(sphere) {\n    return sphere.center.equals(this.center) && sphere.radius === this.radius;\n  }\n\n  clone() {\n    return new this.constructor().copy(this);\n  }\n\n}\n\nexport { Sphere };","map":{"version":3,"sources":["C:/Users/dell/Desktop/projektlogin/vue-3-authentication-jwt/src/games/three/src/math/Sphere.js"],"names":["Box3","Vector3","_box","_v1","_toFarthestPoint","_toPoint","Sphere","constructor","center","radius","set","copy","setFromPoints","points","optionalCenter","undefined","getCenter","maxRadiusSq","i","il","length","Math","max","distanceToSquared","sqrt","sphere","isEmpty","makeEmpty","containsPoint","point","distanceToPoint","distanceTo","intersectsSphere","radiusSum","intersectsBox","box","intersectsPlane","plane","abs","clampPoint","target","deltaLengthSq","sub","normalize","multiplyScalar","add","getBoundingBox","expandByScalar","applyMatrix4","matrix","getMaxScaleOnAxis","translate","offset","expandByPoint","subVectors","lengthSq","missingRadiusHalf","union","equals","clone"],"mappings":"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","sourcesContent":["import { Box3 } from './Box3.js';\r\nimport { Vector3 } from './Vector3.js';\r\n\r\nconst _box = /*@__PURE__*/ new Box3();\r\nconst _v1 = /*@__PURE__*/ new Vector3();\r\nconst _toFarthestPoint = /*@__PURE__*/ new Vector3();\r\nconst _toPoint = /*@__PURE__*/ new Vector3();\r\n\r\nclass Sphere {\r\n\r\n\tconstructor( center = new Vector3(), radius = - 1 ) {\r\n\r\n\t\tthis.center = center;\r\n\t\tthis.radius = radius;\r\n\r\n\t}\r\n\r\n\tset( center, radius ) {\r\n\r\n\t\tthis.center.copy( center );\r\n\t\tthis.radius = radius;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tsetFromPoints( points, optionalCenter ) {\r\n\r\n\t\tconst center = this.center;\r\n\r\n\t\tif ( optionalCenter !== undefined ) {\r\n\r\n\t\t\tcenter.copy( optionalCenter );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t_box.setFromPoints( points ).getCenter( center );\r\n\r\n\t\t}\r\n\r\n\t\tlet maxRadiusSq = 0;\r\n\r\n\t\tfor ( let i = 0, il = points.length; i < il; i ++ ) {\r\n\r\n\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );\r\n\r\n\t\t}\r\n\r\n\t\tthis.radius = Math.sqrt( maxRadiusSq );\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tcopy( sphere ) {\r\n\r\n\t\tthis.center.copy( sphere.center );\r\n\t\tthis.radius = sphere.radius;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tisEmpty() {\r\n\r\n\t\treturn ( this.radius < 0 );\r\n\r\n\t}\r\n\r\n\tmakeEmpty() {\r\n\r\n\t\tthis.center.set( 0, 0, 0 );\r\n\t\tthis.radius = - 1;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tcontainsPoint( point ) {\r\n\r\n\t\treturn ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );\r\n\r\n\t}\r\n\r\n\tdistanceToPoint( point ) {\r\n\r\n\t\treturn ( point.distanceTo( this.center ) - this.radius );\r\n\r\n\t}\r\n\r\n\tintersectsSphere( sphere ) {\r\n\r\n\t\tconst radiusSum = this.radius + sphere.radius;\r\n\r\n\t\treturn sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );\r\n\r\n\t}\r\n\r\n\tintersectsBox( box ) {\r\n\r\n\t\treturn box.intersectsSphere( this );\r\n\r\n\t}\r\n\r\n\tintersectsPlane( plane ) {\r\n\r\n\t\treturn Math.abs( plane.distanceToPoint( this.center ) ) <= this.radius;\r\n\r\n\t}\r\n\r\n\tclampPoint( point, target ) {\r\n\r\n\t\tconst deltaLengthSq = this.center.distanceToSquared( point );\r\n\r\n\t\ttarget.copy( point );\r\n\r\n\t\tif ( deltaLengthSq > ( this.radius * this.radius ) ) {\r\n\r\n\t\t\ttarget.sub( this.center ).normalize();\r\n\t\t\ttarget.multiplyScalar( this.radius ).add( this.center );\r\n\r\n\t\t}\r\n\r\n\t\treturn target;\r\n\r\n\t}\r\n\r\n\tgetBoundingBox( target ) {\r\n\r\n\t\tif ( this.isEmpty() ) {\r\n\r\n\t\t\t// Empty sphere produces empty bounding box\r\n\t\t\ttarget.makeEmpty();\r\n\t\t\treturn target;\r\n\r\n\t\t}\r\n\r\n\t\ttarget.set( this.center, this.center );\r\n\t\ttarget.expandByScalar( this.radius );\r\n\r\n\t\treturn target;\r\n\r\n\t}\r\n\r\n\tapplyMatrix4( matrix ) {\r\n\r\n\t\tthis.center.applyMatrix4( matrix );\r\n\t\tthis.radius = this.radius * matrix.getMaxScaleOnAxis();\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\ttranslate( offset ) {\r\n\r\n\t\tthis.center.add( offset );\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\texpandByPoint( point ) {\r\n\r\n\t\t// from https://github.com/juj/MathGeoLib/blob/2940b99b99cfe575dd45103ef20f4019dee15b54/src/Geometry/Sphere.cpp#L649-L671\r\n\r\n\t\t_toPoint.subVectors( point, this.center );\r\n\r\n\t\tconst lengthSq = _toPoint.lengthSq();\r\n\r\n\t\tif ( lengthSq > ( this.radius * this.radius ) ) {\r\n\r\n\t\t\tconst length = Math.sqrt( lengthSq );\r\n\t\t\tconst missingRadiusHalf = ( length - this.radius ) * 0.5;\r\n\r\n\t\t\t// Nudge this sphere towards the target point. Add half the missing distance to radius,\r\n\t\t\t// and the other half to position. This gives a tighter enclosure, instead of if\r\n\t\t\t// the whole missing distance were just added to radius.\r\n\r\n\t\t\tthis.center.add( _toPoint.multiplyScalar( missingRadiusHalf / length ) );\r\n\t\t\tthis.radius += missingRadiusHalf;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tunion( sphere ) {\r\n\r\n\t\t// from https://github.com/juj/MathGeoLib/blob/2940b99b99cfe575dd45103ef20f4019dee15b54/src/Geometry/Sphere.cpp#L759-L769\r\n\r\n\t\t// To enclose another sphere into this sphere, we only need to enclose two points:\r\n\t\t// 1) Enclose the farthest point on the other sphere into this sphere.\r\n\t\t// 2) Enclose the opposite point of the farthest point into this sphere.\r\n\r\n\t\t if ( this.center.equals( sphere.center ) === true ) {\r\n\r\n\t\t\t _toFarthestPoint.set( 0, 0, 1 ).multiplyScalar( sphere.radius );\r\n\r\n\r\n\t\t} else {\r\n\r\n\t\t\t_toFarthestPoint.subVectors( sphere.center, this.center ).normalize().multiplyScalar( sphere.radius );\r\n\r\n\t\t}\r\n\r\n\t\tthis.expandByPoint( _v1.copy( sphere.center ).add( _toFarthestPoint ) );\r\n\t\tthis.expandByPoint( _v1.copy( sphere.center ).sub( _toFarthestPoint ) );\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tequals( sphere ) {\r\n\r\n\t\treturn sphere.center.equals( this.center ) && ( sphere.radius === this.radius );\r\n\r\n\t}\r\n\r\n\tclone() {\r\n\r\n\t\treturn new this.constructor().copy( this );\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport { Sphere };\r\n"]},"metadata":{},"sourceType":"module"}