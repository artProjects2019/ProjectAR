{"ast":null,"code":"import { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport * as MathUtils from '../math/MathUtils.js';\nimport { Triangle } from '../math/Triangle.js';\nimport { Vector3 } from '../math/Vector3.js';\n\nconst _v0 = new Vector3();\n\nconst _v1 = new Vector3();\n\nconst _normal = new Vector3();\n\nconst _triangle = new Triangle();\n\nclass EdgesGeometry extends BufferGeometry {\n  constructor(geometry = null, thresholdAngle = 1) {\n    super();\n    this.type = 'EdgesGeometry';\n    this.parameters = {\n      geometry: geometry,\n      thresholdAngle: thresholdAngle\n    };\n\n    if (geometry !== null) {\n      const precisionPoints = 4;\n      const precision = Math.pow(10, precisionPoints);\n      const thresholdDot = Math.cos(MathUtils.DEG2RAD * thresholdAngle);\n      const indexAttr = geometry.getIndex();\n      const positionAttr = geometry.getAttribute('position');\n      const indexCount = indexAttr ? indexAttr.count : positionAttr.count;\n      const indexArr = [0, 0, 0];\n      const vertKeys = ['a', 'b', 'c'];\n      const hashes = new Array(3);\n      const edgeData = {};\n      const vertices = [];\n\n      for (let i = 0; i < indexCount; i += 3) {\n        if (indexAttr) {\n          indexArr[0] = indexAttr.getX(i);\n          indexArr[1] = indexAttr.getX(i + 1);\n          indexArr[2] = indexAttr.getX(i + 2);\n        } else {\n          indexArr[0] = i;\n          indexArr[1] = i + 1;\n          indexArr[2] = i + 2;\n        }\n\n        const {\n          a,\n          b,\n          c\n        } = _triangle;\n        a.fromBufferAttribute(positionAttr, indexArr[0]);\n        b.fromBufferAttribute(positionAttr, indexArr[1]);\n        c.fromBufferAttribute(positionAttr, indexArr[2]);\n\n        _triangle.getNormal(_normal); // create hashes for the edge from the vertices\n\n\n        hashes[0] = `${Math.round(a.x * precision)},${Math.round(a.y * precision)},${Math.round(a.z * precision)}`;\n        hashes[1] = `${Math.round(b.x * precision)},${Math.round(b.y * precision)},${Math.round(b.z * precision)}`;\n        hashes[2] = `${Math.round(c.x * precision)},${Math.round(c.y * precision)},${Math.round(c.z * precision)}`; // skip degenerate triangles\n\n        if (hashes[0] === hashes[1] || hashes[1] === hashes[2] || hashes[2] === hashes[0]) {\n          continue;\n        } // iterate over every edge\n\n\n        for (let j = 0; j < 3; j++) {\n          // get the first and next vertex making up the edge\n          const jNext = (j + 1) % 3;\n          const vecHash0 = hashes[j];\n          const vecHash1 = hashes[jNext];\n          const v0 = _triangle[vertKeys[j]];\n          const v1 = _triangle[vertKeys[jNext]];\n          const hash = `${vecHash0}_${vecHash1}`;\n          const reverseHash = `${vecHash1}_${vecHash0}`;\n\n          if (reverseHash in edgeData && edgeData[reverseHash]) {\n            // if we found a sibling edge add it into the vertex array if\n            // it meets the angle threshold and delete the edge from the map.\n            if (_normal.dot(edgeData[reverseHash].normal) <= thresholdDot) {\n              vertices.push(v0.x, v0.y, v0.z);\n              vertices.push(v1.x, v1.y, v1.z);\n            }\n\n            edgeData[reverseHash] = null;\n          } else if (!(hash in edgeData)) {\n            // if we've already got an edge here then skip adding a new one\n            edgeData[hash] = {\n              index0: indexArr[j],\n              index1: indexArr[jNext],\n              normal: _normal.clone()\n            };\n          }\n        }\n      } // iterate over all remaining, unmatched edges and add them to the vertex array\n\n\n      for (const key in edgeData) {\n        if (edgeData[key]) {\n          const {\n            index0,\n            index1\n          } = edgeData[key];\n\n          _v0.fromBufferAttribute(positionAttr, index0);\n\n          _v1.fromBufferAttribute(positionAttr, index1);\n\n          vertices.push(_v0.x, _v0.y, _v0.z);\n          vertices.push(_v1.x, _v1.y, _v1.z);\n        }\n      }\n\n      this.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n    }\n  }\n\n}\n\nexport { EdgesGeometry };","map":{"version":3,"sources":["C:/Users/dell/Desktop/projektlogin/vue-3-authentication-jwt/src/games/three/src/geometries/EdgesGeometry.js"],"names":["BufferGeometry","Float32BufferAttribute","MathUtils","Triangle","Vector3","_v0","_v1","_normal","_triangle","EdgesGeometry","constructor","geometry","thresholdAngle","type","parameters","precisionPoints","precision","Math","pow","thresholdDot","cos","DEG2RAD","indexAttr","getIndex","positionAttr","getAttribute","indexCount","count","indexArr","vertKeys","hashes","Array","edgeData","vertices","i","getX","a","b","c","fromBufferAttribute","getNormal","round","x","y","z","j","jNext","vecHash0","vecHash1","v0","v1","hash","reverseHash","dot","normal","push","index0","index1","clone","key","setAttribute"],"mappings":"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","sourcesContent":["import { BufferGeometry } from '../core/BufferGeometry.js';\r\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\r\nimport * as MathUtils from '../math/MathUtils.js';\r\nimport { Triangle } from '../math/Triangle.js';\r\nimport { Vector3 } from '../math/Vector3.js';\r\n\r\nconst _v0 = new Vector3();\r\nconst _v1 = new Vector3();\r\nconst _normal = new Vector3();\r\nconst _triangle = new Triangle();\r\n\r\nclass EdgesGeometry extends BufferGeometry {\r\n\r\n\tconstructor( geometry = null, thresholdAngle = 1 ) {\r\n\r\n\t\tsuper();\r\n\t\tthis.type = 'EdgesGeometry';\r\n\r\n\t\tthis.parameters = {\r\n\t\t\tgeometry: geometry,\r\n\t\t\tthresholdAngle: thresholdAngle\r\n\t\t};\r\n\r\n\t\tif ( geometry !== null ) {\r\n\r\n\t\t\tconst precisionPoints = 4;\r\n\t\t\tconst precision = Math.pow( 10, precisionPoints );\r\n\t\t\tconst thresholdDot = Math.cos( MathUtils.DEG2RAD * thresholdAngle );\r\n\r\n\t\t\tconst indexAttr = geometry.getIndex();\r\n\t\t\tconst positionAttr = geometry.getAttribute( 'position' );\r\n\t\t\tconst indexCount = indexAttr ? indexAttr.count : positionAttr.count;\r\n\r\n\t\t\tconst indexArr = [ 0, 0, 0 ];\r\n\t\t\tconst vertKeys = [ 'a', 'b', 'c' ];\r\n\t\t\tconst hashes = new Array( 3 );\r\n\r\n\t\t\tconst edgeData = {};\r\n\t\t\tconst vertices = [];\r\n\t\t\tfor ( let i = 0; i < indexCount; i += 3 ) {\r\n\r\n\t\t\t\tif ( indexAttr ) {\r\n\r\n\t\t\t\t\tindexArr[ 0 ] = indexAttr.getX( i );\r\n\t\t\t\t\tindexArr[ 1 ] = indexAttr.getX( i + 1 );\r\n\t\t\t\t\tindexArr[ 2 ] = indexAttr.getX( i + 2 );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tindexArr[ 0 ] = i;\r\n\t\t\t\t\tindexArr[ 1 ] = i + 1;\r\n\t\t\t\t\tindexArr[ 2 ] = i + 2;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconst { a, b, c } = _triangle;\r\n\t\t\t\ta.fromBufferAttribute( positionAttr, indexArr[ 0 ] );\r\n\t\t\t\tb.fromBufferAttribute( positionAttr, indexArr[ 1 ] );\r\n\t\t\t\tc.fromBufferAttribute( positionAttr, indexArr[ 2 ] );\r\n\t\t\t\t_triangle.getNormal( _normal );\r\n\r\n\t\t\t\t// create hashes for the edge from the vertices\r\n\t\t\t\thashes[ 0 ] = `${ Math.round( a.x * precision ) },${ Math.round( a.y * precision ) },${ Math.round( a.z * precision ) }`;\r\n\t\t\t\thashes[ 1 ] = `${ Math.round( b.x * precision ) },${ Math.round( b.y * precision ) },${ Math.round( b.z * precision ) }`;\r\n\t\t\t\thashes[ 2 ] = `${ Math.round( c.x * precision ) },${ Math.round( c.y * precision ) },${ Math.round( c.z * precision ) }`;\r\n\r\n\t\t\t\t// skip degenerate triangles\r\n\t\t\t\tif ( hashes[ 0 ] === hashes[ 1 ] || hashes[ 1 ] === hashes[ 2 ] || hashes[ 2 ] === hashes[ 0 ] ) {\r\n\r\n\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// iterate over every edge\r\n\t\t\t\tfor ( let j = 0; j < 3; j ++ ) {\r\n\r\n\t\t\t\t\t// get the first and next vertex making up the edge\r\n\t\t\t\t\tconst jNext = ( j + 1 ) % 3;\r\n\t\t\t\t\tconst vecHash0 = hashes[ j ];\r\n\t\t\t\t\tconst vecHash1 = hashes[ jNext ];\r\n\t\t\t\t\tconst v0 = _triangle[ vertKeys[ j ] ];\r\n\t\t\t\t\tconst v1 = _triangle[ vertKeys[ jNext ] ];\r\n\r\n\t\t\t\t\tconst hash = `${ vecHash0 }_${ vecHash1 }`;\r\n\t\t\t\t\tconst reverseHash = `${ vecHash1 }_${ vecHash0 }`;\r\n\r\n\t\t\t\t\tif ( reverseHash in edgeData && edgeData[ reverseHash ] ) {\r\n\r\n\t\t\t\t\t\t// if we found a sibling edge add it into the vertex array if\r\n\t\t\t\t\t\t// it meets the angle threshold and delete the edge from the map.\r\n\t\t\t\t\t\tif ( _normal.dot( edgeData[ reverseHash ].normal ) <= thresholdDot ) {\r\n\r\n\t\t\t\t\t\t\tvertices.push( v0.x, v0.y, v0.z );\r\n\t\t\t\t\t\t\tvertices.push( v1.x, v1.y, v1.z );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tedgeData[ reverseHash ] = null;\r\n\r\n\t\t\t\t\t} else if ( ! ( hash in edgeData ) ) {\r\n\r\n\t\t\t\t\t\t// if we've already got an edge here then skip adding a new one\r\n\t\t\t\t\t\tedgeData[ hash ] = {\r\n\r\n\t\t\t\t\t\t\tindex0: indexArr[ j ],\r\n\t\t\t\t\t\t\tindex1: indexArr[ jNext ],\r\n\t\t\t\t\t\t\tnormal: _normal.clone(),\r\n\r\n\t\t\t\t\t\t};\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// iterate over all remaining, unmatched edges and add them to the vertex array\r\n\t\t\tfor ( const key in edgeData ) {\r\n\r\n\t\t\t\tif ( edgeData[ key ] ) {\r\n\r\n\t\t\t\t\tconst { index0, index1 } = edgeData[ key ];\r\n\t\t\t\t\t_v0.fromBufferAttribute( positionAttr, index0 );\r\n\t\t\t\t\t_v1.fromBufferAttribute( positionAttr, index1 );\r\n\r\n\t\t\t\t\tvertices.push( _v0.x, _v0.y, _v0.z );\r\n\t\t\t\t\tvertices.push( _v1.x, _v1.y, _v1.z );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport { EdgesGeometry };\r\n"]},"metadata":{},"sourceType":"module"}