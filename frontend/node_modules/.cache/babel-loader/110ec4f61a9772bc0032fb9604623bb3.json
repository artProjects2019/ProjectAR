{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nimport { AnimationUtils } from './AnimationUtils.js';\nimport { KeyframeTrack } from './KeyframeTrack.js';\nimport { BooleanKeyframeTrack } from './tracks/BooleanKeyframeTrack.js';\nimport { ColorKeyframeTrack } from './tracks/ColorKeyframeTrack.js';\nimport { NumberKeyframeTrack } from './tracks/NumberKeyframeTrack.js';\nimport { QuaternionKeyframeTrack } from './tracks/QuaternionKeyframeTrack.js';\nimport { StringKeyframeTrack } from './tracks/StringKeyframeTrack.js';\nimport { VectorKeyframeTrack } from './tracks/VectorKeyframeTrack.js';\nimport * as MathUtils from '../math/MathUtils.js';\nimport { NormalAnimationBlendMode } from '../constants.js';\n\nclass AnimationClip {\n  constructor(name, duration = -1, tracks, blendMode = NormalAnimationBlendMode) {\n    this.name = name;\n    this.tracks = tracks;\n    this.duration = duration;\n    this.blendMode = blendMode;\n    this.uuid = MathUtils.generateUUID(); // this means it should figure out its duration by scanning the tracks\n\n    if (this.duration < 0) {\n      this.resetDuration();\n    }\n  }\n\n  static parse(json) {\n    const tracks = [],\n          jsonTracks = json.tracks,\n          frameTime = 1.0 / (json.fps || 1.0);\n\n    for (let i = 0, n = jsonTracks.length; i !== n; ++i) {\n      tracks.push(parseKeyframeTrack(jsonTracks[i]).scale(frameTime));\n    }\n\n    const clip = new this(json.name, json.duration, tracks, json.blendMode);\n    clip.uuid = json.uuid;\n    return clip;\n  }\n\n  static toJSON(clip) {\n    const tracks = [],\n          clipTracks = clip.tracks;\n    const json = {\n      'name': clip.name,\n      'duration': clip.duration,\n      'tracks': tracks,\n      'uuid': clip.uuid,\n      'blendMode': clip.blendMode\n    };\n\n    for (let i = 0, n = clipTracks.length; i !== n; ++i) {\n      tracks.push(KeyframeTrack.toJSON(clipTracks[i]));\n    }\n\n    return json;\n  }\n\n  static CreateFromMorphTargetSequence(name, morphTargetSequence, fps, noLoop) {\n    const numMorphTargets = morphTargetSequence.length;\n    const tracks = [];\n\n    for (let i = 0; i < numMorphTargets; i++) {\n      let times = [];\n      let values = [];\n      times.push((i + numMorphTargets - 1) % numMorphTargets, i, (i + 1) % numMorphTargets);\n      values.push(0, 1, 0);\n      const order = AnimationUtils.getKeyframeOrder(times);\n      times = AnimationUtils.sortedArray(times, 1, order);\n      values = AnimationUtils.sortedArray(values, 1, order); // if there is a key at the first frame, duplicate it as the\n      // last frame as well for perfect loop.\n\n      if (!noLoop && times[0] === 0) {\n        times.push(numMorphTargets);\n        values.push(values[0]);\n      }\n\n      tracks.push(new NumberKeyframeTrack('.morphTargetInfluences[' + morphTargetSequence[i].name + ']', times, values).scale(1.0 / fps));\n    }\n\n    return new this(name, -1, tracks);\n  }\n\n  static findByName(objectOrClipArray, name) {\n    let clipArray = objectOrClipArray;\n\n    if (!Array.isArray(objectOrClipArray)) {\n      const o = objectOrClipArray;\n      clipArray = o.geometry && o.geometry.animations || o.animations;\n    }\n\n    for (let i = 0; i < clipArray.length; i++) {\n      if (clipArray[i].name === name) {\n        return clipArray[i];\n      }\n    }\n\n    return null;\n  }\n\n  static CreateClipsFromMorphTargetSequences(morphTargets, fps, noLoop) {\n    const animationToMorphTargets = {}; // tested with https://regex101.com/ on trick sequences\n    // such flamingo_flyA_003, flamingo_run1_003, crdeath0059\n\n    const pattern = /^([\\w-]*?)([\\d]+)$/; // sort morph target names into animation groups based\n    // patterns like Walk_001, Walk_002, Run_001, Run_002\n\n    for (let i = 0, il = morphTargets.length; i < il; i++) {\n      const morphTarget = morphTargets[i];\n      const parts = morphTarget.name.match(pattern);\n\n      if (parts && parts.length > 1) {\n        const name = parts[1];\n        let animationMorphTargets = animationToMorphTargets[name];\n\n        if (!animationMorphTargets) {\n          animationToMorphTargets[name] = animationMorphTargets = [];\n        }\n\n        animationMorphTargets.push(morphTarget);\n      }\n    }\n\n    const clips = [];\n\n    for (const name in animationToMorphTargets) {\n      clips.push(this.CreateFromMorphTargetSequence(name, animationToMorphTargets[name], fps, noLoop));\n    }\n\n    return clips;\n  } // parse the animation.hierarchy format\n\n\n  static parseAnimation(animation, bones) {\n    if (!animation) {\n      console.error('THREE.AnimationClip: No animation in JSONLoader data.');\n      return null;\n    }\n\n    const addNonemptyTrack = function (trackType, trackName, animationKeys, propertyName, destTracks) {\n      // only return track if there are actually keys.\n      if (animationKeys.length !== 0) {\n        const times = [];\n        const values = [];\n        AnimationUtils.flattenJSON(animationKeys, times, values, propertyName); // empty keys are filtered out, so check again\n\n        if (times.length !== 0) {\n          destTracks.push(new trackType(trackName, times, values));\n        }\n      }\n    };\n\n    const tracks = [];\n    const clipName = animation.name || 'default';\n    const fps = animation.fps || 30;\n    const blendMode = animation.blendMode; // automatic length determination in AnimationClip.\n\n    let duration = animation.length || -1;\n    const hierarchyTracks = animation.hierarchy || [];\n\n    for (let h = 0; h < hierarchyTracks.length; h++) {\n      const animationKeys = hierarchyTracks[h].keys; // skip empty tracks\n\n      if (!animationKeys || animationKeys.length === 0) continue; // process morph targets\n\n      if (animationKeys[0].morphTargets) {\n        // figure out all morph targets used in this track\n        const morphTargetNames = {};\n        let k;\n\n        for (k = 0; k < animationKeys.length; k++) {\n          if (animationKeys[k].morphTargets) {\n            for (let m = 0; m < animationKeys[k].morphTargets.length; m++) {\n              morphTargetNames[animationKeys[k].morphTargets[m]] = -1;\n            }\n          }\n        } // create a track for each morph target with all zero\n        // morphTargetInfluences except for the keys in which\n        // the morphTarget is named.\n\n\n        for (const morphTargetName in morphTargetNames) {\n          const times = [];\n          const values = [];\n\n          for (let m = 0; m !== animationKeys[k].morphTargets.length; ++m) {\n            const animationKey = animationKeys[k];\n            times.push(animationKey.time);\n            values.push(animationKey.morphTarget === morphTargetName ? 1 : 0);\n          }\n\n          tracks.push(new NumberKeyframeTrack('.morphTargetInfluence[' + morphTargetName + ']', times, values));\n        }\n\n        duration = morphTargetNames.length * fps;\n      } else {\n        // ...assume skeletal animation\n        const boneName = '.bones[' + bones[h].name + ']';\n        addNonemptyTrack(VectorKeyframeTrack, boneName + '.position', animationKeys, 'pos', tracks);\n        addNonemptyTrack(QuaternionKeyframeTrack, boneName + '.quaternion', animationKeys, 'rot', tracks);\n        addNonemptyTrack(VectorKeyframeTrack, boneName + '.scale', animationKeys, 'scl', tracks);\n      }\n    }\n\n    if (tracks.length === 0) {\n      return null;\n    }\n\n    const clip = new this(clipName, duration, tracks, blendMode);\n    return clip;\n  }\n\n  resetDuration() {\n    const tracks = this.tracks;\n    let duration = 0;\n\n    for (let i = 0, n = tracks.length; i !== n; ++i) {\n      const track = this.tracks[i];\n      duration = Math.max(duration, track.times[track.times.length - 1]);\n    }\n\n    this.duration = duration;\n    return this;\n  }\n\n  trim() {\n    for (let i = 0; i < this.tracks.length; i++) {\n      this.tracks[i].trim(0, this.duration);\n    }\n\n    return this;\n  }\n\n  validate() {\n    let valid = true;\n\n    for (let i = 0; i < this.tracks.length; i++) {\n      valid = valid && this.tracks[i].validate();\n    }\n\n    return valid;\n  }\n\n  optimize() {\n    for (let i = 0; i < this.tracks.length; i++) {\n      this.tracks[i].optimize();\n    }\n\n    return this;\n  }\n\n  clone() {\n    const tracks = [];\n\n    for (let i = 0; i < this.tracks.length; i++) {\n      tracks.push(this.tracks[i].clone());\n    }\n\n    return new this.constructor(this.name, this.duration, tracks, this.blendMode);\n  }\n\n  toJSON() {\n    return this.constructor.toJSON(this);\n  }\n\n}\n\nfunction getTrackTypeForValueTypeName(typeName) {\n  switch (typeName.toLowerCase()) {\n    case 'scalar':\n    case 'double':\n    case 'float':\n    case 'number':\n    case 'integer':\n      return NumberKeyframeTrack;\n\n    case 'vector':\n    case 'vector2':\n    case 'vector3':\n    case 'vector4':\n      return VectorKeyframeTrack;\n\n    case 'color':\n      return ColorKeyframeTrack;\n\n    case 'quaternion':\n      return QuaternionKeyframeTrack;\n\n    case 'bool':\n    case 'boolean':\n      return BooleanKeyframeTrack;\n\n    case 'string':\n      return StringKeyframeTrack;\n  }\n\n  throw new Error('THREE.KeyframeTrack: Unsupported typeName: ' + typeName);\n}\n\nfunction parseKeyframeTrack(json) {\n  if (json.type === undefined) {\n    throw new Error('THREE.KeyframeTrack: track type undefined, can not parse');\n  }\n\n  const trackType = getTrackTypeForValueTypeName(json.type);\n\n  if (json.times === undefined) {\n    const times = [],\n          values = [];\n    AnimationUtils.flattenJSON(json.keys, times, values, 'value');\n    json.times = times;\n    json.values = values;\n  } // derived classes can define a static parse method\n\n\n  if (trackType.parse !== undefined) {\n    return trackType.parse(json);\n  } else {\n    // by default, we assume a constructor compatible with the base\n    return new trackType(json.name, json.times, json.values, json.interpolation);\n  }\n}\n\nexport { AnimationClip };","map":{"version":3,"sources":["C:/Users/dell/Desktop/projektlogin/vue-3-authentication-jwt/src/games/three/src/animation/AnimationClip.js"],"names":["AnimationUtils","KeyframeTrack","BooleanKeyframeTrack","ColorKeyframeTrack","NumberKeyframeTrack","QuaternionKeyframeTrack","StringKeyframeTrack","VectorKeyframeTrack","MathUtils","NormalAnimationBlendMode","AnimationClip","constructor","name","duration","tracks","blendMode","uuid","generateUUID","resetDuration","parse","json","jsonTracks","frameTime","fps","i","n","length","push","parseKeyframeTrack","scale","clip","toJSON","clipTracks","CreateFromMorphTargetSequence","morphTargetSequence","noLoop","numMorphTargets","times","values","order","getKeyframeOrder","sortedArray","findByName","objectOrClipArray","clipArray","Array","isArray","o","geometry","animations","CreateClipsFromMorphTargetSequences","morphTargets","animationToMorphTargets","pattern","il","morphTarget","parts","match","animationMorphTargets","clips","parseAnimation","animation","bones","console","error","addNonemptyTrack","trackType","trackName","animationKeys","propertyName","destTracks","flattenJSON","clipName","hierarchyTracks","hierarchy","h","keys","morphTargetNames","k","m","morphTargetName","animationKey","time","boneName","track","Math","max","trim","validate","valid","optimize","clone","getTrackTypeForValueTypeName","typeName","toLowerCase","Error","type","undefined","interpolation"],"mappings":";AAAA,SAASA,cAAT,QAA+B,qBAA/B;AACA,SAASC,aAAT,QAA8B,oBAA9B;AACA,SAASC,oBAAT,QAAqC,kCAArC;AACA,SAASC,kBAAT,QAAmC,gCAAnC;AACA,SAASC,mBAAT,QAAoC,iCAApC;AACA,SAASC,uBAAT,QAAwC,qCAAxC;AACA,SAASC,mBAAT,QAAoC,iCAApC;AACA,SAASC,mBAAT,QAAoC,iCAApC;AACA,OAAO,KAAKC,SAAZ,MAA2B,sBAA3B;AACA,SAASC,wBAAT,QAAyC,iBAAzC;;AAEA,MAAMC,aAAN,CAAoB;AAEnBC,EAAAA,WAAW,CAAEC,IAAF,EAAQC,QAAQ,GAAG,CAAE,CAArB,EAAwBC,MAAxB,EAAgCC,SAAS,GAAGN,wBAA5C,EAAuE;AAEjF,SAAKG,IAAL,GAAYA,IAAZ;AACA,SAAKE,MAAL,GAAcA,MAAd;AACA,SAAKD,QAAL,GAAgBA,QAAhB;AACA,SAAKE,SAAL,GAAiBA,SAAjB;AAEA,SAAKC,IAAL,GAAYR,SAAS,CAACS,YAAV,EAAZ,CAPiF,CASjF;;AACA,QAAK,KAAKJ,QAAL,GAAgB,CAArB,EAAyB;AAExB,WAAKK,aAAL;AAEA;AAED;;AAGW,SAALC,KAAK,CAAEC,IAAF,EAAS;AAEpB,UAAMN,MAAM,GAAG,EAAf;AAAA,UACCO,UAAU,GAAGD,IAAI,CAACN,MADnB;AAAA,UAECQ,SAAS,GAAG,OAAQF,IAAI,CAACG,GAAL,IAAY,GAApB,CAFb;;AAIA,SAAM,IAAIC,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAGJ,UAAU,CAACK,MAAhC,EAAwCF,CAAC,KAAKC,CAA9C,EAAiD,EAAGD,CAApD,EAAwD;AAEvDV,MAAAA,MAAM,CAACa,IAAP,CAAaC,kBAAkB,CAAEP,UAAU,CAAEG,CAAF,CAAZ,CAAlB,CAAsCK,KAAtC,CAA6CP,SAA7C,CAAb;AAEA;;AAED,UAAMQ,IAAI,GAAG,IAAI,IAAJ,CAAUV,IAAI,CAACR,IAAf,EAAqBQ,IAAI,CAACP,QAA1B,EAAoCC,MAApC,EAA4CM,IAAI,CAACL,SAAjD,CAAb;AACAe,IAAAA,IAAI,CAACd,IAAL,GAAYI,IAAI,CAACJ,IAAjB;AAEA,WAAOc,IAAP;AAEA;;AAEY,SAANC,MAAM,CAAED,IAAF,EAAS;AAErB,UAAMhB,MAAM,GAAG,EAAf;AAAA,UACCkB,UAAU,GAAGF,IAAI,CAAChB,MADnB;AAGA,UAAMM,IAAI,GAAG;AAEZ,cAAQU,IAAI,CAAClB,IAFD;AAGZ,kBAAYkB,IAAI,CAACjB,QAHL;AAIZ,gBAAUC,MAJE;AAKZ,cAAQgB,IAAI,CAACd,IALD;AAMZ,mBAAac,IAAI,CAACf;AANN,KAAb;;AAUA,SAAM,IAAIS,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAGO,UAAU,CAACN,MAAhC,EAAwCF,CAAC,KAAKC,CAA9C,EAAiD,EAAGD,CAApD,EAAwD;AAEvDV,MAAAA,MAAM,CAACa,IAAP,CAAa1B,aAAa,CAAC8B,MAAd,CAAsBC,UAAU,CAAER,CAAF,CAAhC,CAAb;AAEA;;AAED,WAAOJ,IAAP;AAEA;;AAEmC,SAA7Ba,6BAA6B,CAAErB,IAAF,EAAQsB,mBAAR,EAA6BX,GAA7B,EAAkCY,MAAlC,EAA2C;AAE9E,UAAMC,eAAe,GAAGF,mBAAmB,CAACR,MAA5C;AACA,UAAMZ,MAAM,GAAG,EAAf;;AAEA,SAAM,IAAIU,CAAC,GAAG,CAAd,EAAiBA,CAAC,GAAGY,eAArB,EAAsCZ,CAAC,EAAvC,EAA6C;AAE5C,UAAIa,KAAK,GAAG,EAAZ;AACA,UAAIC,MAAM,GAAG,EAAb;AAEAD,MAAAA,KAAK,CAACV,IAAN,CACC,CAAEH,CAAC,GAAGY,eAAJ,GAAsB,CAAxB,IAA8BA,eAD/B,EAECZ,CAFD,EAGC,CAAEA,CAAC,GAAG,CAAN,IAAYY,eAHb;AAKAE,MAAAA,MAAM,CAACX,IAAP,CAAa,CAAb,EAAgB,CAAhB,EAAmB,CAAnB;AAEA,YAAMY,KAAK,GAAGvC,cAAc,CAACwC,gBAAf,CAAiCH,KAAjC,CAAd;AACAA,MAAAA,KAAK,GAAGrC,cAAc,CAACyC,WAAf,CAA4BJ,KAA5B,EAAmC,CAAnC,EAAsCE,KAAtC,CAAR;AACAD,MAAAA,MAAM,GAAGtC,cAAc,CAACyC,WAAf,CAA4BH,MAA5B,EAAoC,CAApC,EAAuCC,KAAvC,CAAT,CAd4C,CAgB5C;AACA;;AACA,UAAK,CAAEJ,MAAF,IAAYE,KAAK,CAAE,CAAF,CAAL,KAAe,CAAhC,EAAoC;AAEnCA,QAAAA,KAAK,CAACV,IAAN,CAAYS,eAAZ;AACAE,QAAAA,MAAM,CAACX,IAAP,CAAaW,MAAM,CAAE,CAAF,CAAnB;AAEA;;AAEDxB,MAAAA,MAAM,CAACa,IAAP,CACC,IAAIvB,mBAAJ,CACC,4BAA4B8B,mBAAmB,CAAEV,CAAF,CAAnB,CAAyBZ,IAArD,GAA4D,GAD7D,EAECyB,KAFD,EAEQC,MAFR,EAGET,KAHF,CAGS,MAAMN,GAHf,CADD;AAMA;;AAED,WAAO,IAAI,IAAJ,CAAUX,IAAV,EAAgB,CAAE,CAAlB,EAAqBE,MAArB,CAAP;AAEA;;AAEgB,SAAV4B,UAAU,CAAEC,iBAAF,EAAqB/B,IAArB,EAA4B;AAE5C,QAAIgC,SAAS,GAAGD,iBAAhB;;AAEA,QAAK,CAAEE,KAAK,CAACC,OAAN,CAAeH,iBAAf,CAAP,EAA4C;AAE3C,YAAMI,CAAC,GAAGJ,iBAAV;AACAC,MAAAA,SAAS,GAAGG,CAAC,CAACC,QAAF,IAAcD,CAAC,CAACC,QAAF,CAAWC,UAAzB,IAAuCF,CAAC,CAACE,UAArD;AAEA;;AAED,SAAM,IAAIzB,CAAC,GAAG,CAAd,EAAiBA,CAAC,GAAGoB,SAAS,CAAClB,MAA/B,EAAuCF,CAAC,EAAxC,EAA8C;AAE7C,UAAKoB,SAAS,CAAEpB,CAAF,CAAT,CAAeZ,IAAf,KAAwBA,IAA7B,EAAoC;AAEnC,eAAOgC,SAAS,CAAEpB,CAAF,CAAhB;AAEA;AAED;;AAED,WAAO,IAAP;AAEA;;AAEyC,SAAnC0B,mCAAmC,CAAEC,YAAF,EAAgB5B,GAAhB,EAAqBY,MAArB,EAA8B;AAEvE,UAAMiB,uBAAuB,GAAG,EAAhC,CAFuE,CAIvE;AACA;;AACA,UAAMC,OAAO,GAAG,oBAAhB,CANuE,CAQvE;AACA;;AACA,SAAM,IAAI7B,CAAC,GAAG,CAAR,EAAW8B,EAAE,GAAGH,YAAY,CAACzB,MAAnC,EAA2CF,CAAC,GAAG8B,EAA/C,EAAmD9B,CAAC,EAApD,EAA0D;AAEzD,YAAM+B,WAAW,GAAGJ,YAAY,CAAE3B,CAAF,CAAhC;AACA,YAAMgC,KAAK,GAAGD,WAAW,CAAC3C,IAAZ,CAAiB6C,KAAjB,CAAwBJ,OAAxB,CAAd;;AAEA,UAAKG,KAAK,IAAIA,KAAK,CAAC9B,MAAN,GAAe,CAA7B,EAAiC;AAEhC,cAAMd,IAAI,GAAG4C,KAAK,CAAE,CAAF,CAAlB;AAEA,YAAIE,qBAAqB,GAAGN,uBAAuB,CAAExC,IAAF,CAAnD;;AAEA,YAAK,CAAE8C,qBAAP,EAA+B;AAE9BN,UAAAA,uBAAuB,CAAExC,IAAF,CAAvB,GAAkC8C,qBAAqB,GAAG,EAA1D;AAEA;;AAEDA,QAAAA,qBAAqB,CAAC/B,IAAtB,CAA4B4B,WAA5B;AAEA;AAED;;AAED,UAAMI,KAAK,GAAG,EAAd;;AAEA,SAAM,MAAM/C,IAAZ,IAAoBwC,uBAApB,EAA8C;AAE7CO,MAAAA,KAAK,CAAChC,IAAN,CAAY,KAAKM,6BAAL,CAAoCrB,IAApC,EAA0CwC,uBAAuB,CAAExC,IAAF,CAAjE,EAA2EW,GAA3E,EAAgFY,MAAhF,CAAZ;AAEA;;AAED,WAAOwB,KAAP;AAEA,GA/KkB,CAiLnB;;;AACqB,SAAdC,cAAc,CAAEC,SAAF,EAAaC,KAAb,EAAqB;AAEzC,QAAK,CAAED,SAAP,EAAmB;AAElBE,MAAAA,OAAO,CAACC,KAAR,CAAe,uDAAf;AACA,aAAO,IAAP;AAEA;;AAED,UAAMC,gBAAgB,GAAG,UAAWC,SAAX,EAAsBC,SAAtB,EAAiCC,aAAjC,EAAgDC,YAAhD,EAA8DC,UAA9D,EAA2E;AAEnG;AACA,UAAKF,aAAa,CAAC1C,MAAd,KAAyB,CAA9B,EAAkC;AAEjC,cAAMW,KAAK,GAAG,EAAd;AACA,cAAMC,MAAM,GAAG,EAAf;AAEAtC,QAAAA,cAAc,CAACuE,WAAf,CAA4BH,aAA5B,EAA2C/B,KAA3C,EAAkDC,MAAlD,EAA0D+B,YAA1D,EALiC,CAOjC;;AACA,YAAKhC,KAAK,CAACX,MAAN,KAAiB,CAAtB,EAA0B;AAEzB4C,UAAAA,UAAU,CAAC3C,IAAX,CAAiB,IAAIuC,SAAJ,CAAeC,SAAf,EAA0B9B,KAA1B,EAAiCC,MAAjC,CAAjB;AAEA;AAED;AAED,KAnBD;;AAqBA,UAAMxB,MAAM,GAAG,EAAf;AAEA,UAAM0D,QAAQ,GAAGX,SAAS,CAACjD,IAAV,IAAkB,SAAnC;AACA,UAAMW,GAAG,GAAGsC,SAAS,CAACtC,GAAV,IAAiB,EAA7B;AACA,UAAMR,SAAS,GAAG8C,SAAS,CAAC9C,SAA5B,CAlCyC,CAoCzC;;AACA,QAAIF,QAAQ,GAAGgD,SAAS,CAACnC,MAAV,IAAoB,CAAE,CAArC;AAEA,UAAM+C,eAAe,GAAGZ,SAAS,CAACa,SAAV,IAAuB,EAA/C;;AAEA,SAAM,IAAIC,CAAC,GAAG,CAAd,EAAiBA,CAAC,GAAGF,eAAe,CAAC/C,MAArC,EAA6CiD,CAAC,EAA9C,EAAoD;AAEnD,YAAMP,aAAa,GAAGK,eAAe,CAAEE,CAAF,CAAf,CAAqBC,IAA3C,CAFmD,CAInD;;AACA,UAAK,CAAER,aAAF,IAAmBA,aAAa,CAAC1C,MAAd,KAAyB,CAAjD,EAAqD,SALF,CAOnD;;AACA,UAAK0C,aAAa,CAAE,CAAF,CAAb,CAAmBjB,YAAxB,EAAuC;AAEtC;AACA,cAAM0B,gBAAgB,GAAG,EAAzB;AAEA,YAAIC,CAAJ;;AAEA,aAAMA,CAAC,GAAG,CAAV,EAAaA,CAAC,GAAGV,aAAa,CAAC1C,MAA/B,EAAuCoD,CAAC,EAAxC,EAA8C;AAE7C,cAAKV,aAAa,CAAEU,CAAF,CAAb,CAAmB3B,YAAxB,EAAuC;AAEtC,iBAAM,IAAI4B,CAAC,GAAG,CAAd,EAAiBA,CAAC,GAAGX,aAAa,CAAEU,CAAF,CAAb,CAAmB3B,YAAnB,CAAgCzB,MAArD,EAA6DqD,CAAC,EAA9D,EAAoE;AAEnEF,cAAAA,gBAAgB,CAAET,aAAa,CAAEU,CAAF,CAAb,CAAmB3B,YAAnB,CAAiC4B,CAAjC,CAAF,CAAhB,GAA2D,CAAE,CAA7D;AAEA;AAED;AAED,SAnBqC,CAqBtC;AACA;AACA;;;AACA,aAAM,MAAMC,eAAZ,IAA+BH,gBAA/B,EAAkD;AAEjD,gBAAMxC,KAAK,GAAG,EAAd;AACA,gBAAMC,MAAM,GAAG,EAAf;;AAEA,eAAM,IAAIyC,CAAC,GAAG,CAAd,EAAiBA,CAAC,KAAKX,aAAa,CAAEU,CAAF,CAAb,CAAmB3B,YAAnB,CAAgCzB,MAAvD,EAA+D,EAAGqD,CAAlE,EAAsE;AAErE,kBAAME,YAAY,GAAGb,aAAa,CAAEU,CAAF,CAAlC;AAEAzC,YAAAA,KAAK,CAACV,IAAN,CAAYsD,YAAY,CAACC,IAAzB;AACA5C,YAAAA,MAAM,CAACX,IAAP,CAAesD,YAAY,CAAC1B,WAAb,KAA6ByB,eAA/B,GAAmD,CAAnD,GAAuD,CAApE;AAEA;;AAEDlE,UAAAA,MAAM,CAACa,IAAP,CAAa,IAAIvB,mBAAJ,CAAyB,2BAA2B4E,eAA3B,GAA6C,GAAtE,EAA2E3C,KAA3E,EAAkFC,MAAlF,CAAb;AAEA;;AAEDzB,QAAAA,QAAQ,GAAGgE,gBAAgB,CAACnD,MAAjB,GAA0BH,GAArC;AAEA,OA5CD,MA4CO;AAEN;AAEA,cAAM4D,QAAQ,GAAG,YAAYrB,KAAK,CAAEa,CAAF,CAAL,CAAW/D,IAAvB,GAA8B,GAA/C;AAEAqD,QAAAA,gBAAgB,CACf1D,mBADe,EACM4E,QAAQ,GAAG,WADjB,EAEff,aAFe,EAEA,KAFA,EAEOtD,MAFP,CAAhB;AAIAmD,QAAAA,gBAAgB,CACf5D,uBADe,EACU8E,QAAQ,GAAG,aADrB,EAEff,aAFe,EAEA,KAFA,EAEOtD,MAFP,CAAhB;AAIAmD,QAAAA,gBAAgB,CACf1D,mBADe,EACM4E,QAAQ,GAAG,QADjB,EAEff,aAFe,EAEA,KAFA,EAEOtD,MAFP,CAAhB;AAIA;AAED;;AAED,QAAKA,MAAM,CAACY,MAAP,KAAkB,CAAvB,EAA2B;AAE1B,aAAO,IAAP;AAEA;;AAED,UAAMI,IAAI,GAAG,IAAI,IAAJ,CAAU0C,QAAV,EAAoB3D,QAApB,EAA8BC,MAA9B,EAAsCC,SAAtC,CAAb;AAEA,WAAOe,IAAP;AAEA;;AAEDZ,EAAAA,aAAa,GAAG;AAEf,UAAMJ,MAAM,GAAG,KAAKA,MAApB;AACA,QAAID,QAAQ,GAAG,CAAf;;AAEA,SAAM,IAAIW,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAGX,MAAM,CAACY,MAA5B,EAAoCF,CAAC,KAAKC,CAA1C,EAA6C,EAAGD,CAAhD,EAAoD;AAEnD,YAAM4D,KAAK,GAAG,KAAKtE,MAAL,CAAaU,CAAb,CAAd;AAEAX,MAAAA,QAAQ,GAAGwE,IAAI,CAACC,GAAL,CAAUzE,QAAV,EAAoBuE,KAAK,CAAC/C,KAAN,CAAa+C,KAAK,CAAC/C,KAAN,CAAYX,MAAZ,GAAqB,CAAlC,CAApB,CAAX;AAEA;;AAED,SAAKb,QAAL,GAAgBA,QAAhB;AAEA,WAAO,IAAP;AAEA;;AAED0E,EAAAA,IAAI,GAAG;AAEN,SAAM,IAAI/D,CAAC,GAAG,CAAd,EAAiBA,CAAC,GAAG,KAAKV,MAAL,CAAYY,MAAjC,EAAyCF,CAAC,EAA1C,EAAgD;AAE/C,WAAKV,MAAL,CAAaU,CAAb,EAAiB+D,IAAjB,CAAuB,CAAvB,EAA0B,KAAK1E,QAA/B;AAEA;;AAED,WAAO,IAAP;AAEA;;AAED2E,EAAAA,QAAQ,GAAG;AAEV,QAAIC,KAAK,GAAG,IAAZ;;AAEA,SAAM,IAAIjE,CAAC,GAAG,CAAd,EAAiBA,CAAC,GAAG,KAAKV,MAAL,CAAYY,MAAjC,EAAyCF,CAAC,EAA1C,EAAgD;AAE/CiE,MAAAA,KAAK,GAAGA,KAAK,IAAI,KAAK3E,MAAL,CAAaU,CAAb,EAAiBgE,QAAjB,EAAjB;AAEA;;AAED,WAAOC,KAAP;AAEA;;AAEDC,EAAAA,QAAQ,GAAG;AAEV,SAAM,IAAIlE,CAAC,GAAG,CAAd,EAAiBA,CAAC,GAAG,KAAKV,MAAL,CAAYY,MAAjC,EAAyCF,CAAC,EAA1C,EAAgD;AAE/C,WAAKV,MAAL,CAAaU,CAAb,EAAiBkE,QAAjB;AAEA;;AAED,WAAO,IAAP;AAEA;;AAEDC,EAAAA,KAAK,GAAG;AAEP,UAAM7E,MAAM,GAAG,EAAf;;AAEA,SAAM,IAAIU,CAAC,GAAG,CAAd,EAAiBA,CAAC,GAAG,KAAKV,MAAL,CAAYY,MAAjC,EAAyCF,CAAC,EAA1C,EAAgD;AAE/CV,MAAAA,MAAM,CAACa,IAAP,CAAa,KAAKb,MAAL,CAAaU,CAAb,EAAiBmE,KAAjB,EAAb;AAEA;;AAED,WAAO,IAAI,KAAKhF,WAAT,CAAsB,KAAKC,IAA3B,EAAiC,KAAKC,QAAtC,EAAgDC,MAAhD,EAAwD,KAAKC,SAA7D,CAAP;AAEA;;AAEDgB,EAAAA,MAAM,GAAG;AAER,WAAO,KAAKpB,WAAL,CAAiBoB,MAAjB,CAAyB,IAAzB,CAAP;AAEA;;AA5XkB;;AAgYpB,SAAS6D,4BAAT,CAAuCC,QAAvC,EAAkD;AAEjD,UAASA,QAAQ,CAACC,WAAT,EAAT;AAEC,SAAK,QAAL;AACA,SAAK,QAAL;AACA,SAAK,OAAL;AACA,SAAK,QAAL;AACA,SAAK,SAAL;AAEC,aAAO1F,mBAAP;;AAED,SAAK,QAAL;AACA,SAAK,SAAL;AACA,SAAK,SAAL;AACA,SAAK,SAAL;AAEC,aAAOG,mBAAP;;AAED,SAAK,OAAL;AAEC,aAAOJ,kBAAP;;AAED,SAAK,YAAL;AAEC,aAAOE,uBAAP;;AAED,SAAK,MAAL;AACA,SAAK,SAAL;AAEC,aAAOH,oBAAP;;AAED,SAAK,QAAL;AAEC,aAAOI,mBAAP;AAhCF;;AAoCA,QAAM,IAAIyF,KAAJ,CAAW,gDAAgDF,QAA3D,CAAN;AAEA;;AAED,SAASjE,kBAAT,CAA6BR,IAA7B,EAAoC;AAEnC,MAAKA,IAAI,CAAC4E,IAAL,KAAcC,SAAnB,EAA+B;AAE9B,UAAM,IAAIF,KAAJ,CAAW,0DAAX,CAAN;AAEA;;AAED,QAAM7B,SAAS,GAAG0B,4BAA4B,CAAExE,IAAI,CAAC4E,IAAP,CAA9C;;AAEA,MAAK5E,IAAI,CAACiB,KAAL,KAAe4D,SAApB,EAAgC;AAE/B,UAAM5D,KAAK,GAAG,EAAd;AAAA,UAAkBC,MAAM,GAAG,EAA3B;AAEAtC,IAAAA,cAAc,CAACuE,WAAf,CAA4BnD,IAAI,CAACwD,IAAjC,EAAuCvC,KAAvC,EAA8CC,MAA9C,EAAsD,OAAtD;AAEAlB,IAAAA,IAAI,CAACiB,KAAL,GAAaA,KAAb;AACAjB,IAAAA,IAAI,CAACkB,MAAL,GAAcA,MAAd;AAEA,GAnBkC,CAqBnC;;;AACA,MAAK4B,SAAS,CAAC/C,KAAV,KAAoB8E,SAAzB,EAAqC;AAEpC,WAAO/B,SAAS,CAAC/C,KAAV,CAAiBC,IAAjB,CAAP;AAEA,GAJD,MAIO;AAEN;AACA,WAAO,IAAI8C,SAAJ,CAAe9C,IAAI,CAACR,IAApB,EAA0BQ,IAAI,CAACiB,KAA/B,EAAsCjB,IAAI,CAACkB,MAA3C,EAAmDlB,IAAI,CAAC8E,aAAxD,CAAP;AAEA;AAED;;AAED,SAASxF,aAAT","sourcesContent":["import { AnimationUtils } from './AnimationUtils.js';\r\nimport { KeyframeTrack } from './KeyframeTrack.js';\r\nimport { BooleanKeyframeTrack } from './tracks/BooleanKeyframeTrack.js';\r\nimport { ColorKeyframeTrack } from './tracks/ColorKeyframeTrack.js';\r\nimport { NumberKeyframeTrack } from './tracks/NumberKeyframeTrack.js';\r\nimport { QuaternionKeyframeTrack } from './tracks/QuaternionKeyframeTrack.js';\r\nimport { StringKeyframeTrack } from './tracks/StringKeyframeTrack.js';\r\nimport { VectorKeyframeTrack } from './tracks/VectorKeyframeTrack.js';\r\nimport * as MathUtils from '../math/MathUtils.js';\r\nimport { NormalAnimationBlendMode } from '../constants.js';\r\n\r\nclass AnimationClip {\r\n\r\n\tconstructor( name, duration = - 1, tracks, blendMode = NormalAnimationBlendMode ) {\r\n\r\n\t\tthis.name = name;\r\n\t\tthis.tracks = tracks;\r\n\t\tthis.duration = duration;\r\n\t\tthis.blendMode = blendMode;\r\n\r\n\t\tthis.uuid = MathUtils.generateUUID();\r\n\r\n\t\t// this means it should figure out its duration by scanning the tracks\r\n\t\tif ( this.duration < 0 ) {\r\n\r\n\t\t\tthis.resetDuration();\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\r\n\tstatic parse( json ) {\r\n\r\n\t\tconst tracks = [],\r\n\t\t\tjsonTracks = json.tracks,\r\n\t\t\tframeTime = 1.0 / ( json.fps || 1.0 );\r\n\r\n\t\tfor ( let i = 0, n = jsonTracks.length; i !== n; ++ i ) {\r\n\r\n\t\t\ttracks.push( parseKeyframeTrack( jsonTracks[ i ] ).scale( frameTime ) );\r\n\r\n\t\t}\r\n\r\n\t\tconst clip = new this( json.name, json.duration, tracks, json.blendMode );\r\n\t\tclip.uuid = json.uuid;\r\n\r\n\t\treturn clip;\r\n\r\n\t}\r\n\r\n\tstatic toJSON( clip ) {\r\n\r\n\t\tconst tracks = [],\r\n\t\t\tclipTracks = clip.tracks;\r\n\r\n\t\tconst json = {\r\n\r\n\t\t\t'name': clip.name,\r\n\t\t\t'duration': clip.duration,\r\n\t\t\t'tracks': tracks,\r\n\t\t\t'uuid': clip.uuid,\r\n\t\t\t'blendMode': clip.blendMode\r\n\r\n\t\t};\r\n\r\n\t\tfor ( let i = 0, n = clipTracks.length; i !== n; ++ i ) {\r\n\r\n\t\t\ttracks.push( KeyframeTrack.toJSON( clipTracks[ i ] ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn json;\r\n\r\n\t}\r\n\r\n\tstatic CreateFromMorphTargetSequence( name, morphTargetSequence, fps, noLoop ) {\r\n\r\n\t\tconst numMorphTargets = morphTargetSequence.length;\r\n\t\tconst tracks = [];\r\n\r\n\t\tfor ( let i = 0; i < numMorphTargets; i ++ ) {\r\n\r\n\t\t\tlet times = [];\r\n\t\t\tlet values = [];\r\n\r\n\t\t\ttimes.push(\r\n\t\t\t\t( i + numMorphTargets - 1 ) % numMorphTargets,\r\n\t\t\t\ti,\r\n\t\t\t\t( i + 1 ) % numMorphTargets );\r\n\r\n\t\t\tvalues.push( 0, 1, 0 );\r\n\r\n\t\t\tconst order = AnimationUtils.getKeyframeOrder( times );\r\n\t\t\ttimes = AnimationUtils.sortedArray( times, 1, order );\r\n\t\t\tvalues = AnimationUtils.sortedArray( values, 1, order );\r\n\r\n\t\t\t// if there is a key at the first frame, duplicate it as the\r\n\t\t\t// last frame as well for perfect loop.\r\n\t\t\tif ( ! noLoop && times[ 0 ] === 0 ) {\r\n\r\n\t\t\t\ttimes.push( numMorphTargets );\r\n\t\t\t\tvalues.push( values[ 0 ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\ttracks.push(\r\n\t\t\t\tnew NumberKeyframeTrack(\r\n\t\t\t\t\t'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',\r\n\t\t\t\t\ttimes, values\r\n\t\t\t\t).scale( 1.0 / fps ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn new this( name, - 1, tracks );\r\n\r\n\t}\r\n\r\n\tstatic findByName( objectOrClipArray, name ) {\r\n\r\n\t\tlet clipArray = objectOrClipArray;\r\n\r\n\t\tif ( ! Array.isArray( objectOrClipArray ) ) {\r\n\r\n\t\t\tconst o = objectOrClipArray;\r\n\t\t\tclipArray = o.geometry && o.geometry.animations || o.animations;\r\n\r\n\t\t}\r\n\r\n\t\tfor ( let i = 0; i < clipArray.length; i ++ ) {\r\n\r\n\t\t\tif ( clipArray[ i ].name === name ) {\r\n\r\n\t\t\t\treturn clipArray[ i ];\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn null;\r\n\r\n\t}\r\n\r\n\tstatic CreateClipsFromMorphTargetSequences( morphTargets, fps, noLoop ) {\r\n\r\n\t\tconst animationToMorphTargets = {};\r\n\r\n\t\t// tested with https://regex101.com/ on trick sequences\r\n\t\t// such flamingo_flyA_003, flamingo_run1_003, crdeath0059\r\n\t\tconst pattern = /^([\\w-]*?)([\\d]+)$/;\r\n\r\n\t\t// sort morph target names into animation groups based\r\n\t\t// patterns like Walk_001, Walk_002, Run_001, Run_002\r\n\t\tfor ( let i = 0, il = morphTargets.length; i < il; i ++ ) {\r\n\r\n\t\t\tconst morphTarget = morphTargets[ i ];\r\n\t\t\tconst parts = morphTarget.name.match( pattern );\r\n\r\n\t\t\tif ( parts && parts.length > 1 ) {\r\n\r\n\t\t\t\tconst name = parts[ 1 ];\r\n\r\n\t\t\t\tlet animationMorphTargets = animationToMorphTargets[ name ];\r\n\r\n\t\t\t\tif ( ! animationMorphTargets ) {\r\n\r\n\t\t\t\t\tanimationToMorphTargets[ name ] = animationMorphTargets = [];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tanimationMorphTargets.push( morphTarget );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tconst clips = [];\r\n\r\n\t\tfor ( const name in animationToMorphTargets ) {\r\n\r\n\t\t\tclips.push( this.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn clips;\r\n\r\n\t}\r\n\r\n\t// parse the animation.hierarchy format\r\n\tstatic parseAnimation( animation, bones ) {\r\n\r\n\t\tif ( ! animation ) {\r\n\r\n\t\t\tconsole.error( 'THREE.AnimationClip: No animation in JSONLoader data.' );\r\n\t\t\treturn null;\r\n\r\n\t\t}\r\n\r\n\t\tconst addNonemptyTrack = function ( trackType, trackName, animationKeys, propertyName, destTracks ) {\r\n\r\n\t\t\t// only return track if there are actually keys.\r\n\t\t\tif ( animationKeys.length !== 0 ) {\r\n\r\n\t\t\t\tconst times = [];\r\n\t\t\t\tconst values = [];\r\n\r\n\t\t\t\tAnimationUtils.flattenJSON( animationKeys, times, values, propertyName );\r\n\r\n\t\t\t\t// empty keys are filtered out, so check again\r\n\t\t\t\tif ( times.length !== 0 ) {\r\n\r\n\t\t\t\t\tdestTracks.push( new trackType( trackName, times, values ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t\tconst tracks = [];\r\n\r\n\t\tconst clipName = animation.name || 'default';\r\n\t\tconst fps = animation.fps || 30;\r\n\t\tconst blendMode = animation.blendMode;\r\n\r\n\t\t// automatic length determination in AnimationClip.\r\n\t\tlet duration = animation.length || - 1;\r\n\r\n\t\tconst hierarchyTracks = animation.hierarchy || [];\r\n\r\n\t\tfor ( let h = 0; h < hierarchyTracks.length; h ++ ) {\r\n\r\n\t\t\tconst animationKeys = hierarchyTracks[ h ].keys;\r\n\r\n\t\t\t// skip empty tracks\r\n\t\t\tif ( ! animationKeys || animationKeys.length === 0 ) continue;\r\n\r\n\t\t\t// process morph targets\r\n\t\t\tif ( animationKeys[ 0 ].morphTargets ) {\r\n\r\n\t\t\t\t// figure out all morph targets used in this track\r\n\t\t\t\tconst morphTargetNames = {};\r\n\r\n\t\t\t\tlet k;\r\n\r\n\t\t\t\tfor ( k = 0; k < animationKeys.length; k ++ ) {\r\n\r\n\t\t\t\t\tif ( animationKeys[ k ].morphTargets ) {\r\n\r\n\t\t\t\t\t\tfor ( let m = 0; m < animationKeys[ k ].morphTargets.length; m ++ ) {\r\n\r\n\t\t\t\t\t\t\tmorphTargetNames[ animationKeys[ k ].morphTargets[ m ] ] = - 1;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// create a track for each morph target with all zero\r\n\t\t\t\t// morphTargetInfluences except for the keys in which\r\n\t\t\t\t// the morphTarget is named.\r\n\t\t\t\tfor ( const morphTargetName in morphTargetNames ) {\r\n\r\n\t\t\t\t\tconst times = [];\r\n\t\t\t\t\tconst values = [];\r\n\r\n\t\t\t\t\tfor ( let m = 0; m !== animationKeys[ k ].morphTargets.length; ++ m ) {\r\n\r\n\t\t\t\t\t\tconst animationKey = animationKeys[ k ];\r\n\r\n\t\t\t\t\t\ttimes.push( animationKey.time );\r\n\t\t\t\t\t\tvalues.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\ttracks.push( new NumberKeyframeTrack( '.morphTargetInfluence[' + morphTargetName + ']', times, values ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tduration = morphTargetNames.length * fps;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// ...assume skeletal animation\r\n\r\n\t\t\t\tconst boneName = '.bones[' + bones[ h ].name + ']';\r\n\r\n\t\t\t\taddNonemptyTrack(\r\n\t\t\t\t\tVectorKeyframeTrack, boneName + '.position',\r\n\t\t\t\t\tanimationKeys, 'pos', tracks );\r\n\r\n\t\t\t\taddNonemptyTrack(\r\n\t\t\t\t\tQuaternionKeyframeTrack, boneName + '.quaternion',\r\n\t\t\t\t\tanimationKeys, 'rot', tracks );\r\n\r\n\t\t\t\taddNonemptyTrack(\r\n\t\t\t\t\tVectorKeyframeTrack, boneName + '.scale',\r\n\t\t\t\t\tanimationKeys, 'scl', tracks );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( tracks.length === 0 ) {\r\n\r\n\t\t\treturn null;\r\n\r\n\t\t}\r\n\r\n\t\tconst clip = new this( clipName, duration, tracks, blendMode );\r\n\r\n\t\treturn clip;\r\n\r\n\t}\r\n\r\n\tresetDuration() {\r\n\r\n\t\tconst tracks = this.tracks;\r\n\t\tlet duration = 0;\r\n\r\n\t\tfor ( let i = 0, n = tracks.length; i !== n; ++ i ) {\r\n\r\n\t\t\tconst track = this.tracks[ i ];\r\n\r\n\t\t\tduration = Math.max( duration, track.times[ track.times.length - 1 ] );\r\n\r\n\t\t}\r\n\r\n\t\tthis.duration = duration;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\ttrim() {\r\n\r\n\t\tfor ( let i = 0; i < this.tracks.length; i ++ ) {\r\n\r\n\t\t\tthis.tracks[ i ].trim( 0, this.duration );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tvalidate() {\r\n\r\n\t\tlet valid = true;\r\n\r\n\t\tfor ( let i = 0; i < this.tracks.length; i ++ ) {\r\n\r\n\t\t\tvalid = valid && this.tracks[ i ].validate();\r\n\r\n\t\t}\r\n\r\n\t\treturn valid;\r\n\r\n\t}\r\n\r\n\toptimize() {\r\n\r\n\t\tfor ( let i = 0; i < this.tracks.length; i ++ ) {\r\n\r\n\t\t\tthis.tracks[ i ].optimize();\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tclone() {\r\n\r\n\t\tconst tracks = [];\r\n\r\n\t\tfor ( let i = 0; i < this.tracks.length; i ++ ) {\r\n\r\n\t\t\ttracks.push( this.tracks[ i ].clone() );\r\n\r\n\t\t}\r\n\r\n\t\treturn new this.constructor( this.name, this.duration, tracks, this.blendMode );\r\n\r\n\t}\r\n\r\n\ttoJSON() {\r\n\r\n\t\treturn this.constructor.toJSON( this );\r\n\r\n\t}\r\n\r\n}\r\n\r\nfunction getTrackTypeForValueTypeName( typeName ) {\r\n\r\n\tswitch ( typeName.toLowerCase() ) {\r\n\r\n\t\tcase 'scalar':\r\n\t\tcase 'double':\r\n\t\tcase 'float':\r\n\t\tcase 'number':\r\n\t\tcase 'integer':\r\n\r\n\t\t\treturn NumberKeyframeTrack;\r\n\r\n\t\tcase 'vector':\r\n\t\tcase 'vector2':\r\n\t\tcase 'vector3':\r\n\t\tcase 'vector4':\r\n\r\n\t\t\treturn VectorKeyframeTrack;\r\n\r\n\t\tcase 'color':\r\n\r\n\t\t\treturn ColorKeyframeTrack;\r\n\r\n\t\tcase 'quaternion':\r\n\r\n\t\t\treturn QuaternionKeyframeTrack;\r\n\r\n\t\tcase 'bool':\r\n\t\tcase 'boolean':\r\n\r\n\t\t\treturn BooleanKeyframeTrack;\r\n\r\n\t\tcase 'string':\r\n\r\n\t\t\treturn StringKeyframeTrack;\r\n\r\n\t}\r\n\r\n\tthrow new Error( 'THREE.KeyframeTrack: Unsupported typeName: ' + typeName );\r\n\r\n}\r\n\r\nfunction parseKeyframeTrack( json ) {\r\n\r\n\tif ( json.type === undefined ) {\r\n\r\n\t\tthrow new Error( 'THREE.KeyframeTrack: track type undefined, can not parse' );\r\n\r\n\t}\r\n\r\n\tconst trackType = getTrackTypeForValueTypeName( json.type );\r\n\r\n\tif ( json.times === undefined ) {\r\n\r\n\t\tconst times = [], values = [];\r\n\r\n\t\tAnimationUtils.flattenJSON( json.keys, times, values, 'value' );\r\n\r\n\t\tjson.times = times;\r\n\t\tjson.values = values;\r\n\r\n\t}\r\n\r\n\t// derived classes can define a static parse method\r\n\tif ( trackType.parse !== undefined ) {\r\n\r\n\t\treturn trackType.parse( json );\r\n\r\n\t} else {\r\n\r\n\t\t// by default, we assume a constructor compatible with the base\r\n\t\treturn new trackType( json.name, json.times, json.values, json.interpolation );\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport { AnimationClip };\r\n"]},"metadata":{},"sourceType":"module"}