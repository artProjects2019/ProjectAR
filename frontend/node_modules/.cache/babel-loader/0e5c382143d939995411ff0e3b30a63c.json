{"ast":null,"code":"import { updateTextureX, updateTextureXWin, updateTextureO, updateTextureOWin } from './drawTicTacToe.js';\nimport { playAudio } from '../../../public/audio/sound.js';\nconst SIZE = 3;\nconst X = 1;\nconst O = 0;\nconst EMPTY = -1; // representation of the game board in the tic-tac-toe's logic\n\nlet logicBoard = [[EMPTY, EMPTY, EMPTY], [EMPTY, EMPTY, EMPTY], [EMPTY, EMPTY, EMPTY]];\nlet gameOver = {\n  status: false\n};\n\nfunction sleep(ms) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\nfunction calculateBoxNumber(row, column) {\n  return 3 * row + column; // number of the box from 0 to 8\n} // if the game is still going then the player makes a move based on the clicked box\n\n\nasync function playerTurn(boxNumber) {\n  if (!gameOver.status) {\n    let row = Math.floor(boxNumber / 3);\n    let column = boxNumber % 3;\n\n    if (logicBoard[row][column] === EMPTY) {\n      logicBoard[row][column] = O;\n      updateTextureO(boxNumber); // check the game status after the player's move\n\n      checkWin(O);\n      checkCatsGame(); // computer makes a move only after player's turn\n\n      await sleep(200);\n      computerTurn();\n    }\n  }\n} // if the game is still going then the computer makes a move\n\n\nfunction computerTurn() {\n  if (!gameOver.status) {\n    computerInput(); // check the game status after the computer's move\n\n    checkWin(X);\n    checkCatsGame();\n  }\n}\n\nfunction computerRandomInput() {\n  let row = Math.floor(Math.random() * 10 % 3);\n  let column = Math.floor(Math.random() * 10 % 3);\n\n  if (logicBoard[row][column] === EMPTY) {\n    logicBoard[row][column] = X;\n    updateTextureX(calculateBoxNumber(row, column));\n  } else {\n    computerRandomInput();\n  }\n} // function used by the computer to check whether it should make a move in one of the rows\n\n\nfunction checkRow(madeTurn, mark) {\n  for (let i = 0; i < SIZE; ++i) {\n    let symbolCount = 0;\n    let column = -1;\n\n    for (let j = 0; j < SIZE; ++j) {\n      if (logicBoard[i][j] === mark) {\n        symbolCount++;\n      } else if (logicBoard[i][j] === EMPTY) {\n        column = j; // remember the position of the potential computer's move\n      }\n    } // if there are 2 the same marks in the same row and the third box is empty\n    // then make a move on the remembered position\n\n\n    if (symbolCount === SIZE - 1 && column >= 0) {\n      logicBoard[i][column] = X;\n      updateTextureX(calculateBoxNumber(i, column));\n      madeTurn.status = true;\n      break;\n    }\n  }\n} // function used by the computer to check whether it should make a move in one of the columns\n\n\nfunction checkColumn(madeTurn, mark) {\n  for (let j = 0; j < SIZE; ++j) {\n    let symbolCount = 0;\n    let row = -1;\n\n    for (let i = 0; i < SIZE; ++i) {\n      if (logicBoard[i][j] === mark) {\n        symbolCount++;\n      } else if (logicBoard[i][j] === EMPTY) {\n        row = i; // remember the position of the potential computer's move\n      }\n    } // if there are 2 the same marks in the same column and the third box is empty\n    // then make a move on the remembered position\n\n\n    if (symbolCount === SIZE - 1 && row >= 0) {\n      logicBoard[row][j] = X;\n      updateTextureX(calculateBoxNumber(row, j));\n      madeTurn.status = true;\n      break;\n    }\n  }\n} // function used by the computer to check whether it should make a move on one of the diagonals\n\n\nfunction checkDiagonalLeftTop(madeTurn, mark) {\n  let symbolCount = 0;\n  let position = -1;\n\n  for (let i = 0; i < SIZE; ++i) {\n    if (logicBoard[i][i] === mark) {\n      symbolCount++;\n    } else if (logicBoard[i][i] === EMPTY) {\n      position = i; // remember the position of the potential computer's move\n    }\n  } // if there are 2 the same marks on the same diagonal and the third box is empty\n  // then make a move on the remembered position\n\n\n  if (symbolCount === SIZE - 1 && position >= 0) {\n    logicBoard[position][position] = X;\n    updateTextureX(calculateBoxNumber(position, position));\n    madeTurn.status = true;\n  }\n} // function used by the computer to check whether it should make a move on one of the diagonals\n\n\nfunction checkDiagonalLeftBottom(madeTurn, mark) {\n  let symbolCount = 0;\n  let position = -1;\n\n  for (let i = 0; i < SIZE; ++i) {\n    if (logicBoard[SIZE - i - 1][i] === mark) {\n      symbolCount++;\n    } else if (logicBoard[SIZE - i - 1][i] === EMPTY) {\n      position = i; // remember the position of the potential computer's move\n    }\n  } // if there are 2 the same marks on the same diagonal and the third box is empty\n  // then make a move on the remembered position\n\n\n  if (symbolCount === SIZE - 1 && position >= 0) {\n    logicBoard[SIZE - position - 1][position] = X;\n    updateTextureX(calculateBoxNumber(SIZE - position - 1, position));\n    madeTurn.status = true;\n  }\n} // computer's logic\n\n\nfunction computerInput() {\n  let turnMade = {\n    status: false\n  }; // Computer checks if it can make 3 in a row and win the game\n\n  checkColumn(turnMade, X);\n\n  if (!turnMade.status) {\n    checkRow(turnMade, X);\n  }\n\n  if (!turnMade.status) {\n    checkDiagonalLeftTop(turnMade, X);\n  }\n\n  if (!turnMade.status) {\n    checkDiagonalLeftBottom(turnMade, X);\n  } // Computer checks if the player can make 3 in a row in the next turn and blocks him if he can\n\n\n  if (!turnMade.status) {\n    checkColumn(turnMade, O);\n  }\n\n  if (!turnMade.status) {\n    checkRow(turnMade, O);\n  }\n\n  if (!turnMade.status) {\n    checkDiagonalLeftBottom(turnMade, O);\n  }\n\n  if (!turnMade.status) {\n    checkDiagonalLeftTop(turnMade, O);\n  } // Computer makes a random move if it did not get to win the game, nor block the player\n\n\n  if (!turnMade.status) {\n    computerRandomInput();\n  }\n} // checks the every column looking for a win for a specific mark(X or O)\n\n\nfunction columnWin(mark) {\n  for (let i = 0; i < SIZE; ++i) {\n    let symbolCount = 0;\n    let boxesInARow = [];\n\n    for (let j = 0; j < SIZE; ++j) {\n      if (logicBoard[i][j] === mark) {\n        symbolCount++;\n        boxesInARow.push(calculateBoxNumber(i, j));\n      }\n    }\n\n    if (symbolCount === SIZE) {\n      drawWin(mark, boxesInARow);\n      gameOver.status = true;\n    }\n  }\n} // checks the every row looking for a win for a specific mark(X or O)\n\n\nfunction rowWin(mark) {\n  for (let i = 0; i < SIZE; ++i) {\n    let symbolCount = 0;\n    let boxesInARow = [];\n\n    for (let j = 0; j < SIZE; ++j) {\n      if (logicBoard[j][i] === mark) {\n        symbolCount++;\n        boxesInARow.push(calculateBoxNumber(j, i));\n      }\n    }\n\n    if (symbolCount === SIZE) {\n      drawWin(mark, boxesInARow);\n      gameOver.status = true;\n    }\n  }\n} // checks the both diagonals looking for a win for a specific mark(X or O)\n\n\nfunction diagonalWin(mark) {\n  let symbolCount = 0;\n  let boxesInARow = [];\n\n  for (let i = 0; i < SIZE; ++i) {\n    if (logicBoard[i][i] === mark) {\n      symbolCount++;\n      boxesInARow.push(calculateBoxNumber(i, i));\n    }\n  }\n\n  if (symbolCount === SIZE) {\n    drawWin(mark, boxesInARow);\n    gameOver.status = true;\n  }\n\n  symbolCount = 0;\n  boxesInARow = [];\n\n  for (let i = 0; i < SIZE; ++i) {\n    if (logicBoard[SIZE - i - 1][i] === mark) {\n      symbolCount++;\n      boxesInARow.push(calculateBoxNumber(SIZE - i - 1, i));\n    }\n  }\n\n  if (symbolCount === SIZE) {\n    drawWin(mark, boxesInARow);\n    gameOver.status = true;\n  }\n} // checks the entire board looking for a win for a specific mark(X or O)\n\n\nfunction checkWin(mark) {\n  columnWin(mark);\n\n  if (!gameOver.status) {\n    rowWin(mark);\n  }\n\n  if (!gameOver.status) {\n    diagonalWin(mark);\n  }\n\n  if (gameOver.status) {\n    if (mark === O) {\n      playAudio(\"./audio/win.wav\");\n    }\n\n    if (mark === X) {\n      playAudio(\"./audio/lose.wav\");\n    }\n  }\n} // changes the textures of the winning boxes\n\n\nfunction drawWin(mark, boxesInARow) {\n  for (let boxNumber of boxesInARow) {\n    if (mark === O) {\n      updateTextureOWin(boxNumber);\n    }\n\n    if (mark === X) {\n      updateTextureXWin(boxNumber);\n    }\n  }\n} // checks whether the game ended in a draw or is still going\n\n\nfunction checkCatsGame() {\n  if (!gameOver.status) {\n    let catsGame = true;\n\n    for (let i = 0; i < SIZE; ++i) {\n      for (let j = 0; j < SIZE; ++j) {\n        if (logicBoard[i][j] === EMPTY) {\n          catsGame = false;\n        }\n      }\n    }\n\n    if (catsGame) {\n      gameOver.status = true;\n      playAudio(\"../audio/draw.wav\");\n    }\n  }\n}\n\nexport { playerTurn };","map":{"version":3,"sources":["C:/Users/dell/Desktop/projektlogin/vue-3-authentication-jwt/src/games/ticTacToe/ticTacToe.js"],"names":["updateTextureX","updateTextureXWin","updateTextureO","updateTextureOWin","playAudio","SIZE","X","O","EMPTY","logicBoard","gameOver","status","sleep","ms","Promise","resolve","setTimeout","calculateBoxNumber","row","column","playerTurn","boxNumber","Math","floor","checkWin","checkCatsGame","computerTurn","computerInput","computerRandomInput","random","checkRow","madeTurn","mark","i","symbolCount","j","checkColumn","checkDiagonalLeftTop","position","checkDiagonalLeftBottom","turnMade","columnWin","boxesInARow","push","drawWin","rowWin","diagonalWin","catsGame"],"mappings":"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","sourcesContent":["import  {\r\n     updateTextureX,\r\n     updateTextureXWin,\r\n     updateTextureO,\r\n     updateTextureOWin\r\n}  from './drawTicTacToe.js'\r\n\r\nimport {playAudio} from '../../../public/audio/sound.js'\r\n\r\nconst SIZE = 3;\r\nconst X = 1;\r\nconst O = 0;\r\nconst EMPTY = -1;\r\n\r\n// representation of the game board in the tic-tac-toe's logic\r\nlet logicBoard =\r\n    [[EMPTY, EMPTY, EMPTY],\r\n        [EMPTY, EMPTY, EMPTY],\r\n        [EMPTY, EMPTY, EMPTY]];\r\n\r\nlet gameOver = {status: false};\r\n\r\nfunction sleep(ms) {\r\n    return new Promise(resolve => setTimeout(resolve, ms));\r\n}\r\n\r\nfunction calculateBoxNumber(row, column) {\r\n    return 3*row+column; // number of the box from 0 to 8\r\n}\r\n\r\n// if the game is still going then the player makes a move based on the clicked box\r\nasync function playerTurn(boxNumber) {\r\n    if(!gameOver.status) {\r\n        let row = Math.floor(boxNumber / 3);\r\n        let column = boxNumber % 3;\r\n\r\n        if(logicBoard[row][column] === EMPTY) {\r\n            logicBoard[row][column] = O;\r\n            updateTextureO(boxNumber);\r\n\r\n            // check the game status after the player's move\r\n            checkWin(O);\r\n            checkCatsGame();\r\n\r\n            // computer makes a move only after player's turn\r\n            await sleep(200);\r\n            computerTurn();\r\n        }\r\n    }\r\n}\r\n\r\n// if the game is still going then the computer makes a move\r\nfunction computerTurn() {\r\n    if(!gameOver.status) {\r\n        computerInput();\r\n\r\n        // check the game status after the computer's move\r\n        checkWin(X);\r\n        checkCatsGame();\r\n    }\r\n}\r\n\r\nfunction computerRandomInput() {\r\n    let row = Math.floor((Math.random() * 10) % 3);\r\n    let column = Math.floor((Math.random() * 10) % 3);\r\n\r\n    if(logicBoard[row][column] === EMPTY) {\r\n        logicBoard[row][column] = X;\r\n        updateTextureX(calculateBoxNumber(row, column));\r\n    }\r\n    else {\r\n        computerRandomInput();\r\n    }\r\n}\r\n\r\n// function used by the computer to check whether it should make a move in one of the rows\r\nfunction checkRow(madeTurn, mark) {\r\n    for(let i = 0; i < SIZE; ++i) {\r\n        let symbolCount = 0;\r\n        let column = -1;\r\n        for(let j = 0; j < SIZE; ++j) {\r\n            if(logicBoard[i][j] === mark) {\r\n                symbolCount++;\r\n            }\r\n            else if(logicBoard[i][j] === EMPTY) {\r\n                column = j; // remember the position of the potential computer's move\r\n            }\r\n        }\r\n\r\n        // if there are 2 the same marks in the same row and the third box is empty\r\n        // then make a move on the remembered position\r\n        if(symbolCount === SIZE - 1 && column >= 0) {\r\n            logicBoard[i][column] = X;\r\n            updateTextureX(calculateBoxNumber(i, column));\r\n            madeTurn.status = true;\r\n            break;\r\n        }\r\n    }\r\n}\r\n\r\n// function used by the computer to check whether it should make a move in one of the columns\r\nfunction checkColumn(madeTurn, mark) {\r\n    for(let j = 0; j < SIZE; ++j) {\r\n        let symbolCount = 0;\r\n        let row = -1;\r\n        for(let i = 0; i < SIZE; ++i) {\r\n            if(logicBoard[i][j] === mark) {\r\n                symbolCount++;\r\n            }\r\n            else if(logicBoard[i][j] === EMPTY) {\r\n                row = i; // remember the position of the potential computer's move\r\n            }\r\n        }\r\n\r\n        // if there are 2 the same marks in the same column and the third box is empty\r\n        // then make a move on the remembered position\r\n        if(symbolCount === SIZE - 1 && row >= 0) {\r\n            logicBoard[row][j] = X;\r\n            updateTextureX(calculateBoxNumber(row, j));\r\n            madeTurn.status = true;\r\n            break;\r\n        }\r\n    }\r\n}\r\n\r\n// function used by the computer to check whether it should make a move on one of the diagonals\r\nfunction checkDiagonalLeftTop(madeTurn, mark) {\r\n    let symbolCount = 0;\r\n    let position = -1;\r\n\r\n    for(let i = 0; i < SIZE; ++i) {\r\n        if(logicBoard[i][i] === mark) {\r\n            symbolCount++;\r\n        }\r\n        else if(logicBoard[i][i] === EMPTY) {\r\n            position = i; // remember the position of the potential computer's move\r\n        }\r\n    }\r\n\r\n    // if there are 2 the same marks on the same diagonal and the third box is empty\r\n    // then make a move on the remembered position\r\n    if(symbolCount === SIZE - 1 && position >= 0) {\r\n        logicBoard[position][position] = X;\r\n        updateTextureX(calculateBoxNumber(position, position));\r\n        madeTurn.status = true;\r\n    }\r\n}\r\n\r\n// function used by the computer to check whether it should make a move on one of the diagonals\r\nfunction checkDiagonalLeftBottom(madeTurn, mark) {\r\n    let symbolCount = 0;\r\n    let position = -1;\r\n\r\n    for(let i = 0; i < SIZE; ++i) {\r\n        if(logicBoard[SIZE - i - 1][i] === mark) {\r\n            symbolCount++;\r\n        }\r\n        else if(logicBoard[SIZE - i - 1][i] === EMPTY) {\r\n            position = i; // remember the position of the potential computer's move\r\n        }\r\n    }\r\n\r\n    // if there are 2 the same marks on the same diagonal and the third box is empty\r\n    // then make a move on the remembered position\r\n    if(symbolCount === SIZE - 1 && position >= 0) {\r\n        logicBoard[SIZE - position - 1][position] = X;\r\n        updateTextureX(calculateBoxNumber((SIZE - position - 1), position));\r\n        madeTurn.status = true;\r\n    }\r\n}\r\n\r\n// computer's logic\r\nfunction computerInput() {\r\n    let turnMade = {status: false};\r\n\r\n    // Computer checks if it can make 3 in a row and win the game\r\n    checkColumn(turnMade, X);\r\n    if(!turnMade.status) {\r\n        checkRow(turnMade, X);\r\n    }\r\n    if(!turnMade.status) {\r\n        checkDiagonalLeftTop(turnMade, X);\r\n    }\r\n    if(!turnMade.status) {\r\n        checkDiagonalLeftBottom(turnMade, X);\r\n    }\r\n\r\n    // Computer checks if the player can make 3 in a row in the next turn and blocks him if he can\r\n    if(!turnMade.status) {\r\n        checkColumn(turnMade, O);\r\n    }\r\n    if(!turnMade.status) {\r\n        checkRow(turnMade, O);\r\n    }\r\n    if(!turnMade.status) {\r\n        checkDiagonalLeftBottom(turnMade, O);\r\n    }\r\n    if(!turnMade.status) {\r\n        checkDiagonalLeftTop(turnMade, O);\r\n    }\r\n\r\n    // Computer makes a random move if it did not get to win the game, nor block the player\r\n    if(!turnMade.status) {\r\n        computerRandomInput();\r\n    }\r\n}\r\n\r\n// checks the every column looking for a win for a specific mark(X or O)\r\nfunction columnWin(mark) {\r\n    for(let i = 0; i < SIZE; ++i) {\r\n        let symbolCount = 0;\r\n        let boxesInARow = [];\r\n        for(let j = 0; j < SIZE; ++j) {\r\n            if(logicBoard[i][j] === mark) {\r\n                symbolCount++;\r\n                boxesInARow.push(calculateBoxNumber(i, j));\r\n            }\r\n        }\r\n        if(symbolCount === SIZE) {\r\n            drawWin(mark, boxesInARow);\r\n            gameOver.status = true;\r\n        }\r\n    }\r\n}\r\n\r\n// checks the every row looking for a win for a specific mark(X or O)\r\nfunction rowWin(mark) {\r\n    for(let i = 0; i < SIZE; ++i) {\r\n        let symbolCount = 0;\r\n        let boxesInARow = [];\r\n        for(let j = 0; j < SIZE; ++j) {\r\n            if(logicBoard[j][i] === mark) {\r\n                symbolCount++;\r\n                boxesInARow.push(calculateBoxNumber(j, i));\r\n            }\r\n        }\r\n        if(symbolCount === SIZE) {\r\n            drawWin(mark, boxesInARow);\r\n            gameOver.status = true;\r\n        }\r\n    }\r\n}\r\n\r\n// checks the both diagonals looking for a win for a specific mark(X or O)\r\nfunction diagonalWin(mark) {\r\n    let symbolCount = 0;\r\n    let boxesInARow = [];\r\n    for(let i = 0; i < SIZE; ++i) {\r\n        if(logicBoard[i][i] === mark) {\r\n            symbolCount++;\r\n            boxesInARow.push(calculateBoxNumber(i, i));\r\n        }\r\n    }\r\n    if(symbolCount === SIZE) {\r\n        drawWin(mark, boxesInARow);\r\n        gameOver.status = true;\r\n    }\r\n\r\n    symbolCount = 0;\r\n    boxesInARow = [];\r\n\r\n    for(let i = 0; i < SIZE; ++i) {\r\n        if(logicBoard[SIZE - i - 1][i] === mark) {\r\n            symbolCount++;\r\n            boxesInARow.push(calculateBoxNumber((SIZE - i - 1), i));\r\n        }\r\n    }\r\n    if(symbolCount === SIZE) {\r\n        drawWin(mark, boxesInARow);\r\n        gameOver.status = true;\r\n    }\r\n}\r\n\r\n// checks the entire board looking for a win for a specific mark(X or O)\r\nfunction checkWin(mark) {\r\n    columnWin(mark);\r\n    if(!gameOver.status) {\r\n        rowWin(mark);\r\n    }\r\n    if(!gameOver.status) {\r\n        diagonalWin(mark);\r\n    }\r\n    if(gameOver.status) {\r\n        if(mark === O) {\r\n            playAudio(\"./audio/win.wav\");\r\n        }\r\n        if(mark === X) {\r\n            playAudio(\"./audio/lose.wav\");\r\n        }\r\n    }\r\n}\r\n\r\n// changes the textures of the winning boxes\r\nfunction drawWin(mark, boxesInARow) {\r\n    for(let boxNumber of boxesInARow) {\r\n        if(mark === O) {\r\n            updateTextureOWin(boxNumber);\r\n        }\r\n        if(mark === X) {\r\n            updateTextureXWin(boxNumber);\r\n        }\r\n    }\r\n}\r\n\r\n// checks whether the game ended in a draw or is still going\r\nfunction checkCatsGame() {\r\n    if(!gameOver.status) {\r\n        let catsGame = true;\r\n\r\n        for(let i = 0; i < SIZE; ++i) {\r\n            for(let j = 0; j < SIZE; ++j) {\r\n                if(logicBoard[i][j] === EMPTY) {\r\n                    catsGame = false;\r\n                }\r\n            }\r\n        }\r\n\r\n        if(catsGame) {\r\n            gameOver.status = true;\r\n            playAudio(\"../audio/draw.wav\");\r\n        }\r\n    }\r\n}\r\n\r\nexport {playerTurn};"]},"metadata":{},"sourceType":"module"}