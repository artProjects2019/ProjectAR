{"ast":null,"code":"import { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport { Vector3 } from '../math/Vector3.js';\n\nclass WireframeGeometry extends BufferGeometry {\n  constructor(geometry = null) {\n    super();\n    this.type = 'WireframeGeometry';\n    this.parameters = {\n      geometry: geometry\n    };\n\n    if (geometry !== null) {\n      // buffer\n      const vertices = [];\n      const edges = new Set(); // helper variables\n\n      const start = new Vector3();\n      const end = new Vector3();\n\n      if (geometry.index !== null) {\n        // indexed BufferGeometry\n        const position = geometry.attributes.position;\n        const indices = geometry.index;\n        let groups = geometry.groups;\n\n        if (groups.length === 0) {\n          groups = [{\n            start: 0,\n            count: indices.count,\n            materialIndex: 0\n          }];\n        } // create a data structure that contains all eges without duplicates\n\n\n        for (let o = 0, ol = groups.length; o < ol; ++o) {\n          const group = groups[o];\n          const groupStart = group.start;\n          const groupCount = group.count;\n\n          for (let i = groupStart, l = groupStart + groupCount; i < l; i += 3) {\n            for (let j = 0; j < 3; j++) {\n              const index1 = indices.getX(i + j);\n              const index2 = indices.getX(i + (j + 1) % 3);\n              start.fromBufferAttribute(position, index1);\n              end.fromBufferAttribute(position, index2);\n\n              if (isUniqueEdge(start, end, edges) === true) {\n                vertices.push(start.x, start.y, start.z);\n                vertices.push(end.x, end.y, end.z);\n              }\n            }\n          }\n        }\n      } else {\n        // non-indexed BufferGeometry\n        const position = geometry.attributes.position;\n\n        for (let i = 0, l = position.count / 3; i < l; i++) {\n          for (let j = 0; j < 3; j++) {\n            // three edges per triangle, an edge is represented as (index1, index2)\n            // e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)\n            const index1 = 3 * i + j;\n            const index2 = 3 * i + (j + 1) % 3;\n            start.fromBufferAttribute(position, index1);\n            end.fromBufferAttribute(position, index2);\n\n            if (isUniqueEdge(start, end, edges) === true) {\n              vertices.push(start.x, start.y, start.z);\n              vertices.push(end.x, end.y, end.z);\n            }\n          }\n        }\n      } // build geometry\n\n\n      this.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n    }\n  }\n\n}\n\nfunction isUniqueEdge(start, end, edges) {\n  const hash1 = `${start.x},${start.y},${start.z}-${end.x},${end.y},${end.z}`;\n  const hash2 = `${end.x},${end.y},${end.z}-${start.x},${start.y},${start.z}`; // coincident edge\n\n  if (edges.has(hash1) === true || edges.has(hash2) === true) {\n    return false;\n  } else {\n    edges.add(hash1);\n    edges.add(hash2);\n    return true;\n  }\n}\n\nexport { WireframeGeometry };","map":{"version":3,"sources":["C:/Users/dell/Desktop/projektlogin/vue-3-authentication-jwt/src/games/three/src/geometries/WireframeGeometry.js"],"names":["BufferGeometry","Float32BufferAttribute","Vector3","WireframeGeometry","constructor","geometry","type","parameters","vertices","edges","Set","start","end","index","position","attributes","indices","groups","length","count","materialIndex","o","ol","group","groupStart","groupCount","i","l","j","index1","getX","index2","fromBufferAttribute","isUniqueEdge","push","x","y","z","setAttribute","hash1","hash2","has","add"],"mappings":"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","sourcesContent":["import { BufferGeometry } from '../core/BufferGeometry.js';\r\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\r\nimport { Vector3 } from '../math/Vector3.js';\r\n\r\nclass WireframeGeometry extends BufferGeometry {\r\n\r\n\tconstructor( geometry = null ) {\r\n\r\n\t\tsuper();\r\n\t\tthis.type = 'WireframeGeometry';\r\n\r\n\t\tthis.parameters = {\r\n\t\t\tgeometry: geometry\r\n\t\t};\r\n\r\n\t\tif ( geometry !== null ) {\r\n\r\n\t\t\t// buffer\r\n\r\n\t\t\tconst vertices = [];\r\n\t\t\tconst edges = new Set();\r\n\r\n\t\t\t// helper variables\r\n\r\n\t\t\tconst start = new Vector3();\r\n\t\t\tconst end = new Vector3();\r\n\r\n\t\t\tif ( geometry.index !== null ) {\r\n\r\n\t\t\t\t// indexed BufferGeometry\r\n\r\n\t\t\t\tconst position = geometry.attributes.position;\r\n\t\t\t\tconst indices = geometry.index;\r\n\t\t\t\tlet groups = geometry.groups;\r\n\r\n\t\t\t\tif ( groups.length === 0 ) {\r\n\r\n\t\t\t\t\tgroups = [ { start: 0, count: indices.count, materialIndex: 0 } ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// create a data structure that contains all eges without duplicates\r\n\r\n\t\t\t\tfor ( let o = 0, ol = groups.length; o < ol; ++ o ) {\r\n\r\n\t\t\t\t\tconst group = groups[ o ];\r\n\r\n\t\t\t\t\tconst groupStart = group.start;\r\n\t\t\t\t\tconst groupCount = group.count;\r\n\r\n\t\t\t\t\tfor ( let i = groupStart, l = ( groupStart + groupCount ); i < l; i += 3 ) {\r\n\r\n\t\t\t\t\t\tfor ( let j = 0; j < 3; j ++ ) {\r\n\r\n\t\t\t\t\t\t\tconst index1 = indices.getX( i + j );\r\n\t\t\t\t\t\t\tconst index2 = indices.getX( i + ( j + 1 ) % 3 );\r\n\r\n\t\t\t\t\t\t\tstart.fromBufferAttribute( position, index1 );\r\n\t\t\t\t\t\t\tend.fromBufferAttribute( position, index2 );\r\n\r\n\t\t\t\t\t\t\tif ( isUniqueEdge( start, end, edges ) === true ) {\r\n\r\n\t\t\t\t\t\t\t\tvertices.push( start.x, start.y, start.z );\r\n\t\t\t\t\t\t\t\tvertices.push( end.x, end.y, end.z );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// non-indexed BufferGeometry\r\n\r\n\t\t\t\tconst position = geometry.attributes.position;\r\n\r\n\t\t\t\tfor ( let i = 0, l = ( position.count / 3 ); i < l; i ++ ) {\r\n\r\n\t\t\t\t\tfor ( let j = 0; j < 3; j ++ ) {\r\n\r\n\t\t\t\t\t\t// three edges per triangle, an edge is represented as (index1, index2)\r\n\t\t\t\t\t\t// e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)\r\n\r\n\t\t\t\t\t\tconst index1 = 3 * i + j;\r\n\t\t\t\t\t\tconst index2 = 3 * i + ( ( j + 1 ) % 3 );\r\n\r\n\t\t\t\t\t\tstart.fromBufferAttribute( position, index1 );\r\n\t\t\t\t\t\tend.fromBufferAttribute( position, index2 );\r\n\r\n\t\t\t\t\t\tif ( isUniqueEdge( start, end, edges ) === true ) {\r\n\r\n\t\t\t\t\t\t\tvertices.push( start.x, start.y, start.z );\r\n\t\t\t\t\t\t\tvertices.push( end.x, end.y, end.z );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// build geometry\r\n\r\n\t\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nfunction isUniqueEdge( start, end, edges ) {\r\n\r\n\tconst hash1 = `${start.x},${start.y},${start.z}-${end.x},${end.y},${end.z}`;\r\n\tconst hash2 = `${end.x},${end.y},${end.z}-${start.x},${start.y},${start.z}`; // coincident edge\r\n\r\n\tif ( edges.has( hash1 ) === true || edges.has( hash2 ) === true ) {\r\n\r\n\t\treturn false;\r\n\r\n\t} else {\r\n\r\n\t\tedges.add( hash1 );\r\n\t\tedges.add( hash2 );\r\n\t\treturn true;\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\nexport { WireframeGeometry };\r\n"]},"metadata":{},"sourceType":"module"}