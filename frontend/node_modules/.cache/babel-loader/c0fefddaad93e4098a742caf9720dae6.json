{"ast":null,"code":"import { Sphere } from '../math/Sphere.js';\nimport { Ray } from '../math/Ray.js';\nimport { Matrix4 } from '../math/Matrix4.js';\nimport { Object3D } from '../core/Object3D.js';\nimport { Vector3 } from '../math/Vector3.js';\nimport { LineBasicMaterial } from '../materials/LineBasicMaterial.js';\nimport { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\n\nconst _start = /*@__PURE__*/new Vector3();\n\nconst _end = /*@__PURE__*/new Vector3();\n\nconst _inverseMatrix = /*@__PURE__*/new Matrix4();\n\nconst _ray = /*@__PURE__*/new Ray();\n\nconst _sphere = /*@__PURE__*/new Sphere();\n\nclass Line extends Object3D {\n  constructor(geometry = new BufferGeometry(), material = new LineBasicMaterial()) {\n    super();\n    this.type = 'Line';\n    this.geometry = geometry;\n    this.material = material;\n    this.updateMorphTargets();\n  }\n\n  copy(source) {\n    super.copy(source);\n    this.material = source.material;\n    this.geometry = source.geometry;\n    return this;\n  }\n\n  computeLineDistances() {\n    const geometry = this.geometry;\n\n    if (geometry.isBufferGeometry) {\n      // we assume non-indexed geometry\n      if (geometry.index === null) {\n        const positionAttribute = geometry.attributes.position;\n        const lineDistances = [0];\n\n        for (let i = 1, l = positionAttribute.count; i < l; i++) {\n          _start.fromBufferAttribute(positionAttribute, i - 1);\n\n          _end.fromBufferAttribute(positionAttribute, i);\n\n          lineDistances[i] = lineDistances[i - 1];\n          lineDistances[i] += _start.distanceTo(_end);\n        }\n\n        geometry.setAttribute('lineDistance', new Float32BufferAttribute(lineDistances, 1));\n      } else {\n        console.warn('THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');\n      }\n    } else if (geometry.isGeometry) {\n      console.error('THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');\n    }\n\n    return this;\n  }\n\n  raycast(raycaster, intersects) {\n    const geometry = this.geometry;\n    const matrixWorld = this.matrixWorld;\n    const threshold = raycaster.params.Line.threshold;\n    const drawRange = geometry.drawRange; // Checking boundingSphere distance to ray\n\n    if (geometry.boundingSphere === null) geometry.computeBoundingSphere();\n\n    _sphere.copy(geometry.boundingSphere);\n\n    _sphere.applyMatrix4(matrixWorld);\n\n    _sphere.radius += threshold;\n    if (raycaster.ray.intersectsSphere(_sphere) === false) return; //\n\n    _inverseMatrix.copy(matrixWorld).invert();\n\n    _ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix);\n\n    const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);\n    const localThresholdSq = localThreshold * localThreshold;\n    const vStart = new Vector3();\n    const vEnd = new Vector3();\n    const interSegment = new Vector3();\n    const interRay = new Vector3();\n    const step = this.isLineSegments ? 2 : 1;\n\n    if (geometry.isBufferGeometry) {\n      const index = geometry.index;\n      const attributes = geometry.attributes;\n      const positionAttribute = attributes.position;\n\n      if (index !== null) {\n        const start = Math.max(0, drawRange.start);\n        const end = Math.min(index.count, drawRange.start + drawRange.count);\n\n        for (let i = start, l = end - 1; i < l; i += step) {\n          const a = index.getX(i);\n          const b = index.getX(i + 1);\n          vStart.fromBufferAttribute(positionAttribute, a);\n          vEnd.fromBufferAttribute(positionAttribute, b);\n\n          const distSq = _ray.distanceSqToSegment(vStart, vEnd, interRay, interSegment);\n\n          if (distSq > localThresholdSq) continue;\n          interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation\n\n          const distance = raycaster.ray.origin.distanceTo(interRay);\n          if (distance < raycaster.near || distance > raycaster.far) continue;\n          intersects.push({\n            distance: distance,\n            // What do we want? intersection point on the ray or on the segment??\n            // point: raycaster.ray.at( distance ),\n            point: interSegment.clone().applyMatrix4(this.matrixWorld),\n            index: i,\n            face: null,\n            faceIndex: null,\n            object: this\n          });\n        }\n      } else {\n        const start = Math.max(0, drawRange.start);\n        const end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);\n\n        for (let i = start, l = end - 1; i < l; i += step) {\n          vStart.fromBufferAttribute(positionAttribute, i);\n          vEnd.fromBufferAttribute(positionAttribute, i + 1);\n\n          const distSq = _ray.distanceSqToSegment(vStart, vEnd, interRay, interSegment);\n\n          if (distSq > localThresholdSq) continue;\n          interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation\n\n          const distance = raycaster.ray.origin.distanceTo(interRay);\n          if (distance < raycaster.near || distance > raycaster.far) continue;\n          intersects.push({\n            distance: distance,\n            // What do we want? intersection point on the ray or on the segment??\n            // point: raycaster.ray.at( distance ),\n            point: interSegment.clone().applyMatrix4(this.matrixWorld),\n            index: i,\n            face: null,\n            faceIndex: null,\n            object: this\n          });\n        }\n      }\n    } else if (geometry.isGeometry) {\n      console.error('THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');\n    }\n  }\n\n  updateMorphTargets() {\n    const geometry = this.geometry;\n\n    if (geometry.isBufferGeometry) {\n      const morphAttributes = geometry.morphAttributes;\n      const keys = Object.keys(morphAttributes);\n\n      if (keys.length > 0) {\n        const morphAttribute = morphAttributes[keys[0]];\n\n        if (morphAttribute !== undefined) {\n          this.morphTargetInfluences = [];\n          this.morphTargetDictionary = {};\n\n          for (let m = 0, ml = morphAttribute.length; m < ml; m++) {\n            const name = morphAttribute[m].name || String(m);\n            this.morphTargetInfluences.push(0);\n            this.morphTargetDictionary[name] = m;\n          }\n        }\n      }\n    } else {\n      const morphTargets = geometry.morphTargets;\n\n      if (morphTargets !== undefined && morphTargets.length > 0) {\n        console.error('THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.');\n      }\n    }\n  }\n\n}\n\nLine.prototype.isLine = true;\nexport { Line };","map":{"version":3,"sources":["C:/Users/dell/Desktop/projektlogin/vue-3-authentication-jwt/src/games/three/src/objects/Line.js"],"names":["Sphere","Ray","Matrix4","Object3D","Vector3","LineBasicMaterial","BufferGeometry","Float32BufferAttribute","_start","_end","_inverseMatrix","_ray","_sphere","Line","constructor","geometry","material","type","updateMorphTargets","copy","source","computeLineDistances","isBufferGeometry","index","positionAttribute","attributes","position","lineDistances","i","l","count","fromBufferAttribute","distanceTo","setAttribute","console","warn","isGeometry","error","raycast","raycaster","intersects","matrixWorld","threshold","params","drawRange","boundingSphere","computeBoundingSphere","applyMatrix4","radius","ray","intersectsSphere","invert","localThreshold","scale","x","y","z","localThresholdSq","vStart","vEnd","interSegment","interRay","step","isLineSegments","start","Math","max","end","min","a","getX","b","distSq","distanceSqToSegment","distance","origin","near","far","push","point","clone","face","faceIndex","object","morphAttributes","keys","Object","length","morphAttribute","undefined","morphTargetInfluences","morphTargetDictionary","m","ml","name","String","morphTargets","prototype","isLine"],"mappings":"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","sourcesContent":["import { Sphere } from '../math/Sphere.js';\r\nimport { Ray } from '../math/Ray.js';\r\nimport { Matrix4 } from '../math/Matrix4.js';\r\nimport { Object3D } from '../core/Object3D.js';\r\nimport { Vector3 } from '../math/Vector3.js';\r\nimport { LineBasicMaterial } from '../materials/LineBasicMaterial.js';\r\nimport { BufferGeometry } from '../core/BufferGeometry.js';\r\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\r\n\r\nconst _start = /*@__PURE__*/ new Vector3();\r\nconst _end = /*@__PURE__*/ new Vector3();\r\nconst _inverseMatrix = /*@__PURE__*/ new Matrix4();\r\nconst _ray = /*@__PURE__*/ new Ray();\r\nconst _sphere = /*@__PURE__*/ new Sphere();\r\n\r\nclass Line extends Object3D {\r\n\r\n\tconstructor( geometry = new BufferGeometry(), material = new LineBasicMaterial() ) {\r\n\r\n\t\tsuper();\r\n\r\n\t\tthis.type = 'Line';\r\n\r\n\t\tthis.geometry = geometry;\r\n\t\tthis.material = material;\r\n\r\n\t\tthis.updateMorphTargets();\r\n\r\n\t}\r\n\r\n\tcopy( source ) {\r\n\r\n\t\tsuper.copy( source );\r\n\r\n\t\tthis.material = source.material;\r\n\t\tthis.geometry = source.geometry;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tcomputeLineDistances() {\r\n\r\n\t\tconst geometry = this.geometry;\r\n\r\n\t\tif ( geometry.isBufferGeometry ) {\r\n\r\n\t\t\t// we assume non-indexed geometry\r\n\r\n\t\t\tif ( geometry.index === null ) {\r\n\r\n\t\t\t\tconst positionAttribute = geometry.attributes.position;\r\n\t\t\t\tconst lineDistances = [ 0 ];\r\n\r\n\t\t\t\tfor ( let i = 1, l = positionAttribute.count; i < l; i ++ ) {\r\n\r\n\t\t\t\t\t_start.fromBufferAttribute( positionAttribute, i - 1 );\r\n\t\t\t\t\t_end.fromBufferAttribute( positionAttribute, i );\r\n\r\n\t\t\t\t\tlineDistances[ i ] = lineDistances[ i - 1 ];\r\n\t\t\t\t\tlineDistances[ i ] += _start.distanceTo( _end );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tgeometry.setAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tconsole.warn( 'THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( geometry.isGeometry ) {\r\n\r\n\t\t\tconsole.error( 'THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\traycast( raycaster, intersects ) {\r\n\r\n\t\tconst geometry = this.geometry;\r\n\t\tconst matrixWorld = this.matrixWorld;\r\n\t\tconst threshold = raycaster.params.Line.threshold;\r\n\t\tconst drawRange = geometry.drawRange;\r\n\r\n\t\t// Checking boundingSphere distance to ray\r\n\r\n\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\r\n\r\n\t\t_sphere.copy( geometry.boundingSphere );\r\n\t\t_sphere.applyMatrix4( matrixWorld );\r\n\t\t_sphere.radius += threshold;\r\n\r\n\t\tif ( raycaster.ray.intersectsSphere( _sphere ) === false ) return;\r\n\r\n\t\t//\r\n\r\n\t\t_inverseMatrix.copy( matrixWorld ).invert();\r\n\t\t_ray.copy( raycaster.ray ).applyMatrix4( _inverseMatrix );\r\n\r\n\t\tconst localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );\r\n\t\tconst localThresholdSq = localThreshold * localThreshold;\r\n\r\n\t\tconst vStart = new Vector3();\r\n\t\tconst vEnd = new Vector3();\r\n\t\tconst interSegment = new Vector3();\r\n\t\tconst interRay = new Vector3();\r\n\t\tconst step = this.isLineSegments ? 2 : 1;\r\n\r\n\t\tif ( geometry.isBufferGeometry ) {\r\n\r\n\t\t\tconst index = geometry.index;\r\n\t\t\tconst attributes = geometry.attributes;\r\n\t\t\tconst positionAttribute = attributes.position;\r\n\r\n\t\t\tif ( index !== null ) {\r\n\r\n\t\t\t\tconst start = Math.max( 0, drawRange.start );\r\n\t\t\t\tconst end = Math.min( index.count, ( drawRange.start + drawRange.count ) );\r\n\r\n\t\t\t\tfor ( let i = start, l = end - 1; i < l; i += step ) {\r\n\r\n\t\t\t\t\tconst a = index.getX( i );\r\n\t\t\t\t\tconst b = index.getX( i + 1 );\r\n\r\n\t\t\t\t\tvStart.fromBufferAttribute( positionAttribute, a );\r\n\t\t\t\t\tvEnd.fromBufferAttribute( positionAttribute, b );\r\n\r\n\t\t\t\t\tconst distSq = _ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );\r\n\r\n\t\t\t\t\tif ( distSq > localThresholdSq ) continue;\r\n\r\n\t\t\t\t\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\r\n\r\n\t\t\t\t\tconst distance = raycaster.ray.origin.distanceTo( interRay );\r\n\r\n\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\r\n\r\n\t\t\t\t\tintersects.push( {\r\n\r\n\t\t\t\t\t\tdistance: distance,\r\n\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\r\n\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\r\n\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\r\n\t\t\t\t\t\tindex: i,\r\n\t\t\t\t\t\tface: null,\r\n\t\t\t\t\t\tfaceIndex: null,\r\n\t\t\t\t\t\tobject: this\r\n\r\n\t\t\t\t\t} );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tconst start = Math.max( 0, drawRange.start );\r\n\t\t\t\tconst end = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );\r\n\r\n\t\t\t\tfor ( let i = start, l = end - 1; i < l; i += step ) {\r\n\r\n\t\t\t\t\tvStart.fromBufferAttribute( positionAttribute, i );\r\n\t\t\t\t\tvEnd.fromBufferAttribute( positionAttribute, i + 1 );\r\n\r\n\t\t\t\t\tconst distSq = _ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );\r\n\r\n\t\t\t\t\tif ( distSq > localThresholdSq ) continue;\r\n\r\n\t\t\t\t\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\r\n\r\n\t\t\t\t\tconst distance = raycaster.ray.origin.distanceTo( interRay );\r\n\r\n\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\r\n\r\n\t\t\t\t\tintersects.push( {\r\n\r\n\t\t\t\t\t\tdistance: distance,\r\n\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\r\n\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\r\n\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\r\n\t\t\t\t\t\tindex: i,\r\n\t\t\t\t\t\tface: null,\r\n\t\t\t\t\t\tfaceIndex: null,\r\n\t\t\t\t\t\tobject: this\r\n\r\n\t\t\t\t\t} );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( geometry.isGeometry ) {\r\n\r\n\t\t\tconsole.error( 'THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tupdateMorphTargets() {\r\n\r\n\t\tconst geometry = this.geometry;\r\n\r\n\t\tif ( geometry.isBufferGeometry ) {\r\n\r\n\t\t\tconst morphAttributes = geometry.morphAttributes;\r\n\t\t\tconst keys = Object.keys( morphAttributes );\r\n\r\n\t\t\tif ( keys.length > 0 ) {\r\n\r\n\t\t\t\tconst morphAttribute = morphAttributes[ keys[ 0 ] ];\r\n\r\n\t\t\t\tif ( morphAttribute !== undefined ) {\r\n\r\n\t\t\t\t\tthis.morphTargetInfluences = [];\r\n\t\t\t\t\tthis.morphTargetDictionary = {};\r\n\r\n\t\t\t\t\tfor ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {\r\n\r\n\t\t\t\t\t\tconst name = morphAttribute[ m ].name || String( m );\r\n\r\n\t\t\t\t\t\tthis.morphTargetInfluences.push( 0 );\r\n\t\t\t\t\t\tthis.morphTargetDictionary[ name ] = m;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tconst morphTargets = geometry.morphTargets;\r\n\r\n\t\t\tif ( morphTargets !== undefined && morphTargets.length > 0 ) {\r\n\r\n\t\t\t\tconsole.error( 'THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nLine.prototype.isLine = true;\r\n\r\n\r\nexport { Line };\r\n"]},"metadata":{},"sourceType":"module"}