{"ast":null,"code":"import { Quaternion } from '../math/Quaternion.js';\nimport { AdditiveAnimationBlendMode } from '../constants.js';\nconst AnimationUtils = {\n  // same as Array.prototype.slice, but also works on typed arrays\n  arraySlice: function (array, from, to) {\n    if (AnimationUtils.isTypedArray(array)) {\n      // in ios9 array.subarray(from, undefined) will return empty array\n      // but array.subarray(from) or array.subarray(from, len) is correct\n      return new array.constructor(array.subarray(from, to !== undefined ? to : array.length));\n    }\n\n    return array.slice(from, to);\n  },\n  // converts an array to a specific type\n  convertArray: function (array, type, forceClone) {\n    if (!array || // let 'undefined' and 'null' pass\n    !forceClone && array.constructor === type) return array;\n\n    if (typeof type.BYTES_PER_ELEMENT === 'number') {\n      return new type(array); // create typed array\n    }\n\n    return Array.prototype.slice.call(array); // create Array\n  },\n  isTypedArray: function (object) {\n    return ArrayBuffer.isView(object) && !(object instanceof DataView);\n  },\n  // returns an array by which times and values can be sorted\n  getKeyframeOrder: function (times) {\n    function compareTime(i, j) {\n      return times[i] - times[j];\n    }\n\n    const n = times.length;\n    const result = new Array(n);\n\n    for (let i = 0; i !== n; ++i) result[i] = i;\n\n    result.sort(compareTime);\n    return result;\n  },\n  // uses the array previously returned by 'getKeyframeOrder' to sort data\n  sortedArray: function (values, stride, order) {\n    const nValues = values.length;\n    const result = new values.constructor(nValues);\n\n    for (let i = 0, dstOffset = 0; dstOffset !== nValues; ++i) {\n      const srcOffset = order[i] * stride;\n\n      for (let j = 0; j !== stride; ++j) {\n        result[dstOffset++] = values[srcOffset + j];\n      }\n    }\n\n    return result;\n  },\n  // function for parsing AOS keyframe formats\n  flattenJSON: function (jsonKeys, times, values, valuePropertyName) {\n    let i = 1,\n        key = jsonKeys[0];\n\n    while (key !== undefined && key[valuePropertyName] === undefined) {\n      key = jsonKeys[i++];\n    }\n\n    if (key === undefined) return; // no data\n\n    let value = key[valuePropertyName];\n    if (value === undefined) return; // no data\n\n    if (Array.isArray(value)) {\n      do {\n        value = key[valuePropertyName];\n\n        if (value !== undefined) {\n          times.push(key.time);\n          values.push.apply(values, value); // push all elements\n        }\n\n        key = jsonKeys[i++];\n      } while (key !== undefined);\n    } else if (value.toArray !== undefined) {\n      // ...assume THREE.Math-ish\n      do {\n        value = key[valuePropertyName];\n\n        if (value !== undefined) {\n          times.push(key.time);\n          value.toArray(values, values.length);\n        }\n\n        key = jsonKeys[i++];\n      } while (key !== undefined);\n    } else {\n      // otherwise push as-is\n      do {\n        value = key[valuePropertyName];\n\n        if (value !== undefined) {\n          times.push(key.time);\n          values.push(value);\n        }\n\n        key = jsonKeys[i++];\n      } while (key !== undefined);\n    }\n  },\n  subclip: function (sourceClip, name, startFrame, endFrame, fps = 30) {\n    const clip = sourceClip.clone();\n    clip.name = name;\n    const tracks = [];\n\n    for (let i = 0; i < clip.tracks.length; ++i) {\n      const track = clip.tracks[i];\n      const valueSize = track.getValueSize();\n      const times = [];\n      const values = [];\n\n      for (let j = 0; j < track.times.length; ++j) {\n        const frame = track.times[j] * fps;\n        if (frame < startFrame || frame >= endFrame) continue;\n        times.push(track.times[j]);\n\n        for (let k = 0; k < valueSize; ++k) {\n          values.push(track.values[j * valueSize + k]);\n        }\n      }\n\n      if (times.length === 0) continue;\n      track.times = AnimationUtils.convertArray(times, track.times.constructor);\n      track.values = AnimationUtils.convertArray(values, track.values.constructor);\n      tracks.push(track);\n    }\n\n    clip.tracks = tracks; // find minimum .times value across all tracks in the trimmed clip\n\n    let minStartTime = Infinity;\n\n    for (let i = 0; i < clip.tracks.length; ++i) {\n      if (minStartTime > clip.tracks[i].times[0]) {\n        minStartTime = clip.tracks[i].times[0];\n      }\n    } // shift all tracks such that clip begins at t=0\n\n\n    for (let i = 0; i < clip.tracks.length; ++i) {\n      clip.tracks[i].shift(-1 * minStartTime);\n    }\n\n    clip.resetDuration();\n    return clip;\n  },\n  makeClipAdditive: function (targetClip, referenceFrame = 0, referenceClip = targetClip, fps = 30) {\n    if (fps <= 0) fps = 30;\n    const numTracks = referenceClip.tracks.length;\n    const referenceTime = referenceFrame / fps; // Make each track's values relative to the values at the reference frame\n\n    for (let i = 0; i < numTracks; ++i) {\n      const referenceTrack = referenceClip.tracks[i];\n      const referenceTrackType = referenceTrack.ValueTypeName; // Skip this track if it's non-numeric\n\n      if (referenceTrackType === 'bool' || referenceTrackType === 'string') continue; // Find the track in the target clip whose name and type matches the reference track\n\n      const targetTrack = targetClip.tracks.find(function (track) {\n        return track.name === referenceTrack.name && track.ValueTypeName === referenceTrackType;\n      });\n      if (targetTrack === undefined) continue;\n      let referenceOffset = 0;\n      const referenceValueSize = referenceTrack.getValueSize();\n\n      if (referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {\n        referenceOffset = referenceValueSize / 3;\n      }\n\n      let targetOffset = 0;\n      const targetValueSize = targetTrack.getValueSize();\n\n      if (targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {\n        targetOffset = targetValueSize / 3;\n      }\n\n      const lastIndex = referenceTrack.times.length - 1;\n      let referenceValue; // Find the value to subtract out of the track\n\n      if (referenceTime <= referenceTrack.times[0]) {\n        // Reference frame is earlier than the first keyframe, so just use the first keyframe\n        const startIndex = referenceOffset;\n        const endIndex = referenceValueSize - referenceOffset;\n        referenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex, endIndex);\n      } else if (referenceTime >= referenceTrack.times[lastIndex]) {\n        // Reference frame is after the last keyframe, so just use the last keyframe\n        const startIndex = lastIndex * referenceValueSize + referenceOffset;\n        const endIndex = startIndex + referenceValueSize - referenceOffset;\n        referenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex, endIndex);\n      } else {\n        // Interpolate to the reference value\n        const interpolant = referenceTrack.createInterpolant();\n        const startIndex = referenceOffset;\n        const endIndex = referenceValueSize - referenceOffset;\n        interpolant.evaluate(referenceTime);\n        referenceValue = AnimationUtils.arraySlice(interpolant.resultBuffer, startIndex, endIndex);\n      } // Conjugate the quaternion\n\n\n      if (referenceTrackType === 'quaternion') {\n        const referenceQuat = new Quaternion().fromArray(referenceValue).normalize().conjugate();\n        referenceQuat.toArray(referenceValue);\n      } // Subtract the reference value from all of the track values\n\n\n      const numTimes = targetTrack.times.length;\n\n      for (let j = 0; j < numTimes; ++j) {\n        const valueStart = j * targetValueSize + targetOffset;\n\n        if (referenceTrackType === 'quaternion') {\n          // Multiply the conjugate for quaternion track types\n          Quaternion.multiplyQuaternionsFlat(targetTrack.values, valueStart, referenceValue, 0, targetTrack.values, valueStart);\n        } else {\n          const valueEnd = targetValueSize - targetOffset * 2; // Subtract each value for all other numeric track types\n\n          for (let k = 0; k < valueEnd; ++k) {\n            targetTrack.values[valueStart + k] -= referenceValue[k];\n          }\n        }\n      }\n    }\n\n    targetClip.blendMode = AdditiveAnimationBlendMode;\n    return targetClip;\n  }\n};\nexport { AnimationUtils };","map":{"version":3,"sources":["C:/Users/dell/Desktop/projektlogin/vue-3-authentication-jwt/src/games/three/src/animation/AnimationUtils.js"],"names":["Quaternion","AdditiveAnimationBlendMode","AnimationUtils","arraySlice","array","from","to","isTypedArray","constructor","subarray","undefined","length","slice","convertArray","type","forceClone","BYTES_PER_ELEMENT","Array","prototype","call","object","ArrayBuffer","isView","DataView","getKeyframeOrder","times","compareTime","i","j","n","result","sort","sortedArray","values","stride","order","nValues","dstOffset","srcOffset","flattenJSON","jsonKeys","valuePropertyName","key","value","isArray","push","time","apply","toArray","subclip","sourceClip","name","startFrame","endFrame","fps","clip","clone","tracks","track","valueSize","getValueSize","frame","k","minStartTime","Infinity","shift","resetDuration","makeClipAdditive","targetClip","referenceFrame","referenceClip","numTracks","referenceTime","referenceTrack","referenceTrackType","ValueTypeName","targetTrack","find","referenceOffset","referenceValueSize","createInterpolant","isInterpolantFactoryMethodGLTFCubicSpline","targetOffset","targetValueSize","lastIndex","referenceValue","startIndex","endIndex","interpolant","evaluate","resultBuffer","referenceQuat","fromArray","normalize","conjugate","numTimes","valueStart","multiplyQuaternionsFlat","valueEnd","blendMode"],"mappings":"AAAA,SAASA,UAAT,QAA2B,uBAA3B;AACA,SAASC,0BAAT,QAA2C,iBAA3C;AAEA,MAAMC,cAAc,GAAG;AAEtB;AACAC,EAAAA,UAAU,EAAE,UAAWC,KAAX,EAAkBC,IAAlB,EAAwBC,EAAxB,EAA6B;AAExC,QAAKJ,cAAc,CAACK,YAAf,CAA6BH,KAA7B,CAAL,EAA4C;AAE3C;AACA;AACA,aAAO,IAAIA,KAAK,CAACI,WAAV,CAAuBJ,KAAK,CAACK,QAAN,CAAgBJ,IAAhB,EAAsBC,EAAE,KAAKI,SAAP,GAAmBJ,EAAnB,GAAwBF,KAAK,CAACO,MAApD,CAAvB,CAAP;AAEA;;AAED,WAAOP,KAAK,CAACQ,KAAN,CAAaP,IAAb,EAAmBC,EAAnB,CAAP;AAEA,GAfqB;AAiBtB;AACAO,EAAAA,YAAY,EAAE,UAAWT,KAAX,EAAkBU,IAAlB,EAAwBC,UAAxB,EAAqC;AAElD,QAAK,CAAEX,KAAF,IAAW;AACf,KAAEW,UAAF,IAAgBX,KAAK,CAACI,WAAN,KAAsBM,IADvC,EAC8C,OAAOV,KAAP;;AAE9C,QAAK,OAAOU,IAAI,CAACE,iBAAZ,KAAkC,QAAvC,EAAkD;AAEjD,aAAO,IAAIF,IAAJ,CAAUV,KAAV,CAAP,CAFiD,CAEvB;AAE1B;;AAED,WAAOa,KAAK,CAACC,SAAN,CAAgBN,KAAhB,CAAsBO,IAAtB,CAA4Bf,KAA5B,CAAP,CAXkD,CAWN;AAE5C,GA/BqB;AAiCtBG,EAAAA,YAAY,EAAE,UAAWa,MAAX,EAAoB;AAEjC,WAAOC,WAAW,CAACC,MAAZ,CAAoBF,MAApB,KACN,EAAIA,MAAM,YAAYG,QAAtB,CADD;AAGA,GAtCqB;AAwCtB;AACAC,EAAAA,gBAAgB,EAAE,UAAWC,KAAX,EAAmB;AAEpC,aAASC,WAAT,CAAsBC,CAAtB,EAAyBC,CAAzB,EAA6B;AAE5B,aAAOH,KAAK,CAAEE,CAAF,CAAL,GAAaF,KAAK,CAAEG,CAAF,CAAzB;AAEA;;AAED,UAAMC,CAAC,GAAGJ,KAAK,CAACd,MAAhB;AACA,UAAMmB,MAAM,GAAG,IAAIb,KAAJ,CAAWY,CAAX,CAAf;;AACA,SAAM,IAAIF,CAAC,GAAG,CAAd,EAAiBA,CAAC,KAAKE,CAAvB,EAA0B,EAAGF,CAA7B,EAAiCG,MAAM,CAAEH,CAAF,CAAN,GAAcA,CAAd;;AAEjCG,IAAAA,MAAM,CAACC,IAAP,CAAaL,WAAb;AAEA,WAAOI,MAAP;AAEA,GAzDqB;AA2DtB;AACAE,EAAAA,WAAW,EAAE,UAAWC,MAAX,EAAmBC,MAAnB,EAA2BC,KAA3B,EAAmC;AAE/C,UAAMC,OAAO,GAAGH,MAAM,CAACtB,MAAvB;AACA,UAAMmB,MAAM,GAAG,IAAIG,MAAM,CAACzB,WAAX,CAAwB4B,OAAxB,CAAf;;AAEA,SAAM,IAAIT,CAAC,GAAG,CAAR,EAAWU,SAAS,GAAG,CAA7B,EAAgCA,SAAS,KAAKD,OAA9C,EAAuD,EAAGT,CAA1D,EAA8D;AAE7D,YAAMW,SAAS,GAAGH,KAAK,CAAER,CAAF,CAAL,GAAaO,MAA/B;;AAEA,WAAM,IAAIN,CAAC,GAAG,CAAd,EAAiBA,CAAC,KAAKM,MAAvB,EAA+B,EAAGN,CAAlC,EAAsC;AAErCE,QAAAA,MAAM,CAAEO,SAAS,EAAX,CAAN,GAAyBJ,MAAM,CAAEK,SAAS,GAAGV,CAAd,CAA/B;AAEA;AAED;;AAED,WAAOE,MAAP;AAEA,GA/EqB;AAiFtB;AACAS,EAAAA,WAAW,EAAE,UAAWC,QAAX,EAAqBf,KAArB,EAA4BQ,MAA5B,EAAoCQ,iBAApC,EAAwD;AAEpE,QAAId,CAAC,GAAG,CAAR;AAAA,QAAWe,GAAG,GAAGF,QAAQ,CAAE,CAAF,CAAzB;;AAEA,WAAQE,GAAG,KAAKhC,SAAR,IAAqBgC,GAAG,CAAED,iBAAF,CAAH,KAA6B/B,SAA1D,EAAsE;AAErEgC,MAAAA,GAAG,GAAGF,QAAQ,CAAEb,CAAC,EAAH,CAAd;AAEA;;AAED,QAAKe,GAAG,KAAKhC,SAAb,EAAyB,OAV2C,CAUnC;;AAEjC,QAAIiC,KAAK,GAAGD,GAAG,CAAED,iBAAF,CAAf;AACA,QAAKE,KAAK,KAAKjC,SAAf,EAA2B,OAbyC,CAajC;;AAEnC,QAAKO,KAAK,CAAC2B,OAAN,CAAeD,KAAf,CAAL,EAA8B;AAE7B,SAAG;AAEFA,QAAAA,KAAK,GAAGD,GAAG,CAAED,iBAAF,CAAX;;AAEA,YAAKE,KAAK,KAAKjC,SAAf,EAA2B;AAE1Be,UAAAA,KAAK,CAACoB,IAAN,CAAYH,GAAG,CAACI,IAAhB;AACAb,UAAAA,MAAM,CAACY,IAAP,CAAYE,KAAZ,CAAmBd,MAAnB,EAA2BU,KAA3B,EAH0B,CAGU;AAEpC;;AAEDD,QAAAA,GAAG,GAAGF,QAAQ,CAAEb,CAAC,EAAH,CAAd;AAEA,OAbD,QAaUe,GAAG,KAAKhC,SAblB;AAeA,KAjBD,MAiBO,IAAKiC,KAAK,CAACK,OAAN,KAAkBtC,SAAvB,EAAmC;AAEzC;AAEA,SAAG;AAEFiC,QAAAA,KAAK,GAAGD,GAAG,CAAED,iBAAF,CAAX;;AAEA,YAAKE,KAAK,KAAKjC,SAAf,EAA2B;AAE1Be,UAAAA,KAAK,CAACoB,IAAN,CAAYH,GAAG,CAACI,IAAhB;AACAH,UAAAA,KAAK,CAACK,OAAN,CAAef,MAAf,EAAuBA,MAAM,CAACtB,MAA9B;AAEA;;AAED+B,QAAAA,GAAG,GAAGF,QAAQ,CAAEb,CAAC,EAAH,CAAd;AAEA,OAbD,QAaUe,GAAG,KAAKhC,SAblB;AAeA,KAnBM,MAmBA;AAEN;AAEA,SAAG;AAEFiC,QAAAA,KAAK,GAAGD,GAAG,CAAED,iBAAF,CAAX;;AAEA,YAAKE,KAAK,KAAKjC,SAAf,EAA2B;AAE1Be,UAAAA,KAAK,CAACoB,IAAN,CAAYH,GAAG,CAACI,IAAhB;AACAb,UAAAA,MAAM,CAACY,IAAP,CAAaF,KAAb;AAEA;;AAEDD,QAAAA,GAAG,GAAGF,QAAQ,CAAEb,CAAC,EAAH,CAAd;AAEA,OAbD,QAaUe,GAAG,KAAKhC,SAblB;AAeA;AAED,GA1JqB;AA4JtBuC,EAAAA,OAAO,EAAE,UAAWC,UAAX,EAAuBC,IAAvB,EAA6BC,UAA7B,EAAyCC,QAAzC,EAAmDC,GAAG,GAAG,EAAzD,EAA8D;AAEtE,UAAMC,IAAI,GAAGL,UAAU,CAACM,KAAX,EAAb;AAEAD,IAAAA,IAAI,CAACJ,IAAL,GAAYA,IAAZ;AAEA,UAAMM,MAAM,GAAG,EAAf;;AAEA,SAAM,IAAI9B,CAAC,GAAG,CAAd,EAAiBA,CAAC,GAAG4B,IAAI,CAACE,MAAL,CAAY9C,MAAjC,EAAyC,EAAGgB,CAA5C,EAAgD;AAE/C,YAAM+B,KAAK,GAAGH,IAAI,CAACE,MAAL,CAAa9B,CAAb,CAAd;AACA,YAAMgC,SAAS,GAAGD,KAAK,CAACE,YAAN,EAAlB;AAEA,YAAMnC,KAAK,GAAG,EAAd;AACA,YAAMQ,MAAM,GAAG,EAAf;;AAEA,WAAM,IAAIL,CAAC,GAAG,CAAd,EAAiBA,CAAC,GAAG8B,KAAK,CAACjC,KAAN,CAAYd,MAAjC,EAAyC,EAAGiB,CAA5C,EAAgD;AAE/C,cAAMiC,KAAK,GAAGH,KAAK,CAACjC,KAAN,CAAaG,CAAb,IAAmB0B,GAAjC;AAEA,YAAKO,KAAK,GAAGT,UAAR,IAAsBS,KAAK,IAAIR,QAApC,EAA+C;AAE/C5B,QAAAA,KAAK,CAACoB,IAAN,CAAYa,KAAK,CAACjC,KAAN,CAAaG,CAAb,CAAZ;;AAEA,aAAM,IAAIkC,CAAC,GAAG,CAAd,EAAiBA,CAAC,GAAGH,SAArB,EAAgC,EAAGG,CAAnC,EAAuC;AAEtC7B,UAAAA,MAAM,CAACY,IAAP,CAAaa,KAAK,CAACzB,MAAN,CAAcL,CAAC,GAAG+B,SAAJ,GAAgBG,CAA9B,CAAb;AAEA;AAED;;AAED,UAAKrC,KAAK,CAACd,MAAN,KAAiB,CAAtB,EAA0B;AAE1B+C,MAAAA,KAAK,CAACjC,KAAN,GAAcvB,cAAc,CAACW,YAAf,CAA6BY,KAA7B,EAAoCiC,KAAK,CAACjC,KAAN,CAAYjB,WAAhD,CAAd;AACAkD,MAAAA,KAAK,CAACzB,MAAN,GAAe/B,cAAc,CAACW,YAAf,CAA6BoB,MAA7B,EAAqCyB,KAAK,CAACzB,MAAN,CAAazB,WAAlD,CAAf;AAEAiD,MAAAA,MAAM,CAACZ,IAAP,CAAaa,KAAb;AAEA;;AAEDH,IAAAA,IAAI,CAACE,MAAL,GAAcA,MAAd,CAzCsE,CA2CtE;;AAEA,QAAIM,YAAY,GAAGC,QAAnB;;AAEA,SAAM,IAAIrC,CAAC,GAAG,CAAd,EAAiBA,CAAC,GAAG4B,IAAI,CAACE,MAAL,CAAY9C,MAAjC,EAAyC,EAAGgB,CAA5C,EAAgD;AAE/C,UAAKoC,YAAY,GAAGR,IAAI,CAACE,MAAL,CAAa9B,CAAb,EAAiBF,KAAjB,CAAwB,CAAxB,CAApB,EAAkD;AAEjDsC,QAAAA,YAAY,GAAGR,IAAI,CAACE,MAAL,CAAa9B,CAAb,EAAiBF,KAAjB,CAAwB,CAAxB,CAAf;AAEA;AAED,KAvDqE,CAyDtE;;;AAEA,SAAM,IAAIE,CAAC,GAAG,CAAd,EAAiBA,CAAC,GAAG4B,IAAI,CAACE,MAAL,CAAY9C,MAAjC,EAAyC,EAAGgB,CAA5C,EAAgD;AAE/C4B,MAAAA,IAAI,CAACE,MAAL,CAAa9B,CAAb,EAAiBsC,KAAjB,CAAwB,CAAE,CAAF,GAAMF,YAA9B;AAEA;;AAEDR,IAAAA,IAAI,CAACW,aAAL;AAEA,WAAOX,IAAP;AAEA,GAjOqB;AAmOtBY,EAAAA,gBAAgB,EAAE,UAAWC,UAAX,EAAuBC,cAAc,GAAG,CAAxC,EAA2CC,aAAa,GAAGF,UAA3D,EAAuEd,GAAG,GAAG,EAA7E,EAAkF;AAEnG,QAAKA,GAAG,IAAI,CAAZ,EAAgBA,GAAG,GAAG,EAAN;AAEhB,UAAMiB,SAAS,GAAGD,aAAa,CAACb,MAAd,CAAqB9C,MAAvC;AACA,UAAM6D,aAAa,GAAGH,cAAc,GAAGf,GAAvC,CALmG,CAOnG;;AACA,SAAM,IAAI3B,CAAC,GAAG,CAAd,EAAiBA,CAAC,GAAG4C,SAArB,EAAgC,EAAG5C,CAAnC,EAAuC;AAEtC,YAAM8C,cAAc,GAAGH,aAAa,CAACb,MAAd,CAAsB9B,CAAtB,CAAvB;AACA,YAAM+C,kBAAkB,GAAGD,cAAc,CAACE,aAA1C,CAHsC,CAKtC;;AACA,UAAKD,kBAAkB,KAAK,MAAvB,IAAiCA,kBAAkB,KAAK,QAA7D,EAAwE,SANlC,CAQtC;;AACA,YAAME,WAAW,GAAGR,UAAU,CAACX,MAAX,CAAkBoB,IAAlB,CAAwB,UAAWnB,KAAX,EAAmB;AAE9D,eAAOA,KAAK,CAACP,IAAN,KAAesB,cAAc,CAACtB,IAA9B,IACHO,KAAK,CAACiB,aAAN,KAAwBD,kBAD5B;AAGA,OALmB,CAApB;AAOA,UAAKE,WAAW,KAAKlE,SAArB,EAAiC;AAEjC,UAAIoE,eAAe,GAAG,CAAtB;AACA,YAAMC,kBAAkB,GAAGN,cAAc,CAACb,YAAf,EAA3B;;AAEA,UAAKa,cAAc,CAACO,iBAAf,CAAiCC,yCAAtC,EAAkF;AAEjFH,QAAAA,eAAe,GAAGC,kBAAkB,GAAG,CAAvC;AAEA;;AAED,UAAIG,YAAY,GAAG,CAAnB;AACA,YAAMC,eAAe,GAAGP,WAAW,CAAChB,YAAZ,EAAxB;;AAEA,UAAKgB,WAAW,CAACI,iBAAZ,CAA8BC,yCAAnC,EAA+E;AAE9EC,QAAAA,YAAY,GAAGC,eAAe,GAAG,CAAjC;AAEA;;AAED,YAAMC,SAAS,GAAGX,cAAc,CAAChD,KAAf,CAAqBd,MAArB,GAA8B,CAAhD;AACA,UAAI0E,cAAJ,CArCsC,CAuCtC;;AACA,UAAKb,aAAa,IAAIC,cAAc,CAAChD,KAAf,CAAsB,CAAtB,CAAtB,EAAkD;AAEjD;AACA,cAAM6D,UAAU,GAAGR,eAAnB;AACA,cAAMS,QAAQ,GAAGR,kBAAkB,GAAGD,eAAtC;AACAO,QAAAA,cAAc,GAAGnF,cAAc,CAACC,UAAf,CAA2BsE,cAAc,CAACxC,MAA1C,EAAkDqD,UAAlD,EAA8DC,QAA9D,CAAjB;AAEA,OAPD,MAOO,IAAKf,aAAa,IAAIC,cAAc,CAAChD,KAAf,CAAsB2D,SAAtB,CAAtB,EAA0D;AAEhE;AACA,cAAME,UAAU,GAAGF,SAAS,GAAGL,kBAAZ,GAAiCD,eAApD;AACA,cAAMS,QAAQ,GAAGD,UAAU,GAAGP,kBAAb,GAAkCD,eAAnD;AACAO,QAAAA,cAAc,GAAGnF,cAAc,CAACC,UAAf,CAA2BsE,cAAc,CAACxC,MAA1C,EAAkDqD,UAAlD,EAA8DC,QAA9D,CAAjB;AAEA,OAPM,MAOA;AAEN;AACA,cAAMC,WAAW,GAAGf,cAAc,CAACO,iBAAf,EAApB;AACA,cAAMM,UAAU,GAAGR,eAAnB;AACA,cAAMS,QAAQ,GAAGR,kBAAkB,GAAGD,eAAtC;AACAU,QAAAA,WAAW,CAACC,QAAZ,CAAsBjB,aAAtB;AACAa,QAAAA,cAAc,GAAGnF,cAAc,CAACC,UAAf,CAA2BqF,WAAW,CAACE,YAAvC,EAAqDJ,UAArD,EAAiEC,QAAjE,CAAjB;AAEA,OA/DqC,CAiEtC;;;AACA,UAAKb,kBAAkB,KAAK,YAA5B,EAA2C;AAE1C,cAAMiB,aAAa,GAAG,IAAI3F,UAAJ,GAAiB4F,SAAjB,CAA4BP,cAA5B,EAA6CQ,SAA7C,GAAyDC,SAAzD,EAAtB;AACAH,QAAAA,aAAa,CAAC3C,OAAd,CAAuBqC,cAAvB;AAEA,OAvEqC,CAyEtC;;;AAEA,YAAMU,QAAQ,GAAGnB,WAAW,CAACnD,KAAZ,CAAkBd,MAAnC;;AACA,WAAM,IAAIiB,CAAC,GAAG,CAAd,EAAiBA,CAAC,GAAGmE,QAArB,EAA+B,EAAGnE,CAAlC,EAAsC;AAErC,cAAMoE,UAAU,GAAGpE,CAAC,GAAGuD,eAAJ,GAAsBD,YAAzC;;AAEA,YAAKR,kBAAkB,KAAK,YAA5B,EAA2C;AAE1C;AACA1E,UAAAA,UAAU,CAACiG,uBAAX,CACCrB,WAAW,CAAC3C,MADb,EAEC+D,UAFD,EAGCX,cAHD,EAIC,CAJD,EAKCT,WAAW,CAAC3C,MALb,EAMC+D,UAND;AASA,SAZD,MAYO;AAEN,gBAAME,QAAQ,GAAGf,eAAe,GAAGD,YAAY,GAAG,CAAlD,CAFM,CAIN;;AACA,eAAM,IAAIpB,CAAC,GAAG,CAAd,EAAiBA,CAAC,GAAGoC,QAArB,EAA+B,EAAGpC,CAAlC,EAAsC;AAErCc,YAAAA,WAAW,CAAC3C,MAAZ,CAAoB+D,UAAU,GAAGlC,CAAjC,KAAwCuB,cAAc,CAAEvB,CAAF,CAAtD;AAEA;AAED;AAED;AAED;;AAEDM,IAAAA,UAAU,CAAC+B,SAAX,GAAuBlG,0BAAvB;AAEA,WAAOmE,UAAP;AAEA;AA5VqB,CAAvB;AAgWA,SAASlE,cAAT","sourcesContent":["import { Quaternion } from '../math/Quaternion.js';\r\nimport { AdditiveAnimationBlendMode } from '../constants.js';\r\n\r\nconst AnimationUtils = {\r\n\r\n\t// same as Array.prototype.slice, but also works on typed arrays\r\n\tarraySlice: function ( array, from, to ) {\r\n\r\n\t\tif ( AnimationUtils.isTypedArray( array ) ) {\r\n\r\n\t\t\t// in ios9 array.subarray(from, undefined) will return empty array\r\n\t\t\t// but array.subarray(from) or array.subarray(from, len) is correct\r\n\t\t\treturn new array.constructor( array.subarray( from, to !== undefined ? to : array.length ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn array.slice( from, to );\r\n\r\n\t},\r\n\r\n\t// converts an array to a specific type\r\n\tconvertArray: function ( array, type, forceClone ) {\r\n\r\n\t\tif ( ! array || // let 'undefined' and 'null' pass\r\n\t\t\t! forceClone && array.constructor === type ) return array;\r\n\r\n\t\tif ( typeof type.BYTES_PER_ELEMENT === 'number' ) {\r\n\r\n\t\t\treturn new type( array ); // create typed array\r\n\r\n\t\t}\r\n\r\n\t\treturn Array.prototype.slice.call( array ); // create Array\r\n\r\n\t},\r\n\r\n\tisTypedArray: function ( object ) {\r\n\r\n\t\treturn ArrayBuffer.isView( object ) &&\r\n\t\t\t! ( object instanceof DataView );\r\n\r\n\t},\r\n\r\n\t// returns an array by which times and values can be sorted\r\n\tgetKeyframeOrder: function ( times ) {\r\n\r\n\t\tfunction compareTime( i, j ) {\r\n\r\n\t\t\treturn times[ i ] - times[ j ];\r\n\r\n\t\t}\r\n\r\n\t\tconst n = times.length;\r\n\t\tconst result = new Array( n );\r\n\t\tfor ( let i = 0; i !== n; ++ i ) result[ i ] = i;\r\n\r\n\t\tresult.sort( compareTime );\r\n\r\n\t\treturn result;\r\n\r\n\t},\r\n\r\n\t// uses the array previously returned by 'getKeyframeOrder' to sort data\r\n\tsortedArray: function ( values, stride, order ) {\r\n\r\n\t\tconst nValues = values.length;\r\n\t\tconst result = new values.constructor( nValues );\r\n\r\n\t\tfor ( let i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {\r\n\r\n\t\t\tconst srcOffset = order[ i ] * stride;\r\n\r\n\t\t\tfor ( let j = 0; j !== stride; ++ j ) {\r\n\r\n\t\t\t\tresult[ dstOffset ++ ] = values[ srcOffset + j ];\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t},\r\n\r\n\t// function for parsing AOS keyframe formats\r\n\tflattenJSON: function ( jsonKeys, times, values, valuePropertyName ) {\r\n\r\n\t\tlet i = 1, key = jsonKeys[ 0 ];\r\n\r\n\t\twhile ( key !== undefined && key[ valuePropertyName ] === undefined ) {\r\n\r\n\t\t\tkey = jsonKeys[ i ++ ];\r\n\r\n\t\t}\r\n\r\n\t\tif ( key === undefined ) return; // no data\r\n\r\n\t\tlet value = key[ valuePropertyName ];\r\n\t\tif ( value === undefined ) return; // no data\r\n\r\n\t\tif ( Array.isArray( value ) ) {\r\n\r\n\t\t\tdo {\r\n\r\n\t\t\t\tvalue = key[ valuePropertyName ];\r\n\r\n\t\t\t\tif ( value !== undefined ) {\r\n\r\n\t\t\t\t\ttimes.push( key.time );\r\n\t\t\t\t\tvalues.push.apply( values, value ); // push all elements\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tkey = jsonKeys[ i ++ ];\r\n\r\n\t\t\t} while ( key !== undefined );\r\n\r\n\t\t} else if ( value.toArray !== undefined ) {\r\n\r\n\t\t\t// ...assume THREE.Math-ish\r\n\r\n\t\t\tdo {\r\n\r\n\t\t\t\tvalue = key[ valuePropertyName ];\r\n\r\n\t\t\t\tif ( value !== undefined ) {\r\n\r\n\t\t\t\t\ttimes.push( key.time );\r\n\t\t\t\t\tvalue.toArray( values, values.length );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tkey = jsonKeys[ i ++ ];\r\n\r\n\t\t\t} while ( key !== undefined );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// otherwise push as-is\r\n\r\n\t\t\tdo {\r\n\r\n\t\t\t\tvalue = key[ valuePropertyName ];\r\n\r\n\t\t\t\tif ( value !== undefined ) {\r\n\r\n\t\t\t\t\ttimes.push( key.time );\r\n\t\t\t\t\tvalues.push( value );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tkey = jsonKeys[ i ++ ];\r\n\r\n\t\t\t} while ( key !== undefined );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tsubclip: function ( sourceClip, name, startFrame, endFrame, fps = 30 ) {\r\n\r\n\t\tconst clip = sourceClip.clone();\r\n\r\n\t\tclip.name = name;\r\n\r\n\t\tconst tracks = [];\r\n\r\n\t\tfor ( let i = 0; i < clip.tracks.length; ++ i ) {\r\n\r\n\t\t\tconst track = clip.tracks[ i ];\r\n\t\t\tconst valueSize = track.getValueSize();\r\n\r\n\t\t\tconst times = [];\r\n\t\t\tconst values = [];\r\n\r\n\t\t\tfor ( let j = 0; j < track.times.length; ++ j ) {\r\n\r\n\t\t\t\tconst frame = track.times[ j ] * fps;\r\n\r\n\t\t\t\tif ( frame < startFrame || frame >= endFrame ) continue;\r\n\r\n\t\t\t\ttimes.push( track.times[ j ] );\r\n\r\n\t\t\t\tfor ( let k = 0; k < valueSize; ++ k ) {\r\n\r\n\t\t\t\t\tvalues.push( track.values[ j * valueSize + k ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( times.length === 0 ) continue;\r\n\r\n\t\t\ttrack.times = AnimationUtils.convertArray( times, track.times.constructor );\r\n\t\t\ttrack.values = AnimationUtils.convertArray( values, track.values.constructor );\r\n\r\n\t\t\ttracks.push( track );\r\n\r\n\t\t}\r\n\r\n\t\tclip.tracks = tracks;\r\n\r\n\t\t// find minimum .times value across all tracks in the trimmed clip\r\n\r\n\t\tlet minStartTime = Infinity;\r\n\r\n\t\tfor ( let i = 0; i < clip.tracks.length; ++ i ) {\r\n\r\n\t\t\tif ( minStartTime > clip.tracks[ i ].times[ 0 ] ) {\r\n\r\n\t\t\t\tminStartTime = clip.tracks[ i ].times[ 0 ];\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// shift all tracks such that clip begins at t=0\r\n\r\n\t\tfor ( let i = 0; i < clip.tracks.length; ++ i ) {\r\n\r\n\t\t\tclip.tracks[ i ].shift( - 1 * minStartTime );\r\n\r\n\t\t}\r\n\r\n\t\tclip.resetDuration();\r\n\r\n\t\treturn clip;\r\n\r\n\t},\r\n\r\n\tmakeClipAdditive: function ( targetClip, referenceFrame = 0, referenceClip = targetClip, fps = 30 ) {\r\n\r\n\t\tif ( fps <= 0 ) fps = 30;\r\n\r\n\t\tconst numTracks = referenceClip.tracks.length;\r\n\t\tconst referenceTime = referenceFrame / fps;\r\n\r\n\t\t// Make each track's values relative to the values at the reference frame\r\n\t\tfor ( let i = 0; i < numTracks; ++ i ) {\r\n\r\n\t\t\tconst referenceTrack = referenceClip.tracks[ i ];\r\n\t\t\tconst referenceTrackType = referenceTrack.ValueTypeName;\r\n\r\n\t\t\t// Skip this track if it's non-numeric\r\n\t\t\tif ( referenceTrackType === 'bool' || referenceTrackType === 'string' ) continue;\r\n\r\n\t\t\t// Find the track in the target clip whose name and type matches the reference track\r\n\t\t\tconst targetTrack = targetClip.tracks.find( function ( track ) {\r\n\r\n\t\t\t\treturn track.name === referenceTrack.name\r\n\t\t\t\t\t&& track.ValueTypeName === referenceTrackType;\r\n\r\n\t\t\t} );\r\n\r\n\t\t\tif ( targetTrack === undefined ) continue;\r\n\r\n\t\t\tlet referenceOffset = 0;\r\n\t\t\tconst referenceValueSize = referenceTrack.getValueSize();\r\n\r\n\t\t\tif ( referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ) {\r\n\r\n\t\t\t\treferenceOffset = referenceValueSize / 3;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tlet targetOffset = 0;\r\n\t\t\tconst targetValueSize = targetTrack.getValueSize();\r\n\r\n\t\t\tif ( targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ) {\r\n\r\n\t\t\t\ttargetOffset = targetValueSize / 3;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst lastIndex = referenceTrack.times.length - 1;\r\n\t\t\tlet referenceValue;\r\n\r\n\t\t\t// Find the value to subtract out of the track\r\n\t\t\tif ( referenceTime <= referenceTrack.times[ 0 ] ) {\r\n\r\n\t\t\t\t// Reference frame is earlier than the first keyframe, so just use the first keyframe\r\n\t\t\t\tconst startIndex = referenceOffset;\r\n\t\t\t\tconst endIndex = referenceValueSize - referenceOffset;\r\n\t\t\t\treferenceValue = AnimationUtils.arraySlice( referenceTrack.values, startIndex, endIndex );\r\n\r\n\t\t\t} else if ( referenceTime >= referenceTrack.times[ lastIndex ] ) {\r\n\r\n\t\t\t\t// Reference frame is after the last keyframe, so just use the last keyframe\r\n\t\t\t\tconst startIndex = lastIndex * referenceValueSize + referenceOffset;\r\n\t\t\t\tconst endIndex = startIndex + referenceValueSize - referenceOffset;\r\n\t\t\t\treferenceValue = AnimationUtils.arraySlice( referenceTrack.values, startIndex, endIndex );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// Interpolate to the reference value\r\n\t\t\t\tconst interpolant = referenceTrack.createInterpolant();\r\n\t\t\t\tconst startIndex = referenceOffset;\r\n\t\t\t\tconst endIndex = referenceValueSize - referenceOffset;\r\n\t\t\t\tinterpolant.evaluate( referenceTime );\r\n\t\t\t\treferenceValue = AnimationUtils.arraySlice( interpolant.resultBuffer, startIndex, endIndex );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Conjugate the quaternion\r\n\t\t\tif ( referenceTrackType === 'quaternion' ) {\r\n\r\n\t\t\t\tconst referenceQuat = new Quaternion().fromArray( referenceValue ).normalize().conjugate();\r\n\t\t\t\treferenceQuat.toArray( referenceValue );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Subtract the reference value from all of the track values\r\n\r\n\t\t\tconst numTimes = targetTrack.times.length;\r\n\t\t\tfor ( let j = 0; j < numTimes; ++ j ) {\r\n\r\n\t\t\t\tconst valueStart = j * targetValueSize + targetOffset;\r\n\r\n\t\t\t\tif ( referenceTrackType === 'quaternion' ) {\r\n\r\n\t\t\t\t\t// Multiply the conjugate for quaternion track types\r\n\t\t\t\t\tQuaternion.multiplyQuaternionsFlat(\r\n\t\t\t\t\t\ttargetTrack.values,\r\n\t\t\t\t\t\tvalueStart,\r\n\t\t\t\t\t\treferenceValue,\r\n\t\t\t\t\t\t0,\r\n\t\t\t\t\t\ttargetTrack.values,\r\n\t\t\t\t\t\tvalueStart\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tconst valueEnd = targetValueSize - targetOffset * 2;\r\n\r\n\t\t\t\t\t// Subtract each value for all other numeric track types\r\n\t\t\t\t\tfor ( let k = 0; k < valueEnd; ++ k ) {\r\n\r\n\t\t\t\t\t\ttargetTrack.values[ valueStart + k ] -= referenceValue[ k ];\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\ttargetClip.blendMode = AdditiveAnimationBlendMode;\r\n\r\n\t\treturn targetClip;\r\n\r\n\t}\r\n\r\n};\r\n\r\nexport { AnimationUtils };\r\n"]},"metadata":{},"sourceType":"module"}