{"ast":null,"code":"import \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport { FloatType, RGBAFormat } from '../../constants.js';\nimport { DataArrayTexture } from '../../textures/DataArrayTexture.js';\nimport { Vector4 } from '../../math/Vector4.js';\nimport { Vector2 } from '../../math/Vector2.js';\n\nfunction numericalSort(a, b) {\n  return a[0] - b[0];\n}\n\nfunction absNumericalSort(a, b) {\n  return Math.abs(b[1]) - Math.abs(a[1]);\n}\n\nfunction denormalize(morph, attribute) {\n  let denominator = 1;\n  const array = attribute.isInterleavedBufferAttribute ? attribute.data.array : attribute.array;\n  if (array instanceof Int8Array) denominator = 127;else if (array instanceof Int16Array) denominator = 32767;else if (array instanceof Int32Array) denominator = 2147483647;else console.error('THREE.WebGLMorphtargets: Unsupported morph attribute data type: ', array);\n  morph.divideScalar(denominator);\n}\n\nfunction WebGLMorphtargets(gl, capabilities, textures) {\n  const influencesList = {};\n  const morphInfluences = new Float32Array(8);\n  const morphTextures = new WeakMap();\n  const morph = new Vector4();\n  const workInfluences = [];\n\n  for (let i = 0; i < 8; i++) {\n    workInfluences[i] = [i, 0];\n  }\n\n  function update(object, geometry, material, program) {\n    const objectInfluences = object.morphTargetInfluences;\n\n    if (capabilities.isWebGL2 === true) {\n      // instead of using attributes, the WebGL 2 code path encodes morph targets\n      // into an array of data textures. Each layer represents a single morph target.\n      const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;\n      const morphTargetsCount = morphAttribute !== undefined ? morphAttribute.length : 0;\n      let entry = morphTextures.get(geometry);\n\n      if (entry === undefined || entry.count !== morphTargetsCount) {\n        if (entry !== undefined) entry.texture.dispose();\n        const hasMorphPosition = geometry.morphAttributes.position !== undefined;\n        const hasMorphNormals = geometry.morphAttributes.normal !== undefined;\n        const hasMorphColors = geometry.morphAttributes.color !== undefined;\n        const morphTargets = geometry.morphAttributes.position || [];\n        const morphNormals = geometry.morphAttributes.normal || [];\n        const morphColors = geometry.morphAttributes.color || [];\n        let vertexDataCount = 0;\n        if (hasMorphPosition === true) vertexDataCount = 1;\n        if (hasMorphNormals === true) vertexDataCount = 2;\n        if (hasMorphColors === true) vertexDataCount = 3;\n        let width = geometry.attributes.position.count * vertexDataCount;\n        let height = 1;\n\n        if (width > capabilities.maxTextureSize) {\n          height = Math.ceil(width / capabilities.maxTextureSize);\n          width = capabilities.maxTextureSize;\n        }\n\n        const buffer = new Float32Array(width * height * 4 * morphTargetsCount);\n        const texture = new DataArrayTexture(buffer, width, height, morphTargetsCount);\n        texture.format = RGBAFormat; // using RGBA since RGB might be emulated (and is thus slower)\n\n        texture.type = FloatType;\n        texture.needsUpdate = true; // fill buffer\n\n        const vertexDataStride = vertexDataCount * 4;\n\n        for (let i = 0; i < morphTargetsCount; i++) {\n          const morphTarget = morphTargets[i];\n          const morphNormal = morphNormals[i];\n          const morphColor = morphColors[i];\n          const offset = width * height * 4 * i;\n\n          for (let j = 0; j < morphTarget.count; j++) {\n            const stride = j * vertexDataStride;\n\n            if (hasMorphPosition === true) {\n              morph.fromBufferAttribute(morphTarget, j);\n              if (morphTarget.normalized === true) denormalize(morph, morphTarget);\n              buffer[offset + stride + 0] = morph.x;\n              buffer[offset + stride + 1] = morph.y;\n              buffer[offset + stride + 2] = morph.z;\n              buffer[offset + stride + 3] = 0;\n            }\n\n            if (hasMorphNormals === true) {\n              morph.fromBufferAttribute(morphNormal, j);\n              if (morphNormal.normalized === true) denormalize(morph, morphNormal);\n              buffer[offset + stride + 4] = morph.x;\n              buffer[offset + stride + 5] = morph.y;\n              buffer[offset + stride + 6] = morph.z;\n              buffer[offset + stride + 7] = 0;\n            }\n\n            if (hasMorphColors === true) {\n              morph.fromBufferAttribute(morphColor, j);\n              if (morphColor.normalized === true) denormalize(morph, morphNormal);\n              buffer[offset + stride + 8] = morph.x;\n              buffer[offset + stride + 9] = morph.y;\n              buffer[offset + stride + 10] = morph.z;\n              buffer[offset + stride + 11] = morphColor.itemSize === 4 ? morph.w : 1;\n            }\n          }\n        }\n\n        entry = {\n          count: morphTargetsCount,\n          texture: texture,\n          size: new Vector2(width, height)\n        };\n        morphTextures.set(geometry, entry);\n\n        function disposeTexture() {\n          texture.dispose();\n          morphTextures.delete(geometry);\n          geometry.removeEventListener('dispose', disposeTexture);\n        }\n\n        geometry.addEventListener('dispose', disposeTexture);\n      } //\n\n\n      let morphInfluencesSum = 0;\n\n      for (let i = 0; i < objectInfluences.length; i++) {\n        morphInfluencesSum += objectInfluences[i];\n      }\n\n      const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;\n      program.getUniforms().setValue(gl, 'morphTargetBaseInfluence', morphBaseInfluence);\n      program.getUniforms().setValue(gl, 'morphTargetInfluences', objectInfluences);\n      program.getUniforms().setValue(gl, 'morphTargetsTexture', entry.texture, textures);\n      program.getUniforms().setValue(gl, 'morphTargetsTextureSize', entry.size);\n    } else {\n      // When object doesn't have morph target influences defined, we treat it as a 0-length array\n      // This is important to make sure we set up morphTargetBaseInfluence / morphTargetInfluences\n      const length = objectInfluences === undefined ? 0 : objectInfluences.length;\n      let influences = influencesList[geometry.id];\n\n      if (influences === undefined || influences.length !== length) {\n        // initialise list\n        influences = [];\n\n        for (let i = 0; i < length; i++) {\n          influences[i] = [i, 0];\n        }\n\n        influencesList[geometry.id] = influences;\n      } // Collect influences\n\n\n      for (let i = 0; i < length; i++) {\n        const influence = influences[i];\n        influence[0] = i;\n        influence[1] = objectInfluences[i];\n      }\n\n      influences.sort(absNumericalSort);\n\n      for (let i = 0; i < 8; i++) {\n        if (i < length && influences[i][1]) {\n          workInfluences[i][0] = influences[i][0];\n          workInfluences[i][1] = influences[i][1];\n        } else {\n          workInfluences[i][0] = Number.MAX_SAFE_INTEGER;\n          workInfluences[i][1] = 0;\n        }\n      }\n\n      workInfluences.sort(numericalSort);\n      const morphTargets = geometry.morphAttributes.position;\n      const morphNormals = geometry.morphAttributes.normal;\n      let morphInfluencesSum = 0;\n\n      for (let i = 0; i < 8; i++) {\n        const influence = workInfluences[i];\n        const index = influence[0];\n        const value = influence[1];\n\n        if (index !== Number.MAX_SAFE_INTEGER && value) {\n          if (morphTargets && geometry.getAttribute('morphTarget' + i) !== morphTargets[index]) {\n            geometry.setAttribute('morphTarget' + i, morphTargets[index]);\n          }\n\n          if (morphNormals && geometry.getAttribute('morphNormal' + i) !== morphNormals[index]) {\n            geometry.setAttribute('morphNormal' + i, morphNormals[index]);\n          }\n\n          morphInfluences[i] = value;\n          morphInfluencesSum += value;\n        } else {\n          if (morphTargets && geometry.hasAttribute('morphTarget' + i) === true) {\n            geometry.deleteAttribute('morphTarget' + i);\n          }\n\n          if (morphNormals && geometry.hasAttribute('morphNormal' + i) === true) {\n            geometry.deleteAttribute('morphNormal' + i);\n          }\n\n          morphInfluences[i] = 0;\n        }\n      } // GLSL shader uses formula baseinfluence * base + sum(target * influence)\n      // This allows us to switch between absolute morphs and relative morphs without changing shader code\n      // When baseinfluence = 1 - sum(influence), the above is equivalent to sum((target - base) * influence)\n\n\n      const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;\n      program.getUniforms().setValue(gl, 'morphTargetBaseInfluence', morphBaseInfluence);\n      program.getUniforms().setValue(gl, 'morphTargetInfluences', morphInfluences);\n    }\n  }\n\n  return {\n    update: update\n  };\n}\n\nexport { WebGLMorphtargets };","map":{"version":3,"sources":["C:/Users/dell/Desktop/projektlogin/vue-3-authentication-jwt/src/games/three/src/renderers/webgl/WebGLMorphtargets.js"],"names":["FloatType","RGBAFormat","DataArrayTexture","Vector4","Vector2","numericalSort","a","b","absNumericalSort","Math","abs","denormalize","morph","attribute","denominator","array","isInterleavedBufferAttribute","data","Int8Array","Int16Array","Int32Array","console","error","divideScalar","WebGLMorphtargets","gl","capabilities","textures","influencesList","morphInfluences","Float32Array","morphTextures","WeakMap","workInfluences","i","update","object","geometry","material","program","objectInfluences","morphTargetInfluences","isWebGL2","morphAttribute","morphAttributes","position","normal","color","morphTargetsCount","undefined","length","entry","get","count","texture","dispose","hasMorphPosition","hasMorphNormals","hasMorphColors","morphTargets","morphNormals","morphColors","vertexDataCount","width","attributes","height","maxTextureSize","ceil","buffer","format","type","needsUpdate","vertexDataStride","morphTarget","morphNormal","morphColor","offset","j","stride","fromBufferAttribute","normalized","x","y","z","itemSize","w","size","set","disposeTexture","delete","removeEventListener","addEventListener","morphInfluencesSum","morphBaseInfluence","morphTargetsRelative","getUniforms","setValue","influences","id","influence","sort","Number","MAX_SAFE_INTEGER","index","value","getAttribute","setAttribute","hasAttribute","deleteAttribute"],"mappings":"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","sourcesContent":["import { FloatType, RGBAFormat } from '../../constants.js';\r\nimport { DataArrayTexture } from '../../textures/DataArrayTexture.js';\r\nimport { Vector4 } from '../../math/Vector4.js';\r\nimport { Vector2 } from '../../math/Vector2.js';\r\n\r\nfunction numericalSort( a, b ) {\r\n\r\n\treturn a[ 0 ] - b[ 0 ];\r\n\r\n}\r\n\r\nfunction absNumericalSort( a, b ) {\r\n\r\n\treturn Math.abs( b[ 1 ] ) - Math.abs( a[ 1 ] );\r\n\r\n}\r\n\r\nfunction denormalize( morph, attribute ) {\r\n\r\n\tlet denominator = 1;\r\n\tconst array = attribute.isInterleavedBufferAttribute ? attribute.data.array : attribute.array;\r\n\r\n\tif ( array instanceof Int8Array ) denominator = 127;\r\n\telse if ( array instanceof Int16Array ) denominator = 32767;\r\n\telse if ( array instanceof Int32Array ) denominator = 2147483647;\r\n\telse console.error( 'THREE.WebGLMorphtargets: Unsupported morph attribute data type: ', array );\r\n\r\n\tmorph.divideScalar( denominator );\r\n\r\n}\r\n\r\nfunction WebGLMorphtargets( gl, capabilities, textures ) {\r\n\r\n\tconst influencesList = {};\r\n\tconst morphInfluences = new Float32Array( 8 );\r\n\tconst morphTextures = new WeakMap();\r\n\tconst morph = new Vector4();\r\n\r\n\tconst workInfluences = [];\r\n\r\n\tfor ( let i = 0; i < 8; i ++ ) {\r\n\r\n\t\tworkInfluences[ i ] = [ i, 0 ];\r\n\r\n\t}\r\n\r\n\tfunction update( object, geometry, material, program ) {\r\n\r\n\t\tconst objectInfluences = object.morphTargetInfluences;\r\n\r\n\t\tif ( capabilities.isWebGL2 === true ) {\r\n\r\n\t\t\t// instead of using attributes, the WebGL 2 code path encodes morph targets\r\n\t\t\t// into an array of data textures. Each layer represents a single morph target.\r\n\r\n\t\t\tconst morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;\r\n\t\t\tconst morphTargetsCount = ( morphAttribute !== undefined ) ? morphAttribute.length : 0;\r\n\r\n\t\t\tlet entry = morphTextures.get( geometry );\r\n\r\n\t\t\tif ( entry === undefined || entry.count !== morphTargetsCount ) {\r\n\r\n\t\t\t\tif ( entry !== undefined ) entry.texture.dispose();\r\n\r\n\t\t\t\tconst hasMorphPosition = geometry.morphAttributes.position !== undefined;\r\n\t\t\t\tconst hasMorphNormals = geometry.morphAttributes.normal !== undefined;\r\n\t\t\t\tconst hasMorphColors = geometry.morphAttributes.color !== undefined;\r\n\r\n\t\t\t\tconst morphTargets = geometry.morphAttributes.position || [];\r\n\t\t\t\tconst morphNormals = geometry.morphAttributes.normal || [];\r\n\t\t\t\tconst morphColors = geometry.morphAttributes.color || [];\r\n\r\n\t\t\t\tlet vertexDataCount = 0;\r\n\r\n\t\t\t\tif ( hasMorphPosition === true ) vertexDataCount = 1;\r\n\t\t\t\tif ( hasMorphNormals === true ) vertexDataCount = 2;\r\n\t\t\t\tif ( hasMorphColors === true ) vertexDataCount = 3;\r\n\r\n\t\t\t\tlet width = geometry.attributes.position.count * vertexDataCount;\r\n\t\t\t\tlet height = 1;\r\n\r\n\t\t\t\tif ( width > capabilities.maxTextureSize ) {\r\n\r\n\t\t\t\t\theight = Math.ceil( width / capabilities.maxTextureSize );\r\n\t\t\t\t\twidth = capabilities.maxTextureSize;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconst buffer = new Float32Array( width * height * 4 * morphTargetsCount );\r\n\r\n\t\t\t\tconst texture = new DataArrayTexture( buffer, width, height, morphTargetsCount );\r\n\t\t\t\ttexture.format = RGBAFormat; // using RGBA since RGB might be emulated (and is thus slower)\r\n\t\t\t\ttexture.type = FloatType;\r\n\t\t\t\ttexture.needsUpdate = true;\r\n\r\n\t\t\t\t// fill buffer\r\n\r\n\t\t\t\tconst vertexDataStride = vertexDataCount * 4;\r\n\r\n\t\t\t\tfor ( let i = 0; i < morphTargetsCount; i ++ ) {\r\n\r\n\t\t\t\t\tconst morphTarget = morphTargets[ i ];\r\n\t\t\t\t\tconst morphNormal = morphNormals[ i ];\r\n\t\t\t\t\tconst morphColor = morphColors[ i ];\r\n\r\n\t\t\t\t\tconst offset = width * height * 4 * i;\r\n\r\n\t\t\t\t\tfor ( let j = 0; j < morphTarget.count; j ++ ) {\r\n\r\n\t\t\t\t\t\tconst stride = j * vertexDataStride;\r\n\r\n\t\t\t\t\t\tif ( hasMorphPosition === true ) {\r\n\r\n\t\t\t\t\t\t\tmorph.fromBufferAttribute( morphTarget, j );\r\n\r\n\t\t\t\t\t\t\tif ( morphTarget.normalized === true ) denormalize( morph, morphTarget );\r\n\r\n\t\t\t\t\t\t\tbuffer[ offset + stride + 0 ] = morph.x;\r\n\t\t\t\t\t\t\tbuffer[ offset + stride + 1 ] = morph.y;\r\n\t\t\t\t\t\t\tbuffer[ offset + stride + 2 ] = morph.z;\r\n\t\t\t\t\t\t\tbuffer[ offset + stride + 3 ] = 0;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif ( hasMorphNormals === true ) {\r\n\r\n\t\t\t\t\t\t\tmorph.fromBufferAttribute( morphNormal, j );\r\n\r\n\t\t\t\t\t\t\tif ( morphNormal.normalized === true ) denormalize( morph, morphNormal );\r\n\r\n\t\t\t\t\t\t\tbuffer[ offset + stride + 4 ] = morph.x;\r\n\t\t\t\t\t\t\tbuffer[ offset + stride + 5 ] = morph.y;\r\n\t\t\t\t\t\t\tbuffer[ offset + stride + 6 ] = morph.z;\r\n\t\t\t\t\t\t\tbuffer[ offset + stride + 7 ] = 0;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif ( hasMorphColors === true ) {\r\n\r\n\t\t\t\t\t\t\tmorph.fromBufferAttribute( morphColor, j );\r\n\r\n\t\t\t\t\t\t\tif ( morphColor.normalized === true ) denormalize( morph, morphNormal );\r\n\r\n\t\t\t\t\t\t\tbuffer[ offset + stride + 8 ] = morph.x;\r\n\t\t\t\t\t\t\tbuffer[ offset + stride + 9 ] = morph.y;\r\n\t\t\t\t\t\t\tbuffer[ offset + stride + 10 ] = morph.z;\r\n\t\t\t\t\t\t\tbuffer[ offset + stride + 11 ] = ( morphColor.itemSize === 4 ) ? morph.w : 1;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tentry = {\r\n\t\t\t\t\tcount: morphTargetsCount,\r\n\t\t\t\t\ttexture: texture,\r\n\t\t\t\t\tsize: new Vector2( width, height )\r\n\t\t\t\t};\r\n\r\n\t\t\t\tmorphTextures.set( geometry, entry );\r\n\r\n\t\t\t\tfunction disposeTexture() {\r\n\r\n\t\t\t\t\ttexture.dispose();\r\n\r\n\t\t\t\t\tmorphTextures.delete( geometry );\r\n\r\n\t\t\t\t\tgeometry.removeEventListener( 'dispose', disposeTexture );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tgeometry.addEventListener( 'dispose', disposeTexture );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t//\r\n\r\n\t\t\tlet morphInfluencesSum = 0;\r\n\r\n\t\t\tfor ( let i = 0; i < objectInfluences.length; i ++ ) {\r\n\r\n\t\t\t\tmorphInfluencesSum += objectInfluences[ i ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;\r\n\r\n\t\t\tprogram.getUniforms().setValue( gl, 'morphTargetBaseInfluence', morphBaseInfluence );\r\n\t\t\tprogram.getUniforms().setValue( gl, 'morphTargetInfluences', objectInfluences );\r\n\r\n\t\t\tprogram.getUniforms().setValue( gl, 'morphTargetsTexture', entry.texture, textures );\r\n\t\t\tprogram.getUniforms().setValue( gl, 'morphTargetsTextureSize', entry.size );\r\n\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// When object doesn't have morph target influences defined, we treat it as a 0-length array\r\n\t\t\t// This is important to make sure we set up morphTargetBaseInfluence / morphTargetInfluences\r\n\r\n\t\t\tconst length = objectInfluences === undefined ? 0 : objectInfluences.length;\r\n\r\n\t\t\tlet influences = influencesList[ geometry.id ];\r\n\r\n\t\t\tif ( influences === undefined || influences.length !== length ) {\r\n\r\n\t\t\t\t// initialise list\r\n\r\n\t\t\t\tinfluences = [];\r\n\r\n\t\t\t\tfor ( let i = 0; i < length; i ++ ) {\r\n\r\n\t\t\t\t\tinfluences[ i ] = [ i, 0 ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tinfluencesList[ geometry.id ] = influences;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Collect influences\r\n\r\n\t\t\tfor ( let i = 0; i < length; i ++ ) {\r\n\r\n\t\t\t\tconst influence = influences[ i ];\r\n\r\n\t\t\t\tinfluence[ 0 ] = i;\r\n\t\t\t\tinfluence[ 1 ] = objectInfluences[ i ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tinfluences.sort( absNumericalSort );\r\n\r\n\t\t\tfor ( let i = 0; i < 8; i ++ ) {\r\n\r\n\t\t\t\tif ( i < length && influences[ i ][ 1 ] ) {\r\n\r\n\t\t\t\t\tworkInfluences[ i ][ 0 ] = influences[ i ][ 0 ];\r\n\t\t\t\t\tworkInfluences[ i ][ 1 ] = influences[ i ][ 1 ];\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tworkInfluences[ i ][ 0 ] = Number.MAX_SAFE_INTEGER;\r\n\t\t\t\t\tworkInfluences[ i ][ 1 ] = 0;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tworkInfluences.sort( numericalSort );\r\n\r\n\t\t\tconst morphTargets = geometry.morphAttributes.position;\r\n\t\t\tconst morphNormals = geometry.morphAttributes.normal;\r\n\r\n\t\t\tlet morphInfluencesSum = 0;\r\n\r\n\t\t\tfor ( let i = 0; i < 8; i ++ ) {\r\n\r\n\t\t\t\tconst influence = workInfluences[ i ];\r\n\t\t\t\tconst index = influence[ 0 ];\r\n\t\t\t\tconst value = influence[ 1 ];\r\n\r\n\t\t\t\tif ( index !== Number.MAX_SAFE_INTEGER && value ) {\r\n\r\n\t\t\t\t\tif ( morphTargets && geometry.getAttribute( 'morphTarget' + i ) !== morphTargets[ index ] ) {\r\n\r\n\t\t\t\t\t\tgeometry.setAttribute( 'morphTarget' + i, morphTargets[ index ] );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( morphNormals && geometry.getAttribute( 'morphNormal' + i ) !== morphNormals[ index ] ) {\r\n\r\n\t\t\t\t\t\tgeometry.setAttribute( 'morphNormal' + i, morphNormals[ index ] );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tmorphInfluences[ i ] = value;\r\n\t\t\t\t\tmorphInfluencesSum += value;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tif ( morphTargets && geometry.hasAttribute( 'morphTarget' + i ) === true ) {\r\n\r\n\t\t\t\t\t\tgeometry.deleteAttribute( 'morphTarget' + i );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( morphNormals && geometry.hasAttribute( 'morphNormal' + i ) === true ) {\r\n\r\n\t\t\t\t\t\tgeometry.deleteAttribute( 'morphNormal' + i );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tmorphInfluences[ i ] = 0;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// GLSL shader uses formula baseinfluence * base + sum(target * influence)\r\n\t\t\t// This allows us to switch between absolute morphs and relative morphs without changing shader code\r\n\t\t\t// When baseinfluence = 1 - sum(influence), the above is equivalent to sum((target - base) * influence)\r\n\t\t\tconst morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;\r\n\r\n\t\t\tprogram.getUniforms().setValue( gl, 'morphTargetBaseInfluence', morphBaseInfluence );\r\n\t\t\tprogram.getUniforms().setValue( gl, 'morphTargetInfluences', morphInfluences );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn {\r\n\r\n\t\tupdate: update\r\n\r\n\t};\r\n\r\n}\r\n\r\n\r\nexport { WebGLMorphtargets };\r\n"]},"metadata":{},"sourceType":"module"}