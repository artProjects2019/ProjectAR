{"ast":null,"code":"import { BackSide, LinearFilter, LinearMipmapLinearFilter, NoBlending, RGBAFormat } from '../constants.js';\nimport { Mesh } from '../objects/Mesh.js';\nimport { BoxGeometry } from '../geometries/BoxGeometry.js';\nimport { ShaderMaterial } from '../materials/ShaderMaterial.js';\nimport { cloneUniforms } from './shaders/UniformsUtils.js';\nimport { WebGLRenderTarget } from './WebGLRenderTarget.js';\nimport { CubeCamera } from '../cameras/CubeCamera.js';\nimport { CubeTexture } from '../textures/CubeTexture.js';\n\nclass WebGLCubeRenderTarget extends WebGLRenderTarget {\n  constructor(size, options = {}) {\n    super(size, size, options);\n    const image = {\n      width: size,\n      height: size,\n      depth: 1\n    };\n    const images = [image, image, image, image, image, image];\n    this.texture = new CubeTexture(images, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding); // By convention -- likely based on the RenderMan spec from the 1990's -- cube maps are specified by WebGL (and three.js)\n    // in a coordinate system in which positive-x is to the right when looking up the positive-z axis -- in other words,\n    // in a left-handed coordinate system. By continuing this convention, preexisting cube maps continued to render correctly.\n    // three.js uses a right-handed coordinate system. So environment maps used in three.js appear to have px and nx swapped\n    // and the flag isRenderTargetTexture controls this conversion. The flip is not required when using WebGLCubeRenderTarget.texture\n    // as a cube texture (this is detected when isRenderTargetTexture is set to true for cube textures).\n\n    this.texture.isRenderTargetTexture = true;\n    this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;\n    this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;\n  }\n\n  fromEquirectangularTexture(renderer, texture) {\n    this.texture.type = texture.type;\n    this.texture.format = RGBAFormat; // see #18859\n\n    this.texture.encoding = texture.encoding;\n    this.texture.generateMipmaps = texture.generateMipmaps;\n    this.texture.minFilter = texture.minFilter;\n    this.texture.magFilter = texture.magFilter;\n    const shader = {\n      uniforms: {\n        tEquirect: {\n          value: null\n        }\n      },\n      vertexShader:\n      /* glsl */\n      `\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t`,\n      fragmentShader:\n      /* glsl */\n      `\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t`\n    };\n    const geometry = new BoxGeometry(5, 5, 5);\n    const material = new ShaderMaterial({\n      name: 'CubemapFromEquirect',\n      uniforms: cloneUniforms(shader.uniforms),\n      vertexShader: shader.vertexShader,\n      fragmentShader: shader.fragmentShader,\n      side: BackSide,\n      blending: NoBlending\n    });\n    material.uniforms.tEquirect.value = texture;\n    const mesh = new Mesh(geometry, material);\n    const currentMinFilter = texture.minFilter; // Avoid blurred poles\n\n    if (texture.minFilter === LinearMipmapLinearFilter) texture.minFilter = LinearFilter;\n    const camera = new CubeCamera(1, 10, this);\n    camera.update(renderer, mesh);\n    texture.minFilter = currentMinFilter;\n    mesh.geometry.dispose();\n    mesh.material.dispose();\n    return this;\n  }\n\n  clear(renderer, color, depth, stencil) {\n    const currentRenderTarget = renderer.getRenderTarget();\n\n    for (let i = 0; i < 6; i++) {\n      renderer.setRenderTarget(this, i);\n      renderer.clear(color, depth, stencil);\n    }\n\n    renderer.setRenderTarget(currentRenderTarget);\n  }\n\n}\n\nWebGLCubeRenderTarget.prototype.isWebGLCubeRenderTarget = true;\nexport { WebGLCubeRenderTarget };","map":{"version":3,"sources":["C:/Users/dell/Desktop/projektlogin/vue-3-authentication-jwt/src/games/three/src/renderers/WebGLCubeRenderTarget.js"],"names":["BackSide","LinearFilter","LinearMipmapLinearFilter","NoBlending","RGBAFormat","Mesh","BoxGeometry","ShaderMaterial","cloneUniforms","WebGLRenderTarget","CubeCamera","CubeTexture","WebGLCubeRenderTarget","constructor","size","options","image","width","height","depth","images","texture","mapping","wrapS","wrapT","magFilter","minFilter","format","type","anisotropy","encoding","isRenderTargetTexture","generateMipmaps","undefined","fromEquirectangularTexture","renderer","shader","uniforms","tEquirect","value","vertexShader","fragmentShader","geometry","material","name","side","blending","mesh","currentMinFilter","camera","update","dispose","clear","color","stencil","currentRenderTarget","getRenderTarget","i","setRenderTarget","prototype","isWebGLCubeRenderTarget"],"mappings":"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","sourcesContent":["import { BackSide, LinearFilter, LinearMipmapLinearFilter, NoBlending, RGBAFormat } from '../constants.js';\r\nimport { Mesh } from '../objects/Mesh.js';\r\nimport { BoxGeometry } from '../geometries/BoxGeometry.js';\r\nimport { ShaderMaterial } from '../materials/ShaderMaterial.js';\r\nimport { cloneUniforms } from './shaders/UniformsUtils.js';\r\nimport { WebGLRenderTarget } from './WebGLRenderTarget.js';\r\nimport { CubeCamera } from '../cameras/CubeCamera.js';\r\nimport { CubeTexture } from '../textures/CubeTexture.js';\r\n\r\nclass WebGLCubeRenderTarget extends WebGLRenderTarget {\r\n\r\n\tconstructor( size, options = {} ) {\r\n\r\n\t\tsuper( size, size, options );\r\n\r\n\t\tconst image = { width: size, height: size, depth: 1 };\r\n\t\tconst images = [ image, image, image, image, image, image ];\r\n\r\n\t\tthis.texture = new CubeTexture( images, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );\r\n\r\n\t\t// By convention -- likely based on the RenderMan spec from the 1990's -- cube maps are specified by WebGL (and three.js)\r\n\t\t// in a coordinate system in which positive-x is to the right when looking up the positive-z axis -- in other words,\r\n\t\t// in a left-handed coordinate system. By continuing this convention, preexisting cube maps continued to render correctly.\r\n\r\n\t\t// three.js uses a right-handed coordinate system. So environment maps used in three.js appear to have px and nx swapped\r\n\t\t// and the flag isRenderTargetTexture controls this conversion. The flip is not required when using WebGLCubeRenderTarget.texture\r\n\t\t// as a cube texture (this is detected when isRenderTargetTexture is set to true for cube textures).\r\n\r\n\t\tthis.texture.isRenderTargetTexture = true;\r\n\r\n\t\tthis.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;\r\n\t\tthis.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;\r\n\r\n\t}\r\n\r\n\tfromEquirectangularTexture( renderer, texture ) {\r\n\r\n\t\tthis.texture.type = texture.type;\r\n\t\tthis.texture.format = RGBAFormat; // see #18859\r\n\t\tthis.texture.encoding = texture.encoding;\r\n\r\n\t\tthis.texture.generateMipmaps = texture.generateMipmaps;\r\n\t\tthis.texture.minFilter = texture.minFilter;\r\n\t\tthis.texture.magFilter = texture.magFilter;\r\n\r\n\t\tconst shader = {\r\n\r\n\t\t\tuniforms: {\r\n\t\t\t\ttEquirect: { value: null },\r\n\t\t\t},\r\n\r\n\t\t\tvertexShader: /* glsl */`\r\n\r\n\t\t\t\tvarying vec3 vWorldDirection;\r\n\r\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\r\n\r\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvoid main() {\r\n\r\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\r\n\r\n\t\t\t\t\t#include <begin_vertex>\r\n\t\t\t\t\t#include <project_vertex>\r\n\r\n\t\t\t\t}\r\n\t\t\t`,\r\n\r\n\t\t\tfragmentShader: /* glsl */`\r\n\r\n\t\t\t\tuniform sampler2D tEquirect;\r\n\r\n\t\t\t\tvarying vec3 vWorldDirection;\r\n\r\n\t\t\t\t#include <common>\r\n\r\n\t\t\t\tvoid main() {\r\n\r\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\r\n\r\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\r\n\r\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\r\n\r\n\t\t\t\t}\r\n\t\t\t`\r\n\t\t};\r\n\r\n\t\tconst geometry = new BoxGeometry( 5, 5, 5 );\r\n\r\n\t\tconst material = new ShaderMaterial( {\r\n\r\n\t\t\tname: 'CubemapFromEquirect',\r\n\r\n\t\t\tuniforms: cloneUniforms( shader.uniforms ),\r\n\t\t\tvertexShader: shader.vertexShader,\r\n\t\t\tfragmentShader: shader.fragmentShader,\r\n\t\t\tside: BackSide,\r\n\t\t\tblending: NoBlending\r\n\r\n\t\t} );\r\n\r\n\t\tmaterial.uniforms.tEquirect.value = texture;\r\n\r\n\t\tconst mesh = new Mesh( geometry, material );\r\n\r\n\t\tconst currentMinFilter = texture.minFilter;\r\n\r\n\t\t// Avoid blurred poles\r\n\t\tif ( texture.minFilter === LinearMipmapLinearFilter ) texture.minFilter = LinearFilter;\r\n\r\n\t\tconst camera = new CubeCamera( 1, 10, this );\r\n\t\tcamera.update( renderer, mesh );\r\n\r\n\t\ttexture.minFilter = currentMinFilter;\r\n\r\n\t\tmesh.geometry.dispose();\r\n\t\tmesh.material.dispose();\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tclear( renderer, color, depth, stencil ) {\r\n\r\n\t\tconst currentRenderTarget = renderer.getRenderTarget();\r\n\r\n\t\tfor ( let i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\trenderer.setRenderTarget( this, i );\r\n\r\n\t\t\trenderer.clear( color, depth, stencil );\r\n\r\n\t\t}\r\n\r\n\t\trenderer.setRenderTarget( currentRenderTarget );\r\n\r\n\t}\r\n\r\n}\r\n\r\nWebGLCubeRenderTarget.prototype.isWebGLCubeRenderTarget = true;\r\n\r\nexport { WebGLCubeRenderTarget };\r\n"]},"metadata":{},"sourceType":"module"}