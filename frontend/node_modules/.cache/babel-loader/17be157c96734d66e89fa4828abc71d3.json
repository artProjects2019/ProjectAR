{"ast":null,"code":"import { Color } from '../../math/Color.js';\nimport { Matrix4 } from '../../math/Matrix4.js';\nimport { Vector2 } from '../../math/Vector2.js';\nimport { Vector3 } from '../../math/Vector3.js';\nimport { UniformsLib } from '../shaders/UniformsLib.js';\n\nfunction UniformsCache() {\n  const lights = {};\n  return {\n    get: function (light) {\n      if (lights[light.id] !== undefined) {\n        return lights[light.id];\n      }\n\n      let uniforms;\n\n      switch (light.type) {\n        case 'DirectionalLight':\n          uniforms = {\n            direction: new Vector3(),\n            color: new Color()\n          };\n          break;\n\n        case 'SpotLight':\n          uniforms = {\n            position: new Vector3(),\n            direction: new Vector3(),\n            color: new Color(),\n            distance: 0,\n            coneCos: 0,\n            penumbraCos: 0,\n            decay: 0\n          };\n          break;\n\n        case 'PointLight':\n          uniforms = {\n            position: new Vector3(),\n            color: new Color(),\n            distance: 0,\n            decay: 0\n          };\n          break;\n\n        case 'HemisphereLight':\n          uniforms = {\n            direction: new Vector3(),\n            skyColor: new Color(),\n            groundColor: new Color()\n          };\n          break;\n\n        case 'RectAreaLight':\n          uniforms = {\n            color: new Color(),\n            position: new Vector3(),\n            halfWidth: new Vector3(),\n            halfHeight: new Vector3()\n          };\n          break;\n      }\n\n      lights[light.id] = uniforms;\n      return uniforms;\n    }\n  };\n}\n\nfunction ShadowUniformsCache() {\n  const lights = {};\n  return {\n    get: function (light) {\n      if (lights[light.id] !== undefined) {\n        return lights[light.id];\n      }\n\n      let uniforms;\n\n      switch (light.type) {\n        case 'DirectionalLight':\n          uniforms = {\n            shadowBias: 0,\n            shadowNormalBias: 0,\n            shadowRadius: 1,\n            shadowMapSize: new Vector2()\n          };\n          break;\n\n        case 'SpotLight':\n          uniforms = {\n            shadowBias: 0,\n            shadowNormalBias: 0,\n            shadowRadius: 1,\n            shadowMapSize: new Vector2()\n          };\n          break;\n\n        case 'PointLight':\n          uniforms = {\n            shadowBias: 0,\n            shadowNormalBias: 0,\n            shadowRadius: 1,\n            shadowMapSize: new Vector2(),\n            shadowCameraNear: 1,\n            shadowCameraFar: 1000\n          };\n          break;\n        // TODO (abelnation): set RectAreaLight shadow uniforms\n      }\n\n      lights[light.id] = uniforms;\n      return uniforms;\n    }\n  };\n}\n\nlet nextVersion = 0;\n\nfunction shadowCastingLightsFirst(lightA, lightB) {\n  return (lightB.castShadow ? 1 : 0) - (lightA.castShadow ? 1 : 0);\n}\n\nfunction WebGLLights(extensions, capabilities) {\n  const cache = new UniformsCache();\n  const shadowCache = ShadowUniformsCache();\n  const state = {\n    version: 0,\n    hash: {\n      directionalLength: -1,\n      pointLength: -1,\n      spotLength: -1,\n      rectAreaLength: -1,\n      hemiLength: -1,\n      numDirectionalShadows: -1,\n      numPointShadows: -1,\n      numSpotShadows: -1\n    },\n    ambient: [0, 0, 0],\n    probe: [],\n    directional: [],\n    directionalShadow: [],\n    directionalShadowMap: [],\n    directionalShadowMatrix: [],\n    spot: [],\n    spotShadow: [],\n    spotShadowMap: [],\n    spotShadowMatrix: [],\n    rectArea: [],\n    rectAreaLTC1: null,\n    rectAreaLTC2: null,\n    point: [],\n    pointShadow: [],\n    pointShadowMap: [],\n    pointShadowMatrix: [],\n    hemi: []\n  };\n\n  for (let i = 0; i < 9; i++) state.probe.push(new Vector3());\n\n  const vector3 = new Vector3();\n  const matrix4 = new Matrix4();\n  const matrix42 = new Matrix4();\n\n  function setup(lights, physicallyCorrectLights) {\n    let r = 0,\n        g = 0,\n        b = 0;\n\n    for (let i = 0; i < 9; i++) state.probe[i].set(0, 0, 0);\n\n    let directionalLength = 0;\n    let pointLength = 0;\n    let spotLength = 0;\n    let rectAreaLength = 0;\n    let hemiLength = 0;\n    let numDirectionalShadows = 0;\n    let numPointShadows = 0;\n    let numSpotShadows = 0;\n    lights.sort(shadowCastingLightsFirst); // artist-friendly light intensity scaling factor\n\n    const scaleFactor = physicallyCorrectLights !== true ? Math.PI : 1;\n\n    for (let i = 0, l = lights.length; i < l; i++) {\n      const light = lights[i];\n      const color = light.color;\n      const intensity = light.intensity;\n      const distance = light.distance;\n      const shadowMap = light.shadow && light.shadow.map ? light.shadow.map.texture : null;\n\n      if (light.isAmbientLight) {\n        r += color.r * intensity * scaleFactor;\n        g += color.g * intensity * scaleFactor;\n        b += color.b * intensity * scaleFactor;\n      } else if (light.isLightProbe) {\n        for (let j = 0; j < 9; j++) {\n          state.probe[j].addScaledVector(light.sh.coefficients[j], intensity);\n        }\n      } else if (light.isDirectionalLight) {\n        const uniforms = cache.get(light);\n        uniforms.color.copy(light.color).multiplyScalar(light.intensity * scaleFactor);\n\n        if (light.castShadow) {\n          const shadow = light.shadow;\n          const shadowUniforms = shadowCache.get(light);\n          shadowUniforms.shadowBias = shadow.bias;\n          shadowUniforms.shadowNormalBias = shadow.normalBias;\n          shadowUniforms.shadowRadius = shadow.radius;\n          shadowUniforms.shadowMapSize = shadow.mapSize;\n          state.directionalShadow[directionalLength] = shadowUniforms;\n          state.directionalShadowMap[directionalLength] = shadowMap;\n          state.directionalShadowMatrix[directionalLength] = light.shadow.matrix;\n          numDirectionalShadows++;\n        }\n\n        state.directional[directionalLength] = uniforms;\n        directionalLength++;\n      } else if (light.isSpotLight) {\n        const uniforms = cache.get(light);\n        uniforms.position.setFromMatrixPosition(light.matrixWorld);\n        uniforms.color.copy(color).multiplyScalar(intensity * scaleFactor);\n        uniforms.distance = distance;\n        uniforms.coneCos = Math.cos(light.angle);\n        uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));\n        uniforms.decay = light.decay;\n\n        if (light.castShadow) {\n          const shadow = light.shadow;\n          const shadowUniforms = shadowCache.get(light);\n          shadowUniforms.shadowBias = shadow.bias;\n          shadowUniforms.shadowNormalBias = shadow.normalBias;\n          shadowUniforms.shadowRadius = shadow.radius;\n          shadowUniforms.shadowMapSize = shadow.mapSize;\n          state.spotShadow[spotLength] = shadowUniforms;\n          state.spotShadowMap[spotLength] = shadowMap;\n          state.spotShadowMatrix[spotLength] = light.shadow.matrix;\n          numSpotShadows++;\n        }\n\n        state.spot[spotLength] = uniforms;\n        spotLength++;\n      } else if (light.isRectAreaLight) {\n        const uniforms = cache.get(light); // (a) intensity is the total visible light emitted\n        //uniforms.color.copy( color ).multiplyScalar( intensity / ( light.width * light.height * Math.PI ) );\n        // (b) intensity is the brightness of the light\n\n        uniforms.color.copy(color).multiplyScalar(intensity);\n        uniforms.halfWidth.set(light.width * 0.5, 0.0, 0.0);\n        uniforms.halfHeight.set(0.0, light.height * 0.5, 0.0);\n        state.rectArea[rectAreaLength] = uniforms;\n        rectAreaLength++;\n      } else if (light.isPointLight) {\n        const uniforms = cache.get(light);\n        uniforms.color.copy(light.color).multiplyScalar(light.intensity * scaleFactor);\n        uniforms.distance = light.distance;\n        uniforms.decay = light.decay;\n\n        if (light.castShadow) {\n          const shadow = light.shadow;\n          const shadowUniforms = shadowCache.get(light);\n          shadowUniforms.shadowBias = shadow.bias;\n          shadowUniforms.shadowNormalBias = shadow.normalBias;\n          shadowUniforms.shadowRadius = shadow.radius;\n          shadowUniforms.shadowMapSize = shadow.mapSize;\n          shadowUniforms.shadowCameraNear = shadow.camera.near;\n          shadowUniforms.shadowCameraFar = shadow.camera.far;\n          state.pointShadow[pointLength] = shadowUniforms;\n          state.pointShadowMap[pointLength] = shadowMap;\n          state.pointShadowMatrix[pointLength] = light.shadow.matrix;\n          numPointShadows++;\n        }\n\n        state.point[pointLength] = uniforms;\n        pointLength++;\n      } else if (light.isHemisphereLight) {\n        const uniforms = cache.get(light);\n        uniforms.skyColor.copy(light.color).multiplyScalar(intensity * scaleFactor);\n        uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity * scaleFactor);\n        state.hemi[hemiLength] = uniforms;\n        hemiLength++;\n      }\n    }\n\n    if (rectAreaLength > 0) {\n      if (capabilities.isWebGL2) {\n        // WebGL 2\n        state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;\n        state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;\n      } else {\n        // WebGL 1\n        if (extensions.has('OES_texture_float_linear') === true) {\n          state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;\n          state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;\n        } else if (extensions.has('OES_texture_half_float_linear') === true) {\n          state.rectAreaLTC1 = UniformsLib.LTC_HALF_1;\n          state.rectAreaLTC2 = UniformsLib.LTC_HALF_2;\n        } else {\n          console.error('THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.');\n        }\n      }\n    }\n\n    state.ambient[0] = r;\n    state.ambient[1] = g;\n    state.ambient[2] = b;\n    const hash = state.hash;\n\n    if (hash.directionalLength !== directionalLength || hash.pointLength !== pointLength || hash.spotLength !== spotLength || hash.rectAreaLength !== rectAreaLength || hash.hemiLength !== hemiLength || hash.numDirectionalShadows !== numDirectionalShadows || hash.numPointShadows !== numPointShadows || hash.numSpotShadows !== numSpotShadows) {\n      state.directional.length = directionalLength;\n      state.spot.length = spotLength;\n      state.rectArea.length = rectAreaLength;\n      state.point.length = pointLength;\n      state.hemi.length = hemiLength;\n      state.directionalShadow.length = numDirectionalShadows;\n      state.directionalShadowMap.length = numDirectionalShadows;\n      state.pointShadow.length = numPointShadows;\n      state.pointShadowMap.length = numPointShadows;\n      state.spotShadow.length = numSpotShadows;\n      state.spotShadowMap.length = numSpotShadows;\n      state.directionalShadowMatrix.length = numDirectionalShadows;\n      state.pointShadowMatrix.length = numPointShadows;\n      state.spotShadowMatrix.length = numSpotShadows;\n      hash.directionalLength = directionalLength;\n      hash.pointLength = pointLength;\n      hash.spotLength = spotLength;\n      hash.rectAreaLength = rectAreaLength;\n      hash.hemiLength = hemiLength;\n      hash.numDirectionalShadows = numDirectionalShadows;\n      hash.numPointShadows = numPointShadows;\n      hash.numSpotShadows = numSpotShadows;\n      state.version = nextVersion++;\n    }\n  }\n\n  function setupView(lights, camera) {\n    let directionalLength = 0;\n    let pointLength = 0;\n    let spotLength = 0;\n    let rectAreaLength = 0;\n    let hemiLength = 0;\n    const viewMatrix = camera.matrixWorldInverse;\n\n    for (let i = 0, l = lights.length; i < l; i++) {\n      const light = lights[i];\n\n      if (light.isDirectionalLight) {\n        const uniforms = state.directional[directionalLength];\n        uniforms.direction.setFromMatrixPosition(light.matrixWorld);\n        vector3.setFromMatrixPosition(light.target.matrixWorld);\n        uniforms.direction.sub(vector3);\n        uniforms.direction.transformDirection(viewMatrix);\n        directionalLength++;\n      } else if (light.isSpotLight) {\n        const uniforms = state.spot[spotLength];\n        uniforms.position.setFromMatrixPosition(light.matrixWorld);\n        uniforms.position.applyMatrix4(viewMatrix);\n        uniforms.direction.setFromMatrixPosition(light.matrixWorld);\n        vector3.setFromMatrixPosition(light.target.matrixWorld);\n        uniforms.direction.sub(vector3);\n        uniforms.direction.transformDirection(viewMatrix);\n        spotLength++;\n      } else if (light.isRectAreaLight) {\n        const uniforms = state.rectArea[rectAreaLength];\n        uniforms.position.setFromMatrixPosition(light.matrixWorld);\n        uniforms.position.applyMatrix4(viewMatrix); // extract local rotation of light to derive width/height half vectors\n\n        matrix42.identity();\n        matrix4.copy(light.matrixWorld);\n        matrix4.premultiply(viewMatrix);\n        matrix42.extractRotation(matrix4);\n        uniforms.halfWidth.set(light.width * 0.5, 0.0, 0.0);\n        uniforms.halfHeight.set(0.0, light.height * 0.5, 0.0);\n        uniforms.halfWidth.applyMatrix4(matrix42);\n        uniforms.halfHeight.applyMatrix4(matrix42);\n        rectAreaLength++;\n      } else if (light.isPointLight) {\n        const uniforms = state.point[pointLength];\n        uniforms.position.setFromMatrixPosition(light.matrixWorld);\n        uniforms.position.applyMatrix4(viewMatrix);\n        pointLength++;\n      } else if (light.isHemisphereLight) {\n        const uniforms = state.hemi[hemiLength];\n        uniforms.direction.setFromMatrixPosition(light.matrixWorld);\n        uniforms.direction.transformDirection(viewMatrix);\n        uniforms.direction.normalize();\n        hemiLength++;\n      }\n    }\n  }\n\n  return {\n    setup: setup,\n    setupView: setupView,\n    state: state\n  };\n}\n\nexport { WebGLLights };","map":{"version":3,"sources":["C:/Users/dell/Desktop/projektlogin/vue-3-authentication-jwt/src/games/three/src/renderers/webgl/WebGLLights.js"],"names":["Color","Matrix4","Vector2","Vector3","UniformsLib","UniformsCache","lights","get","light","id","undefined","uniforms","type","direction","color","position","distance","coneCos","penumbraCos","decay","skyColor","groundColor","halfWidth","halfHeight","ShadowUniformsCache","shadowBias","shadowNormalBias","shadowRadius","shadowMapSize","shadowCameraNear","shadowCameraFar","nextVersion","shadowCastingLightsFirst","lightA","lightB","castShadow","WebGLLights","extensions","capabilities","cache","shadowCache","state","version","hash","directionalLength","pointLength","spotLength","rectAreaLength","hemiLength","numDirectionalShadows","numPointShadows","numSpotShadows","ambient","probe","directional","directionalShadow","directionalShadowMap","directionalShadowMatrix","spot","spotShadow","spotShadowMap","spotShadowMatrix","rectArea","rectAreaLTC1","rectAreaLTC2","point","pointShadow","pointShadowMap","pointShadowMatrix","hemi","i","push","vector3","matrix4","matrix42","setup","physicallyCorrectLights","r","g","b","set","sort","scaleFactor","Math","PI","l","length","intensity","shadowMap","shadow","map","texture","isAmbientLight","isLightProbe","j","addScaledVector","sh","coefficients","isDirectionalLight","copy","multiplyScalar","shadowUniforms","bias","normalBias","radius","mapSize","matrix","isSpotLight","setFromMatrixPosition","matrixWorld","cos","angle","penumbra","isRectAreaLight","width","height","isPointLight","camera","near","far","isHemisphereLight","isWebGL2","LTC_FLOAT_1","LTC_FLOAT_2","has","LTC_HALF_1","LTC_HALF_2","console","error","setupView","viewMatrix","matrixWorldInverse","target","sub","transformDirection","applyMatrix4","identity","premultiply","extractRotation","normalize"],"mappings":"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","sourcesContent":["import { Color } from '../../math/Color.js';\r\nimport { Matrix4 } from '../../math/Matrix4.js';\r\nimport { Vector2 } from '../../math/Vector2.js';\r\nimport { Vector3 } from '../../math/Vector3.js';\r\nimport { UniformsLib } from '../shaders/UniformsLib.js';\r\n\r\nfunction UniformsCache() {\r\n\r\n\tconst lights = {};\r\n\r\n\treturn {\r\n\r\n\t\tget: function ( light ) {\r\n\r\n\t\t\tif ( lights[ light.id ] !== undefined ) {\r\n\r\n\t\t\t\treturn lights[ light.id ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tlet uniforms;\r\n\r\n\t\t\tswitch ( light.type ) {\r\n\r\n\t\t\t\tcase 'DirectionalLight':\r\n\t\t\t\t\tuniforms = {\r\n\t\t\t\t\t\tdirection: new Vector3(),\r\n\t\t\t\t\t\tcolor: new Color()\r\n\t\t\t\t\t};\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'SpotLight':\r\n\t\t\t\t\tuniforms = {\r\n\t\t\t\t\t\tposition: new Vector3(),\r\n\t\t\t\t\t\tdirection: new Vector3(),\r\n\t\t\t\t\t\tcolor: new Color(),\r\n\t\t\t\t\t\tdistance: 0,\r\n\t\t\t\t\t\tconeCos: 0,\r\n\t\t\t\t\t\tpenumbraCos: 0,\r\n\t\t\t\t\t\tdecay: 0\r\n\t\t\t\t\t};\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'PointLight':\r\n\t\t\t\t\tuniforms = {\r\n\t\t\t\t\t\tposition: new Vector3(),\r\n\t\t\t\t\t\tcolor: new Color(),\r\n\t\t\t\t\t\tdistance: 0,\r\n\t\t\t\t\t\tdecay: 0\r\n\t\t\t\t\t};\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'HemisphereLight':\r\n\t\t\t\t\tuniforms = {\r\n\t\t\t\t\t\tdirection: new Vector3(),\r\n\t\t\t\t\t\tskyColor: new Color(),\r\n\t\t\t\t\t\tgroundColor: new Color()\r\n\t\t\t\t\t};\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'RectAreaLight':\r\n\t\t\t\t\tuniforms = {\r\n\t\t\t\t\t\tcolor: new Color(),\r\n\t\t\t\t\t\tposition: new Vector3(),\r\n\t\t\t\t\t\thalfWidth: new Vector3(),\r\n\t\t\t\t\t\thalfHeight: new Vector3()\r\n\t\t\t\t\t};\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tlights[ light.id ] = uniforms;\r\n\r\n\t\t\treturn uniforms;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n}\r\n\r\nfunction ShadowUniformsCache() {\r\n\r\n\tconst lights = {};\r\n\r\n\treturn {\r\n\r\n\t\tget: function ( light ) {\r\n\r\n\t\t\tif ( lights[ light.id ] !== undefined ) {\r\n\r\n\t\t\t\treturn lights[ light.id ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tlet uniforms;\r\n\r\n\t\t\tswitch ( light.type ) {\r\n\r\n\t\t\t\tcase 'DirectionalLight':\r\n\t\t\t\t\tuniforms = {\r\n\t\t\t\t\t\tshadowBias: 0,\r\n\t\t\t\t\t\tshadowNormalBias: 0,\r\n\t\t\t\t\t\tshadowRadius: 1,\r\n\t\t\t\t\t\tshadowMapSize: new Vector2()\r\n\t\t\t\t\t};\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'SpotLight':\r\n\t\t\t\t\tuniforms = {\r\n\t\t\t\t\t\tshadowBias: 0,\r\n\t\t\t\t\t\tshadowNormalBias: 0,\r\n\t\t\t\t\t\tshadowRadius: 1,\r\n\t\t\t\t\t\tshadowMapSize: new Vector2()\r\n\t\t\t\t\t};\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'PointLight':\r\n\t\t\t\t\tuniforms = {\r\n\t\t\t\t\t\tshadowBias: 0,\r\n\t\t\t\t\t\tshadowNormalBias: 0,\r\n\t\t\t\t\t\tshadowRadius: 1,\r\n\t\t\t\t\t\tshadowMapSize: new Vector2(),\r\n\t\t\t\t\t\tshadowCameraNear: 1,\r\n\t\t\t\t\t\tshadowCameraFar: 1000\r\n\t\t\t\t\t};\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t// TODO (abelnation): set RectAreaLight shadow uniforms\r\n\r\n\t\t\t}\r\n\r\n\t\t\tlights[ light.id ] = uniforms;\r\n\r\n\t\t\treturn uniforms;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n}\r\n\r\n\r\n\r\nlet nextVersion = 0;\r\n\r\nfunction shadowCastingLightsFirst( lightA, lightB ) {\r\n\r\n\treturn ( lightB.castShadow ? 1 : 0 ) - ( lightA.castShadow ? 1 : 0 );\r\n\r\n}\r\n\r\nfunction WebGLLights( extensions, capabilities ) {\r\n\r\n\tconst cache = new UniformsCache();\r\n\r\n\tconst shadowCache = ShadowUniformsCache();\r\n\r\n\tconst state = {\r\n\r\n\t\tversion: 0,\r\n\r\n\t\thash: {\r\n\t\t\tdirectionalLength: - 1,\r\n\t\t\tpointLength: - 1,\r\n\t\t\tspotLength: - 1,\r\n\t\t\trectAreaLength: - 1,\r\n\t\t\themiLength: - 1,\r\n\r\n\t\t\tnumDirectionalShadows: - 1,\r\n\t\t\tnumPointShadows: - 1,\r\n\t\t\tnumSpotShadows: - 1\r\n\t\t},\r\n\r\n\t\tambient: [ 0, 0, 0 ],\r\n\t\tprobe: [],\r\n\t\tdirectional: [],\r\n\t\tdirectionalShadow: [],\r\n\t\tdirectionalShadowMap: [],\r\n\t\tdirectionalShadowMatrix: [],\r\n\t\tspot: [],\r\n\t\tspotShadow: [],\r\n\t\tspotShadowMap: [],\r\n\t\tspotShadowMatrix: [],\r\n\t\trectArea: [],\r\n\t\trectAreaLTC1: null,\r\n\t\trectAreaLTC2: null,\r\n\t\tpoint: [],\r\n\t\tpointShadow: [],\r\n\t\tpointShadowMap: [],\r\n\t\tpointShadowMatrix: [],\r\n\t\themi: []\r\n\r\n\t};\r\n\r\n\tfor ( let i = 0; i < 9; i ++ ) state.probe.push( new Vector3() );\r\n\r\n\tconst vector3 = new Vector3();\r\n\tconst matrix4 = new Matrix4();\r\n\tconst matrix42 = new Matrix4();\r\n\r\n\tfunction setup( lights, physicallyCorrectLights ) {\r\n\r\n\t\tlet r = 0, g = 0, b = 0;\r\n\r\n\t\tfor ( let i = 0; i < 9; i ++ ) state.probe[ i ].set( 0, 0, 0 );\r\n\r\n\t\tlet directionalLength = 0;\r\n\t\tlet pointLength = 0;\r\n\t\tlet spotLength = 0;\r\n\t\tlet rectAreaLength = 0;\r\n\t\tlet hemiLength = 0;\r\n\r\n\t\tlet numDirectionalShadows = 0;\r\n\t\tlet numPointShadows = 0;\r\n\t\tlet numSpotShadows = 0;\r\n\r\n\t\tlights.sort( shadowCastingLightsFirst );\r\n\r\n\t\t// artist-friendly light intensity scaling factor\r\n\t\tconst scaleFactor = ( physicallyCorrectLights !== true ) ? Math.PI : 1;\r\n\r\n\t\tfor ( let i = 0, l = lights.length; i < l; i ++ ) {\r\n\r\n\t\t\tconst light = lights[ i ];\r\n\r\n\t\t\tconst color = light.color;\r\n\t\t\tconst intensity = light.intensity;\r\n\t\t\tconst distance = light.distance;\r\n\r\n\t\t\tconst shadowMap = ( light.shadow && light.shadow.map ) ? light.shadow.map.texture : null;\r\n\r\n\t\t\tif ( light.isAmbientLight ) {\r\n\r\n\t\t\t\tr += color.r * intensity * scaleFactor;\r\n\t\t\t\tg += color.g * intensity * scaleFactor;\r\n\t\t\t\tb += color.b * intensity * scaleFactor;\r\n\r\n\t\t\t} else if ( light.isLightProbe ) {\r\n\r\n\t\t\t\tfor ( let j = 0; j < 9; j ++ ) {\r\n\r\n\t\t\t\t\tstate.probe[ j ].addScaledVector( light.sh.coefficients[ j ], intensity );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( light.isDirectionalLight ) {\r\n\r\n\t\t\t\tconst uniforms = cache.get( light );\r\n\r\n\t\t\t\tuniforms.color.copy( light.color ).multiplyScalar( light.intensity * scaleFactor );\r\n\r\n\t\t\t\tif ( light.castShadow ) {\r\n\r\n\t\t\t\t\tconst shadow = light.shadow;\r\n\r\n\t\t\t\t\tconst shadowUniforms = shadowCache.get( light );\r\n\r\n\t\t\t\t\tshadowUniforms.shadowBias = shadow.bias;\r\n\t\t\t\t\tshadowUniforms.shadowNormalBias = shadow.normalBias;\r\n\t\t\t\t\tshadowUniforms.shadowRadius = shadow.radius;\r\n\t\t\t\t\tshadowUniforms.shadowMapSize = shadow.mapSize;\r\n\r\n\t\t\t\t\tstate.directionalShadow[ directionalLength ] = shadowUniforms;\r\n\t\t\t\t\tstate.directionalShadowMap[ directionalLength ] = shadowMap;\r\n\t\t\t\t\tstate.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;\r\n\r\n\t\t\t\t\tnumDirectionalShadows ++;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tstate.directional[ directionalLength ] = uniforms;\r\n\r\n\t\t\t\tdirectionalLength ++;\r\n\r\n\t\t\t} else if ( light.isSpotLight ) {\r\n\r\n\t\t\t\tconst uniforms = cache.get( light );\r\n\r\n\t\t\t\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\r\n\r\n\t\t\t\tuniforms.color.copy( color ).multiplyScalar( intensity * scaleFactor );\r\n\t\t\t\tuniforms.distance = distance;\r\n\r\n\t\t\t\tuniforms.coneCos = Math.cos( light.angle );\r\n\t\t\t\tuniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );\r\n\t\t\t\tuniforms.decay = light.decay;\r\n\r\n\t\t\t\tif ( light.castShadow ) {\r\n\r\n\t\t\t\t\tconst shadow = light.shadow;\r\n\r\n\t\t\t\t\tconst shadowUniforms = shadowCache.get( light );\r\n\r\n\t\t\t\t\tshadowUniforms.shadowBias = shadow.bias;\r\n\t\t\t\t\tshadowUniforms.shadowNormalBias = shadow.normalBias;\r\n\t\t\t\t\tshadowUniforms.shadowRadius = shadow.radius;\r\n\t\t\t\t\tshadowUniforms.shadowMapSize = shadow.mapSize;\r\n\r\n\t\t\t\t\tstate.spotShadow[ spotLength ] = shadowUniforms;\r\n\t\t\t\t\tstate.spotShadowMap[ spotLength ] = shadowMap;\r\n\t\t\t\t\tstate.spotShadowMatrix[ spotLength ] = light.shadow.matrix;\r\n\r\n\t\t\t\t\tnumSpotShadows ++;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tstate.spot[ spotLength ] = uniforms;\r\n\r\n\t\t\t\tspotLength ++;\r\n\r\n\t\t\t} else if ( light.isRectAreaLight ) {\r\n\r\n\t\t\t\tconst uniforms = cache.get( light );\r\n\r\n\t\t\t\t// (a) intensity is the total visible light emitted\r\n\t\t\t\t//uniforms.color.copy( color ).multiplyScalar( intensity / ( light.width * light.height * Math.PI ) );\r\n\r\n\t\t\t\t// (b) intensity is the brightness of the light\r\n\t\t\t\tuniforms.color.copy( color ).multiplyScalar( intensity );\r\n\r\n\t\t\t\tuniforms.halfWidth.set( light.width * 0.5, 0.0, 0.0 );\r\n\t\t\t\tuniforms.halfHeight.set( 0.0, light.height * 0.5, 0.0 );\r\n\r\n\t\t\t\tstate.rectArea[ rectAreaLength ] = uniforms;\r\n\r\n\t\t\t\trectAreaLength ++;\r\n\r\n\t\t\t} else if ( light.isPointLight ) {\r\n\r\n\t\t\t\tconst uniforms = cache.get( light );\r\n\r\n\t\t\t\tuniforms.color.copy( light.color ).multiplyScalar( light.intensity * scaleFactor );\r\n\t\t\t\tuniforms.distance = light.distance;\r\n\t\t\t\tuniforms.decay = light.decay;\r\n\r\n\t\t\t\tif ( light.castShadow ) {\r\n\r\n\t\t\t\t\tconst shadow = light.shadow;\r\n\r\n\t\t\t\t\tconst shadowUniforms = shadowCache.get( light );\r\n\r\n\t\t\t\t\tshadowUniforms.shadowBias = shadow.bias;\r\n\t\t\t\t\tshadowUniforms.shadowNormalBias = shadow.normalBias;\r\n\t\t\t\t\tshadowUniforms.shadowRadius = shadow.radius;\r\n\t\t\t\t\tshadowUniforms.shadowMapSize = shadow.mapSize;\r\n\t\t\t\t\tshadowUniforms.shadowCameraNear = shadow.camera.near;\r\n\t\t\t\t\tshadowUniforms.shadowCameraFar = shadow.camera.far;\r\n\r\n\t\t\t\t\tstate.pointShadow[ pointLength ] = shadowUniforms;\r\n\t\t\t\t\tstate.pointShadowMap[ pointLength ] = shadowMap;\r\n\t\t\t\t\tstate.pointShadowMatrix[ pointLength ] = light.shadow.matrix;\r\n\r\n\t\t\t\t\tnumPointShadows ++;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tstate.point[ pointLength ] = uniforms;\r\n\r\n\t\t\t\tpointLength ++;\r\n\r\n\t\t\t} else if ( light.isHemisphereLight ) {\r\n\r\n\t\t\t\tconst uniforms = cache.get( light );\r\n\r\n\t\t\t\tuniforms.skyColor.copy( light.color ).multiplyScalar( intensity * scaleFactor );\r\n\t\t\t\tuniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity * scaleFactor );\r\n\r\n\t\t\t\tstate.hemi[ hemiLength ] = uniforms;\r\n\r\n\t\t\t\themiLength ++;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( rectAreaLength > 0 ) {\r\n\r\n\t\t\tif ( capabilities.isWebGL2 ) {\r\n\r\n\t\t\t\t// WebGL 2\r\n\r\n\t\t\t\tstate.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;\r\n\t\t\t\tstate.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// WebGL 1\r\n\r\n\t\t\t\tif ( extensions.has( 'OES_texture_float_linear' ) === true ) {\r\n\r\n\t\t\t\t\tstate.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;\r\n\t\t\t\t\tstate.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;\r\n\r\n\t\t\t\t} else if ( extensions.has( 'OES_texture_half_float_linear' ) === true ) {\r\n\r\n\t\t\t\t\tstate.rectAreaLTC1 = UniformsLib.LTC_HALF_1;\r\n\t\t\t\t\tstate.rectAreaLTC2 = UniformsLib.LTC_HALF_2;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.' );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tstate.ambient[ 0 ] = r;\r\n\t\tstate.ambient[ 1 ] = g;\r\n\t\tstate.ambient[ 2 ] = b;\r\n\r\n\t\tconst hash = state.hash;\r\n\r\n\t\tif ( hash.directionalLength !== directionalLength ||\r\n\t\t\thash.pointLength !== pointLength ||\r\n\t\t\thash.spotLength !== spotLength ||\r\n\t\t\thash.rectAreaLength !== rectAreaLength ||\r\n\t\t\thash.hemiLength !== hemiLength ||\r\n\t\t\thash.numDirectionalShadows !== numDirectionalShadows ||\r\n\t\t\thash.numPointShadows !== numPointShadows ||\r\n\t\t\thash.numSpotShadows !== numSpotShadows ) {\r\n\r\n\t\t\tstate.directional.length = directionalLength;\r\n\t\t\tstate.spot.length = spotLength;\r\n\t\t\tstate.rectArea.length = rectAreaLength;\r\n\t\t\tstate.point.length = pointLength;\r\n\t\t\tstate.hemi.length = hemiLength;\r\n\r\n\t\t\tstate.directionalShadow.length = numDirectionalShadows;\r\n\t\t\tstate.directionalShadowMap.length = numDirectionalShadows;\r\n\t\t\tstate.pointShadow.length = numPointShadows;\r\n\t\t\tstate.pointShadowMap.length = numPointShadows;\r\n\t\t\tstate.spotShadow.length = numSpotShadows;\r\n\t\t\tstate.spotShadowMap.length = numSpotShadows;\r\n\t\t\tstate.directionalShadowMatrix.length = numDirectionalShadows;\r\n\t\t\tstate.pointShadowMatrix.length = numPointShadows;\r\n\t\t\tstate.spotShadowMatrix.length = numSpotShadows;\r\n\r\n\t\t\thash.directionalLength = directionalLength;\r\n\t\t\thash.pointLength = pointLength;\r\n\t\t\thash.spotLength = spotLength;\r\n\t\t\thash.rectAreaLength = rectAreaLength;\r\n\t\t\thash.hemiLength = hemiLength;\r\n\r\n\t\t\thash.numDirectionalShadows = numDirectionalShadows;\r\n\t\t\thash.numPointShadows = numPointShadows;\r\n\t\t\thash.numSpotShadows = numSpotShadows;\r\n\r\n\t\t\tstate.version = nextVersion ++;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction setupView( lights, camera ) {\r\n\r\n\t\tlet directionalLength = 0;\r\n\t\tlet pointLength = 0;\r\n\t\tlet spotLength = 0;\r\n\t\tlet rectAreaLength = 0;\r\n\t\tlet hemiLength = 0;\r\n\r\n\t\tconst viewMatrix = camera.matrixWorldInverse;\r\n\r\n\t\tfor ( let i = 0, l = lights.length; i < l; i ++ ) {\r\n\r\n\t\t\tconst light = lights[ i ];\r\n\r\n\t\t\tif ( light.isDirectionalLight ) {\r\n\r\n\t\t\t\tconst uniforms = state.directional[ directionalLength ];\r\n\r\n\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\r\n\t\t\t\tvector3.setFromMatrixPosition( light.target.matrixWorld );\r\n\t\t\t\tuniforms.direction.sub( vector3 );\r\n\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\r\n\r\n\t\t\t\tdirectionalLength ++;\r\n\r\n\t\t\t} else if ( light.isSpotLight ) {\r\n\r\n\t\t\t\tconst uniforms = state.spot[ spotLength ];\r\n\r\n\t\t\t\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\r\n\t\t\t\tuniforms.position.applyMatrix4( viewMatrix );\r\n\r\n\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\r\n\t\t\t\tvector3.setFromMatrixPosition( light.target.matrixWorld );\r\n\t\t\t\tuniforms.direction.sub( vector3 );\r\n\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\r\n\r\n\t\t\t\tspotLength ++;\r\n\r\n\t\t\t} else if ( light.isRectAreaLight ) {\r\n\r\n\t\t\t\tconst uniforms = state.rectArea[ rectAreaLength ];\r\n\r\n\t\t\t\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\r\n\t\t\t\tuniforms.position.applyMatrix4( viewMatrix );\r\n\r\n\t\t\t\t// extract local rotation of light to derive width/height half vectors\r\n\t\t\t\tmatrix42.identity();\r\n\t\t\t\tmatrix4.copy( light.matrixWorld );\r\n\t\t\t\tmatrix4.premultiply( viewMatrix );\r\n\t\t\t\tmatrix42.extractRotation( matrix4 );\r\n\r\n\t\t\t\tuniforms.halfWidth.set( light.width * 0.5, 0.0, 0.0 );\r\n\t\t\t\tuniforms.halfHeight.set( 0.0, light.height * 0.5, 0.0 );\r\n\r\n\t\t\t\tuniforms.halfWidth.applyMatrix4( matrix42 );\r\n\t\t\t\tuniforms.halfHeight.applyMatrix4( matrix42 );\r\n\r\n\t\t\t\trectAreaLength ++;\r\n\r\n\t\t\t} else if ( light.isPointLight ) {\r\n\r\n\t\t\t\tconst uniforms = state.point[ pointLength ];\r\n\r\n\t\t\t\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\r\n\t\t\t\tuniforms.position.applyMatrix4( viewMatrix );\r\n\r\n\t\t\t\tpointLength ++;\r\n\r\n\t\t\t} else if ( light.isHemisphereLight ) {\r\n\r\n\t\t\t\tconst uniforms = state.hemi[ hemiLength ];\r\n\r\n\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\r\n\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\r\n\t\t\t\tuniforms.direction.normalize();\r\n\r\n\t\t\t\themiLength ++;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn {\r\n\t\tsetup: setup,\r\n\t\tsetupView: setupView,\r\n\t\tstate: state\r\n\t};\r\n\r\n}\r\n\r\n\r\nexport { WebGLLights };\r\n"]},"metadata":{},"sourceType":"module"}