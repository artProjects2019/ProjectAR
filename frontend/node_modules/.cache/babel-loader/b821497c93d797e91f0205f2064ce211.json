{"ast":null,"code":"import \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport { Sphere } from '../math/Sphere.js';\nimport { Vector3 } from '../math/Vector3.js';\nimport { BufferAttribute } from '../core/BufferAttribute.js';\nimport { BufferGeometry } from '../core/BufferGeometry.js';\nimport { FileLoader } from './FileLoader.js';\nimport { Loader } from './Loader.js';\nimport { InstancedBufferGeometry } from '../core/InstancedBufferGeometry.js';\nimport { InstancedBufferAttribute } from '../core/InstancedBufferAttribute.js';\nimport { InterleavedBufferAttribute } from '../core/InterleavedBufferAttribute.js';\nimport { InterleavedBuffer } from '../core/InterleavedBuffer.js';\nimport { getTypedArray } from '../utils.js';\n\nclass BufferGeometryLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const loader = new FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    loader.load(url, function (text) {\n      try {\n        onLoad(scope.parse(JSON.parse(text)));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n\n  parse(json) {\n    const interleavedBufferMap = {};\n    const arrayBufferMap = {};\n\n    function getInterleavedBuffer(json, uuid) {\n      if (interleavedBufferMap[uuid] !== undefined) return interleavedBufferMap[uuid];\n      const interleavedBuffers = json.interleavedBuffers;\n      const interleavedBuffer = interleavedBuffers[uuid];\n      const buffer = getArrayBuffer(json, interleavedBuffer.buffer);\n      const array = getTypedArray(interleavedBuffer.type, buffer);\n      const ib = new InterleavedBuffer(array, interleavedBuffer.stride);\n      ib.uuid = interleavedBuffer.uuid;\n      interleavedBufferMap[uuid] = ib;\n      return ib;\n    }\n\n    function getArrayBuffer(json, uuid) {\n      if (arrayBufferMap[uuid] !== undefined) return arrayBufferMap[uuid];\n      const arrayBuffers = json.arrayBuffers;\n      const arrayBuffer = arrayBuffers[uuid];\n      const ab = new Uint32Array(arrayBuffer).buffer;\n      arrayBufferMap[uuid] = ab;\n      return ab;\n    }\n\n    const geometry = json.isInstancedBufferGeometry ? new InstancedBufferGeometry() : new BufferGeometry();\n    const index = json.data.index;\n\n    if (index !== undefined) {\n      const typedArray = getTypedArray(index.type, index.array);\n      geometry.setIndex(new BufferAttribute(typedArray, 1));\n    }\n\n    const attributes = json.data.attributes;\n\n    for (const key in attributes) {\n      const attribute = attributes[key];\n      let bufferAttribute;\n\n      if (attribute.isInterleavedBufferAttribute) {\n        const interleavedBuffer = getInterleavedBuffer(json.data, attribute.data);\n        bufferAttribute = new InterleavedBufferAttribute(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized);\n      } else {\n        const typedArray = getTypedArray(attribute.type, attribute.array);\n        const bufferAttributeConstr = attribute.isInstancedBufferAttribute ? InstancedBufferAttribute : BufferAttribute;\n        bufferAttribute = new bufferAttributeConstr(typedArray, attribute.itemSize, attribute.normalized);\n      }\n\n      if (attribute.name !== undefined) bufferAttribute.name = attribute.name;\n      if (attribute.usage !== undefined) bufferAttribute.setUsage(attribute.usage);\n\n      if (attribute.updateRange !== undefined) {\n        bufferAttribute.updateRange.offset = attribute.updateRange.offset;\n        bufferAttribute.updateRange.count = attribute.updateRange.count;\n      }\n\n      geometry.setAttribute(key, bufferAttribute);\n    }\n\n    const morphAttributes = json.data.morphAttributes;\n\n    if (morphAttributes) {\n      for (const key in morphAttributes) {\n        const attributeArray = morphAttributes[key];\n        const array = [];\n\n        for (let i = 0, il = attributeArray.length; i < il; i++) {\n          const attribute = attributeArray[i];\n          let bufferAttribute;\n\n          if (attribute.isInterleavedBufferAttribute) {\n            const interleavedBuffer = getInterleavedBuffer(json.data, attribute.data);\n            bufferAttribute = new InterleavedBufferAttribute(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized);\n          } else {\n            const typedArray = getTypedArray(attribute.type, attribute.array);\n            bufferAttribute = new BufferAttribute(typedArray, attribute.itemSize, attribute.normalized);\n          }\n\n          if (attribute.name !== undefined) bufferAttribute.name = attribute.name;\n          array.push(bufferAttribute);\n        }\n\n        geometry.morphAttributes[key] = array;\n      }\n    }\n\n    const morphTargetsRelative = json.data.morphTargetsRelative;\n\n    if (morphTargetsRelative) {\n      geometry.morphTargetsRelative = true;\n    }\n\n    const groups = json.data.groups || json.data.drawcalls || json.data.offsets;\n\n    if (groups !== undefined) {\n      for (let i = 0, n = groups.length; i !== n; ++i) {\n        const group = groups[i];\n        geometry.addGroup(group.start, group.count, group.materialIndex);\n      }\n    }\n\n    const boundingSphere = json.data.boundingSphere;\n\n    if (boundingSphere !== undefined) {\n      const center = new Vector3();\n\n      if (boundingSphere.center !== undefined) {\n        center.fromArray(boundingSphere.center);\n      }\n\n      geometry.boundingSphere = new Sphere(center, boundingSphere.radius);\n    }\n\n    if (json.name) geometry.name = json.name;\n    if (json.userData) geometry.userData = json.userData;\n    return geometry;\n  }\n\n}\n\nexport { BufferGeometryLoader };","map":{"version":3,"sources":["C:/Users/dell/Desktop/projektlogin/vue-3-authentication-jwt/src/games/three/src/loaders/BufferGeometryLoader.js"],"names":["Sphere","Vector3","BufferAttribute","BufferGeometry","FileLoader","Loader","InstancedBufferGeometry","InstancedBufferAttribute","InterleavedBufferAttribute","InterleavedBuffer","getTypedArray","BufferGeometryLoader","constructor","manager","load","url","onLoad","onProgress","onError","scope","loader","setPath","path","setRequestHeader","requestHeader","setWithCredentials","withCredentials","text","parse","JSON","e","console","error","itemError","json","interleavedBufferMap","arrayBufferMap","getInterleavedBuffer","uuid","undefined","interleavedBuffers","interleavedBuffer","buffer","getArrayBuffer","array","type","ib","stride","arrayBuffers","arrayBuffer","ab","Uint32Array","geometry","isInstancedBufferGeometry","index","data","typedArray","setIndex","attributes","key","attribute","bufferAttribute","isInterleavedBufferAttribute","itemSize","offset","normalized","bufferAttributeConstr","isInstancedBufferAttribute","name","usage","setUsage","updateRange","count","setAttribute","morphAttributes","attributeArray","i","il","length","push","morphTargetsRelative","groups","drawcalls","offsets","n","group","addGroup","start","materialIndex","boundingSphere","center","fromArray","radius","userData"],"mappings":"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","sourcesContent":["import { Sphere } from '../math/Sphere.js';\r\nimport { Vector3 } from '../math/Vector3.js';\r\nimport { BufferAttribute } from '../core/BufferAttribute.js';\r\nimport { BufferGeometry } from '../core/BufferGeometry.js';\r\nimport { FileLoader } from './FileLoader.js';\r\nimport { Loader } from './Loader.js';\r\nimport { InstancedBufferGeometry } from '../core/InstancedBufferGeometry.js';\r\nimport { InstancedBufferAttribute } from '../core/InstancedBufferAttribute.js';\r\nimport { InterleavedBufferAttribute } from '../core/InterleavedBufferAttribute.js';\r\nimport { InterleavedBuffer } from '../core/InterleavedBuffer.js';\r\nimport { getTypedArray } from '../utils.js';\r\n\r\nclass BufferGeometryLoader extends Loader {\r\n\r\n\tconstructor( manager ) {\r\n\r\n\t\tsuper( manager );\r\n\r\n\t}\r\n\r\n\tload( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tconst scope = this;\r\n\r\n\t\tconst loader = new FileLoader( scope.manager );\r\n\t\tloader.setPath( scope.path );\r\n\t\tloader.setRequestHeader( scope.requestHeader );\r\n\t\tloader.setWithCredentials( scope.withCredentials );\r\n\t\tloader.load( url, function ( text ) {\r\n\r\n\t\t\ttry {\r\n\r\n\t\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\r\n\r\n\t\t\t} catch ( e ) {\r\n\r\n\t\t\t\tif ( onError ) {\r\n\r\n\t\t\t\t\tonError( e );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tconsole.error( e );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tscope.manager.itemError( url );\r\n\r\n\t\t\t}\r\n\r\n\t\t}, onProgress, onError );\r\n\r\n\t}\r\n\r\n\tparse( json ) {\r\n\r\n\t\tconst interleavedBufferMap = {};\r\n\t\tconst arrayBufferMap = {};\r\n\r\n\t\tfunction getInterleavedBuffer( json, uuid ) {\r\n\r\n\t\t\tif ( interleavedBufferMap[ uuid ] !== undefined ) return interleavedBufferMap[ uuid ];\r\n\r\n\t\t\tconst interleavedBuffers = json.interleavedBuffers;\r\n\t\t\tconst interleavedBuffer = interleavedBuffers[ uuid ];\r\n\r\n\t\t\tconst buffer = getArrayBuffer( json, interleavedBuffer.buffer );\r\n\r\n\t\t\tconst array = getTypedArray( interleavedBuffer.type, buffer );\r\n\t\t\tconst ib = new InterleavedBuffer( array, interleavedBuffer.stride );\r\n\t\t\tib.uuid = interleavedBuffer.uuid;\r\n\r\n\t\t\tinterleavedBufferMap[ uuid ] = ib;\r\n\r\n\t\t\treturn ib;\r\n\r\n\t\t}\r\n\r\n\t\tfunction getArrayBuffer( json, uuid ) {\r\n\r\n\t\t\tif ( arrayBufferMap[ uuid ] !== undefined ) return arrayBufferMap[ uuid ];\r\n\r\n\t\t\tconst arrayBuffers = json.arrayBuffers;\r\n\t\t\tconst arrayBuffer = arrayBuffers[ uuid ];\r\n\r\n\t\t\tconst ab = new Uint32Array( arrayBuffer ).buffer;\r\n\r\n\t\t\tarrayBufferMap[ uuid ] = ab;\r\n\r\n\t\t\treturn ab;\r\n\r\n\t\t}\r\n\r\n\t\tconst geometry = json.isInstancedBufferGeometry ? new InstancedBufferGeometry() : new BufferGeometry();\r\n\r\n\t\tconst index = json.data.index;\r\n\r\n\t\tif ( index !== undefined ) {\r\n\r\n\t\t\tconst typedArray = getTypedArray( index.type, index.array );\r\n\t\t\tgeometry.setIndex( new BufferAttribute( typedArray, 1 ) );\r\n\r\n\t\t}\r\n\r\n\t\tconst attributes = json.data.attributes;\r\n\r\n\t\tfor ( const key in attributes ) {\r\n\r\n\t\t\tconst attribute = attributes[ key ];\r\n\t\t\tlet bufferAttribute;\r\n\r\n\t\t\tif ( attribute.isInterleavedBufferAttribute ) {\r\n\r\n\t\t\t\tconst interleavedBuffer = getInterleavedBuffer( json.data, attribute.data );\r\n\t\t\t\tbufferAttribute = new InterleavedBufferAttribute( interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tconst typedArray = getTypedArray( attribute.type, attribute.array );\r\n\t\t\t\tconst bufferAttributeConstr = attribute.isInstancedBufferAttribute ? InstancedBufferAttribute : BufferAttribute;\r\n\t\t\t\tbufferAttribute = new bufferAttributeConstr( typedArray, attribute.itemSize, attribute.normalized );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( attribute.name !== undefined ) bufferAttribute.name = attribute.name;\r\n\t\t\tif ( attribute.usage !== undefined ) bufferAttribute.setUsage( attribute.usage );\r\n\r\n\t\t\tif ( attribute.updateRange !== undefined ) {\r\n\r\n\t\t\t\tbufferAttribute.updateRange.offset = attribute.updateRange.offset;\r\n\t\t\t\tbufferAttribute.updateRange.count = attribute.updateRange.count;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgeometry.setAttribute( key, bufferAttribute );\r\n\r\n\t\t}\r\n\r\n\t\tconst morphAttributes = json.data.morphAttributes;\r\n\r\n\t\tif ( morphAttributes ) {\r\n\r\n\t\t\tfor ( const key in morphAttributes ) {\r\n\r\n\t\t\t\tconst attributeArray = morphAttributes[ key ];\r\n\r\n\t\t\t\tconst array = [];\r\n\r\n\t\t\t\tfor ( let i = 0, il = attributeArray.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tconst attribute = attributeArray[ i ];\r\n\t\t\t\t\tlet bufferAttribute;\r\n\r\n\t\t\t\t\tif ( attribute.isInterleavedBufferAttribute ) {\r\n\r\n\t\t\t\t\t\tconst interleavedBuffer = getInterleavedBuffer( json.data, attribute.data );\r\n\t\t\t\t\t\tbufferAttribute = new InterleavedBufferAttribute( interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tconst typedArray = getTypedArray( attribute.type, attribute.array );\r\n\t\t\t\t\t\tbufferAttribute = new BufferAttribute( typedArray, attribute.itemSize, attribute.normalized );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( attribute.name !== undefined ) bufferAttribute.name = attribute.name;\r\n\t\t\t\t\tarray.push( bufferAttribute );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tgeometry.morphAttributes[ key ] = array;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tconst morphTargetsRelative = json.data.morphTargetsRelative;\r\n\r\n\t\tif ( morphTargetsRelative ) {\r\n\r\n\t\t\tgeometry.morphTargetsRelative = true;\r\n\r\n\t\t}\r\n\r\n\t\tconst groups = json.data.groups || json.data.drawcalls || json.data.offsets;\r\n\r\n\t\tif ( groups !== undefined ) {\r\n\r\n\t\t\tfor ( let i = 0, n = groups.length; i !== n; ++ i ) {\r\n\r\n\t\t\t\tconst group = groups[ i ];\r\n\r\n\t\t\t\tgeometry.addGroup( group.start, group.count, group.materialIndex );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tconst boundingSphere = json.data.boundingSphere;\r\n\r\n\t\tif ( boundingSphere !== undefined ) {\r\n\r\n\t\t\tconst center = new Vector3();\r\n\r\n\t\t\tif ( boundingSphere.center !== undefined ) {\r\n\r\n\t\t\t\tcenter.fromArray( boundingSphere.center );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgeometry.boundingSphere = new Sphere( center, boundingSphere.radius );\r\n\r\n\t\t}\r\n\r\n\t\tif ( json.name ) geometry.name = json.name;\r\n\t\tif ( json.userData ) geometry.userData = json.userData;\r\n\r\n\t\treturn geometry;\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport { BufferGeometryLoader };\r\n"]},"metadata":{},"sourceType":"module"}