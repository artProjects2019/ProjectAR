{"ast":null,"code":"export default\n/* glsl */\n`\n#ifdef ENVMAP_TYPE_CUBE_UV\n\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\n\t// These shader functions convert between the UV coordinates of a single face of\n\t// a cubemap, the 0-5 integer index of a cube face, and the direction vector for\n\t// sampling a textureCube (not generally normalized ).\n\n\tfloat getFace( vec3 direction ) {\n\n\t\tvec3 absDirection = abs( direction );\n\n\t\tfloat face = - 1.0;\n\n\t\tif ( absDirection.x > absDirection.z ) {\n\n\t\t\tif ( absDirection.x > absDirection.y )\n\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\n\t\t\telse\n\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\n\t\t} else {\n\n\t\t\tif ( absDirection.z > absDirection.y )\n\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\n\t\t\telse\n\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\n\t\t}\n\n\t\treturn face;\n\n\t}\n\n\t// RH coordinate system; PMREM face-indexing convention\n\tvec2 getUV( vec3 direction, float face ) {\n\n\t\tvec2 uv;\n\n\t\tif ( face == 0.0 ) {\n\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x ); // pos x\n\n\t\t} else if ( face == 1.0 ) {\n\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y ); // pos y\n\n\t\t} else if ( face == 2.0 ) {\n\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z ); // pos z\n\n\t\t} else if ( face == 3.0 ) {\n\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x ); // neg x\n\n\t\t} else if ( face == 4.0 ) {\n\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y ); // neg y\n\n\t\t} else {\n\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z ); // neg z\n\n\t\t}\n\n\t\treturn 0.5 * ( uv + 1.0 );\n\n\t}\n\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\n\t\tfloat face = getFace( direction );\n\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\n\t\tfloat faceSize = exp2( mipInt );\n\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 ) + 0.5;\n\n\t\tif ( face > 2.0 ) {\n\n\t\t\tuv.y += faceSize;\n\n\t\t\tface -= 3.0;\n\n\t\t}\n\n\t\tuv.x += face * faceSize;\n\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\n\t\t#ifdef texture2DGradEXT\n\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb; // disable anisotropic filtering\n\n\t\t#else\n\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\n\t\t#endif\n\n\t}\n\n\t// These defines must match with PMREMGenerator\n\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\n\tfloat roughnessToMip( float roughness ) {\n\n\t\tfloat mip = 0.0;\n\n\t\tif ( roughness >= r1 ) {\n\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\n\t\t} else if ( roughness >= r4 ) {\n\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\n\t\t} else if ( roughness >= r5 ) {\n\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\n\t\t} else if ( roughness >= r6 ) {\n\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\n\t\t} else {\n\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness ); // 1.16 = 1.79^0.25\n\t\t}\n\n\t\treturn mip;\n\n\t}\n\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, CUBEUV_MAX_MIP );\n\n\t\tfloat mipF = fract( mip );\n\n\t\tfloat mipInt = floor( mip );\n\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\n\t\tif ( mipF == 0.0 ) {\n\n\t\t\treturn vec4( color0, 1.0 );\n\n\t\t} else {\n\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\n\t\t}\n\n\t}\n\n#endif\n`;","map":{"version":3,"sources":["C:/Users/dell/Desktop/projektlogin/vue-3-authentication-jwt/src/games/three/src/renderers/shaders/ShaderChunk/cube_uv_reflection_fragment.glsl.js"],"names":[],"mappings":"AAAA;AAAe;AAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CA9LA","sourcesContent":["export default /* glsl */`\r\n#ifdef ENVMAP_TYPE_CUBE_UV\r\n\r\n\t#define cubeUV_minMipLevel 4.0\r\n\t#define cubeUV_minTileSize 16.0\r\n\r\n\t// These shader functions convert between the UV coordinates of a single face of\r\n\t// a cubemap, the 0-5 integer index of a cube face, and the direction vector for\r\n\t// sampling a textureCube (not generally normalized ).\r\n\r\n\tfloat getFace( vec3 direction ) {\r\n\r\n\t\tvec3 absDirection = abs( direction );\r\n\r\n\t\tfloat face = - 1.0;\r\n\r\n\t\tif ( absDirection.x > absDirection.z ) {\r\n\r\n\t\t\tif ( absDirection.x > absDirection.y )\r\n\r\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\r\n\r\n\t\t\telse\r\n\r\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tif ( absDirection.z > absDirection.y )\r\n\r\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\r\n\r\n\t\t\telse\r\n\r\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\r\n\r\n\t\t}\r\n\r\n\t\treturn face;\r\n\r\n\t}\r\n\r\n\t// RH coordinate system; PMREM face-indexing convention\r\n\tvec2 getUV( vec3 direction, float face ) {\r\n\r\n\t\tvec2 uv;\r\n\r\n\t\tif ( face == 0.0 ) {\r\n\r\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x ); // pos x\r\n\r\n\t\t} else if ( face == 1.0 ) {\r\n\r\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y ); // pos y\r\n\r\n\t\t} else if ( face == 2.0 ) {\r\n\r\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z ); // pos z\r\n\r\n\t\t} else if ( face == 3.0 ) {\r\n\r\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x ); // neg x\r\n\r\n\t\t} else if ( face == 4.0 ) {\r\n\r\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y ); // neg y\r\n\r\n\t\t} else {\r\n\r\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z ); // neg z\r\n\r\n\t\t}\r\n\r\n\t\treturn 0.5 * ( uv + 1.0 );\r\n\r\n\t}\r\n\r\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\r\n\r\n\t\tfloat face = getFace( direction );\r\n\r\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\r\n\r\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\r\n\r\n\t\tfloat faceSize = exp2( mipInt );\r\n\r\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 ) + 0.5;\r\n\r\n\t\tif ( face > 2.0 ) {\r\n\r\n\t\t\tuv.y += faceSize;\r\n\r\n\t\t\tface -= 3.0;\r\n\r\n\t\t}\r\n\r\n\t\tuv.x += face * faceSize;\r\n\r\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\r\n\r\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\r\n\r\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\r\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\r\n\r\n\t\t#ifdef texture2DGradEXT\r\n\r\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb; // disable anisotropic filtering\r\n\r\n\t\t#else\r\n\r\n\t\t\treturn texture2D( envMap, uv ).rgb;\r\n\r\n\t\t#endif\r\n\r\n\t}\r\n\r\n\t// These defines must match with PMREMGenerator\r\n\r\n\t#define r0 1.0\r\n\t#define v0 0.339\r\n\t#define m0 - 2.0\r\n\t#define r1 0.8\r\n\t#define v1 0.276\r\n\t#define m1 - 1.0\r\n\t#define r4 0.4\r\n\t#define v4 0.046\r\n\t#define m4 2.0\r\n\t#define r5 0.305\r\n\t#define v5 0.016\r\n\t#define m5 3.0\r\n\t#define r6 0.21\r\n\t#define v6 0.0038\r\n\t#define m6 4.0\r\n\r\n\tfloat roughnessToMip( float roughness ) {\r\n\r\n\t\tfloat mip = 0.0;\r\n\r\n\t\tif ( roughness >= r1 ) {\r\n\r\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\r\n\r\n\t\t} else if ( roughness >= r4 ) {\r\n\r\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\r\n\r\n\t\t} else if ( roughness >= r5 ) {\r\n\r\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\r\n\r\n\t\t} else if ( roughness >= r6 ) {\r\n\r\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness ); // 1.16 = 1.79^0.25\r\n\t\t}\r\n\r\n\t\treturn mip;\r\n\r\n\t}\r\n\r\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\r\n\r\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, CUBEUV_MAX_MIP );\r\n\r\n\t\tfloat mipF = fract( mip );\r\n\r\n\t\tfloat mipInt = floor( mip );\r\n\r\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\r\n\r\n\t\tif ( mipF == 0.0 ) {\r\n\r\n\t\t\treturn vec4( color0, 1.0 );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\r\n\r\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n#endif\r\n`;\r\n"]},"metadata":{},"sourceType":"module"}