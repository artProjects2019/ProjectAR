{"ast":null,"code":"import { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport { Shape } from '../extras/core/Shape.js';\nimport { ShapeUtils } from '../extras/ShapeUtils.js';\nimport { Vector2 } from '../math/Vector2.js';\n\nclass ShapeGeometry extends BufferGeometry {\n  constructor(shapes = new Shape([new Vector2(0, 0.5), new Vector2(-0.5, -0.5), new Vector2(0.5, -0.5)]), curveSegments = 12) {\n    super();\n    this.type = 'ShapeGeometry';\n    this.parameters = {\n      shapes: shapes,\n      curveSegments: curveSegments\n    }; // buffers\n\n    const indices = [];\n    const vertices = [];\n    const normals = [];\n    const uvs = []; // helper variables\n\n    let groupStart = 0;\n    let groupCount = 0; // allow single and array values for \"shapes\" parameter\n\n    if (Array.isArray(shapes) === false) {\n      addShape(shapes);\n    } else {\n      for (let i = 0; i < shapes.length; i++) {\n        addShape(shapes[i]);\n        this.addGroup(groupStart, groupCount, i); // enables MultiMaterial support\n\n        groupStart += groupCount;\n        groupCount = 0;\n      }\n    } // build geometry\n\n\n    this.setIndex(indices);\n    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2)); // helper functions\n\n    function addShape(shape) {\n      const indexOffset = vertices.length / 3;\n      const points = shape.extractPoints(curveSegments);\n      let shapeVertices = points.shape;\n      const shapeHoles = points.holes; // check direction of vertices\n\n      if (ShapeUtils.isClockWise(shapeVertices) === false) {\n        shapeVertices = shapeVertices.reverse();\n      }\n\n      for (let i = 0, l = shapeHoles.length; i < l; i++) {\n        const shapeHole = shapeHoles[i];\n\n        if (ShapeUtils.isClockWise(shapeHole) === true) {\n          shapeHoles[i] = shapeHole.reverse();\n        }\n      }\n\n      const faces = ShapeUtils.triangulateShape(shapeVertices, shapeHoles); // join vertices of inner and outer paths to a single array\n\n      for (let i = 0, l = shapeHoles.length; i < l; i++) {\n        const shapeHole = shapeHoles[i];\n        shapeVertices = shapeVertices.concat(shapeHole);\n      } // vertices, normals, uvs\n\n\n      for (let i = 0, l = shapeVertices.length; i < l; i++) {\n        const vertex = shapeVertices[i];\n        vertices.push(vertex.x, vertex.y, 0);\n        normals.push(0, 0, 1);\n        uvs.push(vertex.x, vertex.y); // world uvs\n      } // incides\n\n\n      for (let i = 0, l = faces.length; i < l; i++) {\n        const face = faces[i];\n        const a = face[0] + indexOffset;\n        const b = face[1] + indexOffset;\n        const c = face[2] + indexOffset;\n        indices.push(a, b, c);\n        groupCount += 3;\n      }\n    }\n  }\n\n  toJSON() {\n    const data = super.toJSON();\n    const shapes = this.parameters.shapes;\n    return toJSON(shapes, data);\n  }\n\n  static fromJSON(data, shapes) {\n    const geometryShapes = [];\n\n    for (let j = 0, jl = data.shapes.length; j < jl; j++) {\n      const shape = shapes[data.shapes[j]];\n      geometryShapes.push(shape);\n    }\n\n    return new ShapeGeometry(geometryShapes, data.curveSegments);\n  }\n\n}\n\nfunction toJSON(shapes, data) {\n  data.shapes = [];\n\n  if (Array.isArray(shapes)) {\n    for (let i = 0, l = shapes.length; i < l; i++) {\n      const shape = shapes[i];\n      data.shapes.push(shape.uuid);\n    }\n  } else {\n    data.shapes.push(shapes.uuid);\n  }\n\n  return data;\n}\n\nexport { ShapeGeometry, ShapeGeometry as ShapeBufferGeometry };","map":{"version":3,"sources":["C:/Users/dell/Desktop/projektlogin/vue-3-authentication-jwt/src/games/three/src/geometries/ShapeGeometry.js"],"names":["BufferGeometry","Float32BufferAttribute","Shape","ShapeUtils","Vector2","ShapeGeometry","constructor","shapes","curveSegments","type","parameters","indices","vertices","normals","uvs","groupStart","groupCount","Array","isArray","addShape","i","length","addGroup","setIndex","setAttribute","shape","indexOffset","points","extractPoints","shapeVertices","shapeHoles","holes","isClockWise","reverse","l","shapeHole","faces","triangulateShape","concat","vertex","push","x","y","face","a","b","c","toJSON","data","fromJSON","geometryShapes","j","jl","uuid","ShapeBufferGeometry"],"mappings":"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","sourcesContent":["import { BufferGeometry } from '../core/BufferGeometry.js';\r\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\r\nimport { Shape } from '../extras/core/Shape.js';\r\nimport { ShapeUtils } from '../extras/ShapeUtils.js';\r\nimport { Vector2 } from '../math/Vector2.js';\r\n\r\nclass ShapeGeometry extends BufferGeometry {\r\n\r\n\tconstructor( shapes = new Shape( [ new Vector2( 0, 0.5 ), new Vector2( - 0.5, - 0.5 ), new Vector2( 0.5, - 0.5 ) ] ), curveSegments = 12 ) {\r\n\r\n\t\tsuper();\r\n\t\tthis.type = 'ShapeGeometry';\r\n\r\n\t\tthis.parameters = {\r\n\t\t\tshapes: shapes,\r\n\t\t\tcurveSegments: curveSegments\r\n\t\t};\r\n\r\n\t\t// buffers\r\n\r\n\t\tconst indices = [];\r\n\t\tconst vertices = [];\r\n\t\tconst normals = [];\r\n\t\tconst uvs = [];\r\n\r\n\t\t// helper variables\r\n\r\n\t\tlet groupStart = 0;\r\n\t\tlet groupCount = 0;\r\n\r\n\t\t// allow single and array values for \"shapes\" parameter\r\n\r\n\t\tif ( Array.isArray( shapes ) === false ) {\r\n\r\n\t\t\taddShape( shapes );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tfor ( let i = 0; i < shapes.length; i ++ ) {\r\n\r\n\t\t\t\taddShape( shapes[ i ] );\r\n\r\n\t\t\t\tthis.addGroup( groupStart, groupCount, i ); // enables MultiMaterial support\r\n\r\n\t\t\t\tgroupStart += groupCount;\r\n\t\t\t\tgroupCount = 0;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// build geometry\r\n\r\n\t\tthis.setIndex( indices );\r\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\r\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\r\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\r\n\r\n\r\n\t\t// helper functions\r\n\r\n\t\tfunction addShape( shape ) {\r\n\r\n\t\t\tconst indexOffset = vertices.length / 3;\r\n\t\t\tconst points = shape.extractPoints( curveSegments );\r\n\r\n\t\t\tlet shapeVertices = points.shape;\r\n\t\t\tconst shapeHoles = points.holes;\r\n\r\n\t\t\t// check direction of vertices\r\n\r\n\t\t\tif ( ShapeUtils.isClockWise( shapeVertices ) === false ) {\r\n\r\n\t\t\t\tshapeVertices = shapeVertices.reverse();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( let i = 0, l = shapeHoles.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tconst shapeHole = shapeHoles[ i ];\r\n\r\n\t\t\t\tif ( ShapeUtils.isClockWise( shapeHole ) === true ) {\r\n\r\n\t\t\t\t\tshapeHoles[ i ] = shapeHole.reverse();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst faces = ShapeUtils.triangulateShape( shapeVertices, shapeHoles );\r\n\r\n\t\t\t// join vertices of inner and outer paths to a single array\r\n\r\n\t\t\tfor ( let i = 0, l = shapeHoles.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tconst shapeHole = shapeHoles[ i ];\r\n\t\t\t\tshapeVertices = shapeVertices.concat( shapeHole );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// vertices, normals, uvs\r\n\r\n\t\t\tfor ( let i = 0, l = shapeVertices.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tconst vertex = shapeVertices[ i ];\r\n\r\n\t\t\t\tvertices.push( vertex.x, vertex.y, 0 );\r\n\t\t\t\tnormals.push( 0, 0, 1 );\r\n\t\t\t\tuvs.push( vertex.x, vertex.y ); // world uvs\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// incides\r\n\r\n\t\t\tfor ( let i = 0, l = faces.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tconst face = faces[ i ];\r\n\r\n\t\t\t\tconst a = face[ 0 ] + indexOffset;\r\n\t\t\t\tconst b = face[ 1 ] + indexOffset;\r\n\t\t\t\tconst c = face[ 2 ] + indexOffset;\r\n\r\n\t\t\t\tindices.push( a, b, c );\r\n\t\t\t\tgroupCount += 3;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\ttoJSON() {\r\n\r\n\t\tconst data = super.toJSON();\r\n\r\n\t\tconst shapes = this.parameters.shapes;\r\n\r\n\t\treturn toJSON( shapes, data );\r\n\r\n\t}\r\n\r\n\tstatic fromJSON( data, shapes ) {\r\n\r\n\t\tconst geometryShapes = [];\r\n\r\n\t\tfor ( let j = 0, jl = data.shapes.length; j < jl; j ++ ) {\r\n\r\n\t\t\tconst shape = shapes[ data.shapes[ j ] ];\r\n\r\n\t\t\tgeometryShapes.push( shape );\r\n\r\n\t\t}\r\n\r\n\t\treturn new ShapeGeometry( geometryShapes, data.curveSegments );\r\n\r\n\t}\r\n\r\n}\r\n\r\nfunction toJSON( shapes, data ) {\r\n\r\n\tdata.shapes = [];\r\n\r\n\tif ( Array.isArray( shapes ) ) {\r\n\r\n\t\tfor ( let i = 0, l = shapes.length; i < l; i ++ ) {\r\n\r\n\t\t\tconst shape = shapes[ i ];\r\n\r\n\t\t\tdata.shapes.push( shape.uuid );\r\n\r\n\t\t}\r\n\r\n\t} else {\r\n\r\n\t\tdata.shapes.push( shapes.uuid );\r\n\r\n\t}\r\n\r\n\treturn data;\r\n\r\n}\r\n\r\nexport { ShapeGeometry, ShapeGeometry as ShapeBufferGeometry };\r\n"]},"metadata":{},"sourceType":"module"}