{"ast":null,"code":"import \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\n\nconst _floatView = new Float32Array(1);\n\nconst _int32View = new Int32Array(_floatView.buffer);\n\nclass DataUtils {\n  // Converts float32 to float16 (stored as uint16 value).\n  static toHalfFloat(val) {\n    if (val > 65504) {\n      console.warn('THREE.DataUtils.toHalfFloat(): value exceeds 65504.');\n      val = 65504; // maximum representable value in float16\n    } // Source: http://gamedev.stackexchange.com/questions/17326/conversion-of-a-number-from-single-precision-floating-point-representation-to-a/17410#17410\n\n    /* This method is faster than the OpenEXR implementation (very often\r\n    * used, eg. in Ogre), with the additional benefit of rounding, inspired\r\n    * by James Tursa?s half-precision code. */\n\n\n    _floatView[0] = val;\n    const x = _int32View[0];\n    let bits = x >> 16 & 0x8000;\n    /* Get the sign */\n\n    let m = x >> 12 & 0x07ff;\n    /* Keep one extra bit for rounding */\n\n    const e = x >> 23 & 0xff;\n    /* Using int is faster here */\n\n    /* If zero, or denormal, or exponent underflows too much for a denormal\r\n    \t* half, return signed zero. */\n\n    if (e < 103) return bits;\n    /* If NaN, return NaN. If Inf or exponent overflow, return Inf. */\n\n    if (e > 142) {\n      bits |= 0x7c00;\n      /* If exponent was 0xff and one mantissa bit was set, it means NaN,\r\n      \t\t\t* not Inf, so make sure we set one mantissa bit too. */\n\n      bits |= (e == 255 ? 0 : 1) && x & 0x007fffff;\n      return bits;\n    }\n    /* If exponent underflows but not too much, return a denormal */\n\n\n    if (e < 113) {\n      m |= 0x0800;\n      /* Extra rounding may overflow and set mantissa to 0 and exponent\r\n      \t* to 1, which is OK. */\n\n      bits |= (m >> 114 - e) + (m >> 113 - e & 1);\n      return bits;\n    }\n\n    bits |= e - 112 << 10 | m >> 1;\n    /* Extra rounding. An overflow will set mantissa to 0 and increment\r\n    \t* the exponent, which is OK. */\n\n    bits += m & 1;\n    return bits;\n  }\n\n}\n\nexport { DataUtils };","map":{"version":3,"sources":["C:/Users/dell/Desktop/projektlogin/vue-3-authentication-jwt/src/games/three/src/extras/DataUtils.js"],"names":["_floatView","Float32Array","_int32View","Int32Array","buffer","DataUtils","toHalfFloat","val","console","warn","x","bits","m","e"],"mappings":";;;AAAA,MAAMA,UAAU,GAAG,IAAIC,YAAJ,CAAkB,CAAlB,CAAnB;;AACA,MAAMC,UAAU,GAAG,IAAIC,UAAJ,CAAgBH,UAAU,CAACI,MAA3B,CAAnB;;AAEA,MAAMC,SAAN,CAAgB;AAEf;AAEkB,SAAXC,WAAW,CAAEC,GAAF,EAAQ;AAEzB,QAAKA,GAAG,GAAG,KAAX,EAAmB;AAElBC,MAAAA,OAAO,CAACC,IAAR,CAAc,qDAAd;AAEAF,MAAAA,GAAG,GAAG,KAAN,CAJkB,CAIL;AAEb,KARwB,CAUzB;;AAEA;AACF;AACA;;;AAEEP,IAAAA,UAAU,CAAE,CAAF,CAAV,GAAkBO,GAAlB;AACA,UAAMG,CAAC,GAAGR,UAAU,CAAE,CAAF,CAApB;AAEA,QAAIS,IAAI,GAAKD,CAAC,IAAI,EAAP,GAAc,MAAzB;AAAiC;;AACjC,QAAIE,CAAC,GAAKF,CAAC,IAAI,EAAP,GAAc,MAAtB;AAA8B;;AAC9B,UAAMG,CAAC,GAAKH,CAAC,IAAI,EAAP,GAAc,IAAxB;AAA8B;;AAE9B;AACF;;AACE,QAAKG,CAAC,GAAG,GAAT,EAAe,OAAOF,IAAP;AAEf;;AACA,QAAKE,CAAC,GAAG,GAAT,EAAe;AAEdF,MAAAA,IAAI,IAAI,MAAR;AACA;AACH;;AACGA,MAAAA,IAAI,IAAI,CAAIE,CAAC,IAAI,GAAP,GAAe,CAAf,GAAmB,CAArB,KAA8BH,CAAC,GAAG,UAA1C;AACA,aAAOC,IAAP;AAEA;AAED;;;AACA,QAAKE,CAAC,GAAG,GAAT,EAAe;AAEdD,MAAAA,CAAC,IAAI,MAAL;AACA;AACH;;AACGD,MAAAA,IAAI,IAAI,CAAEC,CAAC,IAAM,MAAMC,CAAf,KAA2BD,CAAC,IAAM,MAAMC,CAAf,GAAuB,CAAhD,CAAR;AACA,aAAOF,IAAP;AAEA;;AAEDA,IAAAA,IAAI,IAAQE,CAAC,GAAG,GAAN,IAAe,EAAjB,GAA0BD,CAAC,IAAI,CAAvC;AACA;AACF;;AACED,IAAAA,IAAI,IAAIC,CAAC,GAAG,CAAZ;AACA,WAAOD,IAAP;AAEA;;AA3Dc;;AA+DhB,SAASN,SAAT","sourcesContent":["const _floatView = new Float32Array( 1 );\r\nconst _int32View = new Int32Array( _floatView.buffer );\r\n\r\nclass DataUtils {\r\n\r\n\t// Converts float32 to float16 (stored as uint16 value).\r\n\r\n\tstatic toHalfFloat( val ) {\r\n\r\n\t\tif ( val > 65504 ) {\r\n\r\n\t\t\tconsole.warn( 'THREE.DataUtils.toHalfFloat(): value exceeds 65504.' );\r\n\r\n\t\t\tval = 65504; // maximum representable value in float16\r\n\r\n\t\t}\r\n\r\n\t\t// Source: http://gamedev.stackexchange.com/questions/17326/conversion-of-a-number-from-single-precision-floating-point-representation-to-a/17410#17410\r\n\r\n\t\t/* This method is faster than the OpenEXR implementation (very often\r\n\t\t* used, eg. in Ogre), with the additional benefit of rounding, inspired\r\n\t\t* by James Tursa?s half-precision code. */\r\n\r\n\t\t_floatView[ 0 ] = val;\r\n\t\tconst x = _int32View[ 0 ];\r\n\r\n\t\tlet bits = ( x >> 16 ) & 0x8000; /* Get the sign */\r\n\t\tlet m = ( x >> 12 ) & 0x07ff; /* Keep one extra bit for rounding */\r\n\t\tconst e = ( x >> 23 ) & 0xff; /* Using int is faster here */\r\n\r\n\t\t/* If zero, or denormal, or exponent underflows too much for a denormal\r\n\t\t\t* half, return signed zero. */\r\n\t\tif ( e < 103 ) return bits;\r\n\r\n\t\t/* If NaN, return NaN. If Inf or exponent overflow, return Inf. */\r\n\t\tif ( e > 142 ) {\r\n\r\n\t\t\tbits |= 0x7c00;\r\n\t\t\t/* If exponent was 0xff and one mantissa bit was set, it means NaN,\r\n\t\t\t\t\t\t* not Inf, so make sure we set one mantissa bit too. */\r\n\t\t\tbits |= ( ( e == 255 ) ? 0 : 1 ) && ( x & 0x007fffff );\r\n\t\t\treturn bits;\r\n\r\n\t\t}\r\n\r\n\t\t/* If exponent underflows but not too much, return a denormal */\r\n\t\tif ( e < 113 ) {\r\n\r\n\t\t\tm |= 0x0800;\r\n\t\t\t/* Extra rounding may overflow and set mantissa to 0 and exponent\r\n\t\t\t\t* to 1, which is OK. */\r\n\t\t\tbits |= ( m >> ( 114 - e ) ) + ( ( m >> ( 113 - e ) ) & 1 );\r\n\t\t\treturn bits;\r\n\r\n\t\t}\r\n\r\n\t\tbits |= ( ( e - 112 ) << 10 ) | ( m >> 1 );\r\n\t\t/* Extra rounding. An overflow will set mantissa to 0 and increment\r\n\t\t\t* the exponent, which is OK. */\r\n\t\tbits += m & 1;\r\n\t\treturn bits;\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport { DataUtils };\r\n"]},"metadata":{},"sourceType":"module"}