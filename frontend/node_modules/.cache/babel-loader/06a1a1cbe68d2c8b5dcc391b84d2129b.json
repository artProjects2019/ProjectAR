{"ast":null,"code":"/**\r\n * Creates extruded geometry from a path shape.\r\n *\r\n * parameters = {\r\n *\r\n *  curveSegments: <int>, // number of points on the curves\r\n *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too\r\n *  depth: <float>, // Depth to extrude the shape\r\n *\r\n *  bevelEnabled: <bool>, // turn on bevel\r\n *  bevelThickness: <float>, // how deep into the original shape bevel goes\r\n *  bevelSize: <float>, // how far from shape outline (including bevelOffset) is bevel\r\n *  bevelOffset: <float>, // how far from shape outline does bevel start\r\n *  bevelSegments: <int>, // number of bevel layers\r\n *\r\n *  extrudePath: <THREE.Curve> // curve to extrude shape along\r\n *\r\n *  UVGenerator: <Object> // object that provides UV generator functions\r\n *\r\n * }\r\n */\nimport { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport * as Curves from '../extras/curves/Curves.js';\nimport { Vector2 } from '../math/Vector2.js';\nimport { Vector3 } from '../math/Vector3.js';\nimport { Shape } from '../extras/core/Shape.js';\nimport { ShapeUtils } from '../extras/ShapeUtils.js';\n\nclass ExtrudeGeometry extends BufferGeometry {\n  constructor(shapes = new Shape([new Vector2(0.5, 0.5), new Vector2(-0.5, 0.5), new Vector2(-0.5, -0.5), new Vector2(0.5, -0.5)]), options = {}) {\n    super();\n    this.type = 'ExtrudeGeometry';\n    this.parameters = {\n      shapes: shapes,\n      options: options\n    };\n    shapes = Array.isArray(shapes) ? shapes : [shapes];\n    const scope = this;\n    const verticesArray = [];\n    const uvArray = [];\n\n    for (let i = 0, l = shapes.length; i < l; i++) {\n      const shape = shapes[i];\n      addShape(shape);\n    } // build geometry\n\n\n    this.setAttribute('position', new Float32BufferAttribute(verticesArray, 3));\n    this.setAttribute('uv', new Float32BufferAttribute(uvArray, 2));\n    this.computeVertexNormals(); // functions\n\n    function addShape(shape) {\n      const placeholder = []; // options\n\n      const curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\n      const steps = options.steps !== undefined ? options.steps : 1;\n      let depth = options.depth !== undefined ? options.depth : 1;\n      let bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;\n      let bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 0.2;\n      let bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 0.1;\n      let bevelOffset = options.bevelOffset !== undefined ? options.bevelOffset : 0;\n      let bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;\n      const extrudePath = options.extrudePath;\n      const uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator; // deprecated options\n\n      if (options.amount !== undefined) {\n        console.warn('THREE.ExtrudeBufferGeometry: amount has been renamed to depth.');\n        depth = options.amount;\n      } //\n\n\n      let extrudePts,\n          extrudeByPath = false;\n      let splineTube, binormal, normal, position2;\n\n      if (extrudePath) {\n        extrudePts = extrudePath.getSpacedPoints(steps);\n        extrudeByPath = true;\n        bevelEnabled = false; // bevels not supported for path extrusion\n        // SETUP TNB variables\n        // TODO1 - have a .isClosed in spline?\n\n        splineTube = extrudePath.computeFrenetFrames(steps, false); // console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);\n\n        binormal = new Vector3();\n        normal = new Vector3();\n        position2 = new Vector3();\n      } // Safeguards if bevels are not enabled\n\n\n      if (!bevelEnabled) {\n        bevelSegments = 0;\n        bevelThickness = 0;\n        bevelSize = 0;\n        bevelOffset = 0;\n      } // Variables initialization\n\n\n      const shapePoints = shape.extractPoints(curveSegments);\n      let vertices = shapePoints.shape;\n      const holes = shapePoints.holes;\n      const reverse = !ShapeUtils.isClockWise(vertices);\n\n      if (reverse) {\n        vertices = vertices.reverse(); // Maybe we should also check if holes are in the opposite direction, just to be safe ...\n\n        for (let h = 0, hl = holes.length; h < hl; h++) {\n          const ahole = holes[h];\n\n          if (ShapeUtils.isClockWise(ahole)) {\n            holes[h] = ahole.reverse();\n          }\n        }\n      }\n\n      const faces = ShapeUtils.triangulateShape(vertices, holes);\n      /* Vertices */\n\n      const contour = vertices; // vertices has all points but contour has only points of circumference\n\n      for (let h = 0, hl = holes.length; h < hl; h++) {\n        const ahole = holes[h];\n        vertices = vertices.concat(ahole);\n      }\n\n      function scalePt2(pt, vec, size) {\n        if (!vec) console.error('THREE.ExtrudeGeometry: vec does not exist');\n        return vec.clone().multiplyScalar(size).add(pt);\n      }\n\n      const vlen = vertices.length,\n            flen = faces.length; // Find directions for point movement\n\n      function getBevelVec(inPt, inPrev, inNext) {\n        // computes for inPt the corresponding point inPt' on a new contour\n        //   shifted by 1 unit (length of normalized vector) to the left\n        // if we walk along contour clockwise, this new contour is outside the old one\n        //\n        // inPt' is the intersection of the two lines parallel to the two\n        //  adjacent edges of inPt at a distance of 1 unit on the left side.\n        let v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt\n        // good reading for geometry algorithms (here: line-line intersection)\n        // http://geomalgorithms.com/a05-_intersect-1.html\n\n        const v_prev_x = inPt.x - inPrev.x,\n              v_prev_y = inPt.y - inPrev.y;\n        const v_next_x = inNext.x - inPt.x,\n              v_next_y = inNext.y - inPt.y;\n        const v_prev_lensq = v_prev_x * v_prev_x + v_prev_y * v_prev_y; // check for collinear edges\n\n        const collinear0 = v_prev_x * v_next_y - v_prev_y * v_next_x;\n\n        if (Math.abs(collinear0) > Number.EPSILON) {\n          // not collinear\n          // length of vectors for normalizing\n          const v_prev_len = Math.sqrt(v_prev_lensq);\n          const v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y); // shift adjacent points by unit vectors to the left\n\n          const ptPrevShift_x = inPrev.x - v_prev_y / v_prev_len;\n          const ptPrevShift_y = inPrev.y + v_prev_x / v_prev_len;\n          const ptNextShift_x = inNext.x - v_next_y / v_next_len;\n          const ptNextShift_y = inNext.y + v_next_x / v_next_len; // scaling factor for v_prev to intersection point\n\n          const sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x); // vector from inPt to intersection point\n\n          v_trans_x = ptPrevShift_x + v_prev_x * sf - inPt.x;\n          v_trans_y = ptPrevShift_y + v_prev_y * sf - inPt.y; // Don't normalize!, otherwise sharp corners become ugly\n          //  but prevent crazy spikes\n\n          const v_trans_lensq = v_trans_x * v_trans_x + v_trans_y * v_trans_y;\n\n          if (v_trans_lensq <= 2) {\n            return new Vector2(v_trans_x, v_trans_y);\n          } else {\n            shrink_by = Math.sqrt(v_trans_lensq / 2);\n          }\n        } else {\n          // handle special case of collinear edges\n          let direction_eq = false; // assumes: opposite\n\n          if (v_prev_x > Number.EPSILON) {\n            if (v_next_x > Number.EPSILON) {\n              direction_eq = true;\n            }\n          } else {\n            if (v_prev_x < -Number.EPSILON) {\n              if (v_next_x < -Number.EPSILON) {\n                direction_eq = true;\n              }\n            } else {\n              if (Math.sign(v_prev_y) === Math.sign(v_next_y)) {\n                direction_eq = true;\n              }\n            }\n          }\n\n          if (direction_eq) {\n            // console.log(\"Warning: lines are a straight sequence\");\n            v_trans_x = -v_prev_y;\n            v_trans_y = v_prev_x;\n            shrink_by = Math.sqrt(v_prev_lensq);\n          } else {\n            // console.log(\"Warning: lines are a straight spike\");\n            v_trans_x = v_prev_x;\n            v_trans_y = v_prev_y;\n            shrink_by = Math.sqrt(v_prev_lensq / 2);\n          }\n        }\n\n        return new Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);\n      }\n\n      const contourMovements = [];\n\n      for (let i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {\n        if (j === il) j = 0;\n        if (k === il) k = 0; //  (j)---(i)---(k)\n        // console.log('i,j,k', i, j , k)\n\n        contourMovements[i] = getBevelVec(contour[i], contour[j], contour[k]);\n      }\n\n      const holesMovements = [];\n      let oneHoleMovements,\n          verticesMovements = contourMovements.concat();\n\n      for (let h = 0, hl = holes.length; h < hl; h++) {\n        const ahole = holes[h];\n        oneHoleMovements = [];\n\n        for (let i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {\n          if (j === il) j = 0;\n          if (k === il) k = 0; //  (j)---(i)---(k)\n\n          oneHoleMovements[i] = getBevelVec(ahole[i], ahole[j], ahole[k]);\n        }\n\n        holesMovements.push(oneHoleMovements);\n        verticesMovements = verticesMovements.concat(oneHoleMovements);\n      } // Loop bevelSegments, 1 for the front, 1 for the back\n\n\n      for (let b = 0; b < bevelSegments; b++) {\n        //for ( b = bevelSegments; b > 0; b -- ) {\n        const t = b / bevelSegments;\n        const z = bevelThickness * Math.cos(t * Math.PI / 2);\n        const bs = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset; // contract shape\n\n        for (let i = 0, il = contour.length; i < il; i++) {\n          const vert = scalePt2(contour[i], contourMovements[i], bs);\n          v(vert.x, vert.y, -z);\n        } // expand holes\n\n\n        for (let h = 0, hl = holes.length; h < hl; h++) {\n          const ahole = holes[h];\n          oneHoleMovements = holesMovements[h];\n\n          for (let i = 0, il = ahole.length; i < il; i++) {\n            const vert = scalePt2(ahole[i], oneHoleMovements[i], bs);\n            v(vert.x, vert.y, -z);\n          }\n        }\n      }\n\n      const bs = bevelSize + bevelOffset; // Back facing vertices\n\n      for (let i = 0; i < vlen; i++) {\n        const vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];\n\n        if (!extrudeByPath) {\n          v(vert.x, vert.y, 0);\n        } else {\n          // v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );\n          normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);\n          binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);\n          position2.copy(extrudePts[0]).add(normal).add(binormal);\n          v(position2.x, position2.y, position2.z);\n        }\n      } // Add stepped vertices...\n      // Including front facing vertices\n\n\n      for (let s = 1; s <= steps; s++) {\n        for (let i = 0; i < vlen; i++) {\n          const vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];\n\n          if (!extrudeByPath) {\n            v(vert.x, vert.y, depth / steps * s);\n          } else {\n            // v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );\n            normal.copy(splineTube.normals[s]).multiplyScalar(vert.x);\n            binormal.copy(splineTube.binormals[s]).multiplyScalar(vert.y);\n            position2.copy(extrudePts[s]).add(normal).add(binormal);\n            v(position2.x, position2.y, position2.z);\n          }\n        }\n      } // Add bevel segments planes\n      //for ( b = 1; b <= bevelSegments; b ++ ) {\n\n\n      for (let b = bevelSegments - 1; b >= 0; b--) {\n        const t = b / bevelSegments;\n        const z = bevelThickness * Math.cos(t * Math.PI / 2);\n        const bs = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset; // contract shape\n\n        for (let i = 0, il = contour.length; i < il; i++) {\n          const vert = scalePt2(contour[i], contourMovements[i], bs);\n          v(vert.x, vert.y, depth + z);\n        } // expand holes\n\n\n        for (let h = 0, hl = holes.length; h < hl; h++) {\n          const ahole = holes[h];\n          oneHoleMovements = holesMovements[h];\n\n          for (let i = 0, il = ahole.length; i < il; i++) {\n            const vert = scalePt2(ahole[i], oneHoleMovements[i], bs);\n\n            if (!extrudeByPath) {\n              v(vert.x, vert.y, depth + z);\n            } else {\n              v(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z);\n            }\n          }\n        }\n      }\n      /* Faces */\n      // Top and bottom faces\n\n\n      buildLidFaces(); // Sides faces\n\n      buildSideFaces(); /////  Internal functions\n\n      function buildLidFaces() {\n        const start = verticesArray.length / 3;\n\n        if (bevelEnabled) {\n          let layer = 0; // steps + 1\n\n          let offset = vlen * layer; // Bottom faces\n\n          for (let i = 0; i < flen; i++) {\n            const face = faces[i];\n            f3(face[2] + offset, face[1] + offset, face[0] + offset);\n          }\n\n          layer = steps + bevelSegments * 2;\n          offset = vlen * layer; // Top faces\n\n          for (let i = 0; i < flen; i++) {\n            const face = faces[i];\n            f3(face[0] + offset, face[1] + offset, face[2] + offset);\n          }\n        } else {\n          // Bottom faces\n          for (let i = 0; i < flen; i++) {\n            const face = faces[i];\n            f3(face[2], face[1], face[0]);\n          } // Top faces\n\n\n          for (let i = 0; i < flen; i++) {\n            const face = faces[i];\n            f3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps);\n          }\n        }\n\n        scope.addGroup(start, verticesArray.length / 3 - start, 0);\n      } // Create faces for the z-sides of the shape\n\n\n      function buildSideFaces() {\n        const start = verticesArray.length / 3;\n        let layeroffset = 0;\n        sidewalls(contour, layeroffset);\n        layeroffset += contour.length;\n\n        for (let h = 0, hl = holes.length; h < hl; h++) {\n          const ahole = holes[h];\n          sidewalls(ahole, layeroffset); //, true\n\n          layeroffset += ahole.length;\n        }\n\n        scope.addGroup(start, verticesArray.length / 3 - start, 1);\n      }\n\n      function sidewalls(contour, layeroffset) {\n        let i = contour.length;\n\n        while (--i >= 0) {\n          const j = i;\n          let k = i - 1;\n          if (k < 0) k = contour.length - 1; //console.log('b', i,j, i-1, k,vertices.length);\n\n          for (let s = 0, sl = steps + bevelSegments * 2; s < sl; s++) {\n            const slen1 = vlen * s;\n            const slen2 = vlen * (s + 1);\n            const a = layeroffset + j + slen1,\n                  b = layeroffset + k + slen1,\n                  c = layeroffset + k + slen2,\n                  d = layeroffset + j + slen2;\n            f4(a, b, c, d);\n          }\n        }\n      }\n\n      function v(x, y, z) {\n        placeholder.push(x);\n        placeholder.push(y);\n        placeholder.push(z);\n      }\n\n      function f3(a, b, c) {\n        addVertex(a);\n        addVertex(b);\n        addVertex(c);\n        const nextIndex = verticesArray.length / 3;\n        const uvs = uvgen.generateTopUV(scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);\n        addUV(uvs[0]);\n        addUV(uvs[1]);\n        addUV(uvs[2]);\n      }\n\n      function f4(a, b, c, d) {\n        addVertex(a);\n        addVertex(b);\n        addVertex(d);\n        addVertex(b);\n        addVertex(c);\n        addVertex(d);\n        const nextIndex = verticesArray.length / 3;\n        const uvs = uvgen.generateSideWallUV(scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);\n        addUV(uvs[0]);\n        addUV(uvs[1]);\n        addUV(uvs[3]);\n        addUV(uvs[1]);\n        addUV(uvs[2]);\n        addUV(uvs[3]);\n      }\n\n      function addVertex(index) {\n        verticesArray.push(placeholder[index * 3 + 0]);\n        verticesArray.push(placeholder[index * 3 + 1]);\n        verticesArray.push(placeholder[index * 3 + 2]);\n      }\n\n      function addUV(vector2) {\n        uvArray.push(vector2.x);\n        uvArray.push(vector2.y);\n      }\n    }\n  }\n\n  toJSON() {\n    const data = super.toJSON();\n    const shapes = this.parameters.shapes;\n    const options = this.parameters.options;\n    return toJSON(shapes, options, data);\n  }\n\n  static fromJSON(data, shapes) {\n    const geometryShapes = [];\n\n    for (let j = 0, jl = data.shapes.length; j < jl; j++) {\n      const shape = shapes[data.shapes[j]];\n      geometryShapes.push(shape);\n    }\n\n    const extrudePath = data.options.extrudePath;\n\n    if (extrudePath !== undefined) {\n      data.options.extrudePath = new Curves[extrudePath.type]().fromJSON(extrudePath);\n    }\n\n    return new ExtrudeGeometry(geometryShapes, data.options);\n  }\n\n}\n\nconst WorldUVGenerator = {\n  generateTopUV: function (geometry, vertices, indexA, indexB, indexC) {\n    const a_x = vertices[indexA * 3];\n    const a_y = vertices[indexA * 3 + 1];\n    const b_x = vertices[indexB * 3];\n    const b_y = vertices[indexB * 3 + 1];\n    const c_x = vertices[indexC * 3];\n    const c_y = vertices[indexC * 3 + 1];\n    return [new Vector2(a_x, a_y), new Vector2(b_x, b_y), new Vector2(c_x, c_y)];\n  },\n  generateSideWallUV: function (geometry, vertices, indexA, indexB, indexC, indexD) {\n    const a_x = vertices[indexA * 3];\n    const a_y = vertices[indexA * 3 + 1];\n    const a_z = vertices[indexA * 3 + 2];\n    const b_x = vertices[indexB * 3];\n    const b_y = vertices[indexB * 3 + 1];\n    const b_z = vertices[indexB * 3 + 2];\n    const c_x = vertices[indexC * 3];\n    const c_y = vertices[indexC * 3 + 1];\n    const c_z = vertices[indexC * 3 + 2];\n    const d_x = vertices[indexD * 3];\n    const d_y = vertices[indexD * 3 + 1];\n    const d_z = vertices[indexD * 3 + 2];\n\n    if (Math.abs(a_y - b_y) < Math.abs(a_x - b_x)) {\n      return [new Vector2(a_x, 1 - a_z), new Vector2(b_x, 1 - b_z), new Vector2(c_x, 1 - c_z), new Vector2(d_x, 1 - d_z)];\n    } else {\n      return [new Vector2(a_y, 1 - a_z), new Vector2(b_y, 1 - b_z), new Vector2(c_y, 1 - c_z), new Vector2(d_y, 1 - d_z)];\n    }\n  }\n};\n\nfunction toJSON(shapes, options, data) {\n  data.shapes = [];\n\n  if (Array.isArray(shapes)) {\n    for (let i = 0, l = shapes.length; i < l; i++) {\n      const shape = shapes[i];\n      data.shapes.push(shape.uuid);\n    }\n  } else {\n    data.shapes.push(shapes.uuid);\n  }\n\n  if (options.extrudePath !== undefined) data.options.extrudePath = options.extrudePath.toJSON();\n  return data;\n}\n\nexport { ExtrudeGeometry, ExtrudeGeometry as ExtrudeBufferGeometry };","map":{"version":3,"sources":["C:/Users/dell/Desktop/projektlogin/vue-3-authentication-jwt/src/games/three/src/geometries/ExtrudeGeometry.js"],"names":["BufferGeometry","Float32BufferAttribute","Curves","Vector2","Vector3","Shape","ShapeUtils","ExtrudeGeometry","constructor","shapes","options","type","parameters","Array","isArray","scope","verticesArray","uvArray","i","l","length","shape","addShape","setAttribute","computeVertexNormals","placeholder","curveSegments","undefined","steps","depth","bevelEnabled","bevelThickness","bevelSize","bevelOffset","bevelSegments","extrudePath","uvgen","UVGenerator","WorldUVGenerator","amount","console","warn","extrudePts","extrudeByPath","splineTube","binormal","normal","position2","getSpacedPoints","computeFrenetFrames","shapePoints","extractPoints","vertices","holes","reverse","isClockWise","h","hl","ahole","faces","triangulateShape","contour","concat","scalePt2","pt","vec","size","error","clone","multiplyScalar","add","vlen","flen","getBevelVec","inPt","inPrev","inNext","v_trans_x","v_trans_y","shrink_by","v_prev_x","x","v_prev_y","y","v_next_x","v_next_y","v_prev_lensq","collinear0","Math","abs","Number","EPSILON","v_prev_len","sqrt","v_next_len","ptPrevShift_x","ptPrevShift_y","ptNextShift_x","ptNextShift_y","sf","v_trans_lensq","direction_eq","sign","contourMovements","il","j","k","holesMovements","oneHoleMovements","verticesMovements","push","b","t","z","cos","PI","bs","sin","vert","v","copy","normals","binormals","s","buildLidFaces","buildSideFaces","start","layer","offset","face","f3","addGroup","layeroffset","sidewalls","sl","slen1","slen2","a","c","d","f4","addVertex","nextIndex","uvs","generateTopUV","addUV","generateSideWallUV","index","vector2","toJSON","data","fromJSON","geometryShapes","jl","geometry","indexA","indexB","indexC","a_x","a_y","b_x","b_y","c_x","c_y","indexD","a_z","b_z","c_z","d_x","d_y","d_z","uuid","ExtrudeBufferGeometry"],"mappings":"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","sourcesContent":["/**\r\n * Creates extruded geometry from a path shape.\r\n *\r\n * parameters = {\r\n *\r\n *  curveSegments: <int>, // number of points on the curves\r\n *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too\r\n *  depth: <float>, // Depth to extrude the shape\r\n *\r\n *  bevelEnabled: <bool>, // turn on bevel\r\n *  bevelThickness: <float>, // how deep into the original shape bevel goes\r\n *  bevelSize: <float>, // how far from shape outline (including bevelOffset) is bevel\r\n *  bevelOffset: <float>, // how far from shape outline does bevel start\r\n *  bevelSegments: <int>, // number of bevel layers\r\n *\r\n *  extrudePath: <THREE.Curve> // curve to extrude shape along\r\n *\r\n *  UVGenerator: <Object> // object that provides UV generator functions\r\n *\r\n * }\r\n */\r\n\r\nimport { BufferGeometry } from '../core/BufferGeometry.js';\r\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\r\nimport * as Curves from '../extras/curves/Curves.js';\r\nimport { Vector2 } from '../math/Vector2.js';\r\nimport { Vector3 } from '../math/Vector3.js';\r\nimport { Shape } from '../extras/core/Shape.js';\r\nimport { ShapeUtils } from '../extras/ShapeUtils.js';\r\n\r\nclass ExtrudeGeometry extends BufferGeometry {\r\n\r\n\tconstructor( shapes = new Shape( [ new Vector2( 0.5, 0.5 ), new Vector2( - 0.5, 0.5 ), new Vector2( - 0.5, - 0.5 ), new Vector2( 0.5, - 0.5 ) ] ), options = {} ) {\r\n\r\n\t\tsuper();\r\n\r\n\t\tthis.type = 'ExtrudeGeometry';\r\n\r\n\t\tthis.parameters = {\r\n\t\t\tshapes: shapes,\r\n\t\t\toptions: options\r\n\t\t};\r\n\r\n\t\tshapes = Array.isArray( shapes ) ? shapes : [ shapes ];\r\n\r\n\t\tconst scope = this;\r\n\r\n\t\tconst verticesArray = [];\r\n\t\tconst uvArray = [];\r\n\r\n\t\tfor ( let i = 0, l = shapes.length; i < l; i ++ ) {\r\n\r\n\t\t\tconst shape = shapes[ i ];\r\n\t\t\taddShape( shape );\r\n\r\n\t\t}\r\n\r\n\t\t// build geometry\r\n\r\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( verticesArray, 3 ) );\r\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvArray, 2 ) );\r\n\r\n\t\tthis.computeVertexNormals();\r\n\r\n\t\t// functions\r\n\r\n\t\tfunction addShape( shape ) {\r\n\r\n\t\t\tconst placeholder = [];\r\n\r\n\t\t\t// options\r\n\r\n\t\t\tconst curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\r\n\t\t\tconst steps = options.steps !== undefined ? options.steps : 1;\r\n\t\t\tlet depth = options.depth !== undefined ? options.depth : 1;\r\n\r\n\t\t\tlet bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;\r\n\t\t\tlet bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 0.2;\r\n\t\t\tlet bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 0.1;\r\n\t\t\tlet bevelOffset = options.bevelOffset !== undefined ? options.bevelOffset : 0;\r\n\t\t\tlet bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;\r\n\r\n\t\t\tconst extrudePath = options.extrudePath;\r\n\r\n\t\t\tconst uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator;\r\n\r\n\t\t\t// deprecated options\r\n\r\n\t\t\tif ( options.amount !== undefined ) {\r\n\r\n\t\t\t\tconsole.warn( 'THREE.ExtrudeBufferGeometry: amount has been renamed to depth.' );\r\n\t\t\t\tdepth = options.amount;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t//\r\n\r\n\t\t\tlet extrudePts, extrudeByPath = false;\r\n\t\t\tlet splineTube, binormal, normal, position2;\r\n\r\n\t\t\tif ( extrudePath ) {\r\n\r\n\t\t\t\textrudePts = extrudePath.getSpacedPoints( steps );\r\n\r\n\t\t\t\textrudeByPath = true;\r\n\t\t\t\tbevelEnabled = false; // bevels not supported for path extrusion\r\n\r\n\t\t\t\t// SETUP TNB variables\r\n\r\n\t\t\t\t// TODO1 - have a .isClosed in spline?\r\n\r\n\t\t\t\tsplineTube = extrudePath.computeFrenetFrames( steps, false );\r\n\r\n\t\t\t\t// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);\r\n\r\n\t\t\t\tbinormal = new Vector3();\r\n\t\t\t\tnormal = new Vector3();\r\n\t\t\t\tposition2 = new Vector3();\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Safeguards if bevels are not enabled\r\n\r\n\t\t\tif ( ! bevelEnabled ) {\r\n\r\n\t\t\t\tbevelSegments = 0;\r\n\t\t\t\tbevelThickness = 0;\r\n\t\t\t\tbevelSize = 0;\r\n\t\t\t\tbevelOffset = 0;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Variables initialization\r\n\r\n\t\t\tconst shapePoints = shape.extractPoints( curveSegments );\r\n\r\n\t\t\tlet vertices = shapePoints.shape;\r\n\t\t\tconst holes = shapePoints.holes;\r\n\r\n\t\t\tconst reverse = ! ShapeUtils.isClockWise( vertices );\r\n\r\n\t\t\tif ( reverse ) {\r\n\r\n\t\t\t\tvertices = vertices.reverse();\r\n\r\n\t\t\t\t// Maybe we should also check if holes are in the opposite direction, just to be safe ...\r\n\r\n\t\t\t\tfor ( let h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\r\n\t\t\t\t\tconst ahole = holes[ h ];\r\n\r\n\t\t\t\t\tif ( ShapeUtils.isClockWise( ahole ) ) {\r\n\r\n\t\t\t\t\t\tholes[ h ] = ahole.reverse();\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\r\n\t\t\tconst faces = ShapeUtils.triangulateShape( vertices, holes );\r\n\r\n\t\t\t/* Vertices */\r\n\r\n\t\t\tconst contour = vertices; // vertices has all points but contour has only points of circumference\r\n\r\n\t\t\tfor ( let h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\r\n\t\t\t\tconst ahole = holes[ h ];\r\n\r\n\t\t\t\tvertices = vertices.concat( ahole );\r\n\r\n\t\t\t}\r\n\r\n\r\n\t\t\tfunction scalePt2( pt, vec, size ) {\r\n\r\n\t\t\t\tif ( ! vec ) console.error( 'THREE.ExtrudeGeometry: vec does not exist' );\r\n\r\n\t\t\t\treturn vec.clone().multiplyScalar( size ).add( pt );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst vlen = vertices.length, flen = faces.length;\r\n\r\n\r\n\t\t\t// Find directions for point movement\r\n\r\n\r\n\t\t\tfunction getBevelVec( inPt, inPrev, inNext ) {\r\n\r\n\t\t\t\t// computes for inPt the corresponding point inPt' on a new contour\r\n\t\t\t\t//   shifted by 1 unit (length of normalized vector) to the left\r\n\t\t\t\t// if we walk along contour clockwise, this new contour is outside the old one\r\n\t\t\t\t//\r\n\t\t\t\t// inPt' is the intersection of the two lines parallel to the two\r\n\t\t\t\t//  adjacent edges of inPt at a distance of 1 unit on the left side.\r\n\r\n\t\t\t\tlet v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt\r\n\r\n\t\t\t\t// good reading for geometry algorithms (here: line-line intersection)\r\n\t\t\t\t// http://geomalgorithms.com/a05-_intersect-1.html\r\n\r\n\t\t\t\tconst v_prev_x = inPt.x - inPrev.x,\r\n\t\t\t\t\tv_prev_y = inPt.y - inPrev.y;\r\n\t\t\t\tconst v_next_x = inNext.x - inPt.x,\r\n\t\t\t\t\tv_next_y = inNext.y - inPt.y;\r\n\r\n\t\t\t\tconst v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );\r\n\r\n\t\t\t\t// check for collinear edges\r\n\t\t\t\tconst collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );\r\n\r\n\t\t\t\tif ( Math.abs( collinear0 ) > Number.EPSILON ) {\r\n\r\n\t\t\t\t\t// not collinear\r\n\r\n\t\t\t\t\t// length of vectors for normalizing\r\n\r\n\t\t\t\t\tconst v_prev_len = Math.sqrt( v_prev_lensq );\r\n\t\t\t\t\tconst v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );\r\n\r\n\t\t\t\t\t// shift adjacent points by unit vectors to the left\r\n\r\n\t\t\t\t\tconst ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );\r\n\t\t\t\t\tconst ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );\r\n\r\n\t\t\t\t\tconst ptNextShift_x = ( inNext.x - v_next_y / v_next_len );\r\n\t\t\t\t\tconst ptNextShift_y = ( inNext.y + v_next_x / v_next_len );\r\n\r\n\t\t\t\t\t// scaling factor for v_prev to intersection point\r\n\r\n\t\t\t\t\tconst sf = ( ( ptNextShift_x - ptPrevShift_x ) * v_next_y -\r\n\t\t\t\t\t\t\t( ptNextShift_y - ptPrevShift_y ) * v_next_x ) /\r\n\t\t\t\t\t\t( v_prev_x * v_next_y - v_prev_y * v_next_x );\r\n\r\n\t\t\t\t\t// vector from inPt to intersection point\r\n\r\n\t\t\t\t\tv_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );\r\n\t\t\t\t\tv_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );\r\n\r\n\t\t\t\t\t// Don't normalize!, otherwise sharp corners become ugly\r\n\t\t\t\t\t//  but prevent crazy spikes\r\n\t\t\t\t\tconst v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );\r\n\t\t\t\t\tif ( v_trans_lensq <= 2 ) {\r\n\r\n\t\t\t\t\t\treturn new Vector2( v_trans_x, v_trans_y );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tshrink_by = Math.sqrt( v_trans_lensq / 2 );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// handle special case of collinear edges\r\n\r\n\t\t\t\t\tlet direction_eq = false; // assumes: opposite\r\n\r\n\t\t\t\t\tif ( v_prev_x > Number.EPSILON ) {\r\n\r\n\t\t\t\t\t\tif ( v_next_x > Number.EPSILON ) {\r\n\r\n\t\t\t\t\t\t\tdirection_eq = true;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tif ( v_prev_x < - Number.EPSILON ) {\r\n\r\n\t\t\t\t\t\t\tif ( v_next_x < - Number.EPSILON ) {\r\n\r\n\t\t\t\t\t\t\t\tdirection_eq = true;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tif ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {\r\n\r\n\t\t\t\t\t\t\t\tdirection_eq = true;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( direction_eq ) {\r\n\r\n\t\t\t\t\t\t// console.log(\"Warning: lines are a straight sequence\");\r\n\t\t\t\t\t\tv_trans_x = - v_prev_y;\r\n\t\t\t\t\t\tv_trans_y = v_prev_x;\r\n\t\t\t\t\t\tshrink_by = Math.sqrt( v_prev_lensq );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t// console.log(\"Warning: lines are a straight spike\");\r\n\t\t\t\t\t\tv_trans_x = v_prev_x;\r\n\t\t\t\t\t\tv_trans_y = v_prev_y;\r\n\t\t\t\t\t\tshrink_by = Math.sqrt( v_prev_lensq / 2 );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn new Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );\r\n\r\n\t\t\t}\r\n\r\n\r\n\t\t\tconst contourMovements = [];\r\n\r\n\t\t\tfor ( let i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\r\n\r\n\t\t\t\tif ( j === il ) j = 0;\r\n\t\t\t\tif ( k === il ) k = 0;\r\n\r\n\t\t\t\t//  (j)---(i)---(k)\r\n\t\t\t\t// console.log('i,j,k', i, j , k)\r\n\r\n\t\t\t\tcontourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst holesMovements = [];\r\n\t\t\tlet oneHoleMovements, verticesMovements = contourMovements.concat();\r\n\r\n\t\t\tfor ( let h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\r\n\t\t\t\tconst ahole = holes[ h ];\r\n\r\n\t\t\t\toneHoleMovements = [];\r\n\r\n\t\t\t\tfor ( let i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\r\n\r\n\t\t\t\t\tif ( j === il ) j = 0;\r\n\t\t\t\t\tif ( k === il ) k = 0;\r\n\r\n\t\t\t\t\t//  (j)---(i)---(k)\r\n\t\t\t\t\toneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tholesMovements.push( oneHoleMovements );\r\n\t\t\t\tverticesMovements = verticesMovements.concat( oneHoleMovements );\r\n\r\n\t\t\t}\r\n\r\n\r\n\t\t\t// Loop bevelSegments, 1 for the front, 1 for the back\r\n\r\n\t\t\tfor ( let b = 0; b < bevelSegments; b ++ ) {\r\n\r\n\t\t\t\t//for ( b = bevelSegments; b > 0; b -- ) {\r\n\r\n\t\t\t\tconst t = b / bevelSegments;\r\n\t\t\t\tconst z = bevelThickness * Math.cos( t * Math.PI / 2 );\r\n\t\t\t\tconst bs = bevelSize * Math.sin( t * Math.PI / 2 ) + bevelOffset;\r\n\r\n\t\t\t\t// contract shape\r\n\r\n\t\t\t\tfor ( let i = 0, il = contour.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tconst vert = scalePt2( contour[ i ], contourMovements[ i ], bs );\r\n\r\n\t\t\t\t\tv( vert.x, vert.y, - z );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// expand holes\r\n\r\n\t\t\t\tfor ( let h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\r\n\t\t\t\t\tconst ahole = holes[ h ];\r\n\t\t\t\t\toneHoleMovements = holesMovements[ h ];\r\n\r\n\t\t\t\t\tfor ( let i = 0, il = ahole.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\t\tconst vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\r\n\r\n\t\t\t\t\t\tv( vert.x, vert.y, - z );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst bs = bevelSize + bevelOffset;\r\n\r\n\t\t\t// Back facing vertices\r\n\r\n\t\t\tfor ( let i = 0; i < vlen; i ++ ) {\r\n\r\n\t\t\t\tconst vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\r\n\r\n\t\t\t\tif ( ! extrudeByPath ) {\r\n\r\n\t\t\t\t\tv( vert.x, vert.y, 0 );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );\r\n\r\n\t\t\t\t\tnormal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );\r\n\t\t\t\t\tbinormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );\r\n\r\n\t\t\t\t\tposition2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );\r\n\r\n\t\t\t\t\tv( position2.x, position2.y, position2.z );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Add stepped vertices...\r\n\t\t\t// Including front facing vertices\r\n\r\n\t\t\tfor ( let s = 1; s <= steps; s ++ ) {\r\n\r\n\t\t\t\tfor ( let i = 0; i < vlen; i ++ ) {\r\n\r\n\t\t\t\t\tconst vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\r\n\r\n\t\t\t\t\tif ( ! extrudeByPath ) {\r\n\r\n\t\t\t\t\t\tv( vert.x, vert.y, depth / steps * s );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );\r\n\r\n\t\t\t\t\t\tnormal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );\r\n\t\t\t\t\t\tbinormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );\r\n\r\n\t\t\t\t\t\tposition2.copy( extrudePts[ s ] ).add( normal ).add( binormal );\r\n\r\n\t\t\t\t\t\tv( position2.x, position2.y, position2.z );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\r\n\t\t\t// Add bevel segments planes\r\n\r\n\t\t\t//for ( b = 1; b <= bevelSegments; b ++ ) {\r\n\t\t\tfor ( let b = bevelSegments - 1; b >= 0; b -- ) {\r\n\r\n\t\t\t\tconst t = b / bevelSegments;\r\n\t\t\t\tconst z = bevelThickness * Math.cos( t * Math.PI / 2 );\r\n\t\t\t\tconst bs = bevelSize * Math.sin( t * Math.PI / 2 ) + bevelOffset;\r\n\r\n\t\t\t\t// contract shape\r\n\r\n\t\t\t\tfor ( let i = 0, il = contour.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tconst vert = scalePt2( contour[ i ], contourMovements[ i ], bs );\r\n\t\t\t\t\tv( vert.x, vert.y, depth + z );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// expand holes\r\n\r\n\t\t\t\tfor ( let h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\r\n\t\t\t\t\tconst ahole = holes[ h ];\r\n\t\t\t\t\toneHoleMovements = holesMovements[ h ];\r\n\r\n\t\t\t\t\tfor ( let i = 0, il = ahole.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\t\tconst vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\r\n\r\n\t\t\t\t\t\tif ( ! extrudeByPath ) {\r\n\r\n\t\t\t\t\t\t\tv( vert.x, vert.y, depth + z );\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tv( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t/* Faces */\r\n\r\n\t\t\t// Top and bottom faces\r\n\r\n\t\t\tbuildLidFaces();\r\n\r\n\t\t\t// Sides faces\r\n\r\n\t\t\tbuildSideFaces();\r\n\r\n\r\n\t\t\t/////  Internal functions\r\n\r\n\t\t\tfunction buildLidFaces() {\r\n\r\n\t\t\t\tconst start = verticesArray.length / 3;\r\n\r\n\t\t\t\tif ( bevelEnabled ) {\r\n\r\n\t\t\t\t\tlet layer = 0; // steps + 1\r\n\t\t\t\t\tlet offset = vlen * layer;\r\n\r\n\t\t\t\t\t// Bottom faces\r\n\r\n\t\t\t\t\tfor ( let i = 0; i < flen; i ++ ) {\r\n\r\n\t\t\t\t\t\tconst face = faces[ i ];\r\n\t\t\t\t\t\tf3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tlayer = steps + bevelSegments * 2;\r\n\t\t\t\t\toffset = vlen * layer;\r\n\r\n\t\t\t\t\t// Top faces\r\n\r\n\t\t\t\t\tfor ( let i = 0; i < flen; i ++ ) {\r\n\r\n\t\t\t\t\t\tconst face = faces[ i ];\r\n\t\t\t\t\t\tf3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// Bottom faces\r\n\r\n\t\t\t\t\tfor ( let i = 0; i < flen; i ++ ) {\r\n\r\n\t\t\t\t\t\tconst face = faces[ i ];\r\n\t\t\t\t\t\tf3( face[ 2 ], face[ 1 ], face[ 0 ] );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Top faces\r\n\r\n\t\t\t\t\tfor ( let i = 0; i < flen; i ++ ) {\r\n\r\n\t\t\t\t\t\tconst face = faces[ i ];\r\n\t\t\t\t\t\tf3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tscope.addGroup( start, verticesArray.length / 3 - start, 0 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Create faces for the z-sides of the shape\r\n\r\n\t\t\tfunction buildSideFaces() {\r\n\r\n\t\t\t\tconst start = verticesArray.length / 3;\r\n\t\t\t\tlet layeroffset = 0;\r\n\t\t\t\tsidewalls( contour, layeroffset );\r\n\t\t\t\tlayeroffset += contour.length;\r\n\r\n\t\t\t\tfor ( let h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\r\n\t\t\t\t\tconst ahole = holes[ h ];\r\n\t\t\t\t\tsidewalls( ahole, layeroffset );\r\n\r\n\t\t\t\t\t//, true\r\n\t\t\t\t\tlayeroffset += ahole.length;\r\n\r\n\t\t\t\t}\r\n\r\n\r\n\t\t\t\tscope.addGroup( start, verticesArray.length / 3 - start, 1 );\r\n\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction sidewalls( contour, layeroffset ) {\r\n\r\n\t\t\t\tlet i = contour.length;\r\n\r\n\t\t\t\twhile ( -- i >= 0 ) {\r\n\r\n\t\t\t\t\tconst j = i;\r\n\t\t\t\t\tlet k = i - 1;\r\n\t\t\t\t\tif ( k < 0 ) k = contour.length - 1;\r\n\r\n\t\t\t\t\t//console.log('b', i,j, i-1, k,vertices.length);\r\n\r\n\t\t\t\t\tfor ( let s = 0, sl = ( steps + bevelSegments * 2 ); s < sl; s ++ ) {\r\n\r\n\t\t\t\t\t\tconst slen1 = vlen * s;\r\n\t\t\t\t\t\tconst slen2 = vlen * ( s + 1 );\r\n\r\n\t\t\t\t\t\tconst a = layeroffset + j + slen1,\r\n\t\t\t\t\t\t\tb = layeroffset + k + slen1,\r\n\t\t\t\t\t\t\tc = layeroffset + k + slen2,\r\n\t\t\t\t\t\t\td = layeroffset + j + slen2;\r\n\r\n\t\t\t\t\t\tf4( a, b, c, d );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction v( x, y, z ) {\r\n\r\n\t\t\t\tplaceholder.push( x );\r\n\t\t\t\tplaceholder.push( y );\r\n\t\t\t\tplaceholder.push( z );\r\n\r\n\t\t\t}\r\n\r\n\r\n\t\t\tfunction f3( a, b, c ) {\r\n\r\n\t\t\t\taddVertex( a );\r\n\t\t\t\taddVertex( b );\r\n\t\t\t\taddVertex( c );\r\n\r\n\t\t\t\tconst nextIndex = verticesArray.length / 3;\r\n\t\t\t\tconst uvs = uvgen.generateTopUV( scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1 );\r\n\r\n\t\t\t\taddUV( uvs[ 0 ] );\r\n\t\t\t\taddUV( uvs[ 1 ] );\r\n\t\t\t\taddUV( uvs[ 2 ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction f4( a, b, c, d ) {\r\n\r\n\t\t\t\taddVertex( a );\r\n\t\t\t\taddVertex( b );\r\n\t\t\t\taddVertex( d );\r\n\r\n\t\t\t\taddVertex( b );\r\n\t\t\t\taddVertex( c );\r\n\t\t\t\taddVertex( d );\r\n\r\n\r\n\t\t\t\tconst nextIndex = verticesArray.length / 3;\r\n\t\t\t\tconst uvs = uvgen.generateSideWallUV( scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1 );\r\n\r\n\t\t\t\taddUV( uvs[ 0 ] );\r\n\t\t\t\taddUV( uvs[ 1 ] );\r\n\t\t\t\taddUV( uvs[ 3 ] );\r\n\r\n\t\t\t\taddUV( uvs[ 1 ] );\r\n\t\t\t\taddUV( uvs[ 2 ] );\r\n\t\t\t\taddUV( uvs[ 3 ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction addVertex( index ) {\r\n\r\n\t\t\t\tverticesArray.push( placeholder[ index * 3 + 0 ] );\r\n\t\t\t\tverticesArray.push( placeholder[ index * 3 + 1 ] );\r\n\t\t\t\tverticesArray.push( placeholder[ index * 3 + 2 ] );\r\n\r\n\t\t\t}\r\n\r\n\r\n\t\t\tfunction addUV( vector2 ) {\r\n\r\n\t\t\t\tuvArray.push( vector2.x );\r\n\t\t\t\tuvArray.push( vector2.y );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\ttoJSON() {\r\n\r\n\t\tconst data = super.toJSON();\r\n\r\n\t\tconst shapes = this.parameters.shapes;\r\n\t\tconst options = this.parameters.options;\r\n\r\n\t\treturn toJSON( shapes, options, data );\r\n\r\n\t}\r\n\r\n\tstatic fromJSON( data, shapes ) {\r\n\r\n\t\tconst geometryShapes = [];\r\n\r\n\t\tfor ( let j = 0, jl = data.shapes.length; j < jl; j ++ ) {\r\n\r\n\t\t\tconst shape = shapes[ data.shapes[ j ] ];\r\n\r\n\t\t\tgeometryShapes.push( shape );\r\n\r\n\t\t}\r\n\r\n\t\tconst extrudePath = data.options.extrudePath;\r\n\r\n\t\tif ( extrudePath !== undefined ) {\r\n\r\n\t\t\tdata.options.extrudePath = new Curves[ extrudePath.type ]().fromJSON( extrudePath );\r\n\r\n\t\t}\r\n\r\n\t\treturn new ExtrudeGeometry( geometryShapes, data.options );\r\n\r\n\t}\r\n\r\n}\r\n\r\nconst WorldUVGenerator = {\r\n\r\n\tgenerateTopUV: function ( geometry, vertices, indexA, indexB, indexC ) {\r\n\r\n\t\tconst a_x = vertices[ indexA * 3 ];\r\n\t\tconst a_y = vertices[ indexA * 3 + 1 ];\r\n\t\tconst b_x = vertices[ indexB * 3 ];\r\n\t\tconst b_y = vertices[ indexB * 3 + 1 ];\r\n\t\tconst c_x = vertices[ indexC * 3 ];\r\n\t\tconst c_y = vertices[ indexC * 3 + 1 ];\r\n\r\n\t\treturn [\r\n\t\t\tnew Vector2( a_x, a_y ),\r\n\t\t\tnew Vector2( b_x, b_y ),\r\n\t\t\tnew Vector2( c_x, c_y )\r\n\t\t];\r\n\r\n\t},\r\n\r\n\tgenerateSideWallUV: function ( geometry, vertices, indexA, indexB, indexC, indexD ) {\r\n\r\n\t\tconst a_x = vertices[ indexA * 3 ];\r\n\t\tconst a_y = vertices[ indexA * 3 + 1 ];\r\n\t\tconst a_z = vertices[ indexA * 3 + 2 ];\r\n\t\tconst b_x = vertices[ indexB * 3 ];\r\n\t\tconst b_y = vertices[ indexB * 3 + 1 ];\r\n\t\tconst b_z = vertices[ indexB * 3 + 2 ];\r\n\t\tconst c_x = vertices[ indexC * 3 ];\r\n\t\tconst c_y = vertices[ indexC * 3 + 1 ];\r\n\t\tconst c_z = vertices[ indexC * 3 + 2 ];\r\n\t\tconst d_x = vertices[ indexD * 3 ];\r\n\t\tconst d_y = vertices[ indexD * 3 + 1 ];\r\n\t\tconst d_z = vertices[ indexD * 3 + 2 ];\r\n\r\n\t\tif ( Math.abs( a_y - b_y ) < Math.abs( a_x - b_x ) ) {\r\n\r\n\t\t\treturn [\r\n\t\t\t\tnew Vector2( a_x, 1 - a_z ),\r\n\t\t\t\tnew Vector2( b_x, 1 - b_z ),\r\n\t\t\t\tnew Vector2( c_x, 1 - c_z ),\r\n\t\t\t\tnew Vector2( d_x, 1 - d_z )\r\n\t\t\t];\r\n\r\n\t\t} else {\r\n\r\n\t\t\treturn [\r\n\t\t\t\tnew Vector2( a_y, 1 - a_z ),\r\n\t\t\t\tnew Vector2( b_y, 1 - b_z ),\r\n\t\t\t\tnew Vector2( c_y, 1 - c_z ),\r\n\t\t\t\tnew Vector2( d_y, 1 - d_z )\r\n\t\t\t];\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\r\n\r\nfunction toJSON( shapes, options, data ) {\r\n\r\n\tdata.shapes = [];\r\n\r\n\tif ( Array.isArray( shapes ) ) {\r\n\r\n\t\tfor ( let i = 0, l = shapes.length; i < l; i ++ ) {\r\n\r\n\t\t\tconst shape = shapes[ i ];\r\n\r\n\t\t\tdata.shapes.push( shape.uuid );\r\n\r\n\t\t}\r\n\r\n\t} else {\r\n\r\n\t\tdata.shapes.push( shapes.uuid );\r\n\r\n\t}\r\n\r\n\tif ( options.extrudePath !== undefined ) data.options.extrudePath = options.extrudePath.toJSON();\r\n\r\n\treturn data;\r\n\r\n}\r\n\r\n\r\nexport { ExtrudeGeometry, ExtrudeGeometry as ExtrudeBufferGeometry };\r\n"]},"metadata":{},"sourceType":"module"}