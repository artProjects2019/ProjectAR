{"ast":null,"code":"import { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Vector3 } from '../math/Vector3.js';\nimport { Vector2 } from '../math/Vector2.js';\nimport * as MathUtils from '../math/MathUtils.js';\n\nclass LatheGeometry extends BufferGeometry {\n  constructor(points = [new Vector2(0, 0.5), new Vector2(0.5, 0), new Vector2(0, -0.5)], segments = 12, phiStart = 0, phiLength = Math.PI * 2) {\n    super();\n    this.type = 'LatheGeometry';\n    this.parameters = {\n      points: points,\n      segments: segments,\n      phiStart: phiStart,\n      phiLength: phiLength\n    };\n    segments = Math.floor(segments); // clamp phiLength so it's in range of [ 0, 2PI ]\n\n    phiLength = MathUtils.clamp(phiLength, 0, Math.PI * 2); // buffers\n\n    const indices = [];\n    const vertices = [];\n    const uvs = [];\n    const initNormals = [];\n    const normals = []; // helper variables\n\n    const inverseSegments = 1.0 / segments;\n    const vertex = new Vector3();\n    const uv = new Vector2();\n    const normal = new Vector3();\n    const curNormal = new Vector3();\n    const prevNormal = new Vector3();\n    let dx = 0;\n    let dy = 0; // pre-compute normals for initial \"meridian\"\n\n    for (let j = 0; j <= points.length - 1; j++) {\n      switch (j) {\n        case 0:\n          // special handling for 1st vertex on path\n          dx = points[j + 1].x - points[j].x;\n          dy = points[j + 1].y - points[j].y;\n          normal.x = dy * 1.0;\n          normal.y = -dx;\n          normal.z = dy * 0.0;\n          prevNormal.copy(normal);\n          normal.normalize();\n          initNormals.push(normal.x, normal.y, normal.z);\n          break;\n\n        case points.length - 1:\n          // special handling for last Vertex on path\n          initNormals.push(prevNormal.x, prevNormal.y, prevNormal.z);\n          break;\n\n        default:\n          // default handling for all vertices in between\n          dx = points[j + 1].x - points[j].x;\n          dy = points[j + 1].y - points[j].y;\n          normal.x = dy * 1.0;\n          normal.y = -dx;\n          normal.z = dy * 0.0;\n          curNormal.copy(normal);\n          normal.x += prevNormal.x;\n          normal.y += prevNormal.y;\n          normal.z += prevNormal.z;\n          normal.normalize();\n          initNormals.push(normal.x, normal.y, normal.z);\n          prevNormal.copy(curNormal);\n      }\n    } // generate vertices, uvs and normals\n\n\n    for (let i = 0; i <= segments; i++) {\n      const phi = phiStart + i * inverseSegments * phiLength;\n      const sin = Math.sin(phi);\n      const cos = Math.cos(phi);\n\n      for (let j = 0; j <= points.length - 1; j++) {\n        // vertex\n        vertex.x = points[j].x * sin;\n        vertex.y = points[j].y;\n        vertex.z = points[j].x * cos;\n        vertices.push(vertex.x, vertex.y, vertex.z); // uv\n\n        uv.x = i / segments;\n        uv.y = j / (points.length - 1);\n        uvs.push(uv.x, uv.y); // normal\n\n        const x = initNormals[3 * j + 0] * sin;\n        const y = initNormals[3 * j + 1];\n        const z = initNormals[3 * j + 0] * cos;\n        normals.push(x, y, z);\n      }\n    } // indices\n\n\n    for (let i = 0; i < segments; i++) {\n      for (let j = 0; j < points.length - 1; j++) {\n        const base = j + i * points.length;\n        const a = base;\n        const b = base + points.length;\n        const c = base + points.length + 1;\n        const d = base + 1; // faces\n\n        indices.push(a, b, d);\n        indices.push(c, d, b);\n      }\n    } // build geometry\n\n\n    this.setIndex(indices);\n    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\n    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n  }\n\n  static fromJSON(data) {\n    return new LatheGeometry(data.points, data.segments, data.phiStart, data.phiLength);\n  }\n\n}\n\nexport { LatheGeometry, LatheGeometry as LatheBufferGeometry };","map":{"version":3,"sources":["C:/Users/dell/Desktop/projektlogin/vue-3-authentication-jwt/src/games/three/src/geometries/LatheGeometry.js"],"names":["Float32BufferAttribute","BufferGeometry","Vector3","Vector2","MathUtils","LatheGeometry","constructor","points","segments","phiStart","phiLength","Math","PI","type","parameters","floor","clamp","indices","vertices","uvs","initNormals","normals","inverseSegments","vertex","uv","normal","curNormal","prevNormal","dx","dy","j","length","x","y","z","copy","normalize","push","i","phi","sin","cos","base","a","b","c","d","setIndex","setAttribute","fromJSON","data","LatheBufferGeometry"],"mappings":"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","sourcesContent":["import { Float32BufferAttribute } from '../core/BufferAttribute.js';\r\nimport { BufferGeometry } from '../core/BufferGeometry.js';\r\nimport { Vector3 } from '../math/Vector3.js';\r\nimport { Vector2 } from '../math/Vector2.js';\r\nimport * as MathUtils from '../math/MathUtils.js';\r\n\r\nclass LatheGeometry extends BufferGeometry {\r\n\r\n\tconstructor( points = [ new Vector2( 0, 0.5 ), new Vector2( 0.5, 0 ), new Vector2( 0, - 0.5 ) ], segments = 12, phiStart = 0, phiLength = Math.PI * 2 ) {\r\n\r\n\t\tsuper();\r\n\r\n\t\tthis.type = 'LatheGeometry';\r\n\r\n\t\tthis.parameters = {\r\n\t\t\tpoints: points,\r\n\t\t\tsegments: segments,\r\n\t\t\tphiStart: phiStart,\r\n\t\t\tphiLength: phiLength\r\n\t\t};\r\n\r\n\t\tsegments = Math.floor( segments );\r\n\r\n\t\t// clamp phiLength so it's in range of [ 0, 2PI ]\r\n\r\n\t\tphiLength = MathUtils.clamp( phiLength, 0, Math.PI * 2 );\r\n\r\n\t\t// buffers\r\n\r\n\t\tconst indices = [];\r\n\t\tconst vertices = [];\r\n\t\tconst uvs = [];\r\n\t\tconst initNormals = [];\r\n\t\tconst normals = [];\r\n\r\n\t\t// helper variables\r\n\r\n\t\tconst inverseSegments = 1.0 / segments;\r\n\t\tconst vertex = new Vector3();\r\n\t\tconst uv = new Vector2();\r\n\t\tconst normal = new Vector3();\r\n\t\tconst curNormal = new Vector3();\r\n\t\tconst prevNormal = new Vector3();\r\n\t\tlet dx = 0;\r\n\t\tlet dy = 0;\r\n\r\n\t\t// pre-compute normals for initial \"meridian\"\r\n\r\n\t\tfor ( let j = 0; j <= ( points.length - 1 ); j ++ ) {\r\n\r\n\t\t\tswitch ( j ) {\r\n\r\n\t\t\t\tcase 0:\t\t\t\t// special handling for 1st vertex on path\r\n\r\n\t\t\t\t\tdx = points[ j + 1 ].x - points[ j ].x;\r\n\t\t\t\t\tdy = points[ j + 1 ].y - points[ j ].y;\r\n\r\n\t\t\t\t\tnormal.x = dy * 1.0;\r\n\t\t\t\t\tnormal.y = - dx;\r\n\t\t\t\t\tnormal.z = dy * 0.0;\r\n\r\n\t\t\t\t\tprevNormal.copy( normal );\r\n\r\n\t\t\t\t\tnormal.normalize();\r\n\r\n\t\t\t\t\tinitNormals.push( normal.x, normal.y, normal.z );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase ( points.length - 1 ):\t// special handling for last Vertex on path\r\n\r\n\t\t\t\t\tinitNormals.push( prevNormal.x, prevNormal.y, prevNormal.z );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tdefault:\t\t\t// default handling for all vertices in between\r\n\r\n\t\t\t\t\tdx = points[ j + 1 ].x - points[ j ].x;\r\n\t\t\t\t\tdy = points[ j + 1 ].y - points[ j ].y;\r\n\r\n\t\t\t\t\tnormal.x = dy * 1.0;\r\n\t\t\t\t\tnormal.y = - dx;\r\n\t\t\t\t\tnormal.z = dy * 0.0;\r\n\r\n\t\t\t\t\tcurNormal.copy( normal );\r\n\r\n\t\t\t\t\tnormal.x += prevNormal.x;\r\n\t\t\t\t\tnormal.y += prevNormal.y;\r\n\t\t\t\t\tnormal.z += prevNormal.z;\r\n\r\n\t\t\t\t\tnormal.normalize();\r\n\r\n\t\t\t\t\tinitNormals.push( normal.x, normal.y, normal.z );\r\n\r\n\t\t\t\t\tprevNormal.copy( curNormal );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// generate vertices, uvs and normals\r\n\r\n\t\tfor ( let i = 0; i <= segments; i ++ ) {\r\n\r\n\t\t\tconst phi = phiStart + i * inverseSegments * phiLength;\r\n\r\n\t\t\tconst sin = Math.sin( phi );\r\n\t\t\tconst cos = Math.cos( phi );\r\n\r\n\t\t\tfor ( let j = 0; j <= ( points.length - 1 ); j ++ ) {\r\n\r\n\t\t\t\t// vertex\r\n\r\n\t\t\t\tvertex.x = points[ j ].x * sin;\r\n\t\t\t\tvertex.y = points[ j ].y;\r\n\t\t\t\tvertex.z = points[ j ].x * cos;\r\n\r\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\r\n\r\n\t\t\t\t// uv\r\n\r\n\t\t\t\tuv.x = i / segments;\r\n\t\t\t\tuv.y = j / ( points.length - 1 );\r\n\r\n\t\t\t\tuvs.push( uv.x, uv.y );\r\n\r\n\t\t\t\t// normal\r\n\r\n\t\t\t\tconst x = initNormals[ 3 * j + 0 ] * sin;\r\n\t\t\t\tconst y = initNormals[ 3 * j + 1 ];\r\n\t\t\t\tconst z = initNormals[ 3 * j + 0 ] * cos;\r\n\r\n\t\t\t\tnormals.push( x, y, z );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// indices\r\n\r\n\t\tfor ( let i = 0; i < segments; i ++ ) {\r\n\r\n\t\t\tfor ( let j = 0; j < ( points.length - 1 ); j ++ ) {\r\n\r\n\t\t\t\tconst base = j + i * points.length;\r\n\r\n\t\t\t\tconst a = base;\r\n\t\t\t\tconst b = base + points.length;\r\n\t\t\t\tconst c = base + points.length + 1;\r\n\t\t\t\tconst d = base + 1;\r\n\r\n\t\t\t\t// faces\r\n\r\n\t\t\t\tindices.push( a, b, d );\r\n\t\t\t\tindices.push( c, d, b );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// build geometry\r\n\r\n\t\tthis.setIndex( indices );\r\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\r\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\r\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\r\n\r\n\t}\r\n\r\n\tstatic fromJSON( data ) {\r\n\r\n\t\treturn new LatheGeometry( data.points, data.segments, data.phiStart, data.phiLength );\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\nexport { LatheGeometry, LatheGeometry as LatheBufferGeometry };\r\n"]},"metadata":{},"sourceType":"module"}