{"ast":null,"code":"import { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport { Vector3 } from '../math/Vector3.js';\nimport { Vector2 } from '../math/Vector2.js';\n\nclass CircleGeometry extends BufferGeometry {\n  constructor(radius = 1, segments = 8, thetaStart = 0, thetaLength = Math.PI * 2) {\n    super();\n    this.type = 'CircleGeometry';\n    this.parameters = {\n      radius: radius,\n      segments: segments,\n      thetaStart: thetaStart,\n      thetaLength: thetaLength\n    };\n    segments = Math.max(3, segments); // buffers\n\n    const indices = [];\n    const vertices = [];\n    const normals = [];\n    const uvs = []; // helper variables\n\n    const vertex = new Vector3();\n    const uv = new Vector2(); // center point\n\n    vertices.push(0, 0, 0);\n    normals.push(0, 0, 1);\n    uvs.push(0.5, 0.5);\n\n    for (let s = 0, i = 3; s <= segments; s++, i += 3) {\n      const segment = thetaStart + s / segments * thetaLength; // vertex\n\n      vertex.x = radius * Math.cos(segment);\n      vertex.y = radius * Math.sin(segment);\n      vertices.push(vertex.x, vertex.y, vertex.z); // normal\n\n      normals.push(0, 0, 1); // uvs\n\n      uv.x = (vertices[i] / radius + 1) / 2;\n      uv.y = (vertices[i + 1] / radius + 1) / 2;\n      uvs.push(uv.x, uv.y);\n    } // indices\n\n\n    for (let i = 1; i <= segments; i++) {\n      indices.push(i, i + 1, 0);\n    } // build geometry\n\n\n    this.setIndex(indices);\n    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\n  }\n\n  static fromJSON(data) {\n    return new CircleGeometry(data.radius, data.segments, data.thetaStart, data.thetaLength);\n  }\n\n}\n\nexport { CircleGeometry, CircleGeometry as CircleBufferGeometry };","map":{"version":3,"sources":["C:/Users/dell/Desktop/projektlogin/vue-3-authentication-jwt/src/games/three/src/geometries/CircleGeometry.js"],"names":["BufferGeometry","Float32BufferAttribute","Vector3","Vector2","CircleGeometry","constructor","radius","segments","thetaStart","thetaLength","Math","PI","type","parameters","max","indices","vertices","normals","uvs","vertex","uv","push","s","i","segment","x","cos","y","sin","z","setIndex","setAttribute","fromJSON","data","CircleBufferGeometry"],"mappings":"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","sourcesContent":["import { BufferGeometry } from '../core/BufferGeometry.js';\r\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\r\nimport { Vector3 } from '../math/Vector3.js';\r\nimport { Vector2 } from '../math/Vector2.js';\r\n\r\nclass CircleGeometry extends BufferGeometry {\r\n\r\n\tconstructor( radius = 1, segments = 8, thetaStart = 0, thetaLength = Math.PI * 2 ) {\r\n\r\n\t\tsuper();\r\n\r\n\t\tthis.type = 'CircleGeometry';\r\n\r\n\t\tthis.parameters = {\r\n\t\t\tradius: radius,\r\n\t\t\tsegments: segments,\r\n\t\t\tthetaStart: thetaStart,\r\n\t\t\tthetaLength: thetaLength\r\n\t\t};\r\n\r\n\t\tsegments = Math.max( 3, segments );\r\n\r\n\t\t// buffers\r\n\r\n\t\tconst indices = [];\r\n\t\tconst vertices = [];\r\n\t\tconst normals = [];\r\n\t\tconst uvs = [];\r\n\r\n\t\t// helper variables\r\n\r\n\t\tconst vertex = new Vector3();\r\n\t\tconst uv = new Vector2();\r\n\r\n\t\t// center point\r\n\r\n\t\tvertices.push( 0, 0, 0 );\r\n\t\tnormals.push( 0, 0, 1 );\r\n\t\tuvs.push( 0.5, 0.5 );\r\n\r\n\t\tfor ( let s = 0, i = 3; s <= segments; s ++, i += 3 ) {\r\n\r\n\t\t\tconst segment = thetaStart + s / segments * thetaLength;\r\n\r\n\t\t\t// vertex\r\n\r\n\t\t\tvertex.x = radius * Math.cos( segment );\r\n\t\t\tvertex.y = radius * Math.sin( segment );\r\n\r\n\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\r\n\r\n\t\t\t// normal\r\n\r\n\t\t\tnormals.push( 0, 0, 1 );\r\n\r\n\t\t\t// uvs\r\n\r\n\t\t\tuv.x = ( vertices[ i ] / radius + 1 ) / 2;\r\n\t\t\tuv.y = ( vertices[ i + 1 ] / radius + 1 ) / 2;\r\n\r\n\t\t\tuvs.push( uv.x, uv.y );\r\n\r\n\t\t}\r\n\r\n\t\t// indices\r\n\r\n\t\tfor ( let i = 1; i <= segments; i ++ ) {\r\n\r\n\t\t\tindices.push( i, i + 1, 0 );\r\n\r\n\t\t}\r\n\r\n\t\t// build geometry\r\n\r\n\t\tthis.setIndex( indices );\r\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\r\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\r\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\r\n\r\n\t}\r\n\r\n\tstatic fromJSON( data ) {\r\n\r\n\t\treturn new CircleGeometry( data.radius, data.segments, data.thetaStart, data.thetaLength );\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\nexport { CircleGeometry, CircleGeometry as CircleBufferGeometry };\r\n"]},"metadata":{},"sourceType":"module"}